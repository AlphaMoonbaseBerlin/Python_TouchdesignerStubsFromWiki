{
    "actorCOMP": {
        "label": "actorCOMP",
        "members": [
            {
                "text": "Pulse : Recreates the collision shapes for all the bodies in the Actor COMP. Also resets all velocities and position to their default state. Initialize Actor should be pulsed when any changes are made to the SOPs used for creating the collision shape, or for any changes to the instancing OP.",
                "type": "PulsePar",
                "name": "init",
                "items": []
            },
            {
                "text": "Toggle : If enabled the Actor COMP will automatically update collision shapes. This will occur when the \"Collision SOPs\" or \"Collision Shape\" parameters are changes or the underlying SOPs used to create the collision shape are changed (ie. when their cook count increases).",
                "type": "TogglePar",
                "name": "updatecs",
                "items": []
            },
            {
                "text": "Pulse : When clicked this will instantly update the collosion shape.",
                "type": "PulsePar",
                "name": "updatecspulse",
                "items": []
            },
            {
                "text": "Toggle : Toggle the actor on/off. If the actor is active, then it will be updated as the simulation progress. However, if it is inactive, then it will be removed from the simulation and no longer collide with any of the other actors/bodies. As a result, it's transform will also no longer be updated.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : The kinematic state defines the Actor COMPs ability to move from external forces. If an object is dynamic, then it is moveable in the simulation, but if it static then it is not.",
                "type": "MenuPar",
                "name": "kinstate",
                "items": []
            },
            {
                "text": "OP : Specifies SOPs or COMPs to use for the collision shape. If a SOP is referenced, then just that SOP will be used for the collision shape. But if a COMP is selected then all SOPs inside of that (recursive) will be used for the collision shape. If this parameter is left blank, then the SOPs selected will be all SOPs inside the Actor COMP with display and render flags on.",
                "type": "OPPar",
                "name": "sops",
                "items": []
            },
            {
                "text": "Menu : The type of collision shape to make from the selected SOPs. Collision shapes can be viewed using a guide in the Actor COMP's viewer",
                "type": "MenuPar",
                "name": "shape",
                "items": []
            },
            {
                "text": "Float : The tolerance of the minimum volume bounding ellipsoid. In other words, how close to the optimal solution it is.",
                "type": "FloatPar",
                "name": "elltol",
                "items": []
            },
            {
                "text": "Toggle : Give the actor infinite mass. If the object is dynamic this will make it unmovable and static. Toggling infinite mass on or off will not require recreation of the collision shape, unlike changing the Kinematic State parameter.",
                "type": "TogglePar",
                "name": "infinitemass",
                "items": []
            },
            {
                "text": "Float : The mass in kilograms of the actor.",
                "type": "FloatPar",
                "name": "mass",
                "items": []
            },
            {
                "text": "Toggle : Holds the linear and angular velocity and values given by linvel and angvel. The object will still collide with any other bodies in the simulation.",
                "type": "TogglePar",
                "name": "cuevel",
                "items": []
            },
            {
                "text": "Pulse : Pulse the linear and angular velocity to values given by linvel and angvel. This will set the velocity to the given value at the beginning of the next frame.",
                "type": "PulsePar",
                "name": "cuevelpulse",
                "items": []
            },
            {
                "text": "XYZ : The initial linear velocity of the actor in m/s. This parameter can also be used to modify an actor's linear velocity during a simulation. Additionally, it is used in conjunction with the \"Cue Velocity\" and \"Cue Velocity Pulse\" parameters.",
                "type": "XYZPar",
                "name": "linvelx",
                "items": []
            },
            {
                "text": "XYZ : The initial linear velocity of the actor in m/s. This parameter can also be used to modify an actor's linear velocity during a simulation. Additionally, it is used in conjunction with the \"Cue Velocity\" and \"Cue Velocity Pulse\" parameters.",
                "type": "XYZPar",
                "name": "linvely",
                "items": []
            },
            {
                "text": "XYZ : The initial linear velocity of the actor in m/s. This parameter can also be used to modify an actor's linear velocity during a simulation. Additionally, it is used in conjunction with the \"Cue Velocity\" and \"Cue Velocity Pulse\" parameters.",
                "type": "XYZPar",
                "name": "linvelz",
                "items": []
            },
            {
                "text": "XYZ : The initial angular velocity of the actor in degrees per second in m/s. This parameter can also be used to modify the actor's angular velocity during a simulation. Additionally, it is used in conjunction with the \"Cue Velocity\" and \"Cue Velocity Pulse\" parameters.",
                "type": "XYZPar",
                "name": "angvelx",
                "items": []
            },
            {
                "text": "XYZ : The initial angular velocity of the actor in degrees per second in m/s. This parameter can also be used to modify the actor's angular velocity during a simulation. Additionally, it is used in conjunction with the \"Cue Velocity\" and \"Cue Velocity Pulse\" parameters.",
                "type": "XYZPar",
                "name": "angvely",
                "items": []
            },
            {
                "text": "XYZ : The initial angular velocity of the actor in degrees per second in m/s. This parameter can also be used to modify the actor's angular velocity during a simulation. Additionally, it is used in conjunction with the \"Cue Velocity\" and \"Cue Velocity Pulse\" parameters.",
                "type": "XYZPar",
                "name": "angvelz",
                "items": []
            },
            {
                "text": "OBJ : A list of local forces, meaning forces (ie. Force COMPs) that will only be applied to this actor.",
                "type": "OBJPar",
                "name": "forces",
                "items": []
            },
            {
                "text": "Toggle : Toggle for whether to use the Bullet Solver COMP's gravity (global), or its own local gravity.",
                "type": "TogglePar",
                "name": "globalgrav",
                "items": []
            },
            {
                "text": "XYZ : Actor's local gravity in m/s^2. Will only be applied if the actor is not using the Bullet Solver COMP's global gravity ie. the \"Use Global Gravity\" parameter above is turned off.",
                "type": "XYZPar",
                "name": "gravityx",
                "items": []
            },
            {
                "text": "XYZ : Actor's local gravity in m/s^2. Will only be applied if the actor is not using the Bullet Solver COMP's global gravity ie. the \"Use Global Gravity\" parameter above is turned off.",
                "type": "XYZPar",
                "name": "gravityy",
                "items": []
            },
            {
                "text": "XYZ : Actor's local gravity in m/s^2. Will only be applied if the actor is not using the Bullet Solver COMP's global gravity ie. the \"Use Global Gravity\" parameter above is turned off.",
                "type": "XYZPar",
                "name": "gravityz",
                "items": []
            },
            {
                "text": "Float : The kinetic friction of the actor. It is the resistance between two bodies rubbing/sliding. The overall friction is the product of the two bodies touching. For example, if one body has 0 friction and the other has 1, then the overall friction between the two bodies is 0.",
                "type": "FloatPar",
                "name": "friction",
                "items": []
            },
            {
                "text": "Float : The rolling friction of the actor. It is the resistance/drag of one body (such as a sphere or cone) rolling on another.",
                "type": "FloatPar",
                "name": "rollfric",
                "items": []
            },
            {
                "text": "Float : The coefficient of restitution of the actor. The coefficient of restitution is the ratio of the final to initial relative between two bodies/actors when they collide. In other words, restitution is the fraction of kinetic energy preserved after a collision. If two objects collide with 100% (ie. 1) restitution, then, both bodies will bounce off each other at the same speed at which they collided.",
                "type": "FloatPar",
                "name": "rest",
                "items": []
            },
            {
                "text": "Toggle : Toggles continuous collision detection on/off for this actor. Typically, collision detection is done discretely, meaning that collision is verified at the beginning/end of a frame. However, if a body is going too fast it will move too far in a single frame and therefore clip through any surfaces (ie. No collision detected). Continuous collision detection improves upon this by performing collision detection at intervals between the body's initial and final positions within a frame. Continuous collision detection can affect performance, so even if the parameter is toggled on it will not be used all the time. It will only be used for bodies moving above a velocity threshold.",
                "type": "TogglePar",
                "name": "ccd",
                "items": []
            },
            {
                "text": "Toggle : Toggles on the display for the collision shape in the COMP viewer.",
                "type": "TogglePar",
                "name": "dispguide",
                "items": []
            },
            {
                "text": "XYZ : Specifies the center of mass of the collision shape. The center of mass is the point around which the body will rotate. Center of mass can be viewed using a guide in the Actor COMP's viewer. It is shown as a red axis.",
                "type": "XYZPar",
                "name": "comx",
                "items": []
            },
            {
                "text": "XYZ : Specifies the center of mass of the collision shape. The center of mass is the point around which the body will rotate. Center of mass can be viewed using a guide in the Actor COMP's viewer. It is shown as a red axis.",
                "type": "XYZPar",
                "name": "comy",
                "items": []
            },
            {
                "text": "XYZ : Specifies the center of mass of the collision shape. The center of mass is the point around which the body will rotate. Center of mass can be viewed using a guide in the Actor COMP's viewer. It is shown as a red axis.",
                "type": "XYZPar",
                "name": "comz",
                "items": []
            },
            {
                "text": "CHOP : A reference to a CHOP from which to feedback. The Actor COMP will read transformation and velocity data (in the correct format, see Bullet Solver CHOP for more information) from the CHOP, and overwrite the current values at the beginning of the next frame. A feedback loop can be created with this parameter and the Bullet Solver CHOP. See Bullet Solver CHOP. NOTE: scale cannot be feedbacked. force[xyz] and torque[xyz] can be used to apply forces to specific bodies.",
                "type": "CHOPPar",
                "name": "feedback",
                "items": []
            },
            {
                "text": "Menu : The type of dynamic Flex actor.",
                "type": "MenuPar",
                "name": "flextype",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the Actor COMP will actively emit particles.",
                "type": "TogglePar",
                "name": "emit",
                "items": []
            },
            {
                "text": "XY : The size of the 2D emission grid. The size represents the number of particles on each side of the emission grid. For example, a 2x5 emission size will emit a grid 2 particles wide and 5 particles high.",
                "type": "XYPar",
                "name": "emitsizex",
                "items": []
            },
            {
                "text": "XY : The size of the 2D emission grid. The size represents the number of particles on each side of the emission grid. For example, a 2x5 emission size will emit a grid 2 particles wide and 5 particles high.",
                "type": "XYPar",
                "name": "emitsizey",
                "items": []
            },
            {
                "text": "Float : The speed the particles come out of the emitter.",
                "type": "FloatPar",
                "name": "emitspeed",
                "items": []
            },
            {
                "text": "Float : Sets the maximum number of particles in the Actor COMP. Once this number is reached, emission will be done by recycling existing particles in the Actor COMP.",
                "type": "FloatPar",
                "name": "emitmax",
                "items": []
            },
            {
                "text": "TOP : A reference to a TOP to feedback position. The TOP should be encoded with the position data that will be used to override position in the simulation. The texture data will be read to correspond with the Flex TOP's position texture.",
                "type": "TOPPar",
                "name": "flexposfb",
                "items": []
            },
            {
                "text": "TOP : A reference to a TOP to feedback velocity. The TOP should be encoded with the velocity data that will be used to override velocity in the simulation. The texture data will be read to correspond with the Flex TOP's velocity texture.",
                "type": "TOPPar",
                "name": "flexvelfb",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "actorCOMP",
        "opLabel": "Actor",
        "opClass": "actorCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "An Actor COMP is analogous to a body (or bodies) in a physics system.",
        "long": "An Actor COMP is analogous to a body (or bodies) in a physics system. An Actor COMP must be used in conjunction with a physics solver: either a [[Bullet Solver COMP]] or [[Nvidia Flex Solver COMP]], which in turn is analogous to the world/simulation that the actors/bodies operate in. An Actor COMP can either be static, meaning it is not affected by any forces in the simulation and cannot move (ie. has infinite mass), or it can be dynamic, meaning it is moved by forces and collides with other bodies (either static or dynamic) in the world.\n\nSee also: [[Flex]], [[Bullet Dynamics]], [[Bullet Solver COMP]], [[Force COMP]], [[Constraint COMP]], [[Bullet Solver CHOP]], [[Nvidia Flex Solver COMP]], [[Nvidia Flex TOP]].",
        "opCategories": ""
    },
    "ambientlightCOMP": {
        "label": "ambientlightCOMP",
        "members": [
            {
                "text": "RGB : You can modify the color of the light three ways: <span class=\"tipTextCOMP\">Color List</span>, <span class=\"tipTextCOMP\">Hue</span>, <span class=\"tipTextCOMP\">Saturation</span>, and <span class=\"tipTextCOMP\">Value</span>, or <span class=\"tipTextCOMP\">Red</span>, <span class=\"tipTextCOMP\">Green</span>, and <span class=\"tipTextCOMP\">Blue</span>. To choose one, click on the appropriate box and the color editing fields below change accordingly.",
                "type": "RGBPar",
                "name": "cr",
                "items": []
            },
            {
                "text": "RGB : You can modify the color of the light three ways: <span class=\"tipTextCOMP\">Color List</span>, <span class=\"tipTextCOMP\">Hue</span>, <span class=\"tipTextCOMP\">Saturation</span>, and <span class=\"tipTextCOMP\">Value</span>, or <span class=\"tipTextCOMP\">Red</span>, <span class=\"tipTextCOMP\">Green</span>, and <span class=\"tipTextCOMP\">Blue</span>. To choose one, click on the appropriate box and the color editing fields below change accordingly.",
                "type": "RGBPar",
                "name": "cg",
                "items": []
            },
            {
                "text": "RGB : You can modify the color of the light three ways: <span class=\"tipTextCOMP\">Color List</span>, <span class=\"tipTextCOMP\">Hue</span>, <span class=\"tipTextCOMP\">Saturation</span>, and <span class=\"tipTextCOMP\">Value</span>, or <span class=\"tipTextCOMP\">Red</span>, <span class=\"tipTextCOMP\">Green</span>, and <span class=\"tipTextCOMP\">Blue</span>. To choose one, click on the appropriate box and the color editing fields below change accordingly.",
                "type": "RGBPar",
                "name": "cb",
                "items": []
            },
            {
                "text": "Float : This parameter allows you to change the intensity of the light either as a static value or over time.",
                "type": "FloatPar",
                "name": "dimmer",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Ambient Light",
        "opFamily": "COMP",
        "long": "The Ambient Light Component controls the color and intensity of the environmental light in a given scene. This light, unlike the [[Light COMP|Light Component]], has no particular source. The light it sheds comes from everywhere as opposed to a point light source or focused spotlight.",
        "opClass": "ambientlightCOMP_Class",
        "short": "The Ambient Light Component controls the color and intensity of the environmental light in a given scene.",
        "opType": "ambient",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "animationCOMP": {
        "label": "animationCOMP",
        "members": [
            {
                "text": "OP : The location the Animation COMP looks to for its time information. This is used for default channel range and rate when the <span class=\"tipTextCOMP\">Type</span> parameter on the Range page is set to '''Timeline'''.",
                "type": "OPPar",
                "name": "timeref",
                "items": []
            },
            {
                "text": "Menu : Specifies the method used to playback the animation or allows the output the entire animation curve.",
                "type": "MenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "Toggle : Animation plays when On and stops when Off. This animation playback control is only available when Play Mode is ''Sequential''.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : This is a speed multiplier which only works when Play Mode is ''Sequential''. A value of 1 is the default playback speed. A value of 2 is double speed, 0.5 is half speed and so on. Negative values will play the animation backwards.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Toggle : Jumps to Cue Point when set to 1. Only available when Play Mode is Sequential.",
                "type": "TogglePar",
                "name": "cue",
                "items": []
            },
            {
                "text": "Pulse : Instantly jumps to the Cue Point.",
                "type": "PulsePar",
                "name": "cuepulse",
                "items": []
            },
            {
                "text": "Float : Set any index in the animation as a point to jump to. Only available when Play Mode is Sequential.",
                "type": "FloatPar",
                "name": "cuepoint",
                "items": []
            },
            {
                "text": "Menu : Units used when setting the Cue Point parameter.",
                "type": "MenuPar",
                "name": "cuepointunit",
                "items": []
            },
            {
                "text": "Menu : When <span class=\"tipTextCOMP\">Play Mode</span> is set to '''Use Input Index''' use this menu to choose the units for the index input channel. For example, choose between setting the index with frames or seconds. The Units X option sets the index to use the key information directly from the key DAT table inside the Animation COMP, disregarding any custom settings found in the attributes DAT table.",
                "type": "MenuPar",
                "name": "inputindexunit",
                "items": []
            },
            {
                "text": "Menu : Adapts the range of the animation for cyclic or non-cyclic input indices. When using a cyclic input index the lookup value for index 0.0 and 1.0 result in the same value. To avoid this, set Cyclic Range to Yes and the lookup will cycle smoothly.",
                "type": "MenuPar",
                "name": "cyclic",
                "items": []
            },
            {
                "text": "Toggle : Turn this on to enable the edit attributes parameter below.",
                "type": "TogglePar",
                "name": "specifyedit",
                "items": []
            },
            {
                "text": "Float : Changes the origin of the animation channel edits. This does not change the data stored in the key DAT table, but it does effect the channels display in the graph and playback of the animation.",
                "type": "FloatPar",
                "name": "editorigin",
                "items": []
            },
            {
                "text": "Float : Changes the rate of the animation channel edits. This does not change the data stored in the key DAT table, but it does effect the channels display in the graph and playback of the animation.",
                "type": "FloatPar",
                "name": "editrate",
                "items": []
            },
            {
                "text": "Pulse : Clicking this button will open this Animation COMP in the Animation Editor.",
                "type": "PulsePar",
                "name": "editanimation",
                "items": []
            },
            {
                "text": "Menu : Set the working range for the Animation COMP.",
                "type": "MenuPar",
                "name": "rangetype",
                "items": []
            },
            {
                "text": "Float : Start of the Custom range, expressed in units seconds, frames or samples.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : End of the Custom range, expressed in units seconds, frames or samples.",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Menu : Determines the output of the channels when past the 'End' position. Does not affect Play Mode = Output Full Range, to manipulate the [[Extend Conditions]] of that mode adjust the Extend parameters of the [[Keyframe CHOP]] inside the Animation COMP.",
                "type": "MenuPar",
                "name": "tleft",
                "items": []
            },
            {
                "text": "Menu : Determines the output of the channels when before the 'Start' position. Does not affect Play Mode = Output Full Range, to manipulate the [[Extend Conditions]] of that mode adjust the Extend parameters of the [[Keyframe CHOP]] inside the Animation COMP.",
                "type": "MenuPar",
                "name": "tright",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value trim conditio above.",
                "type": "FloatPar",
                "name": "tdefault",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Animation Component is a special component used for creating keyframe animation channels. The component contains a pre-defined network utilizing a [[Keyframe CHOP]] and a number of [[Table DAT]]s to define the animated [[CHOP]] channels.\t\t\n\t\t\t\nThe [[Animation Editor]] is the user interface for creating and editing the animation of the Animation Component.\t\t\t\n\t\t\t\nThe Animation Component has both in and out CHOP connectors. \t\t\t\n\t\t\t\n'''Animation Component Inputs'''\t\t\t\n\t\t\t\nWith no input connected, the Animation Component's index loops over the time range of the channels. \t\t\t\nThe CHOP input can be used to manually control the index of the animated channels. For example, if the channels are keyed from frame 1 to 600, you can connect an input to the component and manually drive the animation output by feeding it a number between 1 and 600 (indexes outside the range will use the channel extend conditions). \t\t\t\n\t\t\t\nUsing the Keyframe CHOP's Index Units menu, you can drive the animation with numbers expressed in seconds, samples, or a fraction where 0 is the start and 1 is the end.\t\t\t\n\t\t\t\n'''Animation Component Outputs'''\t\t\t\nThe CHOP output gives access to the animation channel's current value. CHOPs can be directly connected or a [[Null CHOP]] may be appended for [[CHOP Export|exporting]] the channels to parameters. The current channel values can also be viewed by turning on the Animation Component's [[Node Viewer|node viewer]].\t\t\t\n\t\t\t\n[[image:AnimationCOMPTimesliced.png|right]]",
        "opLabel": "Animation",
        "opLicense": "Non-Commercial",
        "opFamily": "COMP",
        "short": "The Animation Component is a special component used for creating keyframe animation channels.",
        "opType": "animation",
        "opFilter": "False",
        "opClass": "animationCOMP_Class",
        "opCategories": ""
    },
    "annotateCOMP": {
        "label": "annotateCOMP",
        "members": [
            {
                "text": "Menu : Switch between Comment, Network Box, and Annotate modes. See also [[Network_Utilities:_Comments,_Network_Boxes,_Annotates]].",
                "type": "MenuPar",
                "name": "Mode",
                "items": []
            },
            {
                "text": "Str : Text in the title bar",
                "type": "StrPar",
                "name": "Titletext",
                "items": []
            },
            {
                "text": "Int : Height of the title bar",
                "type": "IntPar",
                "name": "Titleheight",
                "items": []
            },
            {
                "text": "Menu : Alignment of title text",
                "type": "MenuPar",
                "name": "Titlealign",
                "items": []
            },
            {
                "text": "Str : Text in the body area",
                "type": "StrPar",
                "name": "Bodytext",
                "items": []
            },
            {
                "text": "Int : Size of text in the body area",
                "type": "IntPar",
                "name": "Bodyfontsize",
                "items": []
            },
            {
                "text": "Toggle : Wrap body text when it extends past right bound.",
                "type": "TogglePar",
                "name": "Bodywordwrap",
                "items": []
            },
            {
                "text": "Toggle : Converts quotes, ellipsis, and dashes to more typographically nice unicode versions.",
                "type": "TogglePar",
                "name": "Smartquote",
                "items": []
            },
            {
                "text": "Toggle : Use the Max Body Text Width parameter to define maximum width of text.",
                "type": "TogglePar",
                "name": "Bodylimitwidth",
                "items": []
            },
            {
                "text": "Int : Maximum body text width (in panel units)",
                "type": "IntPar",
                "name": "Bodymaxwidth",
                "items": []
            },
            {
                "text": "RGB : Background color",
                "type": "RGBPar",
                "name": "Backcolorr",
                "items": []
            },
            {
                "text": "RGB : Background color",
                "type": "RGBPar",
                "name": "Backcolorg",
                "items": []
            },
            {
                "text": "RGB : Background color",
                "type": "RGBPar",
                "name": "Backcolorb",
                "items": []
            },
            {
                "text": "Float : Background color alpha.",
                "type": "FloatPar",
                "name": "Backcoloralpha",
                "items": []
            },
            {
                "text": "Float : Opacity of the entire Annotate",
                "type": "FloatPar",
                "name": "Opacity",
                "items": []
            },
            {
                "text": "Toggle : Turn the visibility of the viewer specified in the OP parameter below on or off.",
                "type": "TogglePar",
                "name": "Opviewerdisplay",
                "items": []
            },
            {
                "text": "OP : The operator whose viewer is displayed in the Annotate",
                "type": "OPPar",
                "name": "Opviewer",
                "items": []
            },
            {
                "text": "Toggle : Allow interaction with the OP viewer",
                "type": "TogglePar",
                "name": "Opviewerinteractive",
                "items": []
            },
            {
                "text": "Menu : Use the Size/Aspect Override to control viewer's size in the background.",
                "type": "MenuPar",
                "name": "Opvieweroversize",
                "items": []
            },
            {
                "text": "WH : Diplay viewer as-if it were being displayed at this resolution. This is particularly useful for zooming into operators that don't have a built-in resolution, like CHOPs, SOPs, and DATs.",
                "type": "WHPar",
                "name": "Opviewersize",
                "items": []
            },
            {
                "text": "Float : Scale the viewer by this factor",
                "type": "FloatPar",
                "name": "Opviewerscale",
                "items": []
            },
            {
                "text": "Float : Move the border of the viewer towards left edge of Annotate when negative or towards right edge when positive.",
                "type": "FloatPar",
                "name": "Opviewerjustifyx",
                "items": []
            },
            {
                "text": "Float : Move the border of the viewer towards bottom edge of Annotate when negative or towards top edge when positive.",
                "type": "FloatPar",
                "name": "Opviewerjustifyy",
                "items": []
            },
            {
                "text": "Toggle : When True, allow viewer to display in the Annotate title area as well as body",
                "type": "TogglePar",
                "name": "Opviewerfillbodytitle",
                "items": []
            },
            {
                "text": "Float : Zoom the viewer by this scale factor without increasing the size of its display area in the Annotate.",
                "type": "FloatPar",
                "name": "Opviewerzoom",
                "items": []
            },
            {
                "text": "XY : Offsets the displayed area within the viewer. Combined with OP Viewer Zoom, this lets you display a specific area of a viewer, such as a CHOP channel or table cell.",
                "type": "XYPar",
                "name": "Opvieweroffsetx",
                "items": []
            },
            {
                "text": "XY : Offsets the displayed area within the viewer. Combined with OP Viewer Zoom, this lets you display a specific area of a viewer, such as a CHOP channel or table cell.",
                "type": "XYPar",
                "name": "Opvieweroffsety",
                "items": []
            },
            {
                "text": "Float : Alpha value of the background area in the OP Viewer.",
                "type": "FloatPar",
                "name": "Opviewerfillalpha",
                "items": []
            },
            {
                "text": "Str : Annotate COMP default setup version",
                "type": "StrPar",
                "name": "Version",
                "items": []
            },
            {
                "text": "Pulse : Click to open this page",
                "type": "PulsePar",
                "name": "Help",
                "items": []
            },
            {
                "text": "OP : The operator whose view is displayed in the Annotate area. This defines what the entire Annotate looks like and is not to be confused with the OP parameter in the OP Viewer page, which is an integrated viewer _within_ the annotate.",
                "type": "OPPar",
                "name": "opviewer",
                "items": []
            },
            {
                "text": "Toggle : When False, disables ''all'' interaction with the Annotate and passes any clicks through to the network below.",
                "type": "TogglePar",
                "name": "enable",
                "items": []
            },
            {
                "text": "Toggle : When True, other operators in the Annotate's area will move with it when it is moved.",
                "type": "TogglePar",
                "name": "encloseops",
                "items": []
            },
            {
                "text": "Toggle : Include this Annotate in the Order of annotateCOMPs in this network.",
                "type": "TogglePar",
                "name": "includeinorder",
                "items": []
            },
            {
                "text": "Float : Order number of this annotateCOMP",
                "type": "FloatPar",
                "name": "order",
                "items": []
            },
            {
                "text": "Menu : Where this annotateCOMP is layered with regards to other items in the network.",
                "type": "MenuPar",
                "name": "layerzone",
                "items": []
            },
            {
                "text": "Float : Last ditch layering index. AnnotateCOMPs in the same zone will always attempt to display smaller annotateCOMPs they enclose on top.",
                "type": "FloatPar",
                "name": "layer",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "annotateCOMP",
        "opLabel": "Annotate",
        "opClass": "annotateCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "",
        "long": "Annotates are displayed in the Network Editor as colored rectangles containing user-authored text and graphics. It is based on the [[Annotate COMP]] and allows you to document your networks with useful information like comments and node grouping.\n\nThere are three built-in forms of the Annotate COMP:  [[Network_Utilities:_Comments,_Network_Boxes,_Annotates|Comments, Network Boxes, and Annotates]] that can be easily created:\n* '''[[Network_Utilities:_Comments,_Network_Boxes,_Annotates|Comments]]''' are simple, text-only post-it notes. They can be created via the network RMB menu or with the shortcut Shift-C\n* '''[[Network_Utilities:_Comments,_Network_Boxes,_Annotates|Network Boxes]]''' group nodes together for labeling/dragging. They can be created via the network RMB menu or with the shortcut Shift-B\n* '''[[#Default_Setup|Annotates]]''' (Default Setup) do all of the above and incorporate a powerful node-viewing feature. They can be created via the network RMB menu, with the shortcut Shift-A, by holding Alt and left-dragging in the network, or by selecting Annotate from the COMP family in the [[OP Create Dialog]]."
    },
    "baseCOMP": {
        "label": "baseCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLabel": "Base",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "short": "The Base Component has no panel parameters and no 3D object parameters.",
        "opFamily": "COMP",
        "long": "The Base Component has no panel parameters and no 3D object parameters. You would use it for a component that has no panel associated with it, nor any 3D, such as component that converted RGB channels to HSV channels.",
        "opType": "base",
        "opClass": "baseCOMP_Class",
        "opCategories": ""
    },
    "blendCOMP": {
        "label": "blendCOMP",
        "members": [
            {
                "text": "Menu : Method in which parent transforms (i.e. Translate, Rotate, Scale) are combined to produce a unique blended transform.",
                "type": "MenuPar",
                "name": "parenttype",
                "items": []
            },
            {
                "text": "Float : Enabled when Type parameter above is set to Sequence or Constrain, it selects which input's transform to use.",
                "type": "FloatPar",
                "name": "sequence",
                "items": []
            },
            {
                "text": "Float : When in constrain mode, this will reset the final transform back to its original position.  On other frames, when the constrained parent changes, the relative transform to this Object is maintained.",
                "type": "FloatPar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Float : These weights are used to weight each corresponding input parent.",
                "type": "FloatPar",
                "name": "blendw1",
                "items": []
            },
            {
                "text": "Int : These masks are used to select which component of each parent is used in the blending process.",
                "type": "IntPar",
                "name": "blendm1",
                "items": []
            },
            {
                "text": "Float : These weights are used to weight each corresponding input parent.",
                "type": "FloatPar",
                "name": "blendw2",
                "items": []
            },
            {
                "text": "Int : These masks are used to select which component of each parent is used in the blending process.",
                "type": "IntPar",
                "name": "blendm2",
                "items": []
            },
            {
                "text": "Float : These weights are used to weight each corresponding input parent.",
                "type": "FloatPar",
                "name": "blendw3",
                "items": []
            },
            {
                "text": "Int : These masks are used to select which component of each parent is used in the blending process.",
                "type": "IntPar",
                "name": "blendm3",
                "items": []
            },
            {
                "text": "Float : These weights are used to weight each corresponding input parent.",
                "type": "FloatPar",
                "name": "blendw4",
                "items": []
            },
            {
                "text": "Int : These masks are used to select which component of each parent is used in the blending process.",
                "type": "IntPar",
                "name": "blendm4",
                "items": []
            },
            {
                "text": "Float : When exactly three parents are input, the child position may be offset in the direction perpendicular to the triangular plane they form.",
                "type": "FloatPar",
                "name": "noffset",
                "items": []
            },
            {
                "text": "Toggle : When exactly three parents are input this option will orient the child's local axes to match the orientation of the parents as follows:<!--TDparEnd-->\t\n\t\t\t\n<!--TDitemStart-->* '''First Parent'''<nowiki>: Axes Center</nowiki><!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* '''Second Parent'''<nowiki>: Axes +X</nowiki><!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* '''Third Parent'''<nowiki>: Axes +Y </nowiki><!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "axesorient",
                "items": []
            },
            {
                "text": "Toggle : Does quaternion blending in cases with 2 inputs are being blended.",
                "type": "TogglePar",
                "name": "shortrot",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "opLabel": "Blend",
        "opFamily": "COMP",
        "long": "The Blend Component allows the blending of its attached 3D objects, allowing you to animate the parents of Components, sequencing (object A to object B to C, etc.), partial transformation inheritance, three-point orientation, and other effects. It gives you some extra flexibility in setting up parent-child relationships. It operates like the Switch and Sequence Blend SOPs insofar as it takes more than one input and blends or switches those into one output.\tIt affects the object transform only, not the contents of the blended components.\n\nSome potential uses of the Blend op are to animate parenting, such as when one character passes an item to another, or to pass on only part of a parents characteristics.\n\nNote that the effect of the Blend COMP is only visible through a [[Camera COMP]] or the [[Render TOP]] that is rendering that camera's view.\n\nSee also [[Camera Blend COMP]].",
        "opClass": "blendCOMP_Class",
        "short": "The Blend Component allows various effects such as blended inputs, animating the parents of Components, sequencing, partial transformation inheritance, three-point orientation, and other effects.",
        "opType": "blend",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "boneCOMP": {
        "label": "boneCOMP",
        "members": [
            {
                "text": "Toggle : Enabling this option allows you to toggle the display of the link geometry in the Viewport on and off.",
                "type": "TogglePar",
                "name": "displaylink",
                "items": []
            },
            {
                "text": "XYZ : Defines the relative weighting of rotations about Rx, Ry, Rz, the bone's x,y,z axis for the Inverse Kinematics solver.",
                "type": "XYZPar",
                "name": "restanglesx",
                "items": []
            },
            {
                "text": "XYZ : Defines the relative weighting of rotations about Rx, Ry, Rz, the bone's x,y,z axis for the Inverse Kinematics solver.",
                "type": "XYZPar",
                "name": "restanglesy",
                "items": []
            },
            {
                "text": "XYZ : Defines the relative weighting of rotations about Rx, Ry, Rz, the bone's x,y,z axis for the Inverse Kinematics solver.",
                "type": "XYZPar",
                "name": "restanglesz",
                "items": []
            },
            {
                "text": "Float : This parameter changes the overall length of the Bone Component. It affects the size of the bone geometry and the positioning of the capture geometry and also determines the \"end\" of the bone -- i.e. where Bone Components that are children of this bone will be positioned. By default, its end is oriented so that it lays along the local negative Z axis.",
                "type": "FloatPar",
                "name": "length",
                "items": []
            },
            {
                "text": "Float : This parameter prevents bone chains from locking in a dramatically straight line when they are fully extended. This type of locking motion tends to make characters look robotic. The dampening field is a number between zero and one. The larger the number, the greater the dampening effect. Dampening is applied to the entire bone chain as the chain approaches its full extension. The end affector is thus allowed to drift off the end of the bone chain. The net effect is that when the chain is nearly fully extended, a relatively large end affector motion will cause a relatively small motion in the end of the chain. This gives the animator finer granularity in controlling the bone chain when it is fully extended.",
                "type": "FloatPar",
                "name": "ikdamp",
                "items": []
            },
            {
                "text": "Float : Specifies the maximum and minimum rotation angles.",
                "type": "FloatPar",
                "name": "xrange",
                "items": []
            },
            {
                "text": "Float : Applies damping to the rotation of the bone when the rotation in each axis falls within the angle specified by <span class=\"tipTextCOMP\">X / Y Angle Range</span>.",
                "type": "FloatPar",
                "name": "xdamp",
                "items": []
            },
            {
                "text": "Float : Specifes the rate at which the damping increases as the rotation varies through the angle specifed by <span class=\"tipTextCOMP\">X / Y Angle Range</span>.",
                "type": "FloatPar",
                "name": "xrolloff",
                "items": []
            },
            {
                "text": "Float : Specifies the maximum and minimum rotation angles.",
                "type": "FloatPar",
                "name": "yrange",
                "items": []
            },
            {
                "text": "Float : Applies damping to the rotation of the bone when the rotation in each axis falls within the angle specified by <span class=\"tipTextCOMP\">X / Y Angle Range</span>.",
                "type": "FloatPar",
                "name": "ydamp",
                "items": []
            },
            {
                "text": "Float : Specifes the rate at which the damping increases as the rotation varies through the angle specifed by <span class=\"tipTextCOMP\">X / Y Angle Range</span>.",
                "type": "FloatPar",
                "name": "yrolloff",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "displaycapture",
                "items": []
            },
            {
                "text": "XYZ : Position of the center of the region.",
                "type": "XYZPar",
                "name": "crcenterx",
                "items": []
            },
            {
                "text": "XYZ : Position of the center of the region.",
                "type": "XYZPar",
                "name": "crcentery",
                "items": []
            },
            {
                "text": "XYZ : Position of the center of the region.",
                "type": "XYZPar",
                "name": "crcenterz",
                "items": []
            },
            {
                "text": "Float : Height of the region from the centre to the top cap.",
                "type": "FloatPar",
                "name": "crtopheight",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "crtopcapx",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "crtopcapy",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "crtopcapz",
                "items": []
            },
            {
                "text": "Float : Height of the region from the centre to the top cap.",
                "type": "FloatPar",
                "name": "crbotheight",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "crbotcapx",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "crbotcapy",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "crbotcapz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Bone",
        "opFamily": "COMP",
        "long": "The Bone Component is the foundation of all of the [[Character Tools]]. It is a Component with most of the properties of a [[Geometry COMP|Geometry Component]]. It also has some extra features such as length, two types of geometry, end-to-end linking, and kinematic parameters.\t\t\n\t\t\t\nThe Bone Component is used to create hierarchies of limb-like objects that form part of a hierarchy or chain of Bone Components that are parented to one another. The movement of the chain of Bone Components is \"solved\" or computed based on several methods including Inverse Kinematics. The parenting attribute of bones is unique in that each bone attaches to the end, not the origin, of the parent bone.\t\t\t\n\t\t\t\nIt is recommended that you use the Bone Creation state, accessed through the state icons above the Viewport, to construct such a chain because placing individual Bone Components and establishing their parenting relationships from operator to operator is extremely time consuming and not at all intuitive. In addition, a chain created using the Bone state will produce a better behaved bone chain. \t\t\t\n\t\t\t\nBy default, bones do not render. They contain two types of display geometry: \"link geometry\" and \"capture region geometry\". The former consists of a narrow diamond shape which has been stretched to the length specified in ''Bone Length'', and placed along the Bone Component's negative Z-axis. The latter consists of two or more user-controllable ellipses that are used to define capture regions used in skeleton sops. You can specify whether either of the two types of geometry are displayed. \t\t\t\n\t\t\t\nThe actual movement of the Bone Components is controlled through an IK CHOP (when using the standard Capture/Deform model). This is effected through an expression in the '''Transform''' channels of the Bone Component. If you want to override this behaviour, then you need to delete the bone's translate channels such that they are no longer over-ridden by chop control. \t\t\t\n\t\t\t\nIf you make a bone the child of a non-bone Component, then it will attach to the origin of that Component. If you want to reposition the bone relative to its non-bone parent, you must remove the expression in the bone's translate parameters.",
        "opClass": "boneCOMP_Class",
        "short": "The Bone Component is the foundation of all of the [[Character Tools]].",
        "opType": "bone",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "bulletsolverCOMP": {
        "label": "bulletsolverCOMP",
        "members": [
            {
                "text": "objref : The Actor COMPs to include in the simulation. These actors cannot already be a part of another Bullet Solver COMP.",
                "type": "objrefPar",
                "name": "actors",
                "items": []
            },
            {
                "text": "objref : The Force COMPs to include in the simulation. These forces are global forces and will be applied to all non-static actors in the simulation.",
                "type": "objrefPar",
                "name": "forces",
                "items": []
            },
            {
                "text": "float : Gravity applied to all actors in the simulation in m/s^2. Gravity is applied to actors irrespective of their mass.",
                "type": "floatPar",
                "name": "gravity",
                "items": []
            },
            {
                "text": "dropmenu : The dimension of the simulation. The options in this menu can also be recreated using the linear/angular multiplier parameters.",
                "type": "dropmenuPar",
                "name": "dimension",
                "items": []
            },
            {
                "text": "float : A multiplier for the linear velocities of the actors in the simulation. For example, if linmult is (0, 1, 1) then the actors can move linearly at normal speed on the Y and Z axes but cannot move in the X direction. These values are multiplied internally by the values from dimension. For example, if the dimension is 2D and linmult is (0, 1, 1) then the only direction the actors can move is along the Y axis because 2D is constraining on the Z and this parameter is constraining on the Y.",
                "type": "floatPar",
                "name": "linmult",
                "items": []
            },
            {
                "text": "float : A multiplier for the angular velocities of the actors in the simulation. For example, if angmult is (1, 0, 0) then the actors can only rotate on the X axes. These values are multiplied internally by the values from dimension. So, if dimension is 2D and angmult is (1, 0, 0) then the actor will not be able to rotate in any direction because 2D constrains rotation only to the Z axis, and this parameter is constraining it only to the X axis.",
                "type": "floatPar",
                "name": "angmult",
                "items": []
            },
            {
                "text": "button : Resets all bodies to their initial state (ie. position, orientation, velocity) and recreates their collision shapes. This parameter is equivalent to pulsing each Actor COMP's \"Initialize Actor\". Creating collision shapes can be time consuming in certain cases, so if it's not need then Initialize Sim should be used instead. Collision shapes need to be recreated if any of the SOPs used to create the collision shape change, or if the instancing OP changes.",
                "type": "buttonPar",
                "name": "initall",
                "items": []
            },
            {
                "text": "button : Reset all bodies to their initial state (ie. position, orientation, velocity). This will not begin stepping through the simulation, it will only initialize. '''NOTE:''' This will not reset the collision shapes of any Actor COMPs, \"Initialize Sim and Collision Shapes\" above or \"Initialize Actor\" on the Actor COMP should be used for that.",
                "type": "buttonPar",
                "name": "init",
                "items": []
            },
            {
                "text": "button : Initialize the simulation and run it (begin stepping).",
                "type": "buttonPar",
                "name": "start",
                "items": []
            },
            {
                "text": "toggle : Play the simulation. Will step through the simulation when toggled on, but will not when it is toggled off (ie. it will be paused).",
                "type": "togglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "float : The sample rate of the simulation.  The sample rate affects the timestep, which is 1/rate",
                "type": "floatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "float : The speed of the simulation. It is a multiplier for the size of the timestep to slow down or speed up the simulation.",
                "type": "floatPar",
                "name": "simspeed",
                "items": []
            },
            {
                "text": "chopref : (see also: [[Bullet Solver CHOP]]) A reference to a CHOP to feedback. The Bullet Solver COMP will take the transform/velocity channels from the CHOP and override the respective actor's transform or velocity at the beginning of the next simulation step. \nIf you feedback a Bullet Solver CHOP that has no change to the channel values in it, the simulation will act as normal as nothing is being overriden. This allows you do things like the example below. \nFor example, to negate the velocity of every actor in a simulation you could use a Bullet Solver CHOP, put that into a Switch CHOP with the second input being the same CHOP only with the velocity channels negated. Then export a button pulse to the switch index and put the Switch CHOP into the Feedback CHOP parameter. Then, when the button is pressed for a single frame (pulsed) the velocities will be overridden and negated.  \nThe only channels required to feedback are the actor_id and body_id channels, all other channels are optional. The channel names should all be the same as in the Bullet Solver CHOP. In addition to the channels outputted in the Bullet Solver CHOP, force and torque can also be used. The channel names are '''force[xyz]''' and '''torque[xyz]'''. '''NOTE:''' scale cannot be used for feedback.",
                "type": "choprefPar",
                "name": "feedback",
                "items": []
            },
            {
                "text": "toggle : Enables contact testing for all bodies in the simulation. Contact testing is used for the colliding and total_collisions channels on the Bullet Solver CHOP. Without this parameter enabled those channel values will not update. '''NOTE:''' Contact testing can be slow for lots of bodies.",
                "type": "togglePar",
                "name": "contacttest",
                "items": []
            },
            {
                "text": "toggle : When enabled the Bullet Solver COMP will simulate (ie. cook) every frame.",
                "type": "togglePar",
                "name": "alwayssim",
                "items": []
            },
            {
                "text": "datref : A reference to a DAT with python callbacks. The available callbacks are: <code>onCollision(solverComp, collisions)</code>, <code>onFrameStart(solverComp)</code>, <code>onFrameEnd(solverComp)</code>, <code>onInit(solverComp)</code>, <code>onStart(solverComp)</code>. A DAT with these callbacks will be automatically created and referenced when a Bullet Solver COMP is created. <code>onCollision(solverComp, collisions)</code> passes a list of all collisions occuring, and requires that Perform Contact test be enabled. <code>collisions</code> is a list of named tuples (<code>bodyA</code> and <code>bodyB</code>). <code>bodyA</code> and <code>bodyB</code> are the two bodies participating in the collision. <code>bodyA</code> and <code>bodyB</code> are Python Body Objects (see [[Body Class]]).",
                "type": "datrefPar",
                "name": "callbacks",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "bulletsolverCOMP",
        "opLabel": "Bullet Solver",
        "opClass": "bulletsolverCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "In a [[Bullet Dynamics]] system, the Bullet Solver COMP is analogous to the world/simulation in which actors/bodies (ie. [[Actor COMP]]s) operate.",
        "long": "In a [[Bullet Dynamics]] system, the Bullet Solver COMP is analogous to the world/simulation in which actors/bodies (ie. [[Actor COMP]]s) operate. A Bullet Solver COMP contains any number of actors/bodies (Actor COMPs) or forces ([[Force COMP]]/[[Impulse Force COMP]]), and as the name suggests it also uses the [https://pybullet.org/wordpress/ Bullet Physics API] to step through the simulation. \n   \nThe Bullet Solver COMP runs a Bullet simulation based on some simulation parameters (eg. linear multiplier or angular multiplier) and updates the transformations of the Actor COMPs contained within it as the simulation progresses forward. The simulation can be paused, slowed down, sped up, or restarted using the parameters on the COMP. \n\nThe Bullet Solver COMP simulation operates in a vacuum, so there will be no air resistance applied to any actors in the simulation. The simulation is stepped at the given sample rate, and the Actor COMP transform is updated accordingly. These transformations are the same results displayed in the [[Bullet Solver CHOP]]. \n \nThe Actor COMPs referenced by the Bullet Solver COMP do not need to be inside its network. They can be anywhere as long as they are not already referenced by another Bullet Solver COMP.\n\nSee also: [[Bullet Dynamics]], [[Actor COMP]], [[Force COMP]], [[Impulse Force COMP]], [[Constraint COMP]], [[Bullet Solver CHOP]].",
        "opCategories": ""
    },
    "buttonCOMP": {
        "label": "buttonCOMP",
        "members": [
            {
                "text": "Menu : This menu determines the button's state behavior.",
                "type": "MenuPar",
                "name": "buttontype",
                "items": []
            },
            {
                "text": "Str : Create a radio button group using this parameter. Buttons grouped using this parameter must all be located in the same component. Any buttons with the same group label will be in the same radio group.",
                "type": "StrPar",
                "name": "buttongroup",
                "items": []
            },
            {
                "text": "DAT : Specify a [[Table DAT]] that lists all buttons in a radio group. This allows a group of radio buttons to have its member buttons located in any network - the buttons do not have to be in the same component. The paths are relative to the DAT and can contain patterns and wildcards (see [[Pattern Matching]]). When a button is activated, it modifies the radio panel values of the DAT's parent, not its own parent, since buttons can now be scattered in different components.",
                "type": "DATPar",
                "name": "buttongroupdat",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Button Component is used in panels to provide interactive on/off buttons, including toggle buttons, momentary buttons, and sets of radio buttons or exclusive buttons. Radio and exclusive buttons act as a group, which can be as simple as all Button components in a Container component. The group can be specified more tightly using the Button Group Label parameter or the Button Group DAT parameter. \t\t\n\t\t\t\n[[image:ButtonCOMP.png]]\n\t\t\t\nDefault Button Component",
        "1": "Default Button Component",
        "opLicense": "Non-Commercial",
        "opFamily": "COMP",
        "opLabel": "Button",
        "short": "The Button Component is used in panels to provide interactive on/off buttons, including toggle buttons, momentary buttons, and sets of radio buttons or exclusive buttons.",
        "opType": "button",
        "opFilter": "False",
        "opClass": "buttonCOMP_Class",
        "opCategories": ""
    },
    "camerablendCOMP": {
        "label": "camerablendCOMP",
        "members": [
            {
                "text": "Menu : Method in which parent transforms (i.e. Translate, Rotate, Scale) are combined to produce a unique blended transform.",
                "type": "MenuPar",
                "name": "parenttype",
                "items": []
            },
            {
                "text": "Float : Select which input to use for the position when set to Sequence or Constrain.",
                "type": "FloatPar",
                "name": "sequence",
                "items": []
            },
            {
                "text": "Float : When in constrain mode, this will reset the final transform back to its original position. On other frames, when the constrained parent changes, the relative transform to this camera is maintained.",
                "type": "FloatPar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Float : These weights are used to weight each corresponding input parent.",
                "type": "FloatPar",
                "name": "blendw1",
                "items": []
            },
            {
                "text": "Int : These masks are used to select which component of each parent is used in the blending process.",
                "type": "IntPar",
                "name": "blendm1",
                "items": []
            },
            {
                "text": "Float : These weights are used to weight each corresponding input parent.",
                "type": "FloatPar",
                "name": "blendw2",
                "items": []
            },
            {
                "text": "Int : These masks are used to select which component of each parent is used in the blending process.",
                "type": "IntPar",
                "name": "blendm2",
                "items": []
            },
            {
                "text": "Float : These weights are used to weight each corresponding input parent.",
                "type": "FloatPar",
                "name": "blendw3",
                "items": []
            },
            {
                "text": "Int : These masks are used to select which component of each parent is used in the blending process.",
                "type": "IntPar",
                "name": "blendm3",
                "items": []
            },
            {
                "text": "Float : These weights are used to weight each corresponding input parent.",
                "type": "FloatPar",
                "name": "blendw4",
                "items": []
            },
            {
                "text": "Int : These masks are used to select which component of each parent is used in the blending process.",
                "type": "IntPar",
                "name": "blendm4",
                "items": []
            },
            {
                "text": "Float : When exactly three parents are input, the child position may be offset in the direction perpendicular to the triangular plane they form.",
                "type": "FloatPar",
                "name": "noffset",
                "items": []
            },
            {
                "text": "Toggle : When exactly three parents are input, this option will orient the child's local axes to match the orientation of the parents as follows:<!--TDparEnd-->\t\n\t\t\t\n<!--TDitemStart-->* '''First Parent'''<nowiki>: Axes Center</nowiki><!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* '''Second Parent'''<nowiki>: Axes +X</nowiki><!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* '''Third Parent'''<nowiki>: Axes +Y </nowiki><!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "axesorient",
                "items": []
            },
            {
                "text": "Toggle : Does quaternion blending in cases where 2 inputs are being blended.",
                "type": "TogglePar",
                "name": "shortrot",
                "items": []
            },
            {
                "text": "Menu : A pop-up menu lets you choose from <span class=\"tipTextCOMP\">Perspective</span> and <span class=\"tipTextCOMP\">Orthographic</span> projection types. A third option <span class=\"tipTextCOMP\">Perpective to Ortho Blend</span> enables the <span class=\"tipTextCOMP\">Projection Blend</span> parameter below which can be used to blend between perspectives.",
                "type": "MenuPar",
                "name": "projection",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "projectionblend",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "orthowidth",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "viewanglemethod",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "fov",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "focal",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "aperture",
                "items": []
            },
            {
                "text": "Float : This control allows you to designate the near clipping planes. Geometry closer from the lens than these distances will not be visible.\t\n\t\t\t\n'''NOTE:''' If geometry in your scene is producing z-depth artifacts, increase the resolution of the camera's z-depth buffer. To do this, decrease the difference between near and far clipping planes, starting with the near plane.",
                "type": "FloatPar",
                "name": "near",
                "items": []
            },
            {
                "text": "Float : This control allows you to designate the far clipping planes. Geometry further away from the lens than these distances will not be visible.\t\n\t\t\t\n'''NOTE:''' If geometry in your scene is producing z-depth artifacts, increase the resolution of the camera's z-depth buffer. To do this, decrease the difference between near and far clipping planes, starting with the near plane.",
                "type": "FloatPar",
                "name": "far",
                "items": []
            },
            {
                "text": "XY : These parameters define the center of the window during the rendering process. The window parameter takes the view and expands it to fit the camera's field of vision. It is important to note that this action is independent of perspective. In other words, it acts as though you are panning the camera without actually moving the camera.",
                "type": "XYPar",
                "name": "winx",
                "items": []
            },
            {
                "text": "XY : These parameters define the center of the window during the rendering process. The window parameter takes the view and expands it to fit the camera's field of vision. It is important to note that this action is independent of perspective. In other words, it acts as though you are panning the camera without actually moving the camera.",
                "type": "XYPar",
                "name": "winy",
                "items": []
            },
            {
                "text": "XYZ : The <span class=\"tipTextCOMP\">Window Size</span> parameter specifies the dimensions for expanding the view. Similar to <span class=\"tipTextCOMP\">Window X / Y</span>, this parameter creates a zoom effect by scaling the screen before rendering to the viewport.",
                "type": "XYZPar",
                "name": "winsizex",
                "items": []
            },
            {
                "text": "XYZ : The <span class=\"tipTextCOMP\">Window Size</span> parameter specifies the dimensions for expanding the view. Similar to <span class=\"tipTextCOMP\">Window X / Y</span>, this parameter creates a zoom effect by scaling the screen before rendering to the viewport.",
                "type": "XYZPar",
                "name": "winsizey",
                "items": []
            },
            {
                "text": "XYZ : The <span class=\"tipTextCOMP\">Window Size</span> parameter specifies the dimensions for expanding the view. Similar to <span class=\"tipTextCOMP\">Window X / Y</span>, this parameter creates a zoom effect by scaling the screen before rendering to the viewport.",
                "type": "XYZPar",
                "name": "winsizez",
                "items": []
            },
            {
                "text": "XYZ : This parameter sets the amount, in degrees, the window area rolls. This can be set as a static value or as an aspect that changes over the course of the animation. The roll occurs about the centre of the window.",
                "type": "XYZPar",
                "name": "winrollx",
                "items": []
            },
            {
                "text": "XYZ : This parameter sets the amount, in degrees, the window area rolls. This can be set as a static value or as an aspect that changes over the course of the animation. The roll occurs about the centre of the window.",
                "type": "XYZPar",
                "name": "winrolly",
                "items": []
            },
            {
                "text": "XYZ : This parameter sets the amount, in degrees, the window area rolls. This can be set as a static value or as an aspect that changes over the course of the animation. The roll occurs about the centre of the window.",
                "type": "XYZPar",
                "name": "winrollz",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "ipdshiftx",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "ipdshifty",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "ipdshiftz",
                "items": []
            },
            {
                "text": "OP : ",
                "type": "OPPar",
                "name": "projmatrixop",
                "items": []
            },
            {
                "text": "RGBA : Sets the background color and alpha of the camera's view.",
                "type": "RGBAPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGBA : Sets the background color and alpha of the camera's view.",
                "type": "RGBAPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGBA : Sets the background color and alpha of the camera's view.",
                "type": "RGBAPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "RGBA : Sets the background color and alpha of the camera's view.",
                "type": "RGBAPar",
                "name": "bgcolora",
                "items": []
            },
            {
                "text": "Menu : This menu determines the type of fog rendered in the viewport: <blockquote><span class=\"tipTextCOMP\">'''Linear'''</span> fog uses the following equation: </blockquote>\t\n\t\t\t\n[[Image:Objects14.gif]]\t\t\t\n\t\t\t\n<blockquote><span class=\"tipTextCOMP\">'''Exponential'''</span> fog uses the following equation:</blockquote>\t\t\t\n\t\t\t\n[[Image:Objects18.gif]]\t\t\t\n\t\t\t\n<blockquote><span class=\"tipTextCOMP\">'''Squared Exponential'''</span> fog uses the following equation: </blockquote>\t\t\t\n\t\t\t\n[[Image:Objects20.gif]]\t\t\t\n\t\t\t\n<blockquote>Regardless of the fog mode, f is clamped to the range [0,1] after it is computed. Then, if GL is in RGBA color mode, the fragment's color Cr is replaced by:</blockquote>\t\t\t\n\t\t\t\n[[Image:Objects19.gif]]",
                "type": "MenuPar",
                "name": "fog",
                "items": []
            },
            {
                "text": "Float : A value that specifies density or thickness, used in both exponential fog types. Only non-negative densities are accepted.",
                "type": "FloatPar",
                "name": "fogdensity",
                "items": []
            },
            {
                "text": "Float : The starting distance of the fog. If geometry is closer to the camera than this distance, fog will not be calculated in the color of the geometry. Used in the linear fog equation.",
                "type": "FloatPar",
                "name": "fognear",
                "items": []
            },
            {
                "text": "Float : The far distance used in the linear fog equation.",
                "type": "FloatPar",
                "name": "fogfar",
                "items": []
            },
            {
                "text": "RGB : The color of the fog.",
                "type": "RGBPar",
                "name": "fogcolorr",
                "items": []
            },
            {
                "text": "RGB : The color of the fog.",
                "type": "RGBPar",
                "name": "fogcolorg",
                "items": []
            },
            {
                "text": "RGB : The color of the fog.",
                "type": "RGBPar",
                "name": "fogcolorb",
                "items": []
            },
            {
                "text": "Float : Used to control the background opacity of the scene.",
                "type": "FloatPar",
                "name": "fogalpha",
                "items": []
            },
            {
                "text": "TOP : ",
                "type": "TOPPar",
                "name": "fogmap",
                "items": []
            },
            {
                "text": "Object : ",
                "type": "ObjectPar",
                "name": "camlightmask",
                "items": []
            },
            {
                "text": "MAT : ",
                "type": "MATPar",
                "name": "material",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "opLabel": "Camera Blend",
        "opFamily": "COMP",
        "long": "The Camera Blend Component blends the 3D object transforms and viewing settings of multiple Camera Components together. It gives you some extra flexibility in setting up parent-child relationships. It operates like the [[Switch SOP]] and [[Sequence Blend SOP]]s insofar as it takes more than one input and blends or switches those into one output.\t\t\n\t\t\t\nThe Camera Blend COMP can animate camera parameters and positions between various cameras. \n\nTo set up, wire the bottom connector of a Camera COMP to the top input of the Camera Blend COMP. Then for another Camera COMP, wire its bottom connector to the top of the Camera Blend COMP. Then you can adjust the Weight parameters of the Camera Blend COMP.\n\t\t\t\nThe View and Background parameter pages are used as the camera parameters when non-Camera COMPs are connected to the Camera Blend COMP.\t\t\t\n\nSee also [[Blend COMP]].",
        "opClass": "camerablendCOMP_Class",
        "short": "The Camera Blend Component allows various effects by blending multiple Components together.",
        "opType": "camblend",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "cameraCOMP": {
        "label": "cameraCOMP",
        "members": [
            {
                "text": "Menu : A pop-up menu lets you choose from Perspective and Orthographic projection types. A third option Perpective to Ortho Blend enables the Projection Blend parameter below which can be used to blend between perspectives. A 4th option Custom Projection Matrix allows you to specify a custom 4x4 projection matrix using a tdu.Matrix, CHOP or a DAT.",
                "type": "MenuPar",
                "name": "projection",
                "items": []
            },
            {
                "text": "Float : Blends between perspective projection and orthographic projection when the Projection parameter is set to Perspective to Ortho Blend.",
                "type": "FloatPar",
                "name": "projectionblend",
                "items": []
            },
            {
                "text": "Float : Only active if Orthographic is chosen from the Projection pop-up menu. This specifies the width of the orthographic projection.",
                "type": "FloatPar",
                "name": "orthowidth",
                "items": []
            },
            {
                "text": "Menu : This menu determines which method is used to define the camera's angle of view.",
                "type": "MenuPar",
                "name": "viewanglemethod",
                "items": []
            },
            {
                "text": "Float : The field of view (FOV) angle is the angular extend of the scene imaged by the camera.\n        \n'''Useful Equations'''\n\nField of View and Throw Angle: The FOV would be:\t\t\t\n:FOV = arctan( (screenWidth / 2) / (distanceToScreen) ) * 2\t\t\t\n:FOV = arctan( 0.5 * (screenWidth / distanceToScreen) ) * 2\t\t\t\n\nThrow is:\t\t\t\n:Throw = distanceToScreen / screenWidth\t\t\t\n:1/Throw = screenWidth / distanceToScreen\t\t\t\n\t\t\t\nIn terms of throw, it\u2019s\t\t\t\n\t\t\t\n:FOV = arctan(0.5 * (1/Throw)) * 2\t\t\t\n:FOV = arctan(0.5 / Throw) * 2\t\t\t\n\n'''FOV calculations in x and y'''\n\nThe above equations can be used to determine FOV_x and FOV_y (ie. horizontally and vertically) using Comera COMP parameters focal and aperture. In TouchDesigner's Camera COMP, screenWidth = aperture parameter and distanceToScreen = focal parameter (assuming infinity focus), from this \n:FOV_x = arctan( (aperture / 2) / focal) * 2\n\nFurthermore, as mentioned above aperture parameter = aperture_x and if given the resolution in x and y of the rendered view (ie. aspect ratio)\n:aperture_y = resy/resx * aperture_x\n\nFrom this\n:FOV_y = arctan( (aperture_y / 2) / focal ) * 2",
                "type": "FloatPar",
                "name": "fov",
                "items": []
            },
            {
                "text": "Float : The parameter sets the focal length of the lens, zooming in and out. Perspective is flattened or exaggerated depending on focal length. See FOV Angle parameter for relation of aperture, focal length and field of view angle. Some interesting distortion effects can be acheived with this parameter.",
                "type": "FloatPar",
                "name": "focal",
                "items": []
            },
            {
                "text": "Float : This value relates to the area through which light can pass for the camera.",
                "type": "FloatPar",
                "name": "aperture",
                "items": []
            },
            {
                "text": "Float : This control allows you to designate the near clipping planes. Geometry closer from the lens than these distances will not be visible.\t\n\t\t\t\n'''NOTE:''' If geometry in your scene is producing z-depth artifacts, increase the resolution of the camera's z-depth buffer. To do this, decrease the difference between near and far clipping planes, starting with the near plane.",
                "type": "FloatPar",
                "name": "near",
                "items": []
            },
            {
                "text": "Float : This control allows you to designate the far clipping planes. Geometry further away from the lens than these distances will not be visible.\t\n\t\t\t\n'''NOTE:''' If geometry in your scene is producing z-depth artifacts, increase the resolution of the camera's z-depth buffer. To do this, decrease the difference between near and far clipping planes, starting with the near plane.",
                "type": "FloatPar",
                "name": "far",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "winrollpivot",
                "items": []
            },
            {
                "text": "XY : These parameters define the center of the window during the rendering process. The window parameter takes the view and expands it to fit the camera's field of vision. It is important to note that this action is independent of perspective. In other words, it acts as though you are panning the camera without actually moving the camera. The units for this parameter are normalized. That is a Window X of -0.5 will move the previous center of the image to the left edge of the render.",
                "type": "XYPar",
                "name": "winx",
                "items": []
            },
            {
                "text": "XY : These parameters define the center of the window during the rendering process. The window parameter takes the view and expands it to fit the camera's field of vision. It is important to note that this action is independent of perspective. In other words, it acts as though you are panning the camera without actually moving the camera. The units for this parameter are normalized. That is a Window X of -0.5 will move the previous center of the image to the left edge of the render.",
                "type": "XYPar",
                "name": "winy",
                "items": []
            },
            {
                "text": "XYZ : The Window Size parameter specifies the dimensions for expanding the view. Similar to Window X / Y, this parameter creates a zoom effect by scaling the screen before rendering to the viewport.",
                "type": "XYZPar",
                "name": "winsizex",
                "items": []
            },
            {
                "text": "XYZ : The Window Size parameter specifies the dimensions for expanding the view. Similar to Window X / Y, this parameter creates a zoom effect by scaling the screen before rendering to the viewport.",
                "type": "XYZPar",
                "name": "winsizey",
                "items": []
            },
            {
                "text": "XYZ : The Window Size parameter specifies the dimensions for expanding the view. Similar to Window X / Y, this parameter creates a zoom effect by scaling the screen before rendering to the viewport.",
                "type": "XYZPar",
                "name": "winsizez",
                "items": []
            },
            {
                "text": "XYZ : This parameter sets the amount, in degrees, the window area rolls. This can be set as a static value or as an aspect that changes over the course of the animation. The roll occurs about the centre of the window.",
                "type": "XYZPar",
                "name": "winrollx",
                "items": []
            },
            {
                "text": "XYZ : This parameter sets the amount, in degrees, the window area rolls. This can be set as a static value or as an aspect that changes over the course of the animation. The roll occurs about the centre of the window.",
                "type": "XYZPar",
                "name": "winrolly",
                "items": []
            },
            {
                "text": "XYZ : This parameter sets the amount, in degrees, the window area rolls. This can be set as a static value or as an aspect that changes over the course of the animation. The roll occurs about the centre of the window.",
                "type": "XYZPar",
                "name": "winrollz",
                "items": []
            },
            {
                "text": "XYZ : This is the Interpupillary Distance which applies a translation on the X axis. It is separate from the other translations because when doing things such as a Cube Map rendering, the shift needs to occur after the rotation to the other cube face. If you apply the shift directly in the X translate parameter the cameras will be in the incorrect spot for many of the cube faces.\n\nTo use the IPD with 2 cameras, the right eye camera should be set with +IPD/2 and the left eye camera to -IPD/2.",
                "type": "XYZPar",
                "name": "ipdshiftx",
                "items": []
            },
            {
                "text": "XYZ : This is the Interpupillary Distance which applies a translation on the X axis. It is separate from the other translations because when doing things such as a Cube Map rendering, the shift needs to occur after the rotation to the other cube face. If you apply the shift directly in the X translate parameter the cameras will be in the incorrect spot for many of the cube faces.\n\nTo use the IPD with 2 cameras, the right eye camera should be set with +IPD/2 and the left eye camera to -IPD/2.",
                "type": "XYZPar",
                "name": "ipdshifty",
                "items": []
            },
            {
                "text": "XYZ : This is the Interpupillary Distance which applies a translation on the X axis. It is separate from the other translations because when doing things such as a Cube Map rendering, the shift needs to occur after the rotation to the other cube face. If you apply the shift directly in the X translate parameter the cameras will be in the incorrect spot for many of the cube faces.\n\nTo use the IPD with 2 cameras, the right eye camera should be set with +IPD/2 and the left eye camera to -IPD/2.",
                "type": "XYZPar",
                "name": "ipdshiftz",
                "items": []
            },
            {
                "text": "OP : When Custom Projection Matrix is selected, this parameters should be filled in a custom 4x4 projection matrix. For ways to specify a matrix in a parameter, refer to the [[Matrix Parameters]] article.  The projection matrix should generate depth values in Vulkan depth clip range [0,1], not OpenGL clip range [-1,1].",
                "type": "OPPar",
                "name": "projmatrixop",
                "items": []
            },
            {
                "text": "DAT : Takes a DAT containing a GLSL shader to specify custom projection functions. You must provide one functions in this shader. As a starting point, here are the definitions for the function that is used when custom ones are not provided. This will only be used when the Render TOP is rendering a 2D output, not cubemaps or fisheye renders. Note that projection works using Vulkan depth clip range [0,1], not OpenGL's [-1,1]. So the position will be clipped when z is outside the range 0 <= z <= w.\n\t\t\t\n  vec4 UserWorldToProj(vec4 worldSpaceVertPosition, int cameraIndex)\t\t\t\n  {\t\t\t\n      vec4 projP = uTDMats[cameraIndex].camProj * worldSpaceVertPosition;\t\t\t\n      return projP;\t\t\t\n  }\t\t\t\n\t\t\t\n<code>vec3 TDWorldToProj()</code> will automatically call this at the appropriate point. You can use uniforms/samplers in this shader code by declaring them here and providing them in the GLSL page of the [[Render TOP]].",
                "type": "DATPar",
                "name": "customproj",
                "items": []
            },
            {
                "text": "SOP : [[Quad Reprojection]] is a feature that allows reprojection an arbitrary quad in the scene so that portion of the render where it ends up will be blown up to fill the output of the render. Refer to the [[Quad Reprojection]] article for more information about this feature.",
                "type": "SOPPar",
                "name": "quadreprojsop",
                "items": []
            },
            {
                "text": "Int : Specifies 4 point indices in the SOP referenced by Quad Reproject SOP that make up the quad that determines the region to be reprojected. The indices should be listed in bottom left, bottom right, top left, top right order, as viewed from the camera. The SOP that is referenced should be in the COMP that is being rendered, so the world transform that will be applied to is can be taken into account.",
                "type": "IntPar",
                "name": "quadreprojpts",
                "items": []
            },
            {
                "text": "RGBA : Sets the background color and alpha of the camera's view.",
                "type": "RGBAPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGBA : Sets the background color and alpha of the camera's view.",
                "type": "RGBAPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGBA : Sets the background color and alpha of the camera's view.",
                "type": "RGBAPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "RGBA : Sets the background color and alpha of the camera's view.",
                "type": "RGBAPar",
                "name": "bgcolora",
                "items": []
            },
            {
                "text": "Toggle : This option allows the Background Color to be pre-multiplied by alpha.",
                "type": "TogglePar",
                "name": "premultrgbbyalpha",
                "items": []
            },
            {
                "text": "Menu : This menu determines the type of fog rendered in the viewport: '''Linear''' fog uses the following equation:\t\n\t\t\t\n[[Image:Objects14.gif]]\t\t\t\n\t\t\t\n'''Exponential''' fog uses the following equation:\t\t\t\n\t\t\t\n[[Image:Objects18.gif]]\t\t\t\n\t\t\t\n'''Squared Exponential''' fog uses the following equation:\t\t\t\n\t\t\t\n[[Image:Objects20.gif]]",
                "type": "MenuPar",
                "name": "fog",
                "items": []
            },
            {
                "text": "Float : A value that specifies density or thickness, used in both exponential fog types. Only non-negative densities are accepted.",
                "type": "FloatPar",
                "name": "fogdensity",
                "items": []
            },
            {
                "text": "Float : The starting distance of the fog. If geometry is closer to the camera than this distance, fog will not be calculated in the color of the geometry. Used in the linear fog equation.",
                "type": "FloatPar",
                "name": "fognear",
                "items": []
            },
            {
                "text": "Float : The far distance used in the linear fog equation.",
                "type": "FloatPar",
                "name": "fogfar",
                "items": []
            },
            {
                "text": "RGB : The color of the fog.",
                "type": "RGBPar",
                "name": "fogcolorr",
                "items": []
            },
            {
                "text": "RGB : The color of the fog.",
                "type": "RGBPar",
                "name": "fogcolorg",
                "items": []
            },
            {
                "text": "RGB : The color of the fog.",
                "type": "RGBPar",
                "name": "fogcolorb",
                "items": []
            },
            {
                "text": "Float : Used to control the background opacity of the scene.",
                "type": "FloatPar",
                "name": "fogalpha",
                "items": []
            },
            {
                "text": "TOP : Use a TOP texture as a color map for the fog.",
                "type": "TOPPar",
                "name": "fogmap",
                "items": []
            },
            {
                "text": "Object : Allows only specific [[Light COMP|lights]] to be used by this camera. This is used in conjunction with the Lights parameter in the Render TOP to determine what lights are used to illuminate the geometry. When this parameter is left blank, all lights specified in the Render TOP will be used. Lights specified in this parameter will limit the geometry's lighting with this camera to the light(s)specified assuming the light(s) is also listed in the Render TOP.",
                "type": "ObjectPar",
                "name": "camlightmask",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Camera",
        "opFamily": "COMP",
        "long": "The Camera Component is a 3D object that behaves like a real-world camera. You view your scene through it and render from its point of view using a [[Render TOP]]. \n    \nSee [[Geometry Viewer]] to learn about how you can inspect a scene from a camera.\n\nSee [[Palette:camera|cameraViewport]] in the Palette - it's a powerful interactive camera that can be used in place of the basic Camera COMP.\n\nA Camera Component can be attached or linked to any other 3D Component in a [[3D Parenting|3D hierarchy]].",
        "opClass": "cameraCOMP_Class",
        "short": "The Camera Component is a 3D object that acts like real-world cameras.",
        "opType": "cam",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "": {
        "label": "NotSet",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": []
    },
    "constraintCOMP": {
        "label": "constraintCOMP",
        "members": [
            {
                "text": "toggle : Toggle the constraint on/off in the simulation.",
                "type": "togglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "dropmenu : The type of constraint to create: point to point, hinge, or slider.",
                "type": "dropmenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "toggle : Toggle body to body mode on/off. Body to body mode creates a constraint between two bodies (Actor 1 Bodies and Actor 2 Bodies). When toggled off it will create constrain bodies individually. If Actor 1 Bodies and Actor 2 Bodies contain the same number of referenced bodies, then this mode will create a constraint between each respective pair. For instance, if Actor 1 Bodies contains the string \"0 1 2\", and Actor 2 Bodies contains the string \"3 4 5\" then this will create 3 constraints: 0->3, 1->4, 2->5. It is a 1 to 1 relationship between these two parameters. However, if Actor 1 Bodies has more bodies than Actor 2 Bodies, then the remaining \"unmatched\" bodies of Actor 1 Bodies will instead be individually constrained. For instance, if Actor 1 Bodies contains the string \"0 1 2\" and Actor 2 Bodies contains the string \"3 4\", then two constraints will be created between bodies: 0->3, 1->4. Body 2 will be constrained individually. If Actor 2 Bodies contains more bodies than Actor 1 Bodies, then any unmatched bodies in Actor 2 Bodies will simply be disregarded (no constraint created for them).",
                "type": "togglePar",
                "name": "bodytobody",
                "items": []
            },
            {
                "text": "toggle : Turns on/off collisions between the body to body constraints.",
                "type": "togglePar",
                "name": "collisions",
                "items": []
            },
            {
                "text": "toggle : Turns on/off the display of the constraint guide in the viewer.",
                "type": "togglePar",
                "name": "dispcom",
                "items": []
            },
            {
                "text": "objref : A reference to an Actor COMP. This specifies the Actor COMP of which you want to constrain some bodies.",
                "type": "objrefPar",
                "name": "actor1",
                "items": []
            },
            {
                "text": "string : A list (regular expression) of the IDs of the bodies in actor1 to constrain. If an Actor COMP contains N bodies, then body IDs will go from 0 to N-1 for that Actor COMP. The number of bodies can be verified using the [[Bullet Solver CHOP]].",
                "type": "stringPar",
                "name": "bodies1",
                "items": []
            },
            {
                "text": "float : The pivot point for the constraint.",
                "type": "floatPar",
                "name": "pivot1",
                "items": []
            },
            {
                "text": "float : The axis around which to create the hinge. Each value is typically a number between 0 and 1. For example, to spin around the Z axis set to 0, 0, 1.",
                "type": "floatPar",
                "name": "axis1",
                "items": []
            },
            {
                "text": "float : The rotation of the slider constraint axis. By default the slider constraint is applied on the X axis.",
                "type": "floatPar",
                "name": "sliderrot1",
                "items": []
            },
            {
                "text": "objref : A reference to an Actor COMP. This specifies the Actor COMP of which you want to constrain some bodies. This Actor COMP is only used when body to body mode is toggled on.",
                "type": "objrefPar",
                "name": "actor2",
                "items": []
            },
            {
                "text": "string : A list (regular expression) of the IDs of the bodies in actor2 to constrain. If an Actor COMP contains N bodies, then body IDs will go from 0 to N-1 for that Actor COMP. The number of bodies can be verified using the Bullet Solver CHOP.",
                "type": "stringPar",
                "name": "bodies2",
                "items": []
            },
            {
                "text": "float : The pivot point for the constraint.",
                "type": "floatPar",
                "name": "pivot2",
                "items": []
            },
            {
                "text": "float : The axis around which to create the hinge. Each value is typically a number between 0 and 1. For example, to spin around the Z axis set to 0, 0, 1.",
                "type": "floatPar",
                "name": "axis2",
                "items": []
            },
            {
                "text": "float : The rotation of the slider constraint axis. By default the slider constraint is applied on the X axis.",
                "type": "floatPar",
                "name": "sliderrot2",
                "items": []
            },
            {
                "text": "toggle : Enables limits on the constraint. Without constraints, the bodies will be able to rotate a full 360 degrees, or translate any distance.",
                "type": "togglePar",
                "name": "enablelimits",
                "items": []
            },
            {
                "text": "float : The lower limit for translation of the body along the constraint. Only used with slider constraints.",
                "type": "floatPar",
                "name": "lowerlinlim",
                "items": []
            },
            {
                "text": "float : The upper limit for translation of the body along the constraint. Only used with slider constraints.",
                "type": "floatPar",
                "name": "upperlinlim",
                "items": []
            },
            {
                "text": "anglejack : The lower limit for rotation of the body around its axis. Used with slider constraints or hinge constraints.",
                "type": "anglejackPar",
                "name": "loweranglim",
                "items": []
            },
            {
                "text": "anglejack : The upper limit for rotation of the body around its axis. Used with slider constraints or hinge constraints.",
                "type": "anglejackPar",
                "name": "upperanglim",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "constraintCOMP",
        "opLabel": "Constraint",
        "opClass": "constraintCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "A Constraint COMP is used to restrict the movement of the bodies in a set of [[Actor COMP]]s.",
        "long": "A Constraint COMP is used to restrict the movement of the bodies in a set of [[Actor COMP]]s. Currently this can be done in a few ways: point to point, hinge or slider. Constraints can either be applied on a single body or between two bodies. Constraints can be used to create connectivity between bodies, or to create bodies that can move but need to have that movement restricted in some way. Some examples of constraints in the real world: a train, a door, an arm. \n\nIf a point to point constraint is applied to a single body, then that body will be restricted to 3 degrees of freedom (DOF). It will still have all 3 degrees of freedom for rotation (ie. All 3 axes), but the 3 degrees of freedom for translation will all be constrained. If a point to point constraint is applied between two bodies, then they will both be similarly constrained to 3 DOF. However, they will be able to move (translate) along all 3 axes but they will do it connected to each other at their pivot points. By using this constraint method, a chain of bodies can be created. For instance, point to point constraints can be used to simulate train cars connected to each other.\n\nIf a hinge constraint is applied to a single body, then that body will be restricted to 1 DOF relative to the other body. It will only be able to rotate around 1 axis, and that axis is defined using the Axis parameter on the Constraint COMP. Much like the point to point constraint, the hinge also as a pivot point around which it will rotate. If a hinge constraint is applied between two bodies, then they will both be able to move with 3 DOF but they will do it connected to each other at their pivot points. However, they will still only be able to rotate around their respective axis. The simplest example of a hinge constraint is a door.\n\nIf a slider constraint is applied to a single body, then that body's translation/rotation will be constrained to just that axis. In other words, the body can only move along that axis (either direction) and can only rotate along that axis (either direction).\n    \nSee also: [[Bullet Dynamics]], [[Bullet Solver COMP]], [[Actor COMP]], [[Force COMP]], [[Impulse Force COMP]], [[Bullet Solver CHOP]].",
        "opCategories": ""
    },
    "containerCOMP": {
        "label": "containerCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Container",
        "opFamily": "COMP",
        "long": "The Container Component groups together any number of button, slider, field, container and other [[Panel Component]]s to build an interface. For example, the Container Component would be used to start creating your control panel, inside it you would place all the sliders, buttons, and viewer panels. It could also be used to group multiple sliders and buttons together into one panel that can be moved and scaled together, such as 3 RGB sliders for a color picker in your control panel.",
        "opClass": "containerCOMP_Class",
        "short": "The Container Component groups together any number of button, slider, field, container and other [[Panel Component]]s to build an interface.",
        "opType": "container",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "engineCOMP": {
        "label": "engineCOMP",
        "members": [
            {
                "text": "File : Specify the .tox file to load with TouchEngine.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Pulse : Unload the currently loaded component.",
                "type": "PulsePar",
                "name": "unload",
                "items": []
            },
            {
                "text": "Toggle : If the TouchEngine instance quits for any reason, restart it.",
                "type": "TogglePar",
                "name": "keepalive",
                "items": []
            },
            {
                "text": "Menu : Specify the temporal connection to the TouchEngine instance.",
                "type": "MenuPar",
                "name": "clock",
                "items": []
            },
            {
                "text": "Toggle : When enabled, playback will start as soon as the component has been loaded.",
                "type": "TogglePar",
                "name": "startoninit",
                "items": []
            },
            {
                "text": "Pulse : Reload the .tox file, restarting the TouchEngine instance.",
                "type": "PulsePar",
                "name": "initialize",
                "items": []
            },
            {
                "text": "Pulse : Starts playback of the component in the TouchEngine instance.",
                "type": "PulsePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : Turn cooking in the TouchEngine instance on or off.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute for events related to the TouchEngine instance.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Toggle : When on, the component will be cooked in TouchEngine at the same rate as the Engine COMP.",
                "type": "TogglePar",
                "name": "matchrate",
                "items": []
            },
            {
                "text": "Float : The framerate for cooking the component in TouchEngine.",
                "type": "FloatPar",
                "name": "fps",
                "items": []
            },
            {
                "text": "Toggle : When enabled, if a frame takes a long time to cook in TouchEngine the Engine COMP will wait during cooking rather than dropping the late frame.\n\nThis behaviour is affected by the size of the output buffer: eg if Out Buffer Frames is 4, the Engine COMP will wait for the 4th most recent frame to complete.",
                "type": "TogglePar",
                "name": "wait",
                "items": []
            },
            {
                "text": "Int : When waiting for a frame, TouchEngine will give up waiting after this many milliseconds.",
                "type": "IntPar",
                "name": "timeout",
                "items": []
            },
            {
                "text": "Toggle : Automatically manage the number of input frames queued.",
                "type": "TogglePar",
                "name": "inauto",
                "items": []
            },
            {
                "text": "Int : The number of input frames to queue before passing them to the TouchEngine instance.\n\nTo accommodate potential fluctations in time-slice in the TouchEngine instance, CHOP inputs must send a number of frames ahead of time.",
                "type": "IntPar",
                "name": "inframes",
                "items": []
            },
            {
                "text": "Toggle : Automatically manage the number of output frames queued.",
                "type": "TogglePar",
                "name": "outauto",
                "items": []
            },
            {
                "text": "Int : The number of output frames to queue after receiving them from the TouchEngine instance.\n\nTo accommodate potential fluctations in time-slice in the Engine COMP, CHOP outputs must send a number of frames ahead of time.",
                "type": "IntPar",
                "name": "outframes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "engineCOMP",
        "opLabel": "Engine",
        "opClass": "engineCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Engine COMP will run a .tox file (component) in a separate process. It uses [[TouchEngine]] to manage these processes and pass data between the loaded component and the main project.",
        "long": "The Engine COMP will run a .tox file (component) in a separate process. It uses [[TouchEngine]] to manage these processes and pass data between the loaded component and the main project.\n\n'''Ins and Outs'''\n\nThe chosen component's top-level Ins and Outs are exposed as Ins and Outs on the Engine COMP. Only TOP, CHOP and DAT Ins and Outs are supported.\n\n'''Custom Parameters'''\n\nAny custom parameters on the top-level component are added to the Engine COMP's parameters.\n\nNote that parameters work in one direction only - you cannot set a parameter from within the loaded .tox.\n\n'''External File Paths'''\n\nRelative paths on OPs or in scripts '''inside''' the loaded component are relative to the .tox file's location. Relative paths as file or folder parameters '''of''' the component - those that show up on the Engine COMP - are relative to the main project.\n\n'''Component Lifetime'''\n\nUnder TouchEngine, components are loaded into an already-running instance. For this reason, an Execute DAT's onStart() and onExit() method will never be executed under TouchEngine. The onCreate() method will be executed when the component is loaded, and is a good place to do any setup you would normally do in onStart().\n\n'''TouchEngine Versions'''\n\nTouchEngine is installed as part of TouchDesigner, and the currently running version will be used to load the given .tox. If you wish to use a different version of TouchEngine you can either set the environment variable <code>TOUCHENGINE_APP_PATH</code> to the path to a TouchDesigner installation (an installation directory on Windows, or a TouchDesigner app on macOS) ''or'' install TouchDesigner into a folder named <code>TouchEngine</code> alongside the .tox (on macOS rename an application from TouchDesigner to TouchEngine) ''or'' create a link named <code>TouchEngine</code> alongside the .tox which points to an installation directory or TouchDesigner app.",
        "opCategories": ""
    },
    "environmentlightCOMP": {
        "label": "environmentlightCOMP",
        "members": [
            {
                "text": "RGB : You can modify the color of the light three ways: Color List, Hue, Saturation, and Value, or Red, Green, and Blue. To choose one, click on the appropriate box and the color editing fields below change accordingly.",
                "type": "RGBPar",
                "name": "cr",
                "items": []
            },
            {
                "text": "RGB : You can modify the color of the light three ways: Color List, Hue, Saturation, and Value, or Red, Green, and Blue. To choose one, click on the appropriate box and the color editing fields below change accordingly.",
                "type": "RGBPar",
                "name": "cg",
                "items": []
            },
            {
                "text": "RGB : You can modify the color of the light three ways: Color List, Hue, Saturation, and Value, or Red, Green, and Blue. To choose one, click on the appropriate box and the color editing fields below change accordingly.",
                "type": "RGBPar",
                "name": "cb",
                "items": []
            },
            {
                "text": "Float : This parameter allows you to change the intensity of the light either as a static value or over time.",
                "type": "FloatPar",
                "name": "dimmer",
                "items": []
            },
            {
                "text": "TOP : Uses a TOP texture to define an environment map for the material. Environment mapping simulates an object reflecting its surroundings. The TOP defined in this parameter is the texture that will be reflected. The Env Map is added to whatever the normal lighting will be, so to make an object purely reflective turn the Diffuse and Specular parameters to 0. This input expects a sphere map. An example of a sphere map can be found [http://debevec.org/Probes/campus_probe.jpg here]. This input will also accept a cube map, created with the [[Cube Map TOP]] or the [[Render TOP]]'s Render Cube Map parameter.",
                "type": "TOPPar",
                "name": "envlightmap",
                "items": []
            },
            {
                "text": "Menu : Select the type of environment map to use (only equirectangular available for now).",
                "type": "MenuPar",
                "name": "envlightmaptype2d",
                "items": []
            },
            {
                "text": "Float : Controls the number of samples used by the Environment Light which determines the quality of the result. This value is multiplied by the [[PBR MAT]]s Env Light Quality parameter.",
                "type": "FloatPar",
                "name": "envlightmapquality",
                "items": []
            },
            {
                "text": "XYZ : Rotate the texture specified by the Environment Map parameter above.",
                "type": "XYZPar",
                "name": "envlightmaprotatex",
                "items": []
            },
            {
                "text": "XYZ : Rotate the texture specified by the Environment Map parameter above.",
                "type": "XYZPar",
                "name": "envlightmaprotatey",
                "items": []
            },
            {
                "text": "XYZ : Rotate the texture specified by the Environment Map parameter above.",
                "type": "XYZPar",
                "name": "envlightmaprotatez",
                "items": []
            },
            {
                "text": "Menu : Controls how the environment map is pre-filtered. A pre-filtered environment map is expensive to create, but results in much better rendering quality.",
                "type": "MenuPar",
                "name": "envlightmapprefilter",
                "items": []
            },
            {
                "text": "TOP : The 'Environment Light Specular Map' output from the [[PreFilter Map TOP]] to use.",
                "type": "TOPPar",
                "name": "envlightspecmap",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Environment Light",
        "opFamily": "COMP",
        "long": "The Environment Light Component controls the color and intensity of an environmental light in a given scene. This light, unlike the [[Light COMP|Light Component]], has no particular position. It comes from outside all of the objects in the scene and lights them. The orientation of the objects and the Environment Light Map will affect how each side of the objects is lit. However the position of the objects in space will have no effect on how the environment light hits them.",
        "opClass": "environmentlightCOMP_Class",
        "short": "The Environment Light Component controls the color and intensity of an environmental light in a given scene.",
        "opType": "environment",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "fbxCOMP": {
        "label": "fbxCOMP",
        "members": [
            {
                "text": "filepath load : The FBX file to import.",
                "type": "filepath loadPar",
                "name": "file",
                "items": []
            },
            {
                "text": "Menu : Determines what to do when clicking the 'Import' button below.",
                "type": "MenuPar",
                "name": "importmethod",
                "items": []
            },
            {
                "text": "button : A pulse to import the contents based on the setting in the 'Import Method' parameter above.",
                "type": "buttonPar",
                "name": "imp",
                "items": []
            },
            {
                "text": "float : Scales the imported geometry as a multipier.",
                "type": "floatPar",
                "name": "importscale",
                "items": []
            },
            {
                "text": "filepath load : Specifies an additional search location for external texture files if they can't be found at the default location specified inside the FBX file.",
                "type": "filepath loadPar",
                "name": "texdir",
                "items": []
            },
            {
                "text": "toggle : When enabled the FBX COMP will import any lights within the FBX File.",
                "type": "togglePar",
                "name": "lights",
                "items": []
            },
            {
                "text": "toggle : When enabled the FBX COMP will import any cameras within the FBX File.",
                "type": "togglePar",
                "name": "cameras",
                "items": []
            },
            {
                "text": "toggle : When enabled, will generate Actor COMPs in place of Geometry COMPs as the parents' of Import Select SOPs. This is useful for working with [[Bullet Dynamics]] systems with your imported geometry.",
                "type": "togglePar",
                "name": "genactors",
                "items": []
            },
            {
                "text": "toggle : When enabled the FBX COMP will merge Geometry COMPs. Geometry COMPs are merged if they have only default parameters except transform. If they have the same material then their Import Select SOPs will be merged.",
                "type": "togglePar",
                "name": "mergegeo",
                "items": []
            },
            {
                "text": "integer : When enabled the FBX COMP will attempt to merge up to the desired \u201clevel\u201d. Level is how many steps down a node is from the root (FBX COMP). If its level is higher than the merge level and it is mergeable then it will be merged upward.",
                "type": "integerPar",
                "name": "mergelevel",
                "items": []
            },
            {
                "text": "toggle : When enabled the FBX COMP will put each merged SOP into its own primitive group, so that they can be split up later if need be.",
                "type": "togglePar",
                "name": "primgroups",
                "items": []
            },
            {
                "text": "integer : Any COMPs that have more wired children than this parameter will have those wired children converted to internal children of the COMP. This maintains parenting but can cleanup networks.",
                "type": "integerPar",
                "name": "maxwiredchildren",
                "items": []
            },
            {
                "text": "toggle : Load the geometry directly to the GPU.",
                "type": "togglePar",
                "name": "gpudirect",
                "items": []
            },
            {
                "text": "toggle : When enabled, any parameter conflicts during update will keep the user changes. When disabled, any user changes to parameters may be overwritten.",
                "type": "togglePar",
                "name": "keepparams",
                "items": []
            },
            {
                "text": "toggle : When enabled, any wiring/connection conflicts during update will keep the user changes. When disabled, any user changes to wiring/connections may be overwritten.",
                "type": "togglePar",
                "name": "keepconnections",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute during import or update allowing for modification and customization of the imported operators and resulting network.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "minimenu dynamicmenu : Specifies the animation name (if any is specified) to playback from the imported FBX.",
                "type": "minimenu dynamicmenuPar",
                "name": "animation",
                "items": []
            },
            {
                "text": "toggle : A toggle to specify whether to shift the animation to the start of animation indicated in the importing file.",
                "type": "togglePar",
                "name": "shiftanimationstart",
                "items": []
            },
            {
                "text": "dropmenu : Select between using the 'File FPS' embedded in the FBX file or setting a 'Custom' sample rate.",
                "type": "dropmenuPar",
                "name": "sampleratemode",
                "items": []
            },
            {
                "text": "float : Set the sample rate when the \"Sample Rate Mode\" parameter above is set to 'Custom'.",
                "type": "floatPar",
                "name": "samplerate",
                "items": []
            },
            {
                "text": "dropmenu : A menu to specify the method used to play the animation.",
                "type": "dropmenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "button : Resets the animation to its initial state.",
                "type": "buttonPar",
                "name": "initialize",
                "items": []
            },
            {
                "text": "button : Resets the animation to its initial state and starts playback.",
                "type": "buttonPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : Jumps to and holds at the Cue Point when set to 1. Only available when Play Mode is Sequential.",
                "type": "TogglePar",
                "name": "cue",
                "items": []
            },
            {
                "text": "Pulse : Jumps to the Cue Point when pulsed. Only available when Play Mode is Sequential.",
                "type": "PulsePar",
                "name": "cuepulse",
                "items": []
            },
            {
                "text": "joinpair float : Set any index in the animation as a point to jump to. Only available when Play Mode is Sequential.",
                "type": "joinpair floatPar",
                "name": "cuepoint",
                "items": []
            },
            {
                "text": "nolabel shortvalues dropmenu : Select what type of unit to specify the Cue Point with.",
                "type": "nolabel shortvalues dropmenuPar",
                "name": "cuepointunit",
                "items": []
            },
            {
                "text": "toggle : Animation plays when On and stops when Off. This animation playback control is only available when Play Mode is Sequential.",
                "type": "togglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "joinpair float : This parameter explicitly sets the animation position when Play Mode is set to Specify Index. The units menu on the right lets you specify the index in the following units: Index, Frames, Seconds, and Fraction (percentage)",
                "type": "joinpair floatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "nolabel shortvalues dropmenu : ",
                "type": "nolabel shortvalues dropmenuPar",
                "name": "indexunit",
                "items": []
            },
            {
                "text": "float : This is a speed multiplier which only works when Play Mode is Sequential. A value of 1 is the default playback speed. A value of 2 is double speed, 0.5 is half speed and so on. Negative values will play backwards.",
                "type": "floatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "toggle : A toggle to enable the Trim Start and Trim End parameters.",
                "type": "togglePar",
                "name": "trim",
                "items": []
            },
            {
                "text": "joinpair float : Sets an in point from the beginning of the animation, allowing you to trim the starting index of the animation. The units\u2019 menu on the right let you specify this position by index, frames, seconds, or fraction (percentage).",
                "type": "joinpair floatPar",
                "name": "tstart",
                "items": []
            },
            {
                "text": "nolabel shortvalues dropmenu : Specifies a unit type for Trim Start. Changing this will convert the previous unit to the selected unit.",
                "type": "nolabel shortvalues dropmenuPar",
                "name": "tstartunit",
                "items": []
            },
            {
                "text": "joinpair float : Sets an end point from the end of the movie, allowing you to trim the ending index of the animation. The units\u2019 menu on the right let you specify this position by index, frames, seconds, or fraction (percentage).",
                "type": "joinpair floatPar",
                "name": "tend",
                "items": []
            },
            {
                "text": "nolabel shortvalues dropmenu : Specifies a unit type for Trim End. Changing this will convert the previous unit to the selected unit.",
                "type": "nolabel shortvalues dropmenuPar",
                "name": "tendunit",
                "items": []
            },
            {
                "text": "dropmenu : Determines how the animation behaves before the start of the animation (or Trim Start position if it is used).",
                "type": "dropmenuPar",
                "name": "textendleft",
                "items": []
            },
            {
                "text": "dropmenu : Determines how the animation behaves after the end of the animation (or Trim End position if it is used).",
                "type": "dropmenuPar",
                "name": "textendright",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "fbxCOMP",
        "opLabel": "FBX",
        "opClass": "fbxCOMP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The FBX COMP imports geometry, animations and scenes using the FBX file format from Maya, 3DS Max, Cinema4D, Houdini and others.\nThe FBX COMP currently uses the 2019.0 version of the FBX SDK.",
        "long": "The FBX COMP imports geometry, animations and scenes using the FBX file format from Maya, 3DS Max, Cinema4D, Houdini and others.\nThe FBX COMP currently uses the 2019.0 version of the FBX SDK.\n\n[https://www.autodesk.com/products/fbx/overview FBX] is a file format and set of libraries from Autodesk that is used to exchange models, animations and image/texture data between applications. The FBX COMP reads FBX files and supports most of its features. You can drag-drop a <code>.fbx</code> into a TouchDesigner network or import it via the File > Import File... menu. The FBX COMP can also import meshes from .obj and .4ds files, see also [[File Types]].\n\nThe assets from the FBX file are saved into a \"<code>.tdc</code>\" file with the same name as the FBX file inside the <code>TDImportCache</code> folder, which is created next to your <code>.toe</code> file. Assets are read from the \"<code>.tdc</code>\" file using Import Select OPs ([[Import Select TOP]] / [[Import Select SOP]] / [[Import Select CHOP]]). Upon reloading a <code>.toe</code> file, the assets can be imported directly from the \"<code>.tdc</code>\" cache, and the FBX file will not need to be re-imported. However, if there is no existing \"<code>.tdc</code>\" (for instance, if the toe file changed computers) then the FBX file will be reopened to grab the assets and a new \"<code>.tdc</code>\" will be saved out.\n\nTo open an FBX file in an FBX COMP:\n\n1) Specify a valid file path in the \"FBX File\" parameter, including the name of the file with correct <code>.fbx</code> extension.\n\n2) This step is varied depending on whether the FBX COMP is just created and if any changes in the default values of parameters are required or not. If the file is being loaded for the first time in the network and the default parameter values are accepted then simply press the \"Import\" button to generate the FBX network and import the assets. Note that we recommend changing the \"Import Method\" to to other modes (less work) can significantly improve performance. Generally, any changes in the parameters above the \"Import\" button requires the network to be built again.\n\n3) With the \"Import Method\" menu set to \"Merge with Existing\", the \"Import\" pulse will reload the internal assets (e.g. meshes, etc.) and this is specifically useful if the file has moved to another location and when the <code>.toe</code> file is opened the assets were not found and reloaded properly.\n\n4) With the \"Import Method\" menu set to \"Import Assets (Import Selects)\", the \"Import\" button is used when some changes on FBX file are made and we want to merge those changes into the current network without fully rebuilding it.\n\n'''Animation channels''': When there is animation in the FBX file, use the controls on the Play page to initialize, start and guide the animation. Also create an [[Info CHOP]] and attach it to the FBX COMP to watch its animation timing. The Info CHOP channels are similar to those of the [[Timer CHOP]].\n\n'''Textures''': Textures can either be embedded within the FBX file or external and referenced by a path to a texture file. For example, Blender has an option during FBX export to embed, otherwise they'll be external. If they're external then they may be exported with an absolute path to the texture file, which means if you move the FBX file to a different machine or relocate the file, then the textures will fail to load. In this case, if you are unable to re-export to embed the textures, then you can instead specify a search directory using the Texture Directory parameter so that the FBX COMP knows where to locate the texture files at import.\n\nSee also: [[FBX]], [[Import Select CHOP]], [[Import Select TOP]], [[Import Select SOP]], [[USD COMP]]",
        "opCategories": ""
    },
    "fieldCOMP": {
        "label": "fieldCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "'''Note''': Field COMP deprecated build 2022.24200, use [[Text COMP]].\n\nThe Field Component lets you enter text strings and renders text generated with the [[Text TOP]]. Internally it contains a Text TOP which points to one cell of a DAT that contains the text to render. The Field COMP modifies the DAT cell as text is entered.\t\n\t\t\t\n[[image:FieldCOMP.png]]",
        "opLicense": "Non-Commercial",
        "opFamily": "COMP",
        "opLabel": "Field",
        "short": "The Field Component lets you enter text strings and renders text generated with the [[Text TOP]].",
        "opType": "field",
        "opFilter": "False",
        "opClass": "fieldCOMP_Class"
    },
    "forceCOMP": {
        "label": "forceCOMP",
        "members": [
            {
                "text": "toggle : Toggle the active force on/off in the simulation",
                "type": "togglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "float : The linear force in Newtons that will be applied.",
                "type": "floatPar",
                "name": "force",
                "items": []
            },
            {
                "text": "float : The position at which to apply the linear force, relative to the center of the body (Note: the physical center of the object, not the center of mass). Having a nonzero relative position will also cause the body to rotate due to added torque.",
                "type": "floatPar",
                "name": "relpos",
                "items": []
            },
            {
                "text": "float : The rotational force in Newtons that will be applied.",
                "type": "floatPar",
                "name": "torque",
                "items": []
            },
            {
                "text": "pulse : Applies an impulse force in the simulation for 1 frame with the above parameters.",
                "type": "pulsePar",
                "name": "impulse",
                "items": []
            },
            {
                "text": "toggle : Toggle the force field on/off in the simulation",
                "type": "togglePar",
                "name": "ffactive",
                "items": []
            },
            {
                "text": "toggle : The strength of the force field. Positive strength pushes bodies outward and negative strength pulls bodies inward.",
                "type": "togglePar",
                "name": "strength",
                "items": []
            },
            {
                "text": "toggle : The radius of the force field.",
                "type": "togglePar",
                "name": "radius",
                "items": []
            },
            {
                "text": "toggle : Applies linear falloff to the strength of the force field based on the distance from the center.",
                "type": "togglePar",
                "name": "falloff",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "forceCOMP",
        "opLabel": "Force",
        "opClass": "forceCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "=Force COMPs are used to added forces to a physics solver's simulation. [[Bullet Dynamics|Bullet]] supports linear/rotational forces and impulse forces (see Force page) and [[Flex]] supports force fields.",
        "long": "Force COMPs are used to added forces to a physics solver's simulation. [[Bullet Dynamics|Bullet]] supports linear/rotational forces and impulse forces (see Force page) and [[Flex]] supports force fields (see Force Field page).\n\n===<div class=\"subSectionLineDialog\">Active Force</div>===\n\nActive forces are enabled using the Active toggle parameter on the Force page.\n\nAn active force will create a force in the simulation that is applied over time. An active force can either be applied globally by being referenced on the [[Bullet Solver COMP]], or it can be applied locally by being referenced on an individual [[Actor COMP]]. The active force applies its force each frame, and the force applied over 1 second is equivalent to an impulse force of the same value applied in a single frame. \n    \nThe units for the force and torque parameters are in Newtons (N), equivalent to kg*m/s^2. This means that if a force of 10N is applied to an actor with mass equal to 5kg and no initial velocity, then after 1 second the velocity of that actor will be 2m/s => 10N / 5kg * 1 sec = 2m/s. If all the parameters were the same, but instead it was an impulse force, then the velocity would still be 2m/s. However, the impulse force's velocity would change instantaneously and stop increasing (unless pulsed again) whereas with the active force the velocity will continue to increase after 1 second.\n\nThe center of mass is assumed to be center of the bounding box of the mass. By default, if a body is not constrained and not colliding, the force will not cause the body to rotate, unless the Relative Position parameter is set to a non-zero value.  If Relative Position is set to +1 in X and the force is +1 in Y, it will cause the body to rotate counter-clockwise around the Z-axis and translate in Y.\n\nIf the Torque is set to +1 in Z, it will cause the body to only rotate counter-clockwise in the Z-axis (a positive Z rotation), and not translate.\n\nTo apply force/torque to specific bodies use a Feedback CHOP (see [[Bullet Solver COMP]] or [[Actor COMP]]) and '''force[xyz]''' and '''torque[xyz]''' channels.\n\n===<div class=\"subSectionLineDialog\">Impulse Force</div>===\n\nImpulse forces are applied through the Impulse Force pulse parameter.\n\nAn impulse force pulse will create a force in the simulation that is applied for 1 frame. In the real world, impulse forces are forces applied over a very short duration, however in [[Bullet Dynamics|Bullet]] this is somewhat simplified, and they are instead applied instantly (for a single frame). Examples of impulse forces are kicking a ball or shooting a cannon. The velocities of the affected bodies are changed in an instant by the impulse force, and after that instant the force no longer has an effect unless applied again.  \n    \nThe resulting velocity of the bodies after the impulse force is applied is the same as an active force with the same values if the active force is applied for exactly 1 second. For example, if 10N of impulse force is applied to a body with mass 5kg then the resulting velocity will be 10N / 5kg * 1sec = 2m/s. \n\n===<div class=\"subSectionLineDialog\">Force Field</div>===\n\nForce fields are enabled through the Active parameter on the Force Field page.\n\nForce fields are spherical with a radius defined through the Radius parameter. Positive strength pushes bodies outward and negative strength pulls bodies inward.\n\n\nSee also: [[Flex]], [[Bullet Dynamics]], [[Bullet Solver COMP]], [[Actor COMP]], [[Constraint COMP]], [[Bullet Solver CHOP]], [[Nvidia Flex TOP]], [[Nvidia Flex Solver COMP]].",
        "opCategories": ""
    },
    "geotextCOMP": {
        "label": "geotextCOMP",
        "members": [
            {
                "text": "Menu : Controls where text is generated from. Either from the 'Text' parameter, or a table DAT provided via the 'Specification DAT' parameter.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Str : When in 'Text' mode, this specifies the text that will be rendered.",
                "type": "StrPar",
                "name": "text",
                "items": []
            },
            {
                "text": "DAT : In this mode, the Text parameter is ignored and data is taken from a DAT table given in the Specification DAT parameter. Each row of the DAT is a separate line of text, which can have different transforms, alignment, color, word wrap settings applied to them. The column headers should match the parameter name which the column is overriding. If a column entry for a particular row is left empty, then the value of the parameter is used instead. This allows a default value to be used for all rows, but allowing select rows to have different settings as needed. Transforms are not overridden, any transform that is given is applied as a pre-transform before the other transforms given by the parameters. Valid columns are currently: <code>text, tx, ty, tz, rx, ry, rz, sx, sy, sz, px, py, pz, ltx, lty, ltz, lrx, lry, lrz, lsx, lsy, lsz, lpx, lpy, lpz, fontcolorr, fontcolorg, fontcolorb, fontalpha, allignx, aligny, alignymode, fontsize, tracking, skew, horzstretch, linespacing, wordwrap, layoutsizew, layoutsizeh, layoutanchoru, layoutanchorv, textpaddingl, textpaddingr, textpaddingb, textpaddingt, render, append, localxform</code>.",
                "type": "DATPar",
                "name": "specdat",
                "items": []
            },
            {
                "text": "CHOP : Allows use of CHOP data to set parameters of text blocks defined in the Specification DAT. Each sample of the CHOP corresponds to the data rows in the Specification DAT. Only numerical data such as <code>tx, ty, rz, fontcolorr</code>, etc can be provided by the CHOP.",
                "type": "CHOPPar",
                "name": "specchop",
                "items": []
            },
            {
                "text": "Toggle : When using Specification DAT/CHOP mode, enabling this parameter will cause the text blocks to be rendered from back to front relative to the current camera. Sorted rendering is recommended when using translucent text (font alpha < 1) in order to achieve correct color blending. This parameter should be turned off when using solid opaque text (font alpha >= 1) in order to improve performance. The sort order is calculated independently for each camera that is viewing this node.",
                "type": "TogglePar",
                "name": "sorted",
                "items": []
            },
            {
                "text": "Toggle : Enables the use of formatting codes in the text. For example, the code {#color(255, 0, 0);} will turn all text afterwards on that line red. See [[Text_Formatting_Codes|Text Formatting Codes]] for all available codes.",
                "type": "TogglePar",
                "name": "formatcodes",
                "items": []
            },
            {
                "text": "Toggle : Converts '\\n', '\\r' characters into line breaks and '\\t' characters into tabs. Only available in Specification DAT/CHOP mode. For Text mode, use python expressions to insert line breaks and other special characters into text.",
                "type": "TogglePar",
                "name": "escapeseq",
                "items": []
            },
            {
                "text": "Toggle : Enables the use of smart punctuation. For example, pairs of quotes will be replaced with appropriate angled quotes, 3 periods will be replaced with an ellipses character and two hypens will become an em-dash.",
                "type": "TogglePar",
                "name": "smartpunct",
                "items": []
            },
            {
                "text": "Toggle : Wrap lines of text if they go beyond the width of the layout box.",
                "type": "TogglePar",
                "name": "wordwrap",
                "items": []
            },
            {
                "text": "StrMenu : Select the font to be used from the dropdown menu. Available fonts are those that have been registered with the operating system. There may be a delay when selecting fonts that have not been used before as the system creates the necessary intermediate files required for rendering.",
                "type": "StrMenuPar",
                "name": "font",
                "items": []
            },
            {
                "text": "File : Specify a font file to be used for rendering the text. This option can be used for fonts that are not registered with the operating system and do not appear in the drop down menu.",
                "type": "FilePar",
                "name": "fontfile",
                "items": []
            },
            {
                "text": "Toggle : Display the text in '''bold'''.",
                "type": "TogglePar",
                "name": "bold",
                "items": []
            },
            {
                "text": "Toggle : Display the text in ''italics''.",
                "type": "TogglePar",
                "name": "italic",
                "items": []
            },
            {
                "text": "Float : The font size. This is in the same units as the geometry space. So it's arbitrary based on the size of your scene.",
                "type": "FloatPar",
                "name": "fontsize",
                "items": []
            },
            {
                "text": "Float : Sets the horizontal spacing between characters, where 0 is default spacing, > 0 is increased spacing and < 0 is decreased spacing.",
                "type": "FloatPar",
                "name": "tracking",
                "items": []
            },
            {
                "text": "Float : Tilts the top of the characters forwards or backwards relative to the baseline.",
                "type": "FloatPar",
                "name": "skew",
                "items": []
            },
            {
                "text": "Float : Horizontally stretch the characters relative to their current alignment.",
                "type": "FloatPar",
                "name": "horzstretch",
                "items": []
            },
            {
                "text": "Float : Adjust spacing between lines. The value is a multiplier of the default spacing defined by the font.",
                "type": "FloatPar",
                "name": "linespacing",
                "items": []
            },
            {
                "text": "RGB : The color for the font.",
                "type": "RGBPar",
                "name": "fontcolorr",
                "items": []
            },
            {
                "text": "RGB : The color for the font.",
                "type": "RGBPar",
                "name": "fontcolorg",
                "items": []
            },
            {
                "text": "RGB : The color for the font.",
                "type": "RGBPar",
                "name": "fontcolorb",
                "items": []
            },
            {
                "text": "Float : The alpha value for the font.",
                "type": "FloatPar",
                "name": "fontalpha",
                "items": []
            },
            {
                "text": "Float : Along with the Layout Box Anchor V, this allows shifting the layout box from it's current position left/down. It also controls how rotations will pivot around the layout box, so a 0.5, 0.5 anchor will cause rotations to move about the center of the layout box.",
                "type": "FloatPar",
                "name": "layoutanchoru",
                "items": []
            },
            {
                "text": "Float : The V component of the Layout Box Anchor pair.",
                "type": "FloatPar",
                "name": "layoutanchorv",
                "items": []
            },
            {
                "text": "WH : Text is aligned and word-wrapped within a virtual layout box. This box is what is transformed by the various transform parameters, and then the text is aligned and laid out within that. The width and height units are the same units as the font size.",
                "type": "WHPar",
                "name": "layoutsize",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "cliptolayoutbox",
                "items": []
            },
            {
                "text": "Float : Extra padding to add to the sides of the layout box, pushing the text inwards for alignment.",
                "type": "FloatPar",
                "name": "textpadding",
                "items": []
            },
            {
                "text": "Menu : Controls the horizontal alignment of the text.",
                "type": "MenuPar",
                "name": "alignx",
                "items": []
            },
            {
                "text": "Menu : Controls the vertical alignment of the text.",
                "type": "MenuPar",
                "name": "aligny",
                "items": []
            },
            {
                "text": "Menu : Controls how the alignment is calculated for vertical alignment.",
                "type": "MenuPar",
                "name": "alignymode",
                "items": []
            },
            {
                "text": "Menu : Controls where text is generated from. Either from the 'Text' parameter, or a table DAT provided via the 'Specification DAT' parameter.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Str : When in 'Text' mode, this specifies the text that will be rendered.",
                "type": "StrPar",
                "name": "text",
                "items": []
            },
            {
                "text": "DAT : In this mode, the Text parameter is ignored and data is taken from a DAT table given in the Specification DAT parameter. Each row of the DAT is a separate line of text, which can have different transforms, alignment, color, word wrap settings applied to them. The column headers should match the parameter name which the column is overriding. If a column entry for a particular row is left empty, then the value of the parameter is used instead. This allows a default value to be used for all rows, but allowing select rows to have different settings as needed. Transforms are not overridden, any transform that is given is applied as a pre-transform before the other transforms given by the parameters. Valid columns are currently: <code>text, tx, ty, tz, rx, ry, rz, sx, sy, sz, px, py, pz, ltx, lty, ltz, lrx, lry, lrz, lsx, lsy, lsz, lpx, lpy, lpz, fontcolorr, fontcolorg, fontcolorb, fontalpha, allignx, aligny, alignymode, fontsize, tracking, skew, horzstretch, linespacing, wordwrap, layoutsizew, layoutsizeh, layoutanchoru, layoutanchorv, textpaddingl, textpaddingr, textpaddingb, textpaddingt, render, append, localxform</code>.",
                "type": "DATPar",
                "name": "specdat",
                "items": []
            },
            {
                "text": "CHOP : Allows use of CHOP data to set parameters of text blocks defined in the Specification DAT. Each sample of the CHOP corresponds to the data rows in the Specification DAT. Only numerical data such as <code>tx, ty, rz, fontcolorr</code>, etc can be provided by the CHOP.",
                "type": "CHOPPar",
                "name": "specchop",
                "items": []
            },
            {
                "text": "Toggle : Enables the use of formatting codes in the text. For example, the code {#color(255, 0, 0);} will turn all text afterwards on that line red. See [[Text_Formatting_Codes|Text Formatting Codes]] for all available codes.",
                "type": "TogglePar",
                "name": "formatcodes",
                "items": []
            },
            {
                "text": "Toggle : Enables the use of smart punctuation. For example, pairs of quotes will be replaced with appropriate angled quotes, 3 periods will be replaced with an ellipses character and two hypens will become an em-dash.",
                "type": "TogglePar",
                "name": "smartpunct",
                "items": []
            },
            {
                "text": "Toggle : Wrap lines of text if they go beyond the width of the layout box.",
                "type": "TogglePar",
                "name": "wordwrap",
                "items": []
            },
            {
                "text": "StrMenu : Select the font to be used from the dropdown menu. Available fonts are those that have been registered with the operating system. There may be a delay when selecting fonts that have not been used before as the system creates the necessary intermediate files required for rendering.",
                "type": "StrMenuPar",
                "name": "font",
                "items": []
            },
            {
                "text": "File : Specify a font file to be used for rendering the text. This option can be used for fonts that are not registered with the operating system and do not appear in the drop down menu.",
                "type": "FilePar",
                "name": "fontfile",
                "items": []
            },
            {
                "text": "Toggle : Display the text in '''bold'''.",
                "type": "TogglePar",
                "name": "bold",
                "items": []
            },
            {
                "text": "Toggle : Display the text in ''italics''.",
                "type": "TogglePar",
                "name": "italic",
                "items": []
            },
            {
                "text": "Float : The font size. This is in the same units as the geometry space. So it's arbitrary based on the size of your scene.",
                "type": "FloatPar",
                "name": "fontsize",
                "items": []
            },
            {
                "text": "Float : Sets the horizontal spacing between characters, where 0 is default spacing, > 0 is increased spacing and < 0 is decreased spacing.",
                "type": "FloatPar",
                "name": "tracking",
                "items": []
            },
            {
                "text": "Float : Tilts the top of the characters forwards or backwards relative to the baseline.",
                "type": "FloatPar",
                "name": "skew",
                "items": []
            },
            {
                "text": "Float : Horizontally stretch the characters relative to their current alignment.",
                "type": "FloatPar",
                "name": "horzstretch",
                "items": []
            },
            {
                "text": "Float : Adjust spacing between lines. The value is a multiplier of the default spacing defined by the font.",
                "type": "FloatPar",
                "name": "linespacing",
                "items": []
            },
            {
                "text": "RGB : The color for the font.",
                "type": "RGBPar",
                "name": "fontcolorr",
                "items": []
            },
            {
                "text": "RGB : The color for the font.",
                "type": "RGBPar",
                "name": "fontcolorg",
                "items": []
            },
            {
                "text": "RGB : The color for the font.",
                "type": "RGBPar",
                "name": "fontcolorb",
                "items": []
            },
            {
                "text": "Float : The alpha value for the font.",
                "type": "FloatPar",
                "name": "fontalpha",
                "items": []
            },
            {
                "text": "Float : Along with the Layout Box Anchor V, this allows shifting the layout box from it's current position left/down. It also controls how rotations will pivot around the layout box, so a 0.5, 0.5 anchor will cause rotations to move about the center of the layout box.",
                "type": "FloatPar",
                "name": "layoutanchoru",
                "items": []
            },
            {
                "text": "Float : The V component of the Layout Box Anchor pair.",
                "type": "FloatPar",
                "name": "layoutanchorv",
                "items": []
            },
            {
                "text": "WH : Text is aligned and word-wrapped within a virtual layout box. This box is what is transformed by the various transform parameters, and then the text is aligned and laid out within that. The width and height units are the same units as the font size.",
                "type": "WHPar",
                "name": "layoutsize",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "cliptolayoutbox",
                "items": []
            },
            {
                "text": "Float : Extra padding to add to the sides of the layout box, pushing the text inwards for alignment.",
                "type": "FloatPar",
                "name": "textpadding",
                "items": []
            },
            {
                "text": "Menu : Controls the horizontal alignment of the text.",
                "type": "MenuPar",
                "name": "alignx",
                "items": []
            },
            {
                "text": "Menu : Controls the vertical alignment of the text.",
                "type": "MenuPar",
                "name": "aligny",
                "items": []
            },
            {
                "text": "Menu : Controls how the alignment is calculated for vertical alignment.",
                "type": "MenuPar",
                "name": "alignymode",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "geotextCOMP",
        "opLabel": "Geo Text",
        "opClass": "geotextCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "Renders text in 3D.",
        "long": "The Geo Text COMP renders text in 3D. It does not read or generate a SOP as it does direct rendering using the [[Slug Library]] and can be lit and textured with any [[MAT]] material, except the [[Line MAT]].\n\nYou can set fonts, colors, sizes, bold, italic, tracking, multi-lines like you can with the [[Text COMP]]. \n\nYou can also give the Geo Text COMP a Specification DAT which lets you separately 3D position, format and render a text string for each row of the DAT.\n\nBecause the Geo Text COMP doesn't have a boundary, width or height like the Text COMP, we substitute it with a layout box and the Layout Box parameters. The layout box has a width and height, and by default the bottom left of the layout box is placed at 0,0,0 in 3D space of the Geo Text COMP (\"object space\").  The Layout Box Anchor U and V let you put the center of the layout box at 0,0,0 by setting the anchors to .5, 5.\n\nThe dimensions of the layout box aren't visible by default, but are controlled by the Layout Box Size parameter. Using the align parameters, you can right-justify or top-justify text in the layout box, or clip to the layout box.  You can also padding space between the edge of the layout box and the text.\n\nSee also the 2D equivalent [[Text COMP]] and [[Text Formatting Codes]] for ways to override settings per-character.\n\n'''Render multiple strings transformed separately''': The Specification DAT and Specification CHOP allow for individual strings to be each positioned and styled independently in 3D. \n\nEvery row of the Spec DAT represents a \"block\" or \"text block\". Every Spec DAT contains a column named <code>text</code> which is the string that overrides the Text parameter.\n\nMost columns override a Geo Text COMP parameter, such as <code>text</code>, <code>tx</code> and <code>fontsize</code>. Some column names noted below have no corresponding parameter.\n\nThe Spec CHOP can also specify values per block. When including a Spec CHOP the number of Spec CHOP samples needs to be the same number of rows as the Spec DAT following the first column header. \n\nParameters that can be overrided include <code>fontsize</code>, <code>fontcolor</code>, tracking etc., plus all the layout box and alignment parameters. Font/bold/italic are not supported as columns as they are separate fonts. \n\n'''Transforming text blocks''': The column or channel names can include <code>tx</code>, <code>ty</code>, <code>tz</code> and all the rotate and scale channels (which use the Transform Order parameter). \n\nA special column/channel called <code>append</code> can be used with a value of <code>1</code> to position one block of text relative to the end of the previous block. Regular transforms are inherited by each appended text block. \n\nLocal transforms (<code>ltx</code>, <code>lrz</code>, etc), can be used to apply additional block transforms that do not affect transforms of following blocks. Furthermore, if the special column <code>localxform</code> is set to '<code>pre</code>', then the local transform is applied in world space before the inherited transforms are applied. If it is <code>post</code> (the default), it is transformed in the reference frame of the previous block.\n\nThe [[GeotextCOMP_Class|GeotextCOMP Class]] also has a member called <code>layoutText</code> that can be used to retrieve the 2D layout positions for all characters within a given piece of text. The positions include any applicable kerning, wrapping and alignment based on the current parameter settings of the Geo Text COMP. These values can be transformed or projected into 3D space and used to build a Spec DAT/CHOP to render the resulting text.\n\n'''Note''' - The Geo Text COMP uses '''blending/transparency''' to create the glyphs floating in space (each glyph is a partially transparent rectangle). So, to view properly without the enclosing polygons that surround them, you need to ensure they are drawn after other geometry that they are sitting in-front of. This is usually due using the [[#Parameters_-_Render_Page|Draw Priority]] parameter on the 'Render' parameter page and making the value more negative than the Draw Priority of other objects. All things with the highest draw priority are drawn first, then all things with the same second higher draw priority are drawn second. If the priority is the same between two objects, then the order they are drawn is arbitrary and will possibly change. '''Note''': Text within a Spec DAT should be setup so things in the back are earlier in the table than things in the front. It will draw row-by-row from the Spec DAT.\n\n'''Tip to render constant-size text facing the camera''': See [[OP Snippets]] for Geo Text COMP called \"better text beside 3D geo points\".\n\nSee OP Snippets for other transform examples.\n\nThe Geo Text COMP is similar to the [[Text COMP]] which is a 2D [[Panel]]."
    },
    "geometryCOMP": {
        "label": "geometryCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Geometry Component is a 3D surface or [[Object|3D Object]] that you render in TouchDesigner with a [[Render TOP]]. [[Light COMP|Lights]], [[Camera COMP|Cameras]] and other Components affect the scene, but are not visible surfaces. \n    \nEach Geometry Component contains a [[Network]] containing [[SOP]]s (and any other node types), where SOPs are the operators that define its 3D shape. The 3D surfaces can be [[Polygon|polygons]], [[Particle|particles]], sprites, [[Mesh|meshes]], [[Spline|NURBS]] (with trim curves), [[Spline|Bezier]] patches or [[Metaball|metaballs]]. They can be shaded as solid-shaded surfaces or as wireframes.\t\t\n\t\t\t\t\nIn the Geometry COMP's network \n* the [[SOP]]s (Surface Operators) whose [[Render Flag]] is On are rendered by a [[Render TOP]]. More than one SOP can be turned on for rendering in a Geometry component.\n* The SOPs whose [[Display Flag]] is on are seen in the [[Geometry Viewer]] of the Geometry COMP and Camera COMPs in the same network.\t\t\n\nNOTE: Most often users turn on/off the Render and Display flags together so they are always in the same state.\n\nSee [[Geometry Viewer]] to learn about how you can inspect the SOPs that are turned on for display. \n\t\t\t\t\nSome SOPs, like the [[Texture SOP]] determine how texture images wrap and fit on the surface. \t\t\t\t\n\t\t\t\t\nEvery Geometry component needs a [[MAT|Material]] (MAT) operator to apply to the surface. This is assigned in the Material parameter of the Geometry component, or with a [[Material SOP]].\t\t\t\t\n\t\t\t\t\nTo get to the Geometry Component's network, use the roller wheel to zoom into it, or hit Enter or 'i' after selecting a Geometry Component.\t\t\t\t\n\t\t\t\t\nSee [[Geometry Viewer]], [[Render Flag]] and [[Display Flag]].\t\t\t\t\n\t\t\t\t\n[[image:Geometry Component.jpg]]",
        "opLabel": "Geometry",
        "opLicense": "Non-Commercial",
        "opFamily": "COMP",
        "short": "The Geometry Component is a 3D surface that you see and render in TouchDesigner with a [[Render TOP]].",
        "opType": "geo",
        "opFilter": "False",
        "opClass": "geometryCOMP_Class",
        "opCategories": ""
    },
    "glslCOMP": {
        "label": "glslCOMP",
        "members": [
            {
                "text": "DAT : Path to the DAT that holds the vertex shader code.",
                "type": "DATPar",
                "name": "vertexdat",
                "items": []
            },
            {
                "text": "DAT : Path to the DAT that holds the pixel shader code.",
                "type": "DATPar",
                "name": "pixeldat",
                "items": []
            },
            {
                "text": "Str : This is the sampler name that the GLSL program will use to sample from this TOP. The samplers need to be declared at the same dimensions as the TOP (sampler2D for a 2D TOP, sampler3D for 3D TOP).",
                "type": "StrPar",
                "name": "sampler0",
                "items": []
            },
            {
                "text": "TOP : This is the TOP that will be referenced by the above sampler name above it.\n\t\t\t\t\n'''Exposed by the + Button, texture sampling parameters''':\t\t\t\t\n\t\t\t\t\nRefer to the [[Texture Sampling Parameters]] article for more information on the parameters exposed by pressing the + button. The ''parameter'' prefix for each of the parameters is ''top[digit]''.",
                "type": "TOPPar",
                "name": "top0",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0filter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0anisotropy",
                "items": []
            },
            {
                "text": "Str : The name of the uniform.",
                "type": "StrPar",
                "name": "uniname0",
                "items": []
            },
            {
                "text": "XYZW : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZWPar",
                "name": "value0",
                "items": []
            },
            {
                "text": "Str : The constant name, as declared in the shader.",
                "type": "StrPar",
                "name": "constname0",
                "items": []
            },
            {
                "text": "Float : The value to give the constant.",
                "type": "FloatPar",
                "name": "constvalue0",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "glslCOMP",
        "opLabel": "GLSL",
        "opClass": "glslCOMP_Class",
        "opFilter": "False",
        "opLicense": "TouchDesigner Non-Commercial",
        "opCategories": "",
        "os": "",
        "hardware": "",
        "short": "The GLSL COMP uses shaders to render an image in a panel directly to the screen.",
        "long": "The GLSL COMP uses shaders to render an image in a panel directly to the screen. It is useful for rendering pixel accurate UIs as the resolution will automatically adapt to the DPI scaling of the screen it is displayed on. Panel variables can be accessed in the shader for responding to user events,\n    \nFor more information on writing a shader, see the [[:Category:GLSL|GLSL Category]]."
    },
    "handleCOMP": {
        "label": "handleCOMP",
        "members": [
            {
                "text": "Object : Where the Handle will pull the bone towards (like an end-affector).",
                "type": "ObjectPar",
                "name": "target",
                "items": []
            },
            {
                "text": "XYZ : Displacement tx,ty,tz relative to the origin of the bone where the handle is anchored.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Displacement tx,ty,tz relative to the origin of the bone where the handle is anchored.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Displacement tx,ty,tz relative to the origin of the bone where the handle is anchored.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "Float : When multiple handles are attached to a bone, higher weighted handles draw closer to their target.",
                "type": "FloatPar",
                "name": "weight",
                "items": []
            },
            {
                "text": "Toggle : When enabled the handle only contributes the the z rotation of the bone, when disabled it points the bone (rx, ry, and rz).",
                "type": "TogglePar",
                "name": "twistonly",
                "items": []
            },
            {
                "text": "Float : This value affects how much parent bones are affected when the child bone is reaching a target. It affects the flexibility of the chain.",
                "type": "FloatPar",
                "name": "falloff",
                "items": []
            },
            {
                "text": "Toggle : These affects how much the bone is allowed to rotate with respect to its parent.",
                "type": "TogglePar",
                "name": "dorxlimit",
                "items": []
            },
            {
                "text": "Float : Set the minimum and maximum rotation range in X axis.",
                "type": "FloatPar",
                "name": "lrx",
                "items": []
            },
            {
                "text": "Toggle : These affects how much the bone is allowed to rotate with respect to its parent.",
                "type": "TogglePar",
                "name": "dorylimit",
                "items": []
            },
            {
                "text": "Float : Set the minimum and maximum rotation range in Y axis.",
                "type": "FloatPar",
                "name": "lry",
                "items": []
            },
            {
                "text": "Toggle : These affects how much the bone is allowed to rotate with respect to its parent.",
                "type": "TogglePar",
                "name": "dorzlimit",
                "items": []
            },
            {
                "text": "Float : Set the minimum and maximum rotation range in Z axis.",
                "type": "FloatPar",
                "name": "lrz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "opLabel": "Handle",
        "opFamily": "COMP",
        "long": "The Handle Component is a new IK tool designed for manipulating groups of bones. Whereas the previous IK tools only allowed for a single end-affector per bone chain, this new method allows for several end-affectors per bone. Furthermore, the bones need not be a chain. Any setup, including branches, are handled.\t\t\n\t\t\t\nOne typical example is the use of motion capture data. In higher-end systems, you could have a cloud of marker positions and a skeleton to be driven by it.\t\t\t\n\t\t\t\nThis Handle Component works in tandem with the [[Handle CHOP]]. The following setup is commonly used: Given a hierarchy of bones, attach one or more Handle Components to specific locations on each Bone Component. Assign each handle a target in space to follow. Create a Handle CHOP which collects this information and calculates the rotation channels for the bones. Export these values back to the bones.",
        "opClass": "handleCOMP_Class",
        "short": "The Handle Component is a new IK tool designed for manipulating groups of bones.",
        "opType": "handle",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "impulseforceCOMP": {
        "label": "impulseforceCOMP",
        "members": [
            {
                "text": "button : Pulse for the impulse force. When pulsed, on the next frame it will apply the impulse force.",
                "type": "buttonPar",
                "name": "pulse",
                "items": []
            },
            {
                "text": "float : The linear force in Newtons to be applied when the node is pulsed.",
                "type": "floatPar",
                "name": "force",
                "items": []
            },
            {
                "text": "float : The position at which to apply the linear force, relative to the center of the body (Note: the physical center of the object, not the center of mass). Having a nonzero relative position will also cause the body to rotate due to added torque.",
                "type": "floatPar",
                "name": "relpos",
                "items": []
            },
            {
                "text": "float : The rotational force in Newtons that will be applied.",
                "type": "floatPar",
                "name": "torque",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "impulseforceCOMP",
        "opLabel": "Impulse Force",
        "opClass": "impulseforceCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "An Impulse Force COMP will create a force in the simulation that can be applied for 1 frame using the Pulse Force parameter.",
        "long": "An Impulse Force COMP will create a force in the simulation that can be applied for 1 frame using the Pulse Force parameter. In the real world, impulse forces are forces applied over a very short duration, however in [[Bullet Dynamics|Bullet]] this is somewhat simplified, and they are instead applied instantly (for a single frame). Examples of impulse forces are kicking a ball or shooting a cannon. The velocities of the affected bodies are changed in an instant by the impulse force, and after that instant the force no longer has an effect unless applied again.  \n    \nThe resulting velocity of the bodies after the impulse force is applied is the same as the [[Force COMP]] with the same values if the Force COMP is applied for exactly 1 second. For example, if 10N of Impulse Force is applied to a body with mass 5kg then the resulting velocity will be 10N / 5kg * 1sec = 2m/s. \n\nSee also: [[Bullet Dynamics]], [[Bullet Solver COMP]], [[Actor COMP]], [[Force COMP]], [[Constraint COMP]], [[Bullet Solver CHOP]]."
    },
    "lightCOMP": {
        "label": "lightCOMP",
        "members": [
            {
                "text": "RGB : You can modify the color of a light here by adjusting the red, green, and blue parameters.  Alternatively, clicking on the color swatch will open a dialog with HSV and/or RGB sliders allowing interactive color picking with a preview of the selected color.",
                "type": "RGBPar",
                "name": "cr",
                "items": []
            },
            {
                "text": "RGB : You can modify the color of a light here by adjusting the red, green, and blue parameters.  Alternatively, clicking on the color swatch will open a dialog with HSV and/or RGB sliders allowing interactive color picking with a preview of the selected color.",
                "type": "RGBPar",
                "name": "cg",
                "items": []
            },
            {
                "text": "RGB : You can modify the color of a light here by adjusting the red, green, and blue parameters.  Alternatively, clicking on the color swatch will open a dialog with HSV and/or RGB sliders allowing interactive color picking with a preview of the selected color.",
                "type": "RGBPar",
                "name": "cb",
                "items": []
            },
            {
                "text": "Float : This parameter changes the intensity of the light without affecting its hue. Lights with Dimmer intensity below 0.001 are ignored. This optimization allows lights that are set to 0.0 to not be calculated in a [[Render TOP]].",
                "type": "FloatPar",
                "name": "dimmer",
                "items": []
            },
            {
                "text": "Menu : Specifies the type of light.",
                "type": "MenuPar",
                "name": "lighttype",
                "items": []
            },
            {
                "text": "Float : This specifies the angle within which the light remains at full intensity. Decreasing the cone angle to between ten and forty degrees focuses the beam to spotlight proportions.",
                "type": "FloatPar",
                "name": "coneangle",
                "items": []
            },
            {
                "text": "Float : This value, in degrees, represents the angle outside the cone angle through which the light intensity drops from its maximum to zero. Beyond this area, no more light is cast.\t\t\n\t\t\t\t\n[[Image:Objects16.gif]]",
                "type": "FloatPar",
                "name": "conedelta",
                "items": []
            },
            {
                "text": "Float : This parameter (a value between one and ten) defines how gently or suddenly the amount of light decreases between full intensity and zero intensity within the Cone Delta area.",
                "type": "FloatPar",
                "name": "coneroll",
                "items": []
            },
            {
                "text": "Toggle : Turn on this checkbox to enable distance-based attenuation of the light.",
                "type": "TogglePar",
                "name": "attenuated",
                "items": []
            },
            {
                "text": "Float : The distance from the light source where the light attenuation begins.",
                "type": "FloatPar",
                "name": "attenuationstart",
                "items": []
            },
            {
                "text": "Float : The distance from the light source where the light attenuation ends (i.e., no light radiates beyond this point).",
                "type": "FloatPar",
                "name": "attenuationend",
                "items": []
            },
            {
                "text": "Float : Controls how the light fades off between the Attenuation Start and End points.",
                "type": "FloatPar",
                "name": "attenuationexp",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "projmaptype",
                "items": []
            },
            {
                "text": "TOP : The path to a [[TOP]] used for the light's projector map.",
                "type": "TOPPar",
                "name": "projmap",
                "items": []
            },
            {
                "text": "Menu : Sets the extend conditions for the Projector Map texture.",
                "type": "MenuPar",
                "name": "projmapextendu",
                "items": []
            },
            {
                "text": "Menu : Sets the extend conditions for the Projector Map texture.",
                "type": "MenuPar",
                "name": "projmapextendv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend conditions for the Projector Map texture.",
                "type": "MenuPar",
                "name": "projmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "projmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "projmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : Specify how the projection map is applied",
                "type": "MenuPar",
                "name": "projmapmode",
                "items": []
            },
            {
                "text": "Float : Specifies the cone angle spread of the projector map, similar to how the Cone Angle parameter works for Cone Lights.",
                "type": "FloatPar",
                "name": "projangle",
                "items": []
            },
            {
                "text": "Menu : Controls how the polygon's normal is used to light the front face of the polygon. For more information refer to the [[Two-Sided Lighting]] article.",
                "type": "MenuPar",
                "name": "frontfacelit",
                "items": []
            },
            {
                "text": "Menu : Controls how the polygon's normal is used to light the back face of the polygon. For more information refer to the [[Two-Sided Lighting]] article.",
                "type": "MenuPar",
                "name": "backfacelit",
                "items": []
            },
            {
                "text": "Menu : Sets the type of shadows cast by the light.",
                "type": "MenuPar",
                "name": "shadowtype",
                "items": []
            },
            {
                "text": "OP : The [[Geometry COMP]]s that will cast shadows from this light.",
                "type": "OPPar",
                "name": "shadowcasters",
                "items": []
            },
            {
                "text": "Float : Controls the size of the source light when using Soft or Custom shadows.",
                "type": "FloatPar",
                "name": "lightsize",
                "items": []
            },
            {
                "text": "Float : Fine tuning for the shadow's software when using Soft or Custom shadows.",
                "type": "FloatPar",
                "name": "maxshadowsoftness",
                "items": []
            },
            {
                "text": "Int : Controls how many samples to look up into the shadow map for each pixel when doing soft shadows.",
                "type": "IntPar",
                "name": "filtersamples",
                "items": []
            },
            {
                "text": "Int : Controls how many steps to take to search for occlusion when doing soft shadows.",
                "type": "IntPar",
                "name": "searchsteps",
                "items": []
            },
            {
                "text": "Float : Adds an offset to the Z value that depends on how sloped the surface is to the viewer when rendering the shadow map. Helps avoid z-fighting artifacts.",
                "type": "FloatPar",
                "name": "polygonoffsetfactor",
                "items": []
            },
            {
                "text": "Float : Adds a constant offset to the Z value when rendering the shadow map. Helps avoid z-fighting artifacts.",
                "type": "FloatPar",
                "name": "polygonoffsetunits",
                "items": []
            },
            {
                "text": "Int : The resolution of the shadow's texture map used for the calculation.",
                "type": "IntPar",
                "name": "shadowresolution",
                "items": []
            },
            {
                "text": "TOP : The path to a [[TOP]] used for the light's shadow map.  See also [[Rendering Shadows]].",
                "type": "TOPPar",
                "name": "shadowmap",
                "items": []
            },
            {
                "text": "Menu : A pop-up menu lets you choose the projection type.",
                "type": "MenuPar",
                "name": "projection",
                "items": []
            },
            {
                "text": "Toggle : Keeps the aspect ratio of the view correct when using the light as a camera to look through.",
                "type": "TogglePar",
                "name": "aspectcorrect",
                "items": []
            },
            {
                "text": "Float : Only active if Orthographic is chosen from the Projection pop-up menu. This specifies the width of the orthographic projection.",
                "type": "FloatPar",
                "name": "orthowidth",
                "items": []
            },
            {
                "text": "Toggle : If the light is set to Cone Light type, enabling this option sets the FOV using the Cone Angle and Cone Delta parameters on the Light parameter page.",
                "type": "TogglePar",
                "name": "useconeforfov",
                "items": []
            },
            {
                "text": "Menu : This menu determines which method is used to define the camera's angle of view.",
                "type": "MenuPar",
                "name": "viewanglemethod",
                "items": []
            },
            {
                "text": "Float : The field of view (FOV) angle is the angular extend of the scene imaged by the camera.",
                "type": "FloatPar",
                "name": "fov",
                "items": []
            },
            {
                "text": "Float : The parameter sets the focal length of the lens, zooming in and out. Perspective is flattened or exaggerated depending on focal length. Some interesting distortion effects can be acheived with this parameter.",
                "type": "FloatPar",
                "name": "focal",
                "items": []
            },
            {
                "text": "Float : This value relates to the area through which light can pass for the camera.",
                "type": "FloatPar",
                "name": "aperture",
                "items": []
            },
            {
                "text": "Float : This control allows you to designate the near clipping planes. Geometry closer to the lens than these distances will not be visible.",
                "type": "FloatPar",
                "name": "near",
                "items": []
            },
            {
                "text": "Float : This control allows you to designate the far clipping planes. Geometry further away from the lens than these distances will not be visible.",
                "type": "FloatPar",
                "name": "far",
                "items": []
            },
            {
                "text": "OP : When Custom Projection Matrix is selected, this parameters should be filled in with either a CHOP or a DAT with a custom 4x4 projection matrix. If a CHOP is used the first sample of the first 16 channels of the CHOP are used to create a 4x4 matrix. The channels can be thought as being read row-by-row or column-by-column. If a DAT is given a 4x4 table should be used. The matrix convention used is column major, which means vectors/points are multiplied on the right of the matrix.",
                "type": "OPPar",
                "name": "projmatrixop",
                "items": []
            },
            {
                "text": "DAT : Takes a DAT containing a GLSL shader to specify custom projection functions. You must provide two functions in this shader. Both functions must be provided and return correct results for your rendering to work in all cases. As a starting point, here are the definitions for these functions that are used when custom ones are not provided.\t\t\n\t\t\t\t\n  <syntaxhighlight lang=c>\n  vec4 TDSOPToProj(vec4 p)\t\t\t\t\n  {\t\t\t\t\n      vec4 projP = uTDMat.worldCamProj * p;\t\t\t\t\n      return projP;\t\t\t\t\n  }\t\t\t\n  vec4 TDCamToProj(vec4 p)\t\t\t\t\n  {\t\t\t\t\n      vec4 projP = uTDMat.proj * p;\t\t\t\t\n      return projP;\t\t\t\t\n  }\t\n  </syntaxhighlight>\t\t\t\n\t\t\t\t\nThe other convenience variations of these functions such as <code>vec3 TDCamToProj(vec3 p)</code> will automatically call the correct one of either of the two above functions. You can use uniforms/samplers in this shader code by declaring them here and providing them in the GLSL page of the [[Render TOP]].",
                "type": "DATPar",
                "name": "customproj",
                "items": []
            },
            {
                "text": "RGBA : Set the background color of the view when using the light as a camera.",
                "type": "RGBAPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGBA : Set the background color of the view when using the light as a camera.",
                "type": "RGBAPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGBA : Set the background color of the view when using the light as a camera.",
                "type": "RGBAPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "RGBA : Set the background color of the view when using the light as a camera.",
                "type": "RGBAPar",
                "name": "bgcolora",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Light Components are objects which cast light into a 3D scene. With the light parameters you can control the color, brightness, and atmosphere of geometry lit by the light. A scene can also be viewed through a light's perspective, similar to a [[Camera COMP]]. \n    \n'''Tip''': To avoid a light from consuming compute time when it's off, make the Dimmer parameter less than .001.\n\nSee [[Geometry Viewer]] to learn about how you can inspect from a light.",
        "opLabel": "Light",
        "opLicense": "Non-Commercial",
        "opFamily": "COMP",
        "short": "The Light Components are objects which cast light into a 3D scene.",
        "opType": "light",
        "opFilter": "False",
        "opClass": "lightCOMP_Class",
        "opCategories": ""
    },
    "listCOMP": {
        "label": "listCOMP",
        "members": [
            {
                "text": "DAT : A reference to the callback DAT.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Int : The number of rows in the List.",
                "type": "IntPar",
                "name": "rows",
                "items": []
            },
            {
                "text": "Int : The number of columns in the List.",
                "type": "IntPar",
                "name": "cols",
                "items": []
            },
            {
                "text": "Toggle : Locks the first row in place when scrolling horizontally.",
                "type": "TogglePar",
                "name": "lockfirstrow",
                "items": []
            },
            {
                "text": "Toggle : Locks the first column in place when scrolling vertically.",
                "type": "TogglePar",
                "name": "lockfirstcol",
                "items": []
            },
            {
                "text": "Toggle : Enables the horizontal scroll bar.",
                "type": "TogglePar",
                "name": "hscrollbar",
                "items": []
            },
            {
                "text": "Toggle : Enables the vertical scroll bar.",
                "type": "TogglePar",
                "name": "vscrollbar",
                "items": []
            },
            {
                "text": "Toggle : When on, you get callbacks (select, rollover, etc) on List COMP areas that are not in any cells. For example, the area below a list when the list has a large size but only a few entries at the top.",
                "type": "TogglePar",
                "name": "offcellcallbacks",
                "items": []
            },
            {
                "text": "Pulse : Resets the table by running its initialize callbacks.",
                "type": "PulsePar",
                "name": "reset",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "List",
        "opFamily": "COMP",
        "long": "The List Component lets you create large lists that are highly customizable via the List COMPs initialization and callback functions. Refer to the [[Build a List COMP]] article for more info on using this COMP.\t\t\n\nSee Also: [[Palette:lister|Lister Custom COMP]], a Python enhanced custom listCOMP.",
        "opClass": "listCOMP_Class",
        "short": "The List Component lets you create large lists that are highly customizable via the List COMPs initialization and callback functions.",
        "opType": "list",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "flexsolverCOMP": {
        "label": "flexsolverCOMP",
        "members": [
            {
                "text": "OBJ : The Actor COMPs to include in the simulation. These actors cannot already be a part of another Solver COMP.",
                "type": "OBJPar",
                "name": "actors",
                "items": []
            },
            {
                "text": "OBJ : The Force COMPs to include in the simulation. Only force fields are supported in Flex.",
                "type": "OBJPar",
                "name": "forces",
                "items": []
            },
            {
                "text": "XYZ : Gravity applied to all actors in the simulation in m/s^2. Gravity is applied to actors irrespective of their mass.",
                "type": "XYZPar",
                "name": "gravityx",
                "items": []
            },
            {
                "text": "XYZ : Gravity applied to all actors in the simulation in m/s^2. Gravity is applied to actors irrespective of their mass.",
                "type": "XYZPar",
                "name": "gravityy",
                "items": []
            },
            {
                "text": "XYZ : Gravity applied to all actors in the simulation in m/s^2. Gravity is applied to actors irrespective of their mass.",
                "type": "XYZPar",
                "name": "gravityz",
                "items": []
            },
            {
                "text": "Pulse : Reset all bodies to their initial state (ie. position, orientation, velocity). This will not begin stepping through the simulation, it will only initialize.",
                "type": "PulsePar",
                "name": "init",
                "items": []
            },
            {
                "text": "Pulse : Initialize the simulation and run it (begin stepping).",
                "type": "PulsePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : Play the simulation. Will step through the simulation when toggled on, but will be paused when toggled off.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : The sample rate of the simulation. The sample rate affects the timestep, which is 1/rate",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Toggle : Enables simulation pre-roll. Pre-roll can used to step forward the simulation to a desired start state. Pre-roll will happen during the initialization phase. To get info on the state of pre-roll, see the channels on the Solver's [[Info CHOP]].",
                "type": "TogglePar",
                "name": "preroll",
                "items": []
            },
            {
                "text": "Float : The time in seconds to step forward the simulation before start.",
                "type": "FloatPar",
                "name": "prerolltime",
                "items": []
            },
            {
                "text": "Int : The amount of steps to take per TouchDesigner frame during pre-roll. Eg. If pre-roll simulation time is 1 second and pre-roll step is 2 then it will take 0.5 seconds to pre-roll.",
                "type": "IntPar",
                "name": "prerollstep",
                "items": []
            },
            {
                "text": "Toggle : When enabled the results of the pre-roll will be shown in the Actor COMP (ie. have their transforms updated). When disabled, the Actor COMPs will remain in their initial state until pre-roll is complete",
                "type": "TogglePar",
                "name": "showpreroll",
                "items": []
            },
            {
                "text": "Int : Number of substeps to take during one step of the simulation.",
                "type": "IntPar",
                "name": "substeps",
                "items": []
            },
            {
                "text": "Int : Number of iterations in each substep.",
                "type": "IntPar",
                "name": "iterations",
                "items": []
            },
            {
                "text": "Toggle : When enabled the simulation will always step forward.",
                "type": "TogglePar",
                "name": "alwayssim",
                "items": []
            },
            {
                "text": "Toggle : Enable simulation boundaries. These can either be set through a bounding box or individual planes.",
                "type": "TogglePar",
                "name": "bounds",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "boundmode",
                "items": []
            },
            {
                "text": "SOP : The SOP used to calculate the bounding box.",
                "type": "SOPPar",
                "name": "bbox",
                "items": []
            },
            {
                "text": "XYZ : Rotate the default plane. Default plane is a +Z XY plane (same as Grid SOP).",
                "type": "XYZPar",
                "name": "planer0x",
                "items": []
            },
            {
                "text": "XYZ : Rotate the default plane. Default plane is a +Z XY plane (same as Grid SOP).",
                "type": "XYZPar",
                "name": "planer0y",
                "items": []
            },
            {
                "text": "XYZ : Rotate the default plane. Default plane is a +Z XY plane (same as Grid SOP).",
                "type": "XYZPar",
                "name": "planer0z",
                "items": []
            },
            {
                "text": "XYZ : Translate the default plane. Default plane is a +Z XY plane (same as Grid SOP).",
                "type": "XYZPar",
                "name": "planet0x",
                "items": []
            },
            {
                "text": "XYZ : Translate the default plane. Default plane is a +Z XY plane (same as Grid SOP).",
                "type": "XYZPar",
                "name": "planet0y",
                "items": []
            },
            {
                "text": "XYZ : Translate the default plane. Default plane is a +Z XY plane (same as Grid SOP).",
                "type": "XYZPar",
                "name": "planet0z",
                "items": []
            },
            {
                "text": "XYZ : Radius of the particles in the simulation. '''Note:''' This is used by all Actor's in the simulation.",
                "type": "XYZPar",
                "name": "radiusx",
                "items": []
            },
            {
                "text": "XYZ : Radius of the particles in the simulation. '''Note:''' This is used by all Actor's in the simulation.",
                "type": "XYZPar",
                "name": "radiusy",
                "items": []
            },
            {
                "text": "XYZ : Radius of the particles in the simulation. '''Note:''' This is used by all Actor's in the simulation.",
                "type": "XYZPar",
                "name": "radiusz",
                "items": []
            },
            {
                "text": "XYZ : The force of friction between a moving particle and a static shape.",
                "type": "XYZPar",
                "name": "dfrictionx",
                "items": []
            },
            {
                "text": "XYZ : The force of friction between a moving particle and a static shape.",
                "type": "XYZPar",
                "name": "dfrictiony",
                "items": []
            },
            {
                "text": "XYZ : The force of friction between a moving particle and a static shape.",
                "type": "XYZPar",
                "name": "dfrictionz",
                "items": []
            },
            {
                "text": "XYZ : The force of friction between a non-moving particle and a static shape.",
                "type": "XYZPar",
                "name": "sfrictionx",
                "items": []
            },
            {
                "text": "XYZ : The force of friction between a non-moving particle and a static shape.",
                "type": "XYZPar",
                "name": "sfrictiony",
                "items": []
            },
            {
                "text": "XYZ : The force of friction between a non-moving particle and a static shape.",
                "type": "XYZPar",
                "name": "sfrictionz",
                "items": []
            },
            {
                "text": "XYZ : Dynamic friction between particles.",
                "type": "XYZPar",
                "name": "pfrictionx",
                "items": []
            },
            {
                "text": "XYZ : Dynamic friction between particles.",
                "type": "XYZPar",
                "name": "pfrictiony",
                "items": []
            },
            {
                "text": "XYZ : Dynamic friction between particles.",
                "type": "XYZPar",
                "name": "pfrictionz",
                "items": []
            },
            {
                "text": "XYZ : [https://en.wikipedia.org/wiki/Restitution The coefficient of restitution] for particles.",
                "type": "XYZPar",
                "name": "restx",
                "items": []
            },
            {
                "text": "XYZ : [https://en.wikipedia.org/wiki/Restitution The coefficient of restitution] for particles.",
                "type": "XYZPar",
                "name": "resty",
                "items": []
            },
            {
                "text": "XYZ : [https://en.wikipedia.org/wiki/Restitution The coefficient of restitution] for particles.",
                "type": "XYZPar",
                "name": "restz",
                "items": []
            },
            {
                "text": "XYZ : How strongly particles stick to surfaces/shapes they hit.",
                "type": "XYZPar",
                "name": "adhesionx",
                "items": []
            },
            {
                "text": "XYZ : How strongly particles stick to surfaces/shapes they hit.",
                "type": "XYZPar",
                "name": "adhesiony",
                "items": []
            },
            {
                "text": "XYZ : How strongly particles stick to surfaces/shapes they hit.",
                "type": "XYZPar",
                "name": "adhesionz",
                "items": []
            },
            {
                "text": "XYZ : Particles with a velocity less than this threshold will be considered non-moving.",
                "type": "XYZPar",
                "name": "sleepthreshx",
                "items": []
            },
            {
                "text": "XYZ : Particles with a velocity less than this threshold will be considered non-moving.",
                "type": "XYZPar",
                "name": "sleepthreshy",
                "items": []
            },
            {
                "text": "XYZ : Particles with a velocity less than this threshold will be considered non-moving.",
                "type": "XYZPar",
                "name": "sleepthreshz",
                "items": []
            },
            {
                "text": "Toggle : Enable speed clamping.",
                "type": "TogglePar",
                "name": "clampspeed",
                "items": []
            },
            {
                "text": "XYZ : The magnitude of particle velocity will be clamped to this value.",
                "type": "XYZPar",
                "name": "maxspeedx",
                "items": []
            },
            {
                "text": "XYZ : The magnitude of particle velocity will be clamped to this value.",
                "type": "XYZPar",
                "name": "maxspeedy",
                "items": []
            },
            {
                "text": "XYZ : The magnitude of particle velocity will be clamped to this value.",
                "type": "XYZPar",
                "name": "maxspeedz",
                "items": []
            },
            {
                "text": "Toggle : Enable acceleration clamping.",
                "type": "TogglePar",
                "name": "clampaccel",
                "items": []
            },
            {
                "text": "XYZ : The magnitude of particle acceleration will be clamped to this value.",
                "type": "XYZPar",
                "name": "maxaccelx",
                "items": []
            },
            {
                "text": "XYZ : The magnitude of particle acceleration will be clamped to this value.",
                "type": "XYZPar",
                "name": "maxaccely",
                "items": []
            },
            {
                "text": "XYZ : The magnitude of particle acceleration will be clamped to this value.",
                "type": "XYZPar",
                "name": "maxaccelz",
                "items": []
            },
            {
                "text": "XYZ : Damps particle velocity based on how many particle contacts it has.",
                "type": "XYZPar",
                "name": "dissx",
                "items": []
            },
            {
                "text": "XYZ : Damps particle velocity based on how many particle contacts it has.",
                "type": "XYZPar",
                "name": "dissy",
                "items": []
            },
            {
                "text": "XYZ : Damps particle velocity based on how many particle contacts it has.",
                "type": "XYZPar",
                "name": "dissz",
                "items": []
            },
            {
                "text": "XYZ : Viscous drag force. Applies a force proportional and opposite to the particle velocity.",
                "type": "XYZPar",
                "name": "dampingx",
                "items": []
            },
            {
                "text": "XYZ : Viscous drag force. Applies a force proportional and opposite to the particle velocity.",
                "type": "XYZPar",
                "name": "dampingy",
                "items": []
            },
            {
                "text": "XYZ : Viscous drag force. Applies a force proportional and opposite to the particle velocity.",
                "type": "XYZPar",
                "name": "dampingz",
                "items": []
            },
            {
                "text": "XYZ : Controls how strongles particles hold to each other.",
                "type": "XYZPar",
                "name": "cohesionx",
                "items": []
            },
            {
                "text": "XYZ : Controls how strongles particles hold to each other.",
                "type": "XYZPar",
                "name": "cohesiony",
                "items": []
            },
            {
                "text": "XYZ : Controls how strongles particles hold to each other.",
                "type": "XYZPar",
                "name": "cohesionz",
                "items": []
            },
            {
                "text": "XYZ : Controls how strongly particles attempt to minimize surface area.",
                "type": "XYZPar",
                "name": "surftensionx",
                "items": []
            },
            {
                "text": "XYZ : Controls how strongly particles attempt to minimize surface area.",
                "type": "XYZPar",
                "name": "surftensiony",
                "items": []
            },
            {
                "text": "XYZ : Controls how strongly particles attempt to minimize surface area.",
                "type": "XYZPar",
                "name": "surftensionz",
                "items": []
            },
            {
                "text": "XYZ : Smoothes particle velocities using XSPH viscosity.",
                "type": "XYZPar",
                "name": "viscosityx",
                "items": []
            },
            {
                "text": "XYZ : Smoothes particle velocities using XSPH viscosity.",
                "type": "XYZPar",
                "name": "viscosityy",
                "items": []
            },
            {
                "text": "XYZ : Smoothes particle velocities using XSPH viscosity.",
                "type": "XYZPar",
                "name": "viscosityz",
                "items": []
            },
            {
                "text": "XYZ : A gravity scale for fluid particles.",
                "type": "XYZPar",
                "name": "buoyancyx",
                "items": []
            },
            {
                "text": "XYZ : A gravity scale for fluid particles.",
                "type": "XYZPar",
                "name": "buoyancyy",
                "items": []
            },
            {
                "text": "XYZ : A gravity scale for fluid particles.",
                "type": "XYZPar",
                "name": "buoyancyz",
                "items": []
            },
            {
                "text": "XYZ : The distance particles maintain when colliding against shapes.",
                "type": "XYZPar",
                "name": "colldistx",
                "items": []
            },
            {
                "text": "XYZ : The distance particles maintain when colliding against shapes.",
                "type": "XYZPar",
                "name": "colldisty",
                "items": []
            },
            {
                "text": "XYZ : The distance particles maintain when colliding against shapes.",
                "type": "XYZPar",
                "name": "colldistz",
                "items": []
            },
            {
                "text": "XYZ : Increases the particle radius during contact finding against shapes.",
                "type": "XYZPar",
                "name": "scollmarginx",
                "items": []
            },
            {
                "text": "XYZ : Increases the particle radius during contact finding against shapes.",
                "type": "XYZPar",
                "name": "scollmarginy",
                "items": []
            },
            {
                "text": "XYZ : Increases the particle radius during contact finding against shapes.",
                "type": "XYZPar",
                "name": "scollmarginz",
                "items": []
            },
            {
                "text": "XYZ : Controls the strength of Laplacian smoothing in particles for rendering.",
                "type": "XYZPar",
                "name": "smoothingx",
                "items": []
            },
            {
                "text": "XYZ : Controls the strength of Laplacian smoothing in particles for rendering.",
                "type": "XYZPar",
                "name": "smoothingy",
                "items": []
            },
            {
                "text": "XYZ : Controls the strength of Laplacian smoothing in particles for rendering.",
                "type": "XYZPar",
                "name": "smoothingz",
                "items": []
            },
            {
                "text": "XYZ : Increases vorticity by applying rotational forces to particles.",
                "type": "XYZPar",
                "name": "vortconfx",
                "items": []
            },
            {
                "text": "XYZ : Increases vorticity by applying rotational forces to particles.",
                "type": "XYZPar",
                "name": "vortconfy",
                "items": []
            },
            {
                "text": "XYZ : Increases vorticity by applying rotational forces to particles.",
                "type": "XYZPar",
                "name": "vortconfz",
                "items": []
            },
            {
                "text": "XYZ : Control how much anisotropys is present in resulting ellipsoids for rendering.",
                "type": "XYZPar",
                "name": "anisoscalex",
                "items": []
            },
            {
                "text": "XYZ : Control how much anisotropys is present in resulting ellipsoids for rendering.",
                "type": "XYZPar",
                "name": "anisoscaley",
                "items": []
            },
            {
                "text": "XYZ : Control how much anisotropys is present in resulting ellipsoids for rendering.",
                "type": "XYZPar",
                "name": "anisoscalez",
                "items": []
            },
            {
                "text": "XYZ : Clamp the anisotropy scale to this fraction of the radius.",
                "type": "XYZPar",
                "name": "anisominx",
                "items": []
            },
            {
                "text": "XYZ : Clamp the anisotropy scale to this fraction of the radius.",
                "type": "XYZPar",
                "name": "anisominy",
                "items": []
            },
            {
                "text": "XYZ : Clamp the anisotropy scale to this fraction of the radius.",
                "type": "XYZPar",
                "name": "anisominz",
                "items": []
            },
            {
                "text": "XYZ : Clamp the anisotropy scale to this fraction of the radius.",
                "type": "XYZPar",
                "name": "anisomaxx",
                "items": []
            },
            {
                "text": "XYZ : Clamp the anisotropy scale to this fraction of the radius.",
                "type": "XYZPar",
                "name": "anisomaxy",
                "items": []
            },
            {
                "text": "XYZ : Clamp the anisotropy scale to this fraction of the radius.",
                "type": "XYZPar",
                "name": "anisomaxz",
                "items": []
            },
            {
                "text": "XYZ : When enabled, diffuse particles will be created in the simulation. Diffuse particle position/velocity can be fetched using the [[Nvidia Flex TOP]].",
                "type": "XYZPar",
                "name": "diffusex",
                "items": []
            },
            {
                "text": "XYZ : When enabled, diffuse particles will be created in the simulation. Diffuse particle position/velocity can be fetched using the [[Nvidia Flex TOP]].",
                "type": "XYZPar",
                "name": "diffusey",
                "items": []
            },
            {
                "text": "XYZ : When enabled, diffuse particles will be created in the simulation. Diffuse particle position/velocity can be fetched using the [[Nvidia Flex TOP]].",
                "type": "XYZPar",
                "name": "diffusez",
                "items": []
            },
            {
                "text": "XYZ : The maximum number of diffuse particles that can exist in a simulation simultaneously. '''Note:''' if the maximum is too low or the diffuse lifetime too high, then the simulation may not be able to create all the particles needed. However, too many diffuse particles can also affect performance.",
                "type": "XYZPar",
                "name": "maxdiffusex",
                "items": []
            },
            {
                "text": "XYZ : The maximum number of diffuse particles that can exist in a simulation simultaneously. '''Note:''' if the maximum is too low or the diffuse lifetime too high, then the simulation may not be able to create all the particles needed. However, too many diffuse particles can also affect performance.",
                "type": "XYZPar",
                "name": "maxdiffusey",
                "items": []
            },
            {
                "text": "XYZ : The maximum number of diffuse particles that can exist in a simulation simultaneously. '''Note:''' if the maximum is too low or the diffuse lifetime too high, then the simulation may not be able to create all the particles needed. However, too many diffuse particles can also affect performance.",
                "type": "XYZPar",
                "name": "maxdiffusez",
                "items": []
            },
            {
                "text": "XYZ : Particles with ''kinetic energy + divergence'' above this threshold will spawn new diffuse particles",
                "type": "XYZPar",
                "name": "diffthreshx",
                "items": []
            },
            {
                "text": "XYZ : Particles with ''kinetic energy + divergence'' above this threshold will spawn new diffuse particles",
                "type": "XYZPar",
                "name": "diffthreshy",
                "items": []
            },
            {
                "text": "XYZ : Particles with ''kinetic energy + divergence'' above this threshold will spawn new diffuse particles",
                "type": "XYZPar",
                "name": "diffthreshz",
                "items": []
            },
            {
                "text": "XYZ : A gravity scale for diffuse particles.",
                "type": "XYZPar",
                "name": "diffbuoyx",
                "items": []
            },
            {
                "text": "XYZ : A gravity scale for diffuse particles.",
                "type": "XYZPar",
                "name": "diffbuoyy",
                "items": []
            },
            {
                "text": "XYZ : A gravity scale for diffuse particles.",
                "type": "XYZPar",
                "name": "diffbuoyz",
                "items": []
            },
            {
                "text": "XYZ : Scales the force that diffuse particles receive in direction of neighbouring fluid particles.",
                "type": "XYZPar",
                "name": "diffdragx",
                "items": []
            },
            {
                "text": "XYZ : Scales the force that diffuse particles receive in direction of neighbouring fluid particles.",
                "type": "XYZPar",
                "name": "diffdragy",
                "items": []
            },
            {
                "text": "XYZ : Scales the force that diffuse particles receive in direction of neighbouring fluid particles.",
                "type": "XYZPar",
                "name": "diffdragz",
                "items": []
            },
            {
                "text": "XYZ : The number of neighbours below which a diffuse particle is considered ballistic.",
                "type": "XYZPar",
                "name": "diffballx",
                "items": []
            },
            {
                "text": "XYZ : The number of neighbours below which a diffuse particle is considered ballistic.",
                "type": "XYZPar",
                "name": "diffbally",
                "items": []
            },
            {
                "text": "XYZ : The number of neighbours below which a diffuse particle is considered ballistic.",
                "type": "XYZPar",
                "name": "diffballz",
                "items": []
            },
            {
                "text": "XYZ : Time in seconds that a diffuse particle will live for after being spawned.",
                "type": "XYZPar",
                "name": "difflifex",
                "items": []
            },
            {
                "text": "XYZ : Time in seconds that a diffuse particle will live for after being spawned.",
                "type": "XYZPar",
                "name": "difflifey",
                "items": []
            },
            {
                "text": "XYZ : Time in seconds that a diffuse particle will live for after being spawned.",
                "type": "XYZPar",
                "name": "difflifez",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "flexsolverCOMP",
        "opLabel": "Nvidia Flex Solver",
        "opClass": "flexsolverCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This feature is only available on systems with a Nvidia GPU.",
        "short": "The Nvidia Flex Solver COMP is a physics solver COMP similar to the [[Bullet Solver COMP]].",
        "long": "The Nvidia Flex Solver COMP is a physics solver COMP similar to the [[Bullet Solver COMP]].\n\nIn an Nvidia Flex simulation, the Nvidia Flex Solver COMP is analogous to the world/simulation in which actors/bodies (ie. Actor COMPs) operate. An Nvidia Flex Solver COMP contains any number of actors/bodies (Actor COMPs) or force fields (Force COMP), and as the name suggests it uses [https://developer.nvidia.com/flex Nvidia's FleX particle physics API].\n\nThe Nvidia Flex Solver COMP runs an Nvidia Flex simulation based on some simulation parameters (eg. particle radius and cohesion) and updates the transformations of the Actor COMPs contained within it as the simulation progresses forward.\n\nThe Actor COMPs referenced by the Nvidia Flex Solver COMP do not need to be inside its network. They can be anywhere as long as they are not already referenced by another Solver COMP (Nvidia Flex or Bullet). \n\nSee also: [[Flex]], [[Nvidia Flex TOP]], [[Actor COMP]], [[Force COMP]]",
        "opCategories": ""
    },
    "flowEmitterCOMP": {
        "label": "flowEmitterCOMP",
        "members": [
            {
                "text": "toggle : Turns the emitter On or Off.",
                "type": "togglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "dropmenu : Select Emitter or Collider mode.",
                "type": "dropmenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "dropmenu : Select the shape type used for the emitter.",
                "type": "dropmenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "float : Controls the dimensions of the emitter when using Box or Shape TOP types.",
                "type": "floatPar",
                "name": "size",
                "items": []
            },
            {
                "text": "float : Controls the radius of the emitter when using the Sphere or Capsule types.",
                "type": "floatPar",
                "name": "radius",
                "items": []
            },
            {
                "text": "float : Control the length of the emitter when using the Capsule type.",
                "type": "floatPar",
                "name": "length",
                "items": []
            },
            {
                "text": "string : Specify the TOP or SOP to use as an emitter when Type parameter is set to Shape TOP / Shape SOP respectively. For TOP emitters the resolution cannot exceed 2048x2048.",
                "type": "stringPar",
                "name": "shapeop",
                "items": []
            },
            {
                "text": "dropmenu : Allows use of different channels to determine the shape of the emitter created when using Shape TOP.",
                "type": "dropmenuPar",
                "name": "shapechannel",
                "items": []
            },
            {
                "text": "float : Pixels greater than or equal to the threshold value are used for emission, pixels below the threshold value are ignored.",
                "type": "floatPar",
                "name": "shapethreshold",
                "items": []
            },
            {
                "text": "float : Specifies the center of mass of the emitter.",
                "type": "floatPar",
                "name": "centerofmass",
                "items": []
            },
            {
                "text": "float : The shape of the emitter sets the surface shape, and the Inner Width adds to the emitter by filling in the shape from the surface inwards. The default setting of 1.0 effectively fills in the shape like a solid.",
                "type": "floatPar",
                "name": "innerwidth",
                "items": []
            },
            {
                "text": "float : The shape of the emitter set the surface shape, and the Outer Width adds to the emitter by extending the shape outwards from the surface.",
                "type": "floatPar",
                "name": "outerwidth",
                "items": []
            },
            {
                "text": "float : Target linear velocity of the fuel added to the system.",
                "type": "floatPar",
                "name": "linearvel",
                "items": []
            },
            {
                "text": "float : Target angular velocity of the fuel added to the system. Think of this as 'rotational velocity.",
                "type": "floatPar",
                "name": "angularvel",
                "items": []
            },
            {
                "text": "float : Rate at which the the system gets to the target velocity. Each simulation block has its own velocity level, the emitter tries to change any blocks it overlaps with to match its emitter value. The correction rate is how strongly it tries to change the value to this target value, for example if 0 the emiitter won't do anything, when a small value like 0-1 the emitter will gently influence the simulation, when a high value like 10-100 it will force the value.",
                "type": "floatPar",
                "name": "velcorrate",
                "items": []
            },
            {
                "text": "float : Amount of smoke produced per unit of fuel in the system.",
                "type": "floatPar",
                "name": "smoke",
                "items": []
            },
            {
                "text": "float : Rate at which the the system gets to the target smoke level. Each simulation block has its own smoke level, the emitter tries to change any blocks it overlaps with to match its emitter value. The correction rate is how strongly it tries to change the value to this target value, for example if 0 the emiitter won't do anything, when a small value like 0-1 the emitter will gently influence the simulation, when a high value like 10-100 it will force the value.",
                "type": "floatPar",
                "name": "smokecorrate",
                "items": []
            },
            {
                "text": "float : Temperature of the system. Note a temperature value of 0 will not ignite the simlulation, a minimum temperature is required for the simulation to burn.",
                "type": "floatPar",
                "name": "temp",
                "items": []
            },
            {
                "text": "float : Rate at which the the system gets to the target temperature level. Each simulation block has its own temperature level, the emitter tries to change any blocks it overlaps with to match its emitter value. The correction rate is how strongly it tries to change the value to this target value, for example if 0 the emiitter won't do anything, when a small value like 0-1 the emitter will gently influence the simulation, when a high value like 10-100 it will force the value.",
                "type": "floatPar",
                "name": "tempcorrate",
                "items": []
            },
            {
                "text": "float : Amount of fuel added to the system per simulation step. The fuel is treated as gaseous and is converted into temperature (and a certain density) when combustion is taking place.",
                "type": "floatPar",
                "name": "fuel",
                "items": []
            },
            {
                "text": "float : Rate at which the the system gets to the target fuel level. Each simulation block has its own fuel level, the emitter tries to change any blocks it overlaps with to match its emitter value. The correction rate is how strongly it tries to change the value to this target value, for example if 0 the emiitter won't do anything, when a small value like 0-1 the emitter will gently influence the simulation, when a high value like 10-100 it will force the value.",
                "type": "floatPar",
                "name": "fuelcorrate",
                "items": []
            },
            {
                "text": "float : THe temperature required in the system to trigger addition Fuel Release set in the parameter below.",
                "type": "floatPar",
                "name": "fuelreleasetemp",
                "items": []
            },
            {
                "text": "float : An additional amount of fuel is released into the system when the Fuel Release Temperature threshold set above is met. TIP: This can help simulate solid fuels where heat must be applied for a gaseous fuel to be released.",
                "type": "floatPar",
                "name": "fuelrelease",
                "items": []
            },
            {
                "text": "float : The emitter allocates 'blocks' to contain the simulation. This parameter controls this where 0.0 turns off emitter allocation, 1.0 is default, and values greater than 1.0 can help pre-allocate which can be useful when the direction of the simulation is difficult to predict.\n\nThe effect of this parameter can be visualized by turning 'Show Blocks' parameter On in the [[Nvidia Flow TOP]].",
                "type": "floatPar",
                "name": "allocscale",
                "items": []
            },
            {
                "text": "float : Controls the emitter's direction block allocation prediction, used for pre-allocation of blocks for fast emitters.\n    \nThe effect of this parameter can be visualized by turning 'Show Blocks' parameter On in the [[Nvidia Flow TOP]].",
                "type": "floatPar",
                "name": "allocpredict",
                "items": []
            },
            {
                "text": "rgb : The base color of the combustion.",
                "type": "rgbPar",
                "name": "color",
                "items": []
            },
            {
                "text": "chopref : This color ramp will be multiplied with the Color Parameter above. The left-side of the color ramp is used for the cooler temperatures in the system ie. further away from center of combustion and where it turns to smoke. The right-side of the ramp colors the higher temperatures.",
                "type": "choprefPar",
                "name": "colorramp",
                "items": []
            },
            {
                "text": "float : Alpha calculations (determined by Alpha Bias and Alpha Masks below) are multiplied by this value for a final Alpha value.",
                "type": "floatPar",
                "name": "alphascale",
                "items": []
            },
            {
                "text": "float : This value is added to alpha before final alpha values are calculated using the Alpha Mask parameters below.",
                "type": "floatPar",
                "name": "alphabias",
                "items": []
            },
            {
                "text": "float : A mulitplier for the color contribution. Useful to use with the Additive Factor parameter below.",
                "type": "floatPar",
                "name": "intensitybias",
                "items": []
            },
            {
                "text": "float : Controls an additive effect in the rendering ie. transparency is added together giving hotspots and brighter color where there is more gas burning.",
                "type": "floatPar",
                "name": "additivefactor",
                "items": []
            },
            {
                "text": "float : Controls the color contribution of the ignition point of the fuel in the system. The value determines which position in the Color Ramp to use for Burn color.",
                "type": "floatPar",
                "name": "burncolormask",
                "items": []
            },
            {
                "text": "float : Controls the color contribution of the smoke in the system. The value determines which position in the Color Ramp to use for Smoke color.",
                "type": "floatPar",
                "name": "smokecolormask",
                "items": []
            },
            {
                "text": "float : Controls the color contribution of the temperature in the system. Note: Fuel is converted to Temperature when combustion is active. The value determines which position in the Color Ramp to use for Temp color.",
                "type": "floatPar",
                "name": "tempcolormask",
                "items": []
            },
            {
                "text": "float : Controls the color contribution of the fuel in the system before it is burned. The value determines which position in the Color Ramp to use for Fuel color.",
                "type": "floatPar",
                "name": "fuelcolormask",
                "items": []
            },
            {
                "text": "float : Controls the transparency of the Burn Color above.",
                "type": "floatPar",
                "name": "burnalphamask",
                "items": []
            },
            {
                "text": "float : Controls the transparency of the Smoke Color above.",
                "type": "floatPar",
                "name": "smokealphamask",
                "items": []
            },
            {
                "text": "float : Controls the transparency of the Temp Color above.",
                "type": "floatPar",
                "name": "tempalphamask",
                "items": []
            },
            {
                "text": "float : Controls the transparency of the Fuel Color above.",
                "type": "floatPar",
                "name": "fuelalphamask",
                "items": []
            },
            {
                "text": "float : Controls the intensity of the Burn Color above. This value is a multiplier and accepts values greater than 1.0.",
                "type": "floatPar",
                "name": "burnintensitymask",
                "items": []
            },
            {
                "text": "float : Controls the intensity of the Smoke Color above. This value is a multiplier and accepts values greater than 1.0.",
                "type": "floatPar",
                "name": "smokeintensitymask",
                "items": []
            },
            {
                "text": "float : Controls the intensity of the Temp Color above. This value is a multiplier and accepts values greater than 1.0.",
                "type": "floatPar",
                "name": "tempintensitymask",
                "items": []
            },
            {
                "text": "float : Controls the intensity of the Fuel Color above. This value is a multiplier and accepts values greater than 1.0.",
                "type": "floatPar",
                "name": "fuelintensitymask",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "flowEmitterCOMP",
        "opLabel": "Nvidia Flow Emitter",
        "opClass": "flowEmitterCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This operator only works with '''Nvidia GPUs'''.",
        "short": "The Nvidia Flow COMP is the fuel emitter for the Flow simulation and can be placed anywhere in the 3D scene.",
        "long": "NVIDIA Flow is a volumetric fluid based simulation of a burning gas system. The user controls the 3 main factors of temperature, fuel, and smoke to create fire and smoke simulations. \n\nThe Nvidia Flow COMP is the fuel emitter for the Flow simulation and can be placed anywhere in the 3D scene.\n\nSee also [[Nvidia Flow TOP]], [[Nvidia Flow]].",
        "opCategories": ""
    },
    "opviewerCOMP": {
        "label": "opviewerCOMP",
        "members": [
            {
                "text": "OP : Path to the target operator whose node viewer will be used.",
                "type": "OPPar",
                "name": "opviewer",
                "items": []
            },
            {
                "text": "Toggle : Enable or disable mouse or touch screen interaction with the target operator's viewer.",
                "type": "TogglePar",
                "name": "interactive",
                "items": []
            },
            {
                "text": "XY : Lets you pan across the target operator's viewer when the Scale is > 1. Center adjusts what part of the target operator's viewer is in the middle of the OP Viewer.",
                "type": "XYPar",
                "name": "opcenterx",
                "items": []
            },
            {
                "text": "XY : Lets you pan across the target operator's viewer when the Scale is > 1. Center adjusts what part of the target operator's viewer is in the middle of the OP Viewer.",
                "type": "XYPar",
                "name": "opcentery",
                "items": []
            },
            {
                "text": "Menu : Center can be expressed in panel units or fraction of width, or display points.",
                "type": "MenuPar",
                "name": "opcenterunit",
                "items": []
            },
            {
                "text": "Float : Lets you zoom in on parts of the target operator's viewer. Increasing scale magnifies the viewer.",
                "type": "FloatPar",
                "name": "opscale",
                "items": []
            },
            {
                "text": "Toggle : When this is On for TOPs, you always see the RGBA image, as if this was simply a [[Select TOP]]. Normally you see what the viewer is currently displaying, which for TOPs may have overlays and not be displaying RGB.",
                "type": "TogglePar",
                "name": "topdirect",
                "items": []
            },
            {
                "text": "Toggle : Only applicable for viewing TOPs, when this option is On, the Center position is calculated based on the dimensions of the texture rather than the panel i.e. panel units are treated as pixels when calculating the center and fractions are relative to the texture height/width.",
                "type": "TogglePar",
                "name": "contentsize",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "OP Viewer",
        "opFamily": "COMP",
        "long": "The OP Viewer Component allows any operator viewer (CHOP Viewer, SOP Viewer, panels, etc.) to be part of a panel with optional full interactivity.",
        "opClass": "opviewerCOMP_Class",
        "short": "The OP Viewer Component allows any operator viewer (CHOP Viewer, SOP Viewer, panels, etc.) to be part of a panel with optional full interactivity.",
        "opType": "opviewer",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "Pallette:depthProjection Ext": {
        "label": "Pallette:depthProjection Ext",
        "members": [
            {
                "text": "Menu : Determines what kind of depth is stored in the source depth image i.e. whether the point cloud is projected in rays from a single camera point, or from the image plane.",
                "type": "MenuPar",
                "name": "Depthtype",
                "items": []
            },
            {
                "text": "Float : Used for scaling the point cloud depth. This parameter defines the range of depths in the source image. Depths outside this range are extrapolated.",
                "type": "FloatPar",
                "name": "Fromrange",
                "items": []
            },
            {
                "text": "Float : Determines the output range for the depth values. The range of input values is mapped linearly to the output range and values outside of the range are extrapolated.",
                "type": "FloatPar",
                "name": "Torange",
                "items": []
            },
            {
                "text": "Menu : Determines how the field of view is defined for the projection.",
                "type": "MenuPar",
                "name": "Viewanglemethod",
                "items": []
            },
            {
                "text": "Float : The field of view measured in degrees when using Horizontal FOV mode.",
                "type": "FloatPar",
                "name": "Fov",
                "items": []
            },
            {
                "text": "Float : The normalized focal length values when using the Focal Length view angle method.",
                "type": "FloatPar",
                "name": "Focallengths",
                "items": []
            },
            {
                "text": "Float : The position of the camera relative to the image plane in normalized values i.e. (0.5, 0.5) assumes the camera point is directly in the center of the image plane.",
                "type": "FloatPar",
                "name": "Center",
                "items": []
            },
            {
                "text": "Pulse : ",
                "type": "PulsePar",
                "name": "Help",
                "items": []
            },
            {
                "text": "Str : ",
                "type": "StrPar",
                "name": "Version",
                "items": []
            },
            {
                "text": "Str : ",
                "type": "StrPar",
                "name": "Toxsavebuild",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "containerCOMP",
        "opLabel": "depthProjection",
        "opClass": "Pallette:depthProjection Ext",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "The depthProjection component converts a 2D depth map image into a 3D point cloud stored in a floating point texture.",
        "long": "The depthProjection component uses the given camera intrinsic properties to project a 2D depth map image into a 3D point cloud. The resulting point cloud is stored in a floating point texture which can be used as an instancing source for rendering point clouds."
    },
    "parameterCOMP": {
        "label": "parameterCOMP",
        "members": [
            {
                "text": "OP : Path to the operator whose parameters will be used.",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Toggle : Include the header of the parameter dialog. This is the section with OP type, name, and help buttons.",
                "type": "TogglePar",
                "name": "header",
                "items": []
            },
            {
                "text": "Toggle : Include the tabs for the parameter pages in the display.",
                "type": "TogglePar",
                "name": "pagenames",
                "items": []
            },
            {
                "text": "Toggle : Display the separating lines between sections of parameters.",
                "type": "TogglePar",
                "name": "separators",
                "items": []
            },
            {
                "text": "Toggle : Include the multi-input editor UI.  This appears at the end of multi-input parameter dialogs such as the one used in the [[Math CHOP]] or [[Merge SOP]]. \n        \n[[Image:InputEditor.png]]",
                "type": "TogglePar",
                "name": "inputeditor",
                "items": []
            },
            {
                "text": "Toggle : Controls whether or not parameters can be expanded to reveal parameter modes and expression fields.",
                "type": "TogglePar",
                "name": "allowexpend",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's built-in parameters.",
                "type": "TogglePar",
                "name": "builtin",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's [[Custom Parameters]].",
                "type": "TogglePar",
                "name": "custom",
                "items": []
            },
            {
                "text": "Menu : Specify the how to combine the scope parameters below to make the parameter selection.",
                "type": "MenuPar",
                "name": "combinescopes",
                "items": []
            },
            {
                "text": "StrMenu : Selects with pages of parameters to include. Use * for [[Pattern Matching]] all.",
                "type": "StrMenuPar",
                "name": "pagescope",
                "items": []
            },
            {
                "text": "StrMenu : Selects which parameters to include. Use * for [[Pattern Matching]] all.",
                "type": "StrMenuPar",
                "name": "parscope",
                "items": []
            },
            {
                "text": "Toggle : Displays the parameters in the order they are defined in the Parameter Scope parameter above. Only available when Page Name parameter is Off.",
                "type": "TogglePar",
                "name": "scopeorder",
                "items": []
            },
            {
                "text": "Float : When you change the Compress value, the panel stays exactly the same width and height as specified by the Width and Height parameters, but it renders more or less of the parameter dialog in it. Hence when increasing Compress the text is smaller and you see more parameters at a time.",
                "type": "FloatPar",
                "name": "compress",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Parameter",
        "opFamily": "COMP",
        "long": "The Parameter Component allows any operator's parameter dialog to be a panel with full interactivity. You specify which operator whose parameters you want to appear in the panel.\t\t\n\t\t\t\nYou can optionally have it display the header and the page names, and include built-in or [[Custom Parameters]].\t\t\t\n\t\t\t\nYou can specify a scope of pages and individual parameters to display, for example two entire pages plus four parameters on other pages.  When specifying parameters only, the order of the parameters is the order you specify them in.\t\t\t\n\t\t\t\nYou can shrink the UI so it fits into a smaller panel, using the Compress parameter.\n\nYou can control whether users can open the parameter for editing (via the + on the left of the parameter) using the Allow Expansion toggle. You can prevent users from going in and editing expressions.\n\t\t\t\nYou can specify page or parameter names using pattern matching: <code>scale*</code>  <code>^tx</code>, etc, with page names that contain spaces specified in quotes. <code>'Cue 1' 'Cue 2'</code>, or specified as a python list.",
        "opClass": "parameterCOMP_Class",
        "short": "The Parameter Component allows any operator's parameter dialog to be a panel with full interactivity.",
        "opType": "parameter",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "replicatorCOMP": {
        "label": "replicatorCOMP",
        "members": [
            {
                "text": "Menu : Choose between using a Template DAT Table where each row will create a replicant or using the Number of Replicants parameter below to set how many replications to make.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Int : Set number of replicants when using Replication Method = By Number above.",
                "type": "IntPar",
                "name": "numreplicants",
                "items": []
            },
            {
                "text": "DAT : Path to the table DAT that will drive the replicating.",
                "type": "DATPar",
                "name": "template",
                "items": []
            },
            {
                "text": "Menu : How the node names will be generated.",
                "type": "MenuPar",
                "name": "namefromtable",
                "items": []
            },
            {
                "text": "Toggle : Do not create a node for the first row.",
                "type": "TogglePar",
                "name": "ignorefirstrow",
                "items": []
            },
            {
                "text": "Str : Name at the top of the column.",
                "type": "StrPar",
                "name": "colname",
                "items": []
            },
            {
                "text": "Int : Column number, starting from 0.",
                "type": "IntPar",
                "name": "colindex",
                "items": []
            },
            {
                "text": "Str : Add this prefix to all nodes.",
                "type": "StrPar",
                "name": "opprefix",
                "items": []
            },
            {
                "text": "OP : Which node or component to replicate.",
                "type": "OPPar",
                "name": "master",
                "items": []
            },
            {
                "text": "COMP : Where to put the replicant nodes. If the location is <code>..</code>, it puts the nodes inside the parent, which is actually alongside the Replicator component. If you put <code>.</code>, it will put it inside itself, that is, inside the Replicator component.  If left blank, it will error.",
                "type": "COMPPar",
                "name": "destination",
                "items": []
            },
            {
                "text": "Toggle : Enable the parameter below to set a maximum number of allowed replicants.",
                "type": "TogglePar",
                "name": "domaxops",
                "items": []
            },
            {
                "text": "Int : Max number of nodes replicated.",
                "type": "IntPar",
                "name": "maxops",
                "items": []
            },
            {
                "text": "Str : Tscript only (use callback DAT in python): For every replicant, you can run a script to customize it relative to the master, such as setting the Display or Clone parameters, or a Render flag. Replicator runs the script command to customize each replicant versus the master. <code>me.curItem</code> can be used here to access the current item and make changes to it.  Select one of the 3 entries in the drop menu to the right for some examples.\t\n\t\t\t\nIf you are using [[Tscript]], some local variables are defined:\n\t\t\t\n<!--TDitemStart-->* $ITEM Name of current node being replicated.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* $MASTER Name of master node.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* $LOCATION Name of the location component.<!--TDitemEnd-->\t\t\t\n\t\t\t\nThe most common need is for the master to not display, and the replicants to display. For Panel components it is most commonly \"<code>opparm $ITEM paneldisplay ( 1 )</code>\", and for Geometry components it is most commonly \"<code>opset -d on $ITEM</code>\".  Use the popup menu for some common scripts.",
                "type": "StrPar",
                "name": "tscript",
                "items": []
            },
            {
                "text": "Pulse : Select from some commonly used scripts (Tscript) in this menu.",
                "type": "PulsePar",
                "name": "scriptmenu",
                "items": []
            },
            {
                "text": "DAT : Path to a DAT containing callbacks for each event received.  See [[replicatorCOMP_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : How to lay out the new nodes - all in one place (Off), horizontally, vertically, or in a grid.",
                "type": "MenuPar",
                "name": "layout",
                "items": []
            },
            {
                "text": "Int : Where to lay out the new nodes, giving the XY location of the top-left node's bottom-left corner.",
                "type": "IntPar",
                "name": "layoutorigin",
                "items": []
            },
            {
                "text": "Toggle : Enables the parameter below for incremental creation of replicants.",
                "type": "TogglePar",
                "name": "doincremental",
                "items": []
            },
            {
                "text": "Int : Staggers the replication of operators to avoid large frame drops when creating replicants. It will create the specified number of replicants per frame at most, by default 1 per frame, if Incremental Update is on.",
                "type": "IntPar",
                "name": "increment",
                "items": []
            },
            {
                "text": "Pulse : Deletes all nodes it has created, then re-creates them using the template and its current parameters.",
                "type": "PulsePar",
                "name": "recreateall",
                "items": []
            },
            {
                "text": "Pulse : Re-creates missing operators from the template table but does not delete and re-create already existing replicants.",
                "type": "PulsePar",
                "name": "recreatemissing",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Replicator",
        "opFamily": "COMP",
        "long": "The Replicator COMP creates copies of a component, one for every row in a table or using a Number of Replicants parameter - it is the \"for-loop\" of operators. Unlike [[Clone]], it automatically creates copies of a master component.\n    \nIt creates replicant nodes (\"[http://en.wikipedia.org/wiki/Replicant replicants]\") and deletes them as the table changes or the replicant count changes. The replicant master can be a full component and its contents or a single node. \t\t\n\t\t\t\nIt takes the node specified in the <span class=\"tipTextCOMP\">Master Node</span> parameter, and makes a copy of the master for every row in the <span class=\"tipTextCOMP\">Template Table</span> (or specified by the Number of Replicant parameter).\t\n\t\t\t\nThe nodes that are created can be named in two ways. Copies can be named/numbered sequentially using\t\t\t\nthe prefix specified by the <span class=\"tipTextCOMP\">Node Prefix</span> parameter: <code>item1</code>, <code>item2</code>, ... Alternately, copies can be named based on the string in a column of the table, specified with the <span class=\"tipTextCOMP\">Name from Table</span> parameter.\t\t\t\n\t\t\t\n[[Image:Replicator.1.png|700px]]\t\t\t\n\t\t\t\nIf you want to create a node for the first row of the table, un-set the <span class=\"tipTextCOMP\">Ignore First Row</span> parameter.\t\t\t\n\t\t\t\nThe replicants get laid out in a grid in the network, determined by the <span class=\"tipTextCOMP\">Layout</span> and <span class=\"tipTextCOMP\">Layout Origin</span> parameters.\t\t\t\n\t\t\t\nThe Replicator does not assume or require that the master and replicants are components \u2013 they can all be Movie File In TOPs if you want. It also does not assume or require that the replicants are [[Clone]]s.  However the <span class=\"tipTextCOMP\">Master Node</span> can be a component whose [[Clone]] parameter is set to itself, so that all nodes created are clones of the master.\t\t\t\n\t\t\t\nFor every replicant, you can run a script in the callback DAT where you can see some examples of typical cases that you can adapt. Here are some others:\t\t\t\n* change the expression of a [[Par Class|parameter]]: <code>c.par.display.expr = \"op('thing')[op.digits, 'display']\"</code>\t\t\t\n* Change the parameter expression mode:  <code>c.par.display.mode = ParMode.EXPRESSION</code>    The mode is one of: <code>ParMode.CONSTANT</code>, <code>ParMode.EXPRESSION</code>, or <code>ParMode.EXPORT</code>. \t\t\t\n\t\t\t\nIf only one line of a table changes, the other existing replicants are not changed or re-created. In the callback DAT, removing <code>onRemoveReplicant()</code> will keep the replicants around to be re-used when the table grows again.\t\t\t\n\t\t\t\nThis is an extremely powerful node type. Examples: (1) A button gadget for each row of the table. a geometry component, which is replicated at every point of a 3D particle system, each behaving separately. (2) You can feed the table of a [[Multi Touch In DAT]] directly to the Replicator to create something at each fingertip.",
        "opClass": "replicatorCOMP_Class",
        "short": "The Replicator Component creates a node for every row of a table, creating nodes (\"[http://en.wikipedia.org/wiki/Replicant replicants]\") and deleting them as the table changes.",
        "opType": "replicator",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "selectCOMP": {
        "label": "selectCOMP",
        "members": [
            {
                "text": "PanelCOMP : The [[Panel]] Component which is being selected.",
                "type": "PanelCOMPPar",
                "name": "selectpanel",
                "items": []
            },
            {
                "text": "Toggle : Set the Select COMP's width and Height to the referenced Panel Component's dimenions.",
                "type": "TogglePar",
                "name": "matchsize",
                "items": []
            },
            {
                "text": "Toggle : In the case of referencing a Select COMP, Follow Selection will retrieve the dimensions from the upper most component that is not a Select COMP.",
                "type": "TogglePar",
                "name": "followselection",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Select",
        "opFamily": "COMP",
        "long": "The Select Component selects a [[Panel Component]] from any other location. This allows a panel to appear in multiple other panels.\t\t\n\t\t\t\nCan be used to select components recursively. If ''select1'' points to ''select2'', it will display whatever ''select2'' points to (recursively) using ''select2'''s parameters. \t\t\t\n\t\t\t\nThe Select component can re-size the component it refers to by setting its Width and Height parameters.",
        "opClass": "selectCOMP_Class",
        "short": "The Select Component selects a [[Panel Component]] from any other location.",
        "opType": "select",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "sharedmeminCOMP": {
        "label": "sharedmeminCOMP",
        "members": [
            {
                "text": "Str : The name of the memory block it reads from.",
                "type": "StrPar",
                "name": "name",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Shared Mem In",
        "opFamily": "COMP",
        "long": "The Shared Mem In COMP is only available in TouchDesigner Commercial and Pro.\t\n\t\t\nThe Shared Mem In COMP will read transform data from a shared memory block. This memory block can be created by another Touch process using the [[Shared Mem Out COMP]].",
        "opClass": "sharedmeminCOMP_Class",
        "short": "The Shared Mem In COMP will read transform data from a shared memory block.",
        "opType": "sharedmemin",
        "opLicense": "Commercial",
        "opCategories": ""
    },
    "sharedmemoutCOMP": {
        "label": "sharedmemoutCOMP",
        "members": [
            {
                "text": "Toggle : Controls if this node cooks every frame or not.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The name of the memory block it writes to.",
                "type": "StrPar",
                "name": "name",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "opLabel": "Shared Mem Out",
        "opFamily": "COMP",
        "long": "The Shared Mem In TOP is only available in TouchDesigner Commercial and Pro.\t\n\t\t\nThe Shared Mem Out COMP will write transform data to a shared memory block. This memory block can be read by another Touch process using the [[Shared Mem In COMP]].",
        "opClass": "sharedmemoutCOMP_Class",
        "short": "The Shared Mem Out COMP will write transform data to a shared memory block.",
        "opType": "sharedmemout",
        "opLicense": "Commercial",
        "opCategories": ""
    },
    "sliderCOMP": {
        "label": "sliderCOMP",
        "members": [
            {
                "text": "Menu : Sets the type of slider.",
                "type": "MenuPar",
                "name": "slidertype",
                "items": []
            },
            {
                "text": "Float : Sets the left bounding area that the slider will track movement in. 0 is the left edge of the panel, 1 is the right edge of the panel. Values outside the 0-1 range can be used.",
                "type": "FloatPar",
                "name": "zonel",
                "items": []
            },
            {
                "text": "Float : Sets the right bounding area that the slider will track movement in.",
                "type": "FloatPar",
                "name": "zoner",
                "items": []
            },
            {
                "text": "Float : Sets the bottom bounding area that the slider will track movement in.",
                "type": "FloatPar",
                "name": "zoneb",
                "items": []
            },
            {
                "text": "Float : Sets the top bounding area that the slider will track movement in.",
                "type": "FloatPar",
                "name": "zonet",
                "items": []
            },
            {
                "text": "Toggle : Clamps the minimum output of the panel value u to 0.",
                "type": "TogglePar",
                "name": "clampul",
                "items": []
            },
            {
                "text": "Toggle : Clamps the maximum output of the panel value u to 0.",
                "type": "TogglePar",
                "name": "clampuh",
                "items": []
            },
            {
                "text": "Toggle : Clamps the minimum output of the panel value v to 0.",
                "type": "TogglePar",
                "name": "clampvl",
                "items": []
            },
            {
                "text": "Toggle : Clamps the maximum output of the panel value v to 0.",
                "type": "TogglePar",
                "name": "clampvh",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Slider Component lets you build sliders in X, Y and XY, and outputs 1 or 2 channels from a [[Panel CHOP]] placed in the Slider component. \t\t\n\t\t\t\n[[image:SliderCOMP.png]]\t\t\t\n\t\t\t\nDefault Slider Component\t\t\t\n\t\t\t\nSee [[Panel Value]].",
        "1": "Default Slider Component",
        "opLicense": "Non-Commercial",
        "opFamily": "COMP",
        "opLabel": "Slider",
        "short": "The Slider Component lets you build sliders in X, Y and XY, and outputs 1 or 2 channels from a [[Panel CHOP]] placed in the Slider component.",
        "opType": "slider",
        "opFilter": "False",
        "opClass": "sliderCOMP_Class",
        "opCategories": ""
    },
    "tableCOMP": {
        "label": "tableCOMP",
        "members": [
            {
                "text": "DAT : A list of attribute DATs, one per cell.",
                "type": "DATPar",
                "name": "attributes",
                "items": []
            },
            {
                "text": "DAT : A list of attribute DATs, one per row.",
                "type": "DATPar",
                "name": "rowattributes",
                "items": []
            },
            {
                "text": "DAT : A list of attribute DATs, one per column.",
                "type": "DATPar",
                "name": "colattributes",
                "items": []
            },
            {
                "text": "DAT : A single reference to an attribute DAT.",
                "type": "DATPar",
                "name": "tableattributes",
                "items": []
            },
            {
                "text": "DAT : A list of values that contain the contents of each cell when the cell is a field type.",
                "type": "DATPar",
                "name": "values",
                "items": []
            },
            {
                "text": "Int : The number of rows in the table.",
                "type": "IntPar",
                "name": "tablerows",
                "items": []
            },
            {
                "text": "Int : The number of columns in the table.",
                "type": "IntPar",
                "name": "tablecols",
                "items": []
            },
            {
                "text": "Menu : Specifies the order in which cells are arranged:",
                "type": "MenuPar",
                "name": "tablealign",
                "items": []
            },
            {
                "text": "Menu : Lets you choose the unit of the specified font size.",
                "type": "MenuPar",
                "name": "fontsizeunit",
                "items": []
            },
            {
                "text": "Menu : Determines how the state information in a connected [[Info DAT]] is displayed.",
                "type": "MenuPar",
                "name": "infoformat",
                "items": []
            },
            {
                "text": "Int : Offset the Table. This is not offsetting the Table COMP itself but the Table as it is drawn. So when selecting to Crop the Children, the Table will be potentially cut off at the borders of the Table COMP.",
                "type": "IntPar",
                "name": "tableoffset",
                "items": []
            },
            {
                "text": "Pulse : Refreshes the Table COMP. This can be useful if certain definition DATs have changed.",
                "type": "PulsePar",
                "name": "tablereset",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Table",
        "opFamily": "COMP",
        "long": "The Table Component creates a grid of user interface gadgets. These panels are laid out in a grid format where the contents of each cell are defined by DAT tables.",
        "opClass": "tableCOMP_Class",
        "short": "The Table Component creates a grid of user interface gadgets.",
        "opType": "table",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "textCOMP": {
        "label": "textCOMP",
        "members": [
            {
                "text": "Menu : Controls whether the contents are taken from the Text parameter or from a Specification DAT/CHOP.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Str : This parameter is the data source for the text that is displayed in the panel. The value may be a number, string, or a reference to an external data source using a python or bind expression. When the text is edited by the user in the panel, those changes will be saved back to this value or to the original data source it is bound to. For example, you can bind the text in the panel to the contents of a DAT cell using a bind expression like 'op('table1')[0,0]'",
                "type": "StrPar",
                "name": "text",
                "items": []
            },
            {
                "text": "DAT : A path to a Table DAT that is the source of the text data when in Specification DAT mode. The table should have 3 columns labeled x, y and text in their first rows. Each row after that will display one line of text at the given x, y coordinates as measured from the bottom-left corner. x and y are measured in panel units.",
                "type": "DATPar",
                "name": "specdat",
                "items": []
            },
            {
                "text": "CHOP : ",
                "type": "CHOPPar",
                "name": "specchop",
                "items": []
            },
            {
                "text": "Menu : The Type parameter controls how the value is interpreted and as well as what formatting and editing options are available.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : This parameter controls how the source text is is formatted and displayed inside the panel. The options available will change depending on the selected mode. For example, in Float mode there are options for scientific notation or percentage, while in Integer mode there are options to treat the source value as a time code.",
                "type": "MenuPar",
                "name": "formatting",
                "items": []
            },
            {
                "text": "Str : This parameter provides the formatting string for custom modes like Python F-String and C++ Fmt. In both cases, the source text is defined inside curly braces ( {} ) while text outside the braces is treated as constants.",
                "type": "StrPar",
                "name": "customformatting",
                "items": []
            },
            {
                "text": "Int : Used in Float mode to set the number of decimal places.",
                "type": "IntPar",
                "name": "precision",
                "items": []
            },
            {
                "text": "Menu : Used in Float and Integer mode to add a separator between thousands to make it easier to read large numbers. For example 1,000,000",
                "type": "MenuPar",
                "name": "thousandsseparator",
                "items": []
            },
            {
                "text": "Int : Sets the number of frames per second when formatting integers into time codes.",
                "type": "IntPar",
                "name": "framerate",
                "items": []
            },
            {
                "text": "Toggle : Enables the use of smart punctuation. For example, pairs of quotes will be replaced with appropriate angled quotes, 3 periods will be replaced with an ellipses character and two hypens will become an em-dash.",
                "type": "TogglePar",
                "name": "smartquote",
                "items": []
            },
            {
                "text": "Toggle : Enables the use of formatting directives in the text. For example, the code {#color(255, 0, 0);} will turn all text afterwards on that line red. See [[Text_Formatting_Codes|Text Formatting Codes]] for all available codes.",
                "type": "TogglePar",
                "name": "formatcodes",
                "items": []
            },
            {
                "text": "Toggle : Enables the use of smart punctuation. For example, pairs of quotes will be replaced with appropriate angled quotes, 3 periods will be replaced with an ellipses character and two hypens will become an em-dash.",
                "type": "TogglePar",
                "name": "smartpunct",
                "items": []
            },
            {
                "text": "Toggle : Enables word wrap and can only be used when the 'Type' parameter above is set to 'Multi Line'. Word wrap will split single lines of text onto multiple lines when they extend past the edge of the panel. The panel width is based on the Width parameter minus the left and right padding. Lines are generally broken at spaces, tabs or hypens, but can be broken mid word if a single word is longer than the page.",
                "type": "TogglePar",
                "name": "wordwrap",
                "items": []
            },
            {
                "text": "Menu : Controls whether the text can be editing directly in the viewer.",
                "type": "MenuPar",
                "name": "editmode",
                "items": []
            },
            {
                "text": "Toggle : In multiline mode, when this option is enabled, pressing Enter will complete editing and save the value and users must hold Shift and Enter if they wish to create a new line.",
                "type": "TogglePar",
                "name": "shiftenter",
                "items": []
            },
            {
                "text": "Menu : Use this parameter to control whether the text is displayed from left-to-right (LTR) or from right-to-left (RTL). Bidirectional layout is also supported when LTR characters are detected when using RTL mode.",
                "type": "MenuPar",
                "name": "readingdirection",
                "items": []
            },
            {
                "text": "Menu : This parameter controls what happens when a user drags something onto an active panel.",
                "type": "MenuPar",
                "name": "dragdropmode",
                "items": []
            },
            {
                "text": "DAT : A path to a Table DAT containing a list of component paths that is used to control which panel receives the focus when a user hits TAB or Shift+Tab during editing.",
                "type": "DATPar",
                "name": "fieldfocus",
                "items": []
            },
            {
                "text": "DAT : The path of a Text DAT containing python callback functions that can be used to react to different events in the viewer.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Toggle : Enable to select the font using the legacy system of bold and italic toggles. In the new system, bold and italic options can be chosen using the typeface parameter when available.",
                "type": "TogglePar",
                "name": "legacyfontselection",
                "items": []
            },
            {
                "text": "Menu : Select the font to be used from the dropdown menu. Available fonts are those that have been registered with the operating system. There may be a delay when selecting fonts that have not been used before as the system creates the necessary intermediate files required for rendering.",
                "type": "MenuPar",
                "name": "font",
                "items": []
            },
            {
                "text": "File : Specify a font file to be used for rendering the text. This option can be used for fonts that are not registered with the operating system and do not appear in the drop down menu.",
                "type": "FilePar",
                "name": "fontfile",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "typeface",
                "items": []
            },
            {
                "text": "Toggle : Display the text in '''bold'''.",
                "type": "TogglePar",
                "name": "bold",
                "items": []
            },
            {
                "text": "Toggle : Display the text in ''italics''.",
                "type": "TogglePar",
                "name": "italic",
                "items": []
            },
            {
                "text": "Menu : Automatically adjust the font size to fit inside the panel.",
                "type": "MenuPar",
                "name": "scaletofit",
                "items": []
            },
            {
                "text": "Float : Set the size of the font. By default the font is defined in resolution-independent panel units that will be rendered to a variable number of pixels depending on DPI settings of the output window (e.g. monitor scaling).",
                "type": "FloatPar",
                "name": "fontsize",
                "items": []
            },
            {
                "text": "Menu : Determines how the font size is interpretted. The default is resolution-independent panel units.",
                "type": "MenuPar",
                "name": "fontsizeunits",
                "items": []
            },
            {
                "text": "Float : Sets the horizontal spacing between characters, where 0 is default spacing, > 0 is increased spacing and < 0 is decreased spacing.",
                "type": "FloatPar",
                "name": "tracking",
                "items": []
            },
            {
                "text": "Float : Tilts the top of the characters forwards or backwards relative to the baseline.",
                "type": "FloatPar",
                "name": "skew",
                "items": []
            },
            {
                "text": "Float : Horizontally stretch the characters relative to their current alignment.",
                "type": "FloatPar",
                "name": "horzstretch",
                "items": []
            },
            {
                "text": "Float : The spacing between lines when using multiline mode.The value is a multiplier of the default spacing defined by the font.",
                "type": "FloatPar",
                "name": "linespacing",
                "items": []
            },
            {
                "text": "RGB : The default color of the text. Additional colors can be applied to separate parts of the text using formatting codes.",
                "type": "RGBPar",
                "name": "fontcolorr",
                "items": []
            },
            {
                "text": "RGB : The default color of the text. Additional colors can be applied to separate parts of the text using formatting codes.",
                "type": "RGBPar",
                "name": "fontcolorg",
                "items": []
            },
            {
                "text": "RGB : The default color of the text. Additional colors can be applied to separate parts of the text using formatting codes.",
                "type": "RGBPar",
                "name": "fontcolorb",
                "items": []
            },
            {
                "text": "Float : The blending value used to display the text over the background. 1 is opaque while 0 is transparent.",
                "type": "FloatPar",
                "name": "fontalpha",
                "items": []
            },
            {
                "text": "Toggle : Enable this parameter to define a custom color used for the selection bar when editing the text. When disabled, the selection color will be automatically chosen to maximize contrast between the background and text colors.",
                "type": "TogglePar",
                "name": "customselectcolor",
                "items": []
            },
            {
                "text": "RGB : The color of the selection bar when Custom Select Color is enabled.",
                "type": "RGBPar",
                "name": "selectcolorr",
                "items": []
            },
            {
                "text": "RGB : The color of the selection bar when Custom Select Color is enabled.",
                "type": "RGBPar",
                "name": "selectcolorg",
                "items": []
            },
            {
                "text": "RGB : The color of the selection bar when Custom Select Color is enabled.",
                "type": "RGBPar",
                "name": "selectcolorb",
                "items": []
            },
            {
                "text": "XY : An offset applied to the text position after any other alignment operations. Positive values move the text up and to the right.",
                "type": "XYPar",
                "name": "textoffsetx",
                "items": []
            },
            {
                "text": "XY : An offset applied to the text position after any other alignment operations. Positive values move the text up and to the right.",
                "type": "XYPar",
                "name": "textoffsety",
                "items": []
            },
            {
                "text": "Menu : Determine the units used by the Text Offset parameter.",
                "type": "MenuPar",
                "name": "textoffsetunits",
                "items": []
            },
            {
                "text": "Menu : The units used by the text padding.",
                "type": "MenuPar",
                "name": "textpaddingunits",
                "items": []
            },
            {
                "text": "Float : Set the amount of space between the edges of the panel and the text. Whether the padding has an effect on the position of the text depends on the current alignment mode and whether word wrapping is used. For example, if the text is left aligned, the text will be positioned away from the left edge based on the left padding. But the text may extend any distance from the right edge depending on the length of the text. However, if word wrap is enabled in multiline mode, then the text will be wrapped at a distance from the right edge based on the padding.",
                "type": "FloatPar",
                "name": "textpadding",
                "items": []
            },
            {
                "text": "Menu : Determines how the text is positioned horizontally in the panel. For example, with left alignment, the text will be positioned against the left side of the panel plus any defined padding.",
                "type": "MenuPar",
                "name": "alignx",
                "items": []
            },
            {
                "text": "Menu : Determines how the text is measured for calculating the alignment. Only font metrics are available when using Multiline or Specification DAT mode.",
                "type": "MenuPar",
                "name": "alignxmode",
                "items": []
            },
            {
                "text": "Menu : Determines how the text is positioned vertically inside the panel.",
                "type": "MenuPar",
                "name": "aligny",
                "items": []
            },
            {
                "text": "Menu : Determines how the text is measured when doing the vertical alignment.",
                "type": "MenuPar",
                "name": "alignymode",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "textCOMP",
        "opLabel": "Text",
        "opClass": "textCOMP_Class",
        "opFilter": "False",
        "opLicense": "TouchDesigner Non-Commercial",
        "opCategories": "",
        "short": "The Text COMP is a [[panel]] used to display read-only text or editable text.",
        "long": "The Text COMP is a [[panel]] used to display text for building user interfaces. The text can be view-only, view-only but copy/pasteable, or be fully editable directly in the panel. \n    \nThere are '''formatting''' modes for displaying single-line strings and multi-line text, floating point and integer numbers, password fields and more. The source of the text comes from the Text parameter and it is then formatted for display in the panel. Formatting examples include displaying a number as a currency, percent or scientific notation, or converting an integer timecode value to hours/minutes/seconds/frames. Other formatting options include support for Python syntax, Custom C++ Fmt and Custom Python F-String syntax.\n\nWhen a user clicks in the panel to edit the text, the contents are displayed in a raw format and then formatted again once the editing is completed.\n\nThe Text COMP supports '''[[Text Formatting Codes|inline formatting directives]]''' in the text for things like color, strikeouts, underlines, small caps, subscripts, gradients, etc. For example, the code <code>{#color(255, 0, 0);}</code> will turn all text that follows on that line red.\n\nIt has '''text-fitting''' options for wraparound, shrinking text if it doesn't fit, left-center-right alignment and language reading direction. View-only text can be selectable or not selectable.\n\nYou can draw '''multiple transformed/formatted strings using a \"Specification DAT\" table''': It draws one string per row of the table, each with its own position and formatting in your panel. Columns can be <code>x</code>, <code>y</code>, <code>text</code>, <code>fontsize</code>, <code>fontcolorr</code>, <code>fontcolorg</code>, <code>fontcolorb</code>, <code>fontalpha</code>, <code>skew</code>, <code>tracking</code> and <code>horzstretch</code>.\n\nIt has '''python callbacks''' that can be executed for every character or string that has changed, and a callback for change of focus.\n\n'''Resolution-independent text''' is drawn directly to the screen at the resolution required for the panel size, resulting in perfectly crisp text at all zoom levels. It is GPU-based using the [[Slug Library]].\n\nUnits for X, Y, Width and Height are in \"'''panel units'''\" whereas they were actual pixel units before. Default Font Size, Text Offsets and Padding are in panel units.\n\nSee [[Text Formatting Codes]]\n\nSee also [[Geo Text COMP]] for the 3D rendered equivalent of the Text COMP.\n\nNote: The Text COMP is a replacement for the [[Field COMP]], completely replacing it and adding many new features not previously available."
    },
    "timeCOMP": {
        "label": "timeCOMP",
        "members": [
            {
                "text": "Int : Controls the playback of the Time Component. 0 = stop, 1 = play.",
                "type": "IntPar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : Sets the frame per second for the Time Component.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Int : Sets the start frame for the Time Component. The '''Start''' and '''End''' parameters determine the overall length of the Time Component.",
                "type": "IntPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Int : Sets the end frame for the Time Component. The '''Start''' and '''End''' parameters determine the overall length of the Time Component.",
                "type": "IntPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : This menu controls how the playback loops:",
                "type": "MenuPar",
                "name": "rangelimit",
                "items": []
            },
            {
                "text": "Int : Sets the start frame of the working range. The working range is a subset of the start/end range which can be used to focus work on a smaller section of time. The playhead will only playback the frames/beats that are inside this working range.",
                "type": "IntPar",
                "name": "rangestart",
                "items": []
            },
            {
                "text": "Int : Sets the end frame of the working range. The working range is a subset of the start/end range which can be used to focus work on a smaller section of time. The playhead will only playback the frames/beats that are inside this working range.",
                "type": "IntPar",
                "name": "rangeend",
                "items": []
            },
            {
                "text": "Int : Place holder to specify which frame to jump to (Obsolete).",
                "type": "IntPar",
                "name": "resetframe",
                "items": []
            },
            {
                "text": "Int : Specifies the time signature. The first number is the number of beats per measure and the second number indicates the type of note that constitutes one beat. See [http://en.wikipedia.org/wiki/Time_signature Time Signature - Wikipedia] for additional information.",
                "type": "IntPar",
                "name": "signature",
                "items": []
            },
            {
                "text": "Float : Sets the bpm for the Time Component.",
                "type": "FloatPar",
                "name": "tempo",
                "items": []
            },
            {
                "text": "Toggle : When checked on, this Time COMP's time will not be dependant on parent Time Components found in the network hierarchy. For example, starting/pausing other Time COMP's higher in the hierarchy will not start/pause a Time COMP whose '''Run Independently''' parameter is on.",
                "type": "TogglePar",
                "name": "independent",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Time",
        "opFamily": "COMP",
        "long": "The Time Component allows each component to have its own timeline (clock). The Time Component contains a network of operators that can drive a [[Timeline]], drive animations in [[Animation COMP]]s, or be used to drive any custom time-based system. The Time Component's parameters define the speed, range, various options for the time system.  \t\t\n\t\t\t\nThe Time Component is often used in TouchDesigner to allow a component to have its own timeline / clock, this is called [[Component Time]]. It is useful for holding some parts of your system stationary while others are allowed to play forward. A Time Component's location must be in the <code>/local</code> network of a [[Component]] for the Time Component to create a '''Component Time'''. \t\t\t\n\t\t\t\nTo add Component Time to a component, right-click on the component and select '''Add Component Time...''' from the popup menu, this will add the following Time Component <code>/''comppath''/local/time</code>.\t\t\t\n\t\t\t\nThe Time Component's predefined network is [[Clone|Cloned]] from Master Component <code>/sys/local/time</code>.  The Time Component's network can be modified if the path in the Clone parameter is removed.",
        "opClass": "timeCOMP_Class",
        "short": "The Time Component allows each component to have its own timeline (clock).",
        "opType": "time",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "usdCOMP": {
        "label": "usdCOMP",
        "members": [
            {
                "text": "filepath load : The path to the USD file. The file can be a binary (.usd or .usdc) or ASCII format (.usda).",
                "type": "filepath loadPar",
                "name": "file",
                "items": []
            },
            {
                "text": "button : A pulse to reload the assets from the file without making any changes to the existing network.",
                "type": "buttonPar",
                "name": "reload",
                "items": []
            },
            {
                "text": "toggle : A toggle to specify whether the material/shading be enabled for all the geometry primitives with material binding or not. By turning this toggle on, the MAT nodes and -according to the need- the ImportSelect TOPs for texture mapping assets are generated.",
                "type": "togglePar",
                "name": "usematerial",
                "items": []
            },
            {
                "text": "toggle : A toggle to specify whether the Camera nodes (subject to be defined in the USD file) created for the USD COMP or not.",
                "type": "togglePar",
                "name": "cameras",
                "items": []
            },
            {
                "text": "toggle : When enabled, will generate Actor COMPs in place of Geometry COMPs as the parents' of Import Select SOPs.",
                "type": "togglePar",
                "name": "genactors",
                "items": []
            },
            {
                "text": "toggle : A toggle to merge the mergeable geometries SOPs and their transformation COMPs up to a specified merge level. This feature can noticeably increase the performance of the USD COMP network.",
                "type": "togglePar",
                "name": "mergegeo",
                "items": []
            },
            {
                "text": "integer : Defines the desired merge level for merging the nodes. The start value is 1 which is the root of the network and it increases for the children of nodes the same as their positions within tree hierarchy. By default, this parameter is disabled and can be enabled once the toggle for Merge Geometry is set to ON.",
                "type": "integerPar",
                "name": "mergelevel",
                "items": []
            },
            {
                "text": "integer : This value is used to define how many wired children a Geometry/Null COMP node can have on the same network level (note that this network level refers to all the nodes that can be seen on the same canvas network). If a node has more children than this value, all its children will be relocated inside of it. This is used to prune out the wired children nodes of a parent node to make a lighter and cleaner network. The default value is 5.",
                "type": "integerPar",
                "name": "maxwiredchildren",
                "items": []
            },
            {
                "text": "toggle : A toggle for generating normal vectors from subdivision schema specified from USD file using OpenSubdiv library. Turning this toggle to OFF makes will make the SOPs use the TouchDesigner generated normal instead (only CPU mode).",
                "type": "togglePar",
                "name": "computenormals",
                "items": []
            },
            {
                "text": "toggle : A toggle to load the geometry directly to the GPU. This makes the rendering much faster than CPU mode. However, currently the only supported geometries are mesh and point primitives. If a USD scene contains other prim types such as NURBs Patches, an error will be generated for each [[Import Select SOP]] that is not supported.",
                "type": "togglePar",
                "name": "gpudirect",
                "items": []
            },
            {
                "text": "button : Every time (including the first time) you specify a new file, or change any parameter from the USD page, you need to re-build it, so it generates the network according to the current selected parameters.",
                "type": "buttonPar",
                "name": "buildnetwork",
                "items": []
            },
            {
                "text": "toggle : A toggle to keep the parameters of the current network over parameters of the re-imported (via Update parameter) network.",
                "type": "togglePar",
                "name": "keepparams",
                "items": []
            },
            {
                "text": "toggle : A toggle to keep the connection of the current network over the connections of the re-imported (via Update parameter) network.",
                "type": "togglePar",
                "name": "keepconnections",
                "items": []
            },
            {
                "text": "button : Updates the network. This option is specifically useful when the USD file is edited after the USD network is imported in TouchDesigner.",
                "type": "buttonPar",
                "name": "update",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute during import or update allowing for modification and customization of the imported operators and resulting network.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "toggle : A toggle to specify whether to shift the animation to the start of animation indicated in the USD file.",
                "type": "togglePar",
                "name": "shiftanimationstart",
                "items": []
            },
            {
                "text": "dropmenu : A menu to choose between the file FPS or custom sample rate.",
                "type": "dropmenuPar",
                "name": "sampleratemode",
                "items": []
            },
            {
                "text": "float : It is used to specify the sample rate (FPS) for the animation. This parameter is disabled by default and can be enabled once the Custom option is selected from the Sample Rate Menu.",
                "type": "floatPar",
                "name": "samplerate",
                "items": []
            },
            {
                "text": "dropmenu : A menu to specify the method used to play the animation.",
                "type": "dropmenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "button : Resets the animation to its initial state.",
                "type": "buttonPar",
                "name": "initialize",
                "items": []
            },
            {
                "text": "button : Resets the animation to its initial state and starts playback.",
                "type": "buttonPar",
                "name": "start",
                "items": []
            },
            {
                "text": "joinpair toggle : A toggle to jump to Cue Point when it\u2019s set to ON and it stays at that position. Only available when Play Mode is Sequential.",
                "type": "joinpair togglePar",
                "name": "cue",
                "items": []
            },
            {
                "text": "nolabel button : When pressed the animation jumps to the Cue Point and continues from that point.",
                "type": "nolabel buttonPar",
                "name": "cuepulse",
                "items": []
            },
            {
                "text": "joinpair float : Set any index in the animation as a point to jump to.",
                "type": "joinpair floatPar",
                "name": "cuepoint",
                "items": []
            },
            {
                "text": "nolabel shortvalues dropmenu : Specifies a unit type for Cue Point. Changing this will convert the previous unit to the selected unit.",
                "type": "nolabel shortvalues dropmenuPar",
                "name": "cuepointunit",
                "items": []
            },
            {
                "text": "toggle : A toggle that makes the animation to play when it sets to ON. This Parameter is only available/enabled if the Sequential mode is selected from the Play Mode.",
                "type": "togglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "joinpair float : This parameter explicitly sets the animation position when Play Mode is set to Specify Index. The units\u2019 menu on the right lets you specify the index in the following units: Index, Frames, Seconds, and Fraction (percentage).",
                "type": "joinpair floatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "nolabel shortvalues dropmenu : Specifies a unit type for Index. Changing this will convert the previous unit to the selected unit.",
                "type": "nolabel shortvalues dropmenuPar",
                "name": "indexunit",
                "items": []
            },
            {
                "text": "float : This is a speed multiplier which only works when Play Mode is Sequential. A value of 1 is the default playback speed. A value of 2 is double speed, 0.5 is half speed and so on.",
                "type": "floatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "toggle : A toggle to enable the Trim Start and Trim End parameters.",
                "type": "togglePar",
                "name": "trim",
                "items": []
            },
            {
                "text": "joinpair float : Sets an in point from the beginning of the animation, allowing you to trim the starting index of the animation. The units\u2019 menu on the right let you specify this position by index, frames, seconds, or fraction (percentage).",
                "type": "joinpair floatPar",
                "name": "tstart",
                "items": []
            },
            {
                "text": "nolabel shortvalues dropmenu : Specifies a unit type for Trim Start. Changing this will convert the previous unit to the selected unit.",
                "type": "nolabel shortvalues dropmenuPar",
                "name": "tstartunit",
                "items": []
            },
            {
                "text": "joinpair float : Sets an end point from the end of the movie, allowing you to trim the ending index of the animation. The units\u2019 menu on the right let you specify this position by index, frames, seconds, or fraction (percentage).",
                "type": "joinpair floatPar",
                "name": "tend",
                "items": []
            },
            {
                "text": "nolabel shortvalues dropmenu : Specifies a unit type for Trim End. Changing this will convert the previous unit to the selected unit.",
                "type": "nolabel shortvalues dropmenuPar",
                "name": "tendunit",
                "items": []
            },
            {
                "text": "dropmenu : Determines how USD COMP handles animation positions that lie before the Trim Start position. For example, if Trim Start is set to 1, and the animation current index is -10, the Extend Left menu determines how the animation position is calculated.",
                "type": "dropmenuPar",
                "name": "textendleft",
                "items": []
            },
            {
                "text": "dropmenu : Determines how USD COMP handles animation positions that lie after the Trim End position. For example, if Trim End is set to 20, and the animation current index is 25, the Extend Right menu determines how the animation position is calculated.",
                "type": "dropmenuPar",
                "name": "textendright",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "usdCOMP",
        "opLabel": "USD",
        "opClass": "usdCOMP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The USD COMP loads and imports most geometric schemas from a [[USD]] file in crate/binary or ASCII file formats with extensions as (<code>.usd</code>), (<code>.usda</code>), (<code>.usdc</code>), and (<code>.usdz</code>). Currently the USD version 20.08 is being used in USD COMP.",
        "long": "The USD COMP loads and imports most geometric schemas from a [[USD]] file in crate/binary or ASCII file formats with extensions as (<code>.usd</code>), (<code>.usda</code>), (<code>.usdc</code>), and (<code>.usdz</code>). Currently the USD version 0.18.9 is being used in USD COMP. You can drag-drop a USD file into a TouchDesigner network, or import it via the USD File parameter. See also [[File Types]].\n\nThe assets from the USD file are saved into a \"<code>.tdc</code>\" file with the same name as the USD file inside the TDImportCache folder, which is created next to your toe file. Assets are read from the \"<code>.tdc</code>\" file using Import Select OPs ([[Import Select TOP]] / [[Import Select SOP]] / [[Import Select CHOP]]). Upon reloading a <code>.toe</code> file, the assets can be imported directly from the \"<code>.tdc</code>\" cache, and the USD file will not need to be re-imported. However, if there is no existing \"<code>.tdc</code>\" (for instance, if the toe file changed computers) then the USD file will be reopened to grab the assets and a new \"<code>.tdc</code>\" will be saved out.\n\nTo open a USD file in an USD COMP:\n\n1) Specify a valid file path in the \"USD File\" parameter, including the name of the file with correct .usd extension.\n\n2) This step is varied depending on whether the USD COMP is just created and if any changes in the default values of parameters are required or not. If the file is being loaded for the first time in the network and the default parameter values are accepted then simply press the \"Build Network\" to generate the USD network and import the assets. Note that we recommend toggling the \"Merge Geometry\" for any medium or large files as it can significantly improve performance. Generally, any changes in the parameters above the \"Build Network\" requires the network to be built again.\n\n3) The \"Reload\" button is being used for reloading the internal assets (e.g. meshes, points, etc.) and this is specifically useful if the file has moved to another location and when the <code>.toe</code> file is opened the assets were not found and reloaded properly.\n\n4) The \"Update\" button is used when some changes on USD file are made and we want to merge those changes into the current network without fully rebuilding it.\n\nHere are some examples: https://developer.apple.com/augmented-reality/quick-look/\n\nSee also: [[USD]], [[USD In TouchDesigner]], [[Import Select CHOP]], [[Import Select TOP]], [[Import Select SOP]], [[FBX COMP]]",
        "opCategories": ""
    },
    "widgetCOMP": {
        "label": "widgetCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "COMP",
        "opType": "widgetCOMP",
        "opLabel": "Widget",
        "opClass": "widgetCOMP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "",
        "long": "",
        "opCategories": ""
    },
    "windowCOMP": {
        "label": "windowCOMP",
        "members": [
            {
                "text": "OP : Specifies the operator the window will display.",
                "type": "OPPar",
                "name": "winop",
                "items": []
            },
            {
                "text": "Str : Specify the window's title.",
                "type": "StrPar",
                "name": "title",
                "items": []
            },
            {
                "text": "Menu : All the positioning parameters below are done relative to the location you specify here. Your window can span more than the specified 'area', it's just used as the reference for positioning.",
                "type": "MenuPar",
                "name": "justifyoffsetto",
                "items": []
            },
            {
                "text": "Toggle : The Windows taskBar is ignored when this option is 'On'. When off the taskbar is accounted for so position and sizing will not cover it up.",
                "type": "TogglePar",
                "name": "ignoretaskbar",
                "items": []
            },
            {
                "text": "Int : Specify the monitor index when <span class=\"tipTextCOMP\">Area</span> is set to '''Single Monitor'''.",
                "type": "IntPar",
                "name": "monitor",
                "items": []
            },
            {
                "text": "Menu : Aligns the window horizontally with the monitor or bounds of all monitors.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Aligns the window vertically with the monitor or bounds of all monitors.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Int : Horizontal offset applied to window after justifying.",
                "type": "IntPar",
                "name": "winoffset",
                "items": []
            },
            {
                "text": "Menu : This menu has options for shifting the opening window. You can either shift to a single monitor or shift to the monitor the cursor is over when the window opens.",
                "type": "MenuPar",
                "name": "single",
                "items": []
            },
            {
                "text": "Menu : Options for managing DPI scaling on high DPI monitors. To inspect a monitor's DPI scaling setting, you can use the [[Monitors DAT]] and refer to the <code>dpi_scale</code> column.",
                "type": "MenuPar",
                "name": "dpiscaling",
                "items": []
            },
            {
                "text": "Menu : Determines how the size of the window is determined.",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Int : The width of the window when Opening Size parameter is set to Custom.",
                "type": "IntPar",
                "name": "winw",
                "items": []
            },
            {
                "text": "Int : The height of the window when Opening Size parameter is set to Custom.",
                "type": "IntPar",
                "name": "winh",
                "items": []
            },
            {
                "text": "Pulse : When the window is open you can reposition and resize it. Clicking this button will then read its current windows settings and apply them to the parameters above.",
                "type": "PulsePar",
                "name": "update",
                "items": []
            },
            {
                "text": "Toggle : Controls whether or not the window contains borders and a title bar.",
                "type": "TogglePar",
                "name": "borders",
                "items": []
            },
            {
                "text": "Toggle : When 'On' the borders are included in the size of the window.",
                "type": "TogglePar",
                "name": "bordersinsize",
                "items": []
            },
            {
                "text": "Toggle : Controls whether or not the window always sits atop other floating windows.",
                "type": "TogglePar",
                "name": "alwaysontop",
                "items": []
            },
            {
                "text": "Menu : Controls whether or not the cursor remains visible when over this window.",
                "type": "MenuPar",
                "name": "cursorvisible",
                "items": []
            },
            {
                "text": "Toggle : When 'On' pressing the escape key over this window will close it.\t'''TIP''': Shift-Escape will always close it, whether this parameter is on or off.",
                "type": "TogglePar",
                "name": "closeescape",
                "items": []
            },
            {
                "text": "Toggle : Enables interactions with the operator specified in the Window Operator parameter.",
                "type": "TogglePar",
                "name": "interact",
                "items": []
            },
            {
                "text": "Toggle : Enables the window to be minimized in the taskbar (dock in macOS).",
                "type": "TogglePar",
                "name": "allowminimize",
                "items": []
            },
            {
                "text": "Menu : Controls how the window is updated with regards to V-Sync. Enabled means it will update in sync with the monitors refresh which avoids tearing and lost frames. Disabled means it can update at any point during the refresh which can result in tearing or lost frames. FPS is Half Monitor Rate should be used when doing things such as running a 30fps file on a 60Hz display. This makes each update be shown for exactly 2 refreshes which keeps motion looking smooth.",
                "type": "MenuPar",
                "name": "vsyncmode",
                "items": []
            },
            {
                "text": "Toggle : When disabled the window will not update it's contents at all. Useful for processes that arn't doing rendering such as Audio or networking processes, or for when using VR devices.",
                "type": "TogglePar",
                "name": "drawwindow",
                "items": []
            },
            {
                "text": "Toggle : Provides multi-GPU frame-lock sync using [https://www.nvidia.com/en-us/design-visualization/solutions/quadro-sync/ Nvidia Quadro Sync] and [http://www.amd.com/us/products/workstation/graphics/s400/Pages/s400.aspx AMD S400] sync cards. '''Note: Not currently supported on the 2022.20000 and later series of builds, since this feature is not yet available for Vulkan'''. For more information, see [[Syncing Multiple Computers]] and [[Hardware Frame Lock]].",
                "type": "TogglePar",
                "name": "hwframelock",
                "items": []
            },
            {
                "text": "Toggle : Turn 'On' when using openGL stereoscopic output.",
                "type": "TogglePar",
                "name": "openglstereo",
                "items": []
            },
            {
                "text": "OP : This parameter is enabled when the OpenGL Stereo parameter above is turned on. Specify the [[Camera COMP]] used for the right eye here.",
                "type": "OPPar",
                "name": "winrightop",
                "items": []
            },
            {
                "text": "Pulse : Opens this Window COMP in [[Perform Mode]]. Any Window COMP can be set as default Perform Window (opens using F1 shortcut) using the [[Window Placement Dialog]]. This button allows you to open this Window COMP in Perform Mode without changing what is currently selected as the 'default' Perform Window.",
                "type": "PulsePar",
                "name": "performance",
                "items": []
            },
            {
                "text": "Pulse : Opens this Window COMP as its own floating window, not as the Perform Window. Useful for things such as dialog boxes, popups, or testing, but should not be used for putting final rendered content to outputs. Use a single large Perform Window for that instead of separate windows.",
                "type": "PulsePar",
                "name": "winopen",
                "items": []
            },
            {
                "text": "Pulse : Closes the window, if it's open.",
                "type": "PulsePar",
                "name": "winclose",
                "items": []
            },
            {
                "text": "Pulse : Permanently changes the Perform Window setting in the Window Placement dialog to this window.",
                "type": "PulsePar",
                "name": "setperform",
                "items": []
            },
            {
                "text": "Pulse : A shortcut to open the Window Placement dialog.",
                "type": "PulsePar",
                "name": "opendialog",
                "items": []
            },
            {
                "text": "Toggle : When 'On' this Window COMP will be displayed in the Window Placement Dialog.",
                "type": "TogglePar",
                "name": "includedialog",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Window",
        "opFamily": "COMP",
        "long": "The Window Component allows you to create and maintain a separate floating or fixed window displaying the contents of any [[Panel]] or any [[Node Viewer]]. \n\nMost frequently you are setting up the Window COMP <code>/perform</code> in the default TouchDesigner project. <code>/perform</code> is the default window for [[Perform Mode]]. In the Parameter dialog of the Window component you adjust its settings such as resolution, centering, and which monitor(s) the window will get displayed on.\n\nYou then press F1 to go into [[Perform Mode]] and operate/display the panel standalone.\n\t\t\t\nPress Esc over a window to close it and go back to [[Designer Mode]].\n\nYou can create more Window Components, point them to panels or other Operators like TOPs, adjust their parameters and then pulse the parameter Open as Separate Window to see its effect.\n\nUse the Dialog-> [[Window Placement Dialog]] which controls which window COMPs get displayed on startup. All Window COMPS in your project are listed there and you can test them individually.\n\nA window can be fit to a single monitor, or span several monitors.\n\t\t\t\nAttach an [[Info CHOP]] to the Window component - it will show you the window's current location and size, and whether the window is actually open.\n\nSee also [[Window]], [[Multiple Monitors]].",
        "opClass": "windowCOMP_Class",
        "short": "The Window Component allows you to create and maintain a separate floating window displaying the contents of any [[Panel]] or any other [[Node Viewer]].",
        "opType": "window",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "addTOP": {
        "label": "addTOP",
        "members": [
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]].",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLabel": "Add",
        "opType": "add",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opClass": "addTOP_Class",
        "opFilter": "True",
        "short": "The Add TOP composites the input images together by adding the pixel values.",
        "long": "The Add TOP composites the input images together by adding the pixel values. Output = Input1 + Input2. It clamps a color channel if the sum exceeds 1.",
        "opCategories": ""
    },
    "analyzeTOP": {
        "label": "analyzeTOP",
        "members": [
            {
                "text": "Menu : The operation to perform on the input image.",
                "type": "MenuPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Menu : Determines what value the operation is being performed on. For example, when the operation is Minimum and the Analyze Channel is Red, the output will be the pixel with the lowest red value (not necessarily the lowest Blue or Green values). To separately find the lowest value in each channel, set this parameter to RGBA Independent.",
                "type": "MenuPar",
                "name": "analyzechannel",
                "items": []
            },
            {
                "text": "Menu : Determines how pixels are grouped together to calculate the results.",
                "type": "MenuPar",
                "name": "scope",
                "items": []
            },
            {
                "text": "Toggle : Enable this parameter to skip pixels with a NaN value in the input image. NaNs typically represent errors in previous calculations (such as dividing by zero), but they can also be used to represent invalid pixels in a point cloud image. When most operations encounter a NaN pixel, the resulting output will always be a NaN, so you must enable this parameter to get valid results. If you do not expect NaN values in your input, it is recommended to leave this parameter turned off since it will reduce performance.",
                "type": "TogglePar",
                "name": "excludenans",
                "items": []
            },
            {
                "text": "Menu : This parameter allows you to exclude certain pixels based on the values in one or more channels in the input. For example, if set to Alpha, only pixels that have a non-zero value in the alpha will be included. This can be useful, for example, if you need to find the average position of a point cloud image that is using an Active channel to indicate which pixels store valid point data.",
                "type": "MenuPar",
                "name": "mask",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "analyzeTOP",
        "opLabel": "Analyze",
        "opClass": "analyzeTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The Analyze TOP takes any image and determines various characteristics of it, such as the average pixel color, or the pixel with the maximum luminance.",
        "long": "The Analyze TOP takes any image and determines various characteristics of it, such as the average pixel color, the pixel with the maximum luminance, or the min and max values in each channel. The result is stored in a 1x1, 1xN or Nx1 image depending on the chosen scope (See Scope parameter below). The calculated values can be brought into CHOPs using the [[TOP to CHOP]] node.\n    \n'''Note:''' When using the minimum and maximum operators, the default behaviour is to select the pixel with the highest value as chosen in the Analyze Channel parameter. For example, if Luminance is selected, the output will be the RGBA values of the pixel with the highest luminance, not the luminance value itself. Similarly, if a single channel is selected e.g. Red, Green, Blue, etc, then the output will be the pixel with the highest red value, rather than the highest values in each channel. To find the min or max values in each channel separately, set the Analyze Channel to RGBA Independent.\n\n'''Note:''' When the operation is set to Count Pixels or Sum, the output image will default to a 32 bit floating point format in order to properly store the output data. For all other operations, the default output format will match the input format. The image format can be set manually using the parameter on the Common page.\n\n'''Note:''' Using the Exclude NaNs or Mask features will slow down the performance of the node and should only be enabled if they are necessary.",
        "opCategories": ""
    },
    "antialiasTOP": {
        "label": "antialiasTOP",
        "members": [
            {
                "text": "Menu : Controls the quality of the anti-alias process. A higher quality will require more GPU power to compute.",
                "type": "MenuPar",
                "name": "quality",
                "items": []
            },
            {
                "text": "Menu : This controls how edges are detected in the image. Anti-aliasing is only done along detected edges.",
                "type": "MenuPar",
                "name": "edgedetectsource",
                "items": []
            },
            {
                "text": "Float : Controls the sensitivity of edge detection. Use the \"Output Edges\" mode to see it in action.",
                "type": "FloatPar",
                "name": "edgethreshold",
                "items": []
            },
            {
                "text": "Int : How many horizontal and vertical search steps are done when looking for edges.",
                "type": "IntPar",
                "name": "maxsearchsteps",
                "items": []
            },
            {
                "text": "Int : How many diagonal search steps are done when looking for edges.",
                "type": "IntPar",
                "name": "maxdiagsearchsteps",
                "items": []
            },
            {
                "text": "Int : Control strength of rounding edge corners.",
                "type": "IntPar",
                "name": "cornerrounding",
                "items": []
            },
            {
                "text": "Toggle : For visualizing what parts of the image will be anti-aliased. This shows the edges that are being detected, so you can tell where the anti-aliasing is being applied.",
                "type": "TogglePar",
                "name": "outputedges",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "antialiasTOP_Class",
        "short": "The Anti-Alias TOP uses a screen space antialiasing technique called \u2018SMAA: Enhanced Subpixel Morphological Antialiasing\u2019.",
        "opFilter": "True",
        "opLabel": "Anti Alias",
        "opFamily": "TOP",
        "long": "The Anti-Alias TOP uses a screen space antialiasing technique called \u2018SMAA: Enhanced Subpixel Morphological Antialiasing\u2019. Detailed information here: http://www.iryoku.com/smaa/  It uses an image\u2019s luminance, color or a depth map to detect edges of objects and then applies anti-aliasing to those edges. The current implementation does not yet use the temporal features of it, so each image is individually anti-aliased without requiring knowledge of other frames. It doesn\u2019t require the extra memory that regular Render TOP anti-aliasing does, and avoids work involved with antialiasing polygon edges that are ultimately occluded by another object.",
        "opType": "antialias",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "blobtrackTOP": {
        "label": "blobtrackTOP",
        "members": [
            {
                "text": "Toggle : Resets all tracking data and learned background data while this parameter is On.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly resets all tracking data and learned background data.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "Menu : Blob tracking is done using a single channel. This menu controls what single channel is used to detect blobs.",
                "type": "MenuPar",
                "name": "monosource",
                "items": []
            },
            {
                "text": "Toggle : Draws rectangles on the TOP image that shows where the tracked blobs are.",
                "type": "TogglePar",
                "name": "drawblobs",
                "items": []
            },
            {
                "text": "RGB : Determines the color of the rectangles that are drawn to show the blobs.",
                "type": "RGBPar",
                "name": "blobcolorr",
                "items": []
            },
            {
                "text": "RGB : Determines the color of the rectangles that are drawn to show the blobs.",
                "type": "RGBPar",
                "name": "blobcolorg",
                "items": []
            },
            {
                "text": "RGB : Determines the color of the rectangles that are drawn to show the blobs.",
                "type": "RGBPar",
                "name": "blobcolorb",
                "items": []
            },
            {
                "text": "Float : Threshold used to create the binary texture when using background subtraction. It is the threshold of the difference between the background texture and the input texture.",
                "type": "FloatPar",
                "name": "threshold",
                "items": []
            },
            {
                "text": "Float : Blobs must be at least this big to be tracked.",
                "type": "FloatPar",
                "name": "minblobsize",
                "items": []
            },
            {
                "text": "Float : Blobs larger than this will not be tracked.",
                "type": "FloatPar",
                "name": "maxblobsize",
                "items": []
            },
            {
                "text": "Float : The maximum distance a blob can move in one frame and still be considered to the same blob (maintain the same ID).",
                "type": "FloatPar",
                "name": "maxmovedistance",
                "items": []
            },
            {
                "text": "Toggle : Sometimes (depending on the tracking method) duplicate blobs may be created. This feature allows you to delete blobs that are too close to each other.",
                "type": "TogglePar",
                "name": "deletenearby",
                "items": []
            },
            {
                "text": "Float : When deleting nearby blobs, blobs will be deleted if they are within this number of pixels of each other. The smaller blob will be deleted.",
                "type": "FloatPar",
                "name": "deletedist",
                "items": []
            },
            {
                "text": "Float : Along with the distance, the area of the two blobs can be compared. If this parameter is 1, than the area is ignored. As this parameter gets smaller only blobs that have a significant size difference (between the two blobs being compared) will be deleted.",
                "type": "FloatPar",
                "name": "deletenearbytol",
                "items": []
            },
            {
                "text": "Toggle : Deletes blobs that are overlapping.",
                "type": "TogglePar",
                "name": "deleteoverlap",
                "items": []
            },
            {
                "text": "Float : If this parameter is 1 then only blobs that are completely overlapped will be deleted. As this value gets smaller less and less overlap is needed for a blob to get deleted.",
                "type": "FloatPar",
                "name": "deleteoverlaptol",
                "items": []
            },
            {
                "text": "Toggle : When enabled, will revive lost blobs (ie. same ID) if they satisfy all the below parameters",
                "type": "TogglePar",
                "name": "reviveblobs",
                "items": []
            },
            {
                "text": "Float : The time (in seconds) threshold for reviving a lost blob. If a blob has been lost for longer than revive time, it will not be revived and is considered expired.",
                "type": "FloatPar",
                "name": "revivetime",
                "items": []
            },
            {
                "text": "Float : The area difference threshold for the new blob and the lost blob.",
                "type": "FloatPar",
                "name": "revivearea",
                "items": []
            },
            {
                "text": "Float : The distance threshold between the new blob and the lost blob.",
                "type": "FloatPar",
                "name": "revivedistance",
                "items": []
            },
            {
                "text": "Toggle : When enabled, lost blobs will be included in the Blob Track TOP's Info DAT table.",
                "type": "TogglePar",
                "name": "includelost",
                "items": []
            },
            {
                "text": "Toggle : When enabled, expired blobs (ie. blobs that have no chance of revival) will be included in the Blob Track TOP's Info DAT table.",
                "type": "TogglePar",
                "name": "includeexpired",
                "items": []
            },
            {
                "text": "Float : Time in seconds for blobs to remain in the Info DAT table after expiring.",
                "type": "FloatPar",
                "name": "expiredtime",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "blobtrackTOP_Class",
        "short": "The Blob Track TOP is implemented using [https://opencv.org/ OpenCV].",
        "opFilter": "True",
        "opLabel": "Blob Track",
        "opFamily": "TOP",
        "long": "The Blob Track TOP is implemented using [https://opencv.org// OpenCV].\n    \nTo get the results of the Blob Track TOP, attach an [[Info DAT]] or [[Info CHOP]] to it. The Info reports the current blob IDs, coordinates and sizes in pixels. The blob ID increases for every new blob that is detected.\t\t\t\n\t\t\t\nIt converts the incoming image to monochrome (since it operates on an single color channel), but to better prepare the image, preceed it with a Monochrome TOP followed by a Luma Level TOP, and adjust Black Level, Brightness and Gamma.\n\nTypical usage is connecting a video source (such as  [[Video Device In TOP]] to the Blob Track TOP).\n\t\t\t\n'''NOTE:''' can track an unlimited number of blobs in Pro and Commercial, and up to 2 blobs in the Non-Commercial version of TouchDesigner.\t\t\n\nSee also [[Blob Track CHOP]]",
        "opType": "blobtrack",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "blurTOP": {
        "label": "blurTOP",
        "members": [
            {
                "text": "Menu : Determines how the blur is applied.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Menu : Determines the mathematical function used to create the blur.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : Sets the extend conditions to determine what happens to the blur at the edge of the image.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Int : Reduces the image's resolution before applying the blur.",
                "type": "IntPar",
                "name": "preshrink",
                "items": []
            },
            {
                "text": "Int : The amount of blur in pixels. If you want a resolution-independent blur, use an expression like <code>me.par.resolutionw/100</code> in this parameter (which would result in a 1% image blur).",
                "type": "IntPar",
                "name": "size",
                "items": []
            },
            {
                "text": "XY : When sampling the image, this determines the distance from each pixel to the sample pixel. When units are set to pixels, it is the number of pixels away from the current pixel which is sampled to blur the image. A Sample Step of 3 would sample pixels 3 pixels away.",
                "type": "XYPar",
                "name": "offsetx",
                "items": []
            },
            {
                "text": "XY : When sampling the image, this determines the distance from each pixel to the sample pixel. When units are set to pixels, it is the number of pixels away from the current pixel which is sampled to blur the image. A Sample Step of 3 would sample pixels 3 pixels away.",
                "type": "XYPar",
                "name": "offsety",
                "items": []
            },
            {
                "text": "Menu : Select between Pixel, Fraction, or Fraction Aspect as the units to use for the Sample Step parameter.",
                "type": "MenuPar",
                "name": "offsetunit",
                "items": []
            },
            {
                "text": "Float : Rotates the blur filter. More noticeable when <span class=\"tipTextTOP\">Method</span> is set to Horizontal.",
                "type": "FloatPar",
                "name": "rotate",
                "items": []
            },
            {
                "text": "Toggle : Enabling makes 8-bit blurs look smoother.  This can help if the blur operation introduces banding or other unexpected artifacts.",
                "type": "TogglePar",
                "name": "dither",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "blurTOP_Class",
        "short": "The Blur TOP blurs the image with various kernel filters and radii.",
        "opFilter": "True",
        "opLabel": "Blur",
        "opFamily": "TOP",
        "long": "The Blur TOP blurs the image with various kernel filters and radii. It can do multi-pass blurs and can do horizontal-only or vertical-only blurs. \t\t\n\t\t\t\nUse Pre-shrink when the blurs are high and you want to optimize performance.\t\t\t\n\t\t\t\n'''Tip:''' Filter Size is expressed in pixels. If you want resolution-independent blurs, use an expression like <code>me.par.resolutionw/100</code> in the Filter Size parameter, which gives a 1% image blur.",
        "opType": "blur",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "cacheselectTOP": {
        "label": "cacheselectTOP",
        "members": [
            {
                "text": "TOP : Specify which Cache TOP to grab the image from.",
                "type": "TOPPar",
                "name": "cachetop",
                "items": []
            },
            {
                "text": "Int : Specify the image to grab from the sequence of cached images. The index starts at 0, which is the current image. Images are then accessed backwards in time, such that the image before the current image has an index of -1, the image before that has an index of -2, and so on.",
                "type": "IntPar",
                "name": "index",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "cacheselectTOP_Class",
        "short": "The Cache Select TOP grabs an image from a [[Cache TOP]] based on the index parameter.",
        "opFilter": "False",
        "opLabel": "Cache Select",
        "opFamily": "TOP",
        "long": "The Cache Select TOP grabs an image from a [[Cache TOP]] based on the index parameter. This gives direct, random access to any image stored in a Cache TOP.The Cache Select TOP grabs an image from a [[Cache TOP]] based on the index parameter. This gives direct, random access to any image stored in a Cache TOP.",
        "opType": "cacheselect",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "cacheTOP": {
        "label": "cacheTOP",
        "members": [
            {
                "text": "Toggle : While this is On, the Cache TOP will capture images into its memory.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Pulse : Captures an image for the single frame this was pulsed.",
                "type": "PulsePar",
                "name": "activepulse",
                "items": []
            },
            {
                "text": "Toggle : Checking this On will cook the TOP once after startup to load an initial image.",
                "type": "TogglePar",
                "name": "cacheonce",
                "items": []
            },
            {
                "text": "Toggle : While this is On, the Cache TOP will replace the image at 'Replace Index' with the input image. This allows you to replace specific images in the cache at will.",
                "type": "TogglePar",
                "name": "replace",
                "items": []
            },
            {
                "text": "Pulse : Replace an image for the single frame this was pulsed.",
                "type": "PulsePar",
                "name": "replacespulse",
                "items": []
            },
            {
                "text": "Int : Select the image index that will be replaced by the input, when 'Replace Single' is turned on.",
                "type": "IntPar",
                "name": "replaceindex",
                "items": []
            },
            {
                "text": "Toggle : Cooks 'Cache Size' number of times to fill the Cache TOP with images. When set to 1, it will fill the cache. If set to 1 during playback, it will fill immediately. If set to 1 and saved out, then next time the file is opened the cache will pre-fill. While this is > 0, the node behaves as if the Active parameter is Off. If set to 0, then back > 0, it will clear the previous data, and pre-fill again. For more information refer to the [[Pre-Filling]] article.",
                "type": "TogglePar",
                "name": "prefill",
                "items": []
            },
            {
                "text": "Pulse : Pre-fills a single image during the frame this was pulsed.",
                "type": "PulsePar",
                "name": "prefillpulse",
                "items": []
            },
            {
                "text": "Int : Determines the number of images that can be stored in this Cache TOP.",
                "type": "IntPar",
                "name": "cachesize",
                "items": []
            },
            {
                "text": "Int : The number of cooks that go by before the Cache TOP grabs an image. A Step Size of 2 will cache an image every 2nd cook, a Step Size of 3 will cache every 3rd cook, and so on.",
                "type": "IntPar",
                "name": "step",
                "items": []
            },
            {
                "text": "Float : Determines which image in cache the TOP outputs. 0 is the most recent image, negative integers output image further back in time.",
                "type": "FloatPar",
                "name": "outputindex",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Output Index parameter.",
                "type": "MenuPar",
                "name": "outputindexunit",
                "items": []
            },
            {
                "text": "Toggle : When On (On = 1), the Cache TOP will interpolate between frames when non-integer values are used in the Output Index parameter. For example, a value of -0.5 in Output Index will output a blended image of the most recent frame (0.0) and the second most recent frame (-1.0).",
                "type": "TogglePar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Toggle : Forces the operator to cook every frame.",
                "type": "TogglePar",
                "name": "alwayscook",
                "items": []
            },
            {
                "text": "Toggle : While On this will empty the cache of stored images and release the memory held by the TOP.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly empty the cache.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Cache TOP stores a sequence of images into GPU memory. These cached images can be read by the graphics card much faster than an image cache in main memory or reading images off disk. \t\n\t\t\nThe Cache TOP can be used to freeze images in the TOP by turning the Active parameter Off. (You can set the cache size too <code>1</code>.)\t\t\n\t\t\nThe Cache TOP acts as a delay if you set Output Index to negative numbers and leave the Active parameter On.\t\t\n\t\t\nOnce a sequence of images has been captured by turning the Active parameter On or toggling the Active Pulse parameter, they can be looped by animating the Output Index parameter.",
        "opLabel": "Cache",
        "opClass": "cacheTOP_Class",
        "opType": "cache",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "short": "The Cache TOP stores a sequence of images into GPU memory.",
        "opCategories": ""
    },
    "channelmixTOP": {
        "label": "channelmixTOP",
        "members": [
            {
                "text": "Float : Red output mix. Use these 4 values to mix the RGBA inputs into the output's red channel.",
                "type": "FloatPar",
                "name": "red",
                "items": []
            },
            {
                "text": "Float : Green output mix. Use these 4 values to mix the RGBA inputs into the output's green channel.",
                "type": "FloatPar",
                "name": "green",
                "items": []
            },
            {
                "text": "Float : Blue output mix. Use these 4 values to mix the RGBA inputs into the output's blue channel.",
                "type": "FloatPar",
                "name": "blue",
                "items": []
            },
            {
                "text": "Float : Alpha output mix. Use these 4 values to mix the RGBA inputs into the output's alpha channel.",
                "type": "FloatPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Float : Use these 4 values to add or subtract a constant amount to the output channels.",
                "type": "FloatPar",
                "name": "constant",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "channelmixTOP_Class",
        "short": "The Channel Mix TOP allows mixing of the input RGBA channels to any other color channel of the output.",
        "opFilter": "True",
        "opLabel": "Channel Mix",
        "opFamily": "TOP",
        "long": "The Channel Mix TOP allows mixing of the input RGBA channels to any other color channel of the output. For example, the pixels in the blue channel of the input can be added to the output's red channel, added or subtracted by the amount in Red parameter's blue column.\t\t\n\t\t\t\nSee also [[Reorder TOP]].",
        "opType": "chanmix",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "choptoTOP": {
        "label": "choptoTOP",
        "members": [
            {
                "text": "CHOP : The path of the CHOP being referenced.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Menu : Determines how the input CHOP channels will be turned into an image. If the CHOP is missing channels required to provide all the data for a scanline, the extra channels are ignored.",
                "type": "MenuPar",
                "name": "dataformat",
                "items": []
            },
            {
                "text": "Toggle : Clamps CHOP values to 0-1 range.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Menu : Controls the dimensions of the output image and how the CHOP samples are arranged as pixels. This menu replaces the previous 'Crop Long Channels' and 'Fit to Square' parameters.",
                "type": "MenuPar",
                "name": "layout",
                "items": []
            },
            {
                "text": "Float : If the current Image Layout results in more pixels than there are available samples in the input CHOP, the values specified here will be used to fill in the extra pixels. (All textures require full rows of pixels, in other words all rows of pixels have the same number of pixels.)",
                "type": "FloatPar",
                "name": "rgba",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "choptoTOP_Class",
        "short": "The CHOP to TOP puts CHOP channels into a TOP image.",
        "opFilter": "False",
        "opLabel": "CHOP to",
        "opFamily": "TOP",
        "long": "The CHOP to TOP puts CHOP channels into a TOP image. By default the texture created will be 32-bit floating point to match the precision of the CHOP data. This can be changed setting the TOP's Pixel Format to something other than 'Input'.\n    \nThe Data Format parameter determines how the input channels are converted into pixel colors in the output image. For example, when the Data Format is set to 'R', each channel will be interpreted as a row of red pixel data. Likewise, if the Data Format is RGBA, then the first 4 channels will become a set of red, blue, green and alpha data for one row of pixels and each subsequent set of 4 channels will become additional rows. ''Note:'' Channels are grouped by their order in the CHOP rather than their names i.e. just because a channel is named g0 or b1 does not mean it will necessarily be be placed in a blue or green pixel.\n\nThe Image Layout parameter controls how the pixel rows are arranged in the output image. By default, the width of the image will be equal to the number of samples in the CHOP, clamped to a maximum texture width (often 32768) (the sample rate is ignored), and the height will be equal to the number of channel sets. For example, when the Data Format is RGB and the there are 9 input channels (for example, r0 g0 b0 r1 g1 b1 r2 g2 b2), there will be 3 rows of pixels using the default image layout.\n\nIf the channel length is longer than the image width, the wrapped layout option can be used to continue the channel data onto additional rows of pixels. Each new set of channels will still begin on a new row of pixels. \n\nIf the Image Layout parameter is set to Fit to Square, the TOP determines the image resolution based on the total number of samples across all channel sets (approximately the square root of the number of samples + 1) in width and height. This layout is most often used for point cloud data, where an efficient layout is preferred and the position of a pixel is not generally important. Unlike in the wrapped layout, channel sets in this mode are appended immediately to the end of the previous set, so that any empty pixels will appear at the end of the image.  Where there are some unused pixels, you can fill the unused pixels at the top with a special value based on the Extra Pixel Values parameter, (0, 0, 0, 0) by default. To put (0, 0, 0, -1) you have to set the pixel format to 32-bit float so you can represent negative and positive numbers of any value.",
        "opType": "chopto",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "chromakeyTOP": {
        "label": "chromakeyTOP",
        "members": [
            {
                "text": "Float : The minimum hue value that is added to the chroma key. 0 = min, 360 = max.",
                "type": "FloatPar",
                "name": "huemin",
                "items": []
            },
            {
                "text": "Float : The maximum hue value that is added to the key. 0 = min, 360 = max.",
                "type": "FloatPar",
                "name": "huemax",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Hue Min setting.",
                "type": "FloatPar",
                "name": "hsoftlow",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Hue Max setting.",
                "type": "FloatPar",
                "name": "hsofthigh",
                "items": []
            },
            {
                "text": "Float : The minimum saturation value that is added to the key.",
                "type": "FloatPar",
                "name": "satmin",
                "items": []
            },
            {
                "text": "Float : The maximum saturation value that is added to the key.",
                "type": "FloatPar",
                "name": "satmax",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Sat Min setting.",
                "type": "FloatPar",
                "name": "ssoftlow",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Sat Max setting.",
                "type": "FloatPar",
                "name": "ssofthigh",
                "items": []
            },
            {
                "text": "Float : The minimum value that is added to the key.",
                "type": "FloatPar",
                "name": "valmin",
                "items": []
            },
            {
                "text": "Float : The maximum value that is added to the key.",
                "type": "FloatPar",
                "name": "valmax",
                "items": []
            },
            {
                "text": "Float : The rate off falloff at the Val Min setting.",
                "type": "FloatPar",
                "name": "vsoftlow",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Val Max setting.",
                "type": "FloatPar",
                "name": "vsofthigh",
                "items": []
            },
            {
                "text": "Float : Inverts the key that is created.",
                "type": "FloatPar",
                "name": "invert",
                "items": []
            },
            {
                "text": "Menu : Determines the output of the RGB channels from the Chroma Key TOP.",
                "type": "MenuPar",
                "name": "rgbout",
                "items": []
            },
            {
                "text": "Menu : Determines the output of the Alpha channel from the Chroma Key TOP.",
                "type": "MenuPar",
                "name": "alphaout",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "chromakeyTOP_Class",
        "short": "The Chroma Key TOP pulls a key matte from the image using Hue, Saturation, and Value settings.",
        "opFilter": "True",
        "opLabel": "Chroma Key",
        "opFamily": "TOP",
        "long": "The Chroma Key TOP pulls a key matte from the image using Hue, Saturation, and Value settings. If a pixel falls between the Min and Max parameters for all three settings, then it is included in the key. It outputs an alpha map, or the image with the key color removed.\t\t\n\t\t\t\nSee also the <code>chromaKey</code> component in the [[Palette]], which is a user interface around the Chroma Key TOP that lets you grab frames on-the-fly and interactively set the key color ranges. The UI also adds edge softening and color spill controls.",
        "opType": "chroma",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "circleTOP": {
        "label": "circleTOP",
        "members": [
            {
                "text": "XY : X and Y radii of the Circle. For polygons, only the X radius is used.",
                "type": "XYPar",
                "name": "radiusx",
                "items": []
            },
            {
                "text": "XY : X and Y radii of the Circle. For polygons, only the X radius is used.",
                "type": "XYPar",
                "name": "radiusy",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "radiusunit",
                "items": []
            },
            {
                "text": "Float : Rotates the shape by the specified number of degrees.",
                "type": "FloatPar",
                "name": "rotate",
                "items": []
            },
            {
                "text": "XY : Coordinates of the center of the shape. (0,0) corresponds to a perfectly centered shape.",
                "type": "XYPar",
                "name": "centerx",
                "items": []
            },
            {
                "text": "XY : Coordinates of the center of the shape. (0,0) corresponds to a perfectly centered shape.",
                "type": "XYPar",
                "name": "centery",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "centerunit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the circle.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the circle.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "RGB : Color to use for the fill of the shape.",
                "type": "RGBPar",
                "name": "fillcolorr",
                "items": []
            },
            {
                "text": "RGB : Color to use for the fill of the shape.",
                "type": "RGBPar",
                "name": "fillcolorg",
                "items": []
            },
            {
                "text": "RGB : Color to use for the fill of the shape.",
                "type": "RGBPar",
                "name": "fillcolorb",
                "items": []
            },
            {
                "text": "Float : Alpha of the fill color.",
                "type": "FloatPar",
                "name": "fillalpha",
                "items": []
            },
            {
                "text": "RGB : Color to use for the border of the shape.",
                "type": "RGBPar",
                "name": "borderr",
                "items": []
            },
            {
                "text": "RGB : Color to use for the border of the shape.",
                "type": "RGBPar",
                "name": "borderg",
                "items": []
            },
            {
                "text": "RGB : Color to use for the border of the shape.",
                "type": "RGBPar",
                "name": "borderb",
                "items": []
            },
            {
                "text": "Float : Alpha of the border color.",
                "type": "FloatPar",
                "name": "borderalpha",
                "items": []
            },
            {
                "text": "RGB : Color to use for the background.",
                "type": "RGBPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGB : Color to use for the background.",
                "type": "RGBPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGB : Color to use for the background.",
                "type": "RGBPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "Float : Alpha of the background color.",
                "type": "FloatPar",
                "name": "bgalpha",
                "items": []
            },
            {
                "text": "Toggle : Multiplies the RGB values by the Alpha values.",
                "type": "TogglePar",
                "name": "multrgbbyalpha",
                "items": []
            },
            {
                "text": "Float : Width of the border to draw on the shape.",
                "type": "FloatPar",
                "name": "borderwidth",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "borderwidthunit",
                "items": []
            },
            {
                "text": "Float : Value from 0 to 1 indicating the fraction of the border that extends beyond the radius of the shape. Effectively sets the radius to <code>radius + borderoffset*borderwidth</code>.",
                "type": "FloatPar",
                "name": "borderoffset",
                "items": []
            },
            {
                "text": "Float : Specifies the angles at which the shape is to start and end. The region between <code>beginarcangle</code> and <code>endarcangle</code>, with clockwise rotation, will not be drawn.",
                "type": "FloatPar",
                "name": "arcangle",
                "items": []
            },
            {
                "text": "Toggle : When on, the shape will be anti-aliased.",
                "type": "TogglePar",
                "name": "antialias",
                "items": []
            },
            {
                "text": "Float : Specifies the amount that the background color should be blended into the shape.",
                "type": "FloatPar",
                "name": "softness",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "softnessunit",
                "items": []
            },
            {
                "text": "Toggle : When on, a polygon will be drawn. Otherwise a circle is drawn.",
                "type": "TogglePar",
                "name": "ispolygon",
                "items": []
            },
            {
                "text": "Int : When drawing a polygon, this corresponds to the number of sides the polygon should have.",
                "type": "IntPar",
                "name": "sides",
                "items": []
            },
            {
                "text": "Toggle : Turning this On will composite the input with the image.",
                "type": "TogglePar",
                "name": "compoverinput",
                "items": []
            },
            {
                "text": "Menu : Choose which composite operation is performed from this menu. Search the web for 'blend modes' for more detailed information on the effects of each type.",
                "type": "MenuPar",
                "name": "operand",
                "items": []
            },
            {
                "text": "Toggle : Swaps the order of the composite with the input.",
                "type": "TogglePar",
                "name": "swaporder",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "circleTOP_Class",
        "short": "The Circle TOP can be used to generate circles, ellipses and N-sided polygons.",
        "opFilter": "False",
        "opLabel": "Circle",
        "opFamily": "TOP",
        "long": "The Circle TOP can be used to generate circles, ellipses and N-sided polygons.\t\t\n\t\t\t\nThe shapes can be customized with different sizes, rotation and positioning. An optional border can be added to the shape. Background, border and fill colors can all be set independently. Anti-aliasing can be turned on or off.\t\t\t\n\t\t\t\nYou can use the arc angles to cut out part of the shape. In the case of polygons, the number of visible sides will be preserved no matter how much is cut out.",
        "opType": "circle",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "compositeTOP": {
        "label": "compositeTOP",
        "members": [
            {
                "text": "TOP : In addition to all the inputs attached, you can specify more using the TOPs listed in this field. Example: <code>ramp*</code> will composite all TOPs whose name starts with <code>ramp</code>.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Toggle : This outputs an image showing the effect of all operation types in a grid, with the inputs swapped on the right side of each tile.",
                "type": "TogglePar",
                "name": "previewgrid",
                "items": []
            },
            {
                "text": "Toggle : Instead of doing the composites, this causes only one of the inputs to pass through.",
                "type": "TogglePar",
                "name": "selectinput",
                "items": []
            },
            {
                "text": "Int : When passing through an input with Select Input on, this is the index of the image that is passed through.",
                "type": "IntPar",
                "name": "inputindex",
                "items": []
            },
            {
                "text": "Menu : Choose which composite operation is performed from this menu. Search the web for 'blend modes' for more detailed information on the effects of each type.",
                "type": "MenuPar",
                "name": "operand",
                "items": []
            },
            {
                "text": "Toggle : Swaps the order of the input pairs. A operation B is changed to B operation A. Operations like Add don't matter, but many do, like Over and Hard Light.",
                "type": "TogglePar",
                "name": "swaporder",
                "items": []
            },
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]]",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layers cumulatively, that is the first Overlay layer is translated by the amount specified, the second Overlay layer is translated by 2 times that amount, the third Overlay layer by 3 times that amount and so on.",
                "type": "XYPar",
                "name": "tstepx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layers cumulatively, that is the first Overlay layer is translated by the amount specified, the second Overlay layer is translated by 2 times that amount, the third Overlay layer by 3 times that amount and so on.",
                "type": "XYPar",
                "name": "tstepy",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate Step parameter",
                "type": "MenuPar",
                "name": "tstepunit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "compositeTOP_Class",
        "short": "The Composite TOP is a multi-input TOP that will perform a composite operation for each input.",
        "opFilter": "True",
        "opLabel": "Composite",
        "opFamily": "TOP",
        "long": "The Composite TOP is a multi-input TOP that will perform a composite operation for each input. Select the composite operation using the Operation parameter on the Composite parameter page.\t\t\n\t\t\t\n'''Note:''' See also the [[Palette:blendModes|blendModes component]] in the Palette. Refer also to [[OP Snippets]].",
        "opType": "comp",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "constantTOP": {
        "label": "constantTOP",
        "members": [
            {
                "text": "RGB : Sets the red, green and blue color channels. Clicking on the color swatch opens a color picker with RGB and HSV (Hue, Sat, and Value) pickers.",
                "type": "RGBPar",
                "name": "colorr",
                "items": []
            },
            {
                "text": "RGB : Sets the red, green and blue color channels. Clicking on the color swatch opens a color picker with RGB and HSV (Hue, Sat, and Value) pickers.",
                "type": "RGBPar",
                "name": "colorg",
                "items": []
            },
            {
                "text": "RGB : Sets the red, green and blue color channels. Clicking on the color swatch opens a color picker with RGB and HSV (Hue, Sat, and Value) pickers.",
                "type": "RGBPar",
                "name": "colorb",
                "items": []
            },
            {
                "text": "Float : Sets the alpha channel value.",
                "type": "FloatPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Toggle : Premultiplies the image.",
                "type": "TogglePar",
                "name": "multrgbbyalpha",
                "items": []
            },
            {
                "text": "Menu : Specify the color values using different ranges. Note that this is only for purposes of setting the color, the data values in the TOP always use the RGBA Unit range 0-1.",
                "type": "MenuPar",
                "name": "rgbaunit",
                "items": []
            },
            {
                "text": "Toggle : Turning this On will composite the input with the image.",
                "type": "TogglePar",
                "name": "compoverinput",
                "items": []
            },
            {
                "text": "Menu : Choose which composite operation is performed from this menu. Search the web for 'blend modes' for more detailed information on the effects of each type.",
                "type": "MenuPar",
                "name": "operand",
                "items": []
            },
            {
                "text": "Toggle : Swaps the order of the composite with the input.",
                "type": "TogglePar",
                "name": "swaporder",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "constantTOP_Class",
        "short": "The Constant TOP sets the red, green, blue, and alpha (r, g, b, and a) channels individually.",
        "opFilter": "False",
        "opLabel": "Constant",
        "opFamily": "TOP",
        "long": "The Constant TOP sets the red, green, blue, and alpha (r, g, b, and a) channels individually. It is commonly used to create a solid color TOP image.",
        "opType": "constant",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "convolveTOP": {
        "label": "convolveTOP",
        "members": [
            {
                "text": "DAT : The DAT containing the rows and columns of coefficients.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "Toggle : This will normalize the coefficients before using them in the convolve. Normaliziation is done by summing all the coefficients and dividing every coefficient by that sum. Note: If the coefficients add up to 0, then this parameter does nothing.",
                "type": "TogglePar",
                "name": "normalize",
                "items": []
            },
            {
                "text": "Toggle : When off, the alpha channel will not be convolved.",
                "type": "TogglePar",
                "name": "applytoalpha",
                "items": []
            },
            {
                "text": "Float : After the convolution, this value will be added to the R, G and B of the pixel (and A if enabled).",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "convolveTOP_Class",
        "short": "The Convolve TOP uses a DAT table containing numeric coefficients.",
        "opFilter": "True",
        "opLabel": "Convolve",
        "opFamily": "TOP",
        "long": "The Convolve TOP uses a DAT table containing numeric coefficients. For each pixel, it combines its RGBA values and it's neighboring pixels' RGBA values by multiplying the values by the corresponding coefficients in the table, adding the results together. For example, if the table is 5 rows and 5 columns, the pixel and its 24 neighbors are combined.\t\n\t\t\nExample coefficient for 3x3 blur, edge, emboss, sharpen and vertical slope kernels. Be sure to turn on 'Normalize Coefficients' to use these coefficients as -is:\n\n[[image:ConvolveTOP.1.jpg]]",
        "opType": "convolve",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "cornerpinTOP": {
        "label": "cornerpinTOP",
        "members": [
            {
                "text": "XY : The x and y position of the bottom left corner of the extraction.",
                "type": "XYPar",
                "name": "extractp3x",
                "items": []
            },
            {
                "text": "XY : The x and y position of the bottom left corner of the extraction.",
                "type": "XYPar",
                "name": "extractp3y",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "extractp3unit",
                "items": []
            },
            {
                "text": "XY : The x and y position of the bottom right corner of the extraction.",
                "type": "XYPar",
                "name": "extractp4x",
                "items": []
            },
            {
                "text": "XY : The x and y position of the bottom right corner of the extraction.",
                "type": "XYPar",
                "name": "extractp4y",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "extractp4unit",
                "items": []
            },
            {
                "text": "XY : The x and y position of the top left corner of the extraction.",
                "type": "XYPar",
                "name": "extractp1x",
                "items": []
            },
            {
                "text": "XY : The x and y position of the top left corner of the extraction.",
                "type": "XYPar",
                "name": "extractp1y",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "extractp1unit",
                "items": []
            },
            {
                "text": "XY : The x and y position of the top right corner of the extraction.",
                "type": "XYPar",
                "name": "extractp2x",
                "items": []
            },
            {
                "text": "XY : The x and y position of the top right corner of the extraction.",
                "type": "XYPar",
                "name": "extractp2y",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "extractp2unit",
                "items": []
            },
            {
                "text": "Menu : Determines how the image is handled at its edges.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "XY : The x and y position of the bottom left corner of the extraction.",
                "type": "XYPar",
                "name": "pinp3x",
                "items": []
            },
            {
                "text": "XY : The x and y position of the bottom left corner of the extraction.",
                "type": "XYPar",
                "name": "pinp3y",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "pinp3unit",
                "items": []
            },
            {
                "text": "XY : The x and y position of the bottom right corner of the extraction.",
                "type": "XYPar",
                "name": "pinp4x",
                "items": []
            },
            {
                "text": "XY : The x and y position of the bottom right corner of the extraction.",
                "type": "XYPar",
                "name": "pinp4y",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "pinp4unit",
                "items": []
            },
            {
                "text": "XY : The x and y position of the top left corner of the extraction.",
                "type": "XYPar",
                "name": "pinp1x",
                "items": []
            },
            {
                "text": "XY : The x and y position of the top left corner of the extraction.",
                "type": "XYPar",
                "name": "pinp1y",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "pinp1unit",
                "items": []
            },
            {
                "text": "XY : The x and y position of the top right corner of the extraction.",
                "type": "XYPar",
                "name": "pinp2x",
                "items": []
            },
            {
                "text": "XY : The x and y position of the top right corner of the extraction.",
                "type": "XYPar",
                "name": "pinp2y",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "pinp2unit",
                "items": []
            },
            {
                "text": "Int : To perform the Extract and Pin operations, the image is placed on a polygonal grid to break it up into blocks that can be distorted. <span class=\"tipTextTOP\">Grid Refinement</span> sets the number of divisions in this grid.",
                "type": "IntPar",
                "name": "gridrefine",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the corners of the Corner Pin have been positioned inside the original image space. Set the <span class=\"tipTextTOP\">Bottom Left</span> x-position to 1.0 and you will see the background color in the bottom left corner of the image.",
                "type": "RGBAPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the corners of the Corner Pin have been positioned inside the original image space. Set the <span class=\"tipTextTOP\">Bottom Left</span> x-position to 1.0 and you will see the background color in the bottom left corner of the image.",
                "type": "RGBAPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the corners of the Corner Pin have been positioned inside the original image space. Set the <span class=\"tipTextTOP\">Bottom Left</span> x-position to 1.0 and you will see the background color in the bottom left corner of the image.",
                "type": "RGBAPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the corners of the Corner Pin have been positioned inside the original image space. Set the <span class=\"tipTextTOP\">Bottom Left</span> x-position to 1.0 and you will see the background color in the bottom left corner of the image.",
                "type": "RGBAPar",
                "name": "bgcolora",
                "items": []
            },
            {
                "text": "Toggle : This option allows the Background Color to be pre-multiplied by alpha.",
                "type": "TogglePar",
                "name": "premultrgbbyalpha",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "cornerpinTOP_Class",
        "short": "The Corner Pin TOP can perform two operations.",
        "opFilter": "True",
        "opLabel": "Corner Pin",
        "opFamily": "TOP",
        "long": "The Corner Pin TOP can perform two operations. The Extract page lets you specify a sub-section of the image to use by moving 4 points. The Corner Pin page let you move the corner points of the extracted image to any location.\n \nSee also [[Projection Mapping]].",
        "opType": "corner",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "cplusplusTOP": {
        "label": "cplusplusTOP",
        "members": [
            {
                "text": "File : The path to the plugin you want to load.",
                "type": "FilePar",
                "name": "plugin",
                "items": []
            },
            {
                "text": "Toggle : When this parameter is On, it will delete the instance of the class created by the plugin, and create a new one.",
                "type": "TogglePar",
                "name": "reinit",
                "items": []
            },
            {
                "text": "Pulse : Instantly reinitialize the class.",
                "type": "PulsePar",
                "name": "reinitpulse",
                "items": []
            },
            {
                "text": "Toggle : When this parameter goes above 1, it will delete the instance of the class created by the plugin and unload the plugin. If multiple TOPs have loaded the same plugin they will all need to unload it to release the file.",
                "type": "TogglePar",
                "name": "unloadplugin",
                "items": []
            },
            {
                "text": "Menu : The level of anti-aliasing you want the framebuffer that will be created for you to have.",
                "type": "MenuPar",
                "name": "antialias",
                "items": []
            },
            {
                "text": "Menu : Specifies the pixel format of the depth buffer you want, if any.",
                "type": "MenuPar",
                "name": "depthbuffer",
                "items": []
            },
            {
                "text": "Toggle : Turn on if you want a stencil buffer.",
                "type": "TogglePar",
                "name": "stencilbuffer",
                "items": []
            },
            {
                "text": "Int : Any shader you write can output to more than one RGBA buffer at a time. Instead of writing to gl_FragColor in your shader, you write to gl_FragData[i] where i is the color buffer index you want to write the value to.",
                "type": "IntPar",
                "name": "numcolorbufs",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "cplusplusTOP_Class",
        "short": "The CPlusPlus TOP allows you to make custom TOP operators by writing your own plugin using C++.",
        "opFilter": "False",
        "opLabel": "CPlusPlus",
        "opFamily": "TOP",
        "long": "The CPlusPlus TOP allows you to make custom TOP operators by writing your own plugin using C++.\t\t\n\t\t\t\nSee [[Write a CPlusPlus Plugin]] and the other articles in the [[:Category:C++ | C++ Category]] for more detailed information on how to make plugins for use with this node and how to access example projects.\t\t\t\n\t\t\t\nSee also: [[CPlusPlus CHOP]], [[CUDA]]",
        "opType": "cplusplus",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "cropTOP": {
        "label": "cropTOP",
        "members": [
            {
                "text": "Float : Positions the left edge of the image.",
                "type": "FloatPar",
                "name": "cropleft",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "cropleftunit",
                "items": []
            },
            {
                "text": "Float : Positions the right edge of the image.",
                "type": "FloatPar",
                "name": "cropright",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "croprightunit",
                "items": []
            },
            {
                "text": "Float : Positions the bottom edge of the image.",
                "type": "FloatPar",
                "name": "cropbottom",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "cropbottomunit",
                "items": []
            },
            {
                "text": "Float : Positions the top edge of the image.",
                "type": "FloatPar",
                "name": "croptop",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "croptopunit",
                "items": []
            },
            {
                "text": "Menu : This parameter determines what happens at the edges of the tiles.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "cropTOP_Class",
        "short": "The Crop TOP crops an image by defining the position of the left, right, bottom, and top edges of the image.",
        "opFilter": "True",
        "opLabel": "Crop",
        "opFamily": "TOP",
        "long": "The Crop TOP crops an image by defining the position of the left, right, bottom, and top edges of the image. The cropped part of the image is discarded, thus reducing the resolution of the image.",
        "opType": "crop",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "crossTOP": {
        "label": "crossTOP",
        "members": [
            {
                "text": "Float : Determines the amount each input is added to the output. When Cross = 0, Input1 is output; when Cross = 1, Input2 is output.",
                "type": "FloatPar",
                "name": "cross",
                "items": []
            },
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]]",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "crossTOP_Class",
        "short": "The Cross TOP blends between the two input images based on the value of the Cross parameter (refered to as ''Cross_value'' below).",
        "opFilter": "True",
        "opLabel": "Cross",
        "opFamily": "TOP",
        "long": "The Cross TOP blends between the two input images based on the value of the Cross parameter (refered to as ''Cross_value'' below).\t\t\n\t\t\t\n<code>Output = Input1*(1-''Cross_value'') + Input2*(''Cross_value'')</code>",
        "opType": "cross",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "cubemapTOP": {
        "label": "cubemapTOP",
        "members": [
            {
                "text": "Menu : Determine how the cube map is created from the input images.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Cube Map TOP builds a texture map in the [[Cube Map]] internal texture format. It accepts a vertical cross image, or 1 input per side of the cube. The [[Phong MAT]] can use the cube maps from the Cube Map TOP for reflections. The [[Render TOP]] can also create cube maps. You can sample a cube map in a GLSL shader by declaring them like this\t\t\n<syntaxhighlight lang=glsl>uniform samplerCube <name>;</syntaxhighlight>\t\t\t\nand sampling them using this in GLSL 3.30+\t\t\t\n<syntaxhighlight lang=glsl>texture(samplerCube name, vec3 texcoords)</syntaxhighlight>\t\t\t\n\t\t\t\nor this in GLSL 1.20\t\t\t\n<syntaxhighlight lang=glsl>textureCube(samplerCube name, vec3 texcoords)</syntaxhighlight>",
        "opLabel": "Cube Map",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "short": "The Cube Map TOP builds a texture map in the [[Cube Map]] internal texture format.",
        "opType": "cubemap",
        "opFilter": "True",
        "opClass": "cubemapTOP_Class",
        "opCategories": ""
    },
    "depthTOP": {
        "label": "depthTOP",
        "members": [
            {
                "text": "OP : Specifies the Render TOP used for depth values.",
                "type": "OPPar",
                "name": "rendertop",
                "items": []
            },
            {
                "text": "Int : When using [[Multi-Camera Rendering]], chooses which camera's output to select.",
                "type": "IntPar",
                "name": "cameraindex",
                "items": []
            },
            {
                "text": "Int : When using the 'Depth-Peeling' feature in the [[Render TOP]], this chooses which peel layer to select.",
                "type": "IntPar",
                "name": "peellayerindex",
                "items": []
            },
            {
                "text": "Menu : The pixel format the Depth texture should be output as.",
                "type": "MenuPar",
                "name": "pixelformat",
                "items": []
            },
            {
                "text": "Menu : The space the depth values should be output in.",
                "type": "MenuPar",
                "name": "depthspace",
                "items": []
            },
            {
                "text": "Float : The range to convert from when using 'Rerange from Camera Space'. This would often be your area of interest in the camera's depth.",
                "type": "FloatPar",
                "name": "rangefrom",
                "items": []
            },
            {
                "text": "Float : The range of values you want to convert the depth values to. This is the range you would find the depth to more useful for processing, often 0-1.",
                "type": "FloatPar",
                "name": "rangeto",
                "items": []
            },
            {
                "text": "Toggle : Enable to clamp the depth values between 0 and 1.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Float : Apply a  gamma curve to the depth values.",
                "type": "FloatPar",
                "name": "gamma",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "depthTOP_Class",
        "short": "The Depth TOP reads an image containing depth information from a scene described in a specified [[Render TOP]]. The resulting image is black (0) at pixels where the surface is at the near depth value (Camera's parameter \"Near\"). It is white (1) at pixels where the surface is at the far depth value (parameter \"Far\").",
        "opFilter": "False",
        "opLabel": "Depth",
        "opFamily": "TOP",
        "long": "The Depth TOP reads an image containing depth information from a scene described in a specified [[Render TOP]]. The resulting image is black (0) at pixels where the surface is at the near depth value (Camera's parameter \"Near\"). It is white (1) at pixels where the surface is at the far depth value (parameter \"Far\"). \t\t\n\t\t\t\nThe Depth TOP is used to do shadow mapping. It can have many other uses also, such as edge detection based on depth. \t\t\t\n\t\t\t\nThe depth range is by definition the near plane -> far plane. Values in the Depth TOP will be 0 at the near plane, and 1 at the far plane. Generally the image in the Depth TOP will be white, unless you have your planes really tight around your object. But just because you can't visually see anything, it doesn't mean the information isn't there. \t\t\t\n\t\t\t\nAnother option is Linear Camera-Space Depth. If the Render TOP's Depth Buffer Format is set to 32-Bit Floating-Point and its Linear Camera-Space Depth parameter is on, then the Depth TOP will output linear camera space depth.\t\t\t\n\t\t\t\nYou can use the [[Level TOP]] to re-range the Depth TOP's values. However make sure you set the Pixel Format of the Level TOP to 16 or 32-bit, or you'll lose a lot of information from the Depth TOP's data (The Depth TOP has 24-bit data).\t\t\t\n\t\t\t\nThe Depth TOP creates a 24-bit fixed-point or 32-bit floating-point single channel image. When the Depth TOP is used as an input to another TOP, its data will be treated like an RGBA value of (D, D, D, 1). The same is true when sampling a depth texture in a GLSL shader.",
        "opType": "depth",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "differenceTOP": {
        "label": "differenceTOP",
        "members": [
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]]",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "differenceTOP_Class",
        "short": "The Difference TOP performs a difference composite on its two input images.",
        "opFilter": "True",
        "opLabel": "Difference",
        "opFamily": "TOP",
        "long": "The Difference TOP performs a difference composite on its two input images.",
        "opType": "diff",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "directxinTOP": {
        "label": "directxinTOP",
        "members": [
            {
                "text": "Str : Specify the handle pointing to the DirectX texture. You can get the handle of any [[DirectX Out TOP]] texture by attaching an [[Info DAT]] to it. The <code>handle</code> is one of the columns. Other applications that support sharing texture will have their own way of getting a texture handle, please consult the application's documentation.",
                "type": "StrPar",
                "name": "handle",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "directxinTOP_Class",
        "short": "The DirectX In TOP brings DirectX textures from other applications into TouchDesigner.",
        "opFilter": "False",
        "opLabel": "DirectX In",
        "opFamily": "TOP",
        "long": "The DirectX In TOP brings DirectX textures from other applications into TouchDesigner. This feature is accessed through the DirectX Sharing Resources feature. This supports DirectX 9.0 and higher.\t\n\t\t\nSee also: [[DirectX Out TOP]]",
        "opType": "directxin",
        "opLicense": "Commercial",
        "os": "Microsoft Windows",
        "opCategories": ""
    },
    "directxoutTOP": {
        "label": "directxoutTOP",
        "members": [
            {
                "text": "Toggle : Enable or disable DirectX output.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Int : Number of DirectX textures created. These textures are updated in a cycle, 1 per frame. Use an [[Info DAT]] to inspect the list of textures.",
                "type": "IntPar",
                "name": "queuesize",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "directxoutTOP_Class",
        "opLabel": "DirectX Out",
        "opFamily": "TOP",
        "opLicense": "Commercial",
        "os": "Microsoft Windows",
        "opType": "directxout",
        "opFilter": "True",
        "long": "The DirectX Out TOP creates textures that a DirectX application can access, or any instance of TouchDesigner with a DirectX In TOP. This features is accessed though the DirectX Sharing Resources feature. This supports DirectX 9.0 and higher.\t\n\t\t\nSee also: [[DirectX In TOP]]",
        "short": "The DirectX Out TOP creates textures that a DirectX application can access, or any instance of TouchDesigner with a DirectX In TOP.",
        "opCategories": ""
    },
    "displaceTOP": {
        "label": "displaceTOP",
        "members": [
            {
                "text": "Menu : Instead of using the Red channel to displace horizontally, you can choose a different channel.",
                "type": "MenuPar",
                "name": "horzsource",
                "items": []
            },
            {
                "text": "Menu : Instead of using the Blue channel to displace vertically, you can choose a different channel.",
                "type": "MenuPar",
                "name": "vertsource",
                "items": []
            },
            {
                "text": "XY : This value is the color values that will result in no displacement. Values below this will cause the displacement to come from the left/bottom of the pixel, while values above this will cause the displacement to come from the right/top of the pixel.",
                "type": "XYPar",
                "name": "midpointx",
                "items": []
            },
            {
                "text": "XY : This value is the color values that will result in no displacement. Values below this will cause the displacement to come from the left/bottom of the pixel, while values above this will cause the displacement to come from the right/top of the pixel.",
                "type": "XYPar",
                "name": "midpointy",
                "items": []
            },
            {
                "text": "XY : This scales the offset caused by the Displace Image. It will cause the pixels fetched to be closer/farther along the sample vector created by the Horizontal and Vertical Source.",
                "type": "XYPar",
                "name": "displaceweightx",
                "items": []
            },
            {
                "text": "XY : This scales the offset caused by the Displace Image. It will cause the pixels fetched to be closer/farther along the sample vector created by the Horizontal and Vertical Source.",
                "type": "XYPar",
                "name": "displaceweighty",
                "items": []
            },
            {
                "text": "Float : This reduces the influence of the pixel's position when brought toward 0. At its default of 1, it doesn't zoom into the Displace Image. When 0, it anchors the displacements relative to one pixel in the Source Image defined by the Offset and Offset Weight parameters.",
                "type": "FloatPar",
                "name": "uvweight",
                "items": []
            },
            {
                "text": "XY : The Offset is first multiplied by the Offset Weight. Then it will be added to the coordinates caluclated after looking up into the displacement map. These final coordinates is what will be used to sample from the source image.",
                "type": "XYPar",
                "name": "offsetx",
                "items": []
            },
            {
                "text": "XY : The Offset is first multiplied by the Offset Weight. Then it will be added to the coordinates caluclated after looking up into the displacement map. These final coordinates is what will be used to sample from the source image.",
                "type": "XYPar",
                "name": "offsety",
                "items": []
            },
            {
                "text": "Float : Scales the Offset parameter values. When this is 0 the Offset parameter will have no effect.",
                "type": "FloatPar",
                "name": "offsetweight",
                "items": []
            },
            {
                "text": "Menu : This parameter determines what happens at the edges of the tiles.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "displaceTOP_Class",
        "opLabel": "Displace",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "displace",
        "opFilter": "True",
        "long": "The Displace TOP will cause one image to be warped by another image. A pixel of the output image at (Uo,Vo) gets its RGBA value from a different pixel (Ui, Vi) of the Source Image by using the second input image (the Displace Image). \t\t\n\t\t\t\nFor each pixel in the output image, three factors affect which pixel to fetch from the source:\t\t\t\n* The horizontal and vertical source channels of the Displace Image (Red and Blue by default).\n* the Uo and Vo coordinate of the output pixel.\t\t\t\n* A constant Ua and Va anchor point (Offset).\t\t\t\n\t\t\t\n'''Displace Image''' - In using the Displace Image, for each pixel in the output, it gets the corresponding pixel from the input, and uses the red channel and blue channel as its U and V displacement. If the red and blue are .5, .5, then Uo = Ui and Vo = Vi. That is, there is no warp if the Displace Image is a 50% grey. Also the warp is reduced to 0 if the Displace Weight is 0. Where red < .5 in the Displace Image, it fetches a pixel from the left of Uo in the Source Image. If blue < .5, it fetches a pixel from below Vo in the Source Image. Thus the pixel is retrieved from Ui, Vi at Uo*Scale*(red-.5), Vo*Scale*(.5-blue) of the Source Image.\t\t\t\n\t\t\t\n'''Uo and Vo offset''' - By default, the warping of each output pixel is relative to its Uo, Vo. But when the UV Weight parameter is 0, the displacement is relative to the center pixel of the Source Image.\t\t\t\n\t\t\t\n'''Ua and Va anchor (offset) point''' - This zooms into a pixel of the input if you bring the two other weights down to 0.\t\t\t\n\t\t\t\nFor the Displace Image, you can change which of its RGBA channels cause the warp. \t\t\t\n\t\t\t\nYou can choose if there is wraparound in the image warping. If the computed Uo and Vo is less than 0 or greater than 1, it can wraparound, clamp or mirror.\t\t\t\n\t\t\t\nThe Displace Image can be any photograph followed by a Slope TOP, which will give luminance gradients in red and blue, with the neutral value at .5, exactly the form required by the Displace TOP.\t\t\t\n\t\t\t\nOne way to experiment is to make a Displace Image from Ramp TOPs. Alternately use a Constant TOP set to .5, .5, .5, 1, then subtract a photo using a Subtract TOP, and add another photo image using an Add TOP. Before subtracting and adding the images, you can lower their effect using Level TOPs and adjusting Brightness.\t\t\t\n\t\t\t\nSee also: [[Remap TOP]], [[Lookup TOP]]",
        "short": "The Displace TOP will cause one image to be warped by another image.",
        "opCategories": ""
    },
    "edgeTOP": {
        "label": "edgeTOP",
        "members": [
            {
                "text": "Menu : This menu determines how the edges are pulled from the image.",
                "type": "MenuPar",
                "name": "select",
                "items": []
            },
            {
                "text": "Float : Applies a black level adjustment to the input image before finding the edges.",
                "type": "FloatPar",
                "name": "blacklevel",
                "items": []
            },
            {
                "text": "Float : Higher gain values will make more edge details appear.",
                "type": "FloatPar",
                "name": "strength",
                "items": []
            },
            {
                "text": "Float : When sampling the image, this determines the distance from each pixel to the sample pixel. When units are set to pixels, it is the number of pixels away from the current pixel which is sampled to find edges. A <span class=\"tipTextTOP\">Sample Step</span> of 3 would sample pixels 3 pixels away to look for edges.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "offsetunit",
                "items": []
            },
            {
                "text": "RGBA : The color of the edges in RGBA.",
                "type": "RGBAPar",
                "name": "edgecolorr",
                "items": []
            },
            {
                "text": "RGBA : The color of the edges in RGBA.",
                "type": "RGBAPar",
                "name": "edgecolorg",
                "items": []
            },
            {
                "text": "RGBA : The color of the edges in RGBA.",
                "type": "RGBAPar",
                "name": "edgecolorb",
                "items": []
            },
            {
                "text": "RGBA : The color of the edges in RGBA.",
                "type": "RGBAPar",
                "name": "edgecolora",
                "items": []
            },
            {
                "text": "Menu : This menu determines how the alpha channel is output from the Edge TOP.",
                "type": "MenuPar",
                "name": "alphaoutputmenu",
                "items": []
            },
            {
                "text": "Toggle : Turning this On will composite the edges over the input image.",
                "type": "TogglePar",
                "name": "compinput",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "edgeTOP_Class",
        "opLabel": "Edge",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "edge",
        "opFilter": "True",
        "long": "The Edge TOP finds edges in an image and highlights them. For each pixel, it looks at the values at neighboring pixels, and where differences are greater than a threshold, the output's value is higher.\t\t\n\t\t\t\nSee also the [[Convolve TOP]].",
        "short": "The Edge TOP finds edges in an image and highlights them.",
        "opCategories": ""
    },
    "embossTOP": {
        "label": "embossTOP",
        "members": [
            {
                "text": "Menu : This menu selects how the edges in the image are found. The edges will appear raised or depressed in the output image depending on their slope.",
                "type": "MenuPar",
                "name": "select",
                "items": []
            },
            {
                "text": "Menu : Determines what pixels to use when calculating the slope at each pixel in the image.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Float : Sets the greyscale color of the midpoint of the emboss. This is the color of any part in the image that is not raised or depressed.",
                "type": "FloatPar",
                "name": "midpoint",
                "items": []
            },
            {
                "text": "Float : The depth of the emboss. Higher values make the output look more deeply etched.",
                "type": "FloatPar",
                "name": "strength",
                "items": []
            },
            {
                "text": "Float : When sampling the image, this determines the distance from each pixel to the sample pixel. When units are set to pixels, it is the number of pixels away from the current pixel which is sampled to find edges. A <span class=\"tipTextTOP\">Sample Step</span> of 3 would sample pixels 3 pixels away to look for edges.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "offsetunit",
                "items": []
            },
            {
                "text": "Float : Controls the position of the light source, changing the direction of the highlights and shadows in the embossed output image.",
                "type": "FloatPar",
                "name": "direction",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "embossTOP_Class",
        "opLabel": "Emboss",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "emboss",
        "opFilter": "True",
        "long": "The Emboss TOP creates the effect that an image is embossed in a thin sheet of metal. Edges in the image will appear raised.",
        "short": "The Emboss TOP creates the effect that an image is embossed in a thin sheet of metal.",
        "opCategories": ""
    },
    "feedbackTOP": {
        "label": "feedbackTOP",
        "members": [
            {
                "text": "TOP : Specifies a TOP for feedback to use as its source when activated.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Toggle : Activates feedback when set to 0. Disables feedback when set to 1. When disabled, the Feedback TOP passes thru the image connected to its input.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Resets the feedback in a single frame when clicked.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "feedbackTOP_Class",
        "opLabel": "Feedback",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "feedback",
        "opFilter": "True",
        "long": "The Feedback TOP can be used to create feedback effects in TOPs. It can give fake motion blur by not clearing the color buffer. The Feedback TOP's input image will be passed through whenever Feedback is bypassed (by setting the <span class=\"tipTextTOP\">Bypass Feedback</span> parameter = 1). When feedback is activated (<span class=\"tipTextTOP\">Bypass Feedback</span> parameter = 0) the Feedback TOP will output an image stream sourced from its Target TOP. By selecting a Target TOP downstream in the feedback network, other filter TOPs can be added in between the Feedback TOP and its Target TOP to achive feedback effects. See the example networks below.\t\n\t\t\nSee [[OP Snippets]] for some examples on how to use the Feedback TOP.",
        "short": "The Feedback TOP can be used to create feedback effects in TOPs.",
        "opCategories": ""
    },
    "fitTOP": {
        "label": "fitTOP",
        "members": [
            {
                "text": "Menu : Determines how the input is fit to the specified resolution.",
                "type": "MenuPar",
                "name": "fit",
                "items": []
            },
            {
                "text": "Menu : The menu attached to this parameter allows you to specify the order in which the changes to your TOP will take place. Changing the Transform order will change where things go much the same way as going a block and turning east gets you to a different place than turning east and then going a block.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "XY : The two fields for Translate and Scale allows you to specify transforms in x and y axes. The field for Rotate allow you to specify the amount of rotation.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : The two fields for Translate and Scale allows you to specify transforms in x and y axes. The field for Rotate allow you to specify the amount of rotation.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XYZ : The field for rotation allows you to specify the amount of rotation of the image.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : The field for rotation allows you to specify the amount of rotation of the image.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : The field for rotation allows you to specify the amount of rotation of the image.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XY : The two fields for Scale allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : The two fields for Scale allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : The Pivot point edit fields allow you to define the point about which the TOP scales and rotates. Altering the pivot point of a TOP produces different results depending on the transformation performed on the TOP image.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of a TOP image is located at <code>-1,-1</code> and you wanted to scale the image by <code>0.5</code> (reduce its size by 50%), then the TOP would scale toward the pivot point and appear to slide down and to the left.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : The Pivot point edit fields allow you to define the point about which the TOP scales and rotates. Altering the pivot point of a TOP produces different results depending on the transformation performed on the TOP image.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of a TOP image is located at <code>-1,-1</code> and you wanted to scale the image by <code>0.5</code> (reduce its size by 50%), then the TOP would scale toward the pivot point and appear to slide down and to the left.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the image is translated or scaled down. Try scaling an image down 50% in size (Scale = 0.5,0.5) and setting the background color.",
                "type": "RGBAPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the image is translated or scaled down. Try scaling an image down 50% in size (Scale = 0.5,0.5) and setting the background color.",
                "type": "RGBAPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the image is translated or scaled down. Try scaling an image down 50% in size (Scale = 0.5,0.5) and setting the background color.",
                "type": "RGBAPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the image is translated or scaled down. Try scaling an image down 50% in size (Scale = 0.5,0.5) and setting the background color.",
                "type": "RGBAPar",
                "name": "bgcolora",
                "items": []
            },
            {
                "text": "Toggle : This option allows the Background Color to be pre-multiplied by alpha.",
                "type": "TogglePar",
                "name": "premultrgbbyalpha",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "fitTOP_Class",
        "opLabel": "Fit",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "fit",
        "opFilter": "True",
        "long": "The Fit TOP re-sizes its input to the resolution set on the Common Page using the method specified in the Fit parameter menu. This is useful for changing the aspect ratio of an image without distorting it horizontally or vertically. It will crop the image or fill with the background color depending on the Fit parameter options.",
        "short": "The Fit TOP re-sizes its input to the resolution set on the Common Page using the method specified in the Fit parameter menu.",
        "opCategories": ""
    },
    "flipTOP": {
        "label": "flipTOP",
        "members": [
            {
                "text": "Toggle : Flips the image in X.",
                "type": "TogglePar",
                "name": "flipx",
                "items": []
            },
            {
                "text": "Toggle : Flips the image in Y.",
                "type": "TogglePar",
                "name": "flipy",
                "items": []
            },
            {
                "text": "Menu : Flops the image. Flop is a combination of a flip and a rotation. The X resolution becomes the Y resolution. The Y becomes the X.\t\n\t\t\t\n* No Flop - No flop performed.\t\t\t\n* Bottom Left - The image is flipped in X and then rotated 90 degrees clockwise.\t\t\t\n* Top Left - The image is flipped in X and then rotated 90 degrees counter-clockwise.",
                "type": "MenuPar",
                "name": "flop",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "flipTOP_Class",
        "opLabel": "Flip",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "flip",
        "opFilter": "True",
        "long": "The Flip TOP will Flip an image in X and/or Y. It also offers a Flop option to turn each row of pixels into a column.",
        "short": "The Flip TOP will Flip an image in X and/or Y.",
        "opCategories": ""
    },
    "functionTOP": {
        "label": "functionTOP",
        "members": [
            {
                "text": "Float : Applies a scale and shift to the input values before the function is calculated i.e. input = (input * rerange2) + rerange1. '''Note:''' This feature only affects integer texture formats and is not used on floating point formats.",
                "type": "FloatPar",
                "name": "rerange",
                "items": []
            },
            {
                "text": "Menu : Applies the selected function to the R, G, B, and A channels.",
                "type": "MenuPar",
                "name": "funcrgba",
                "items": []
            },
            {
                "text": "Menu : Applies the selected function to the R, G, and B channels.",
                "type": "MenuPar",
                "name": "funcrgb",
                "items": []
            },
            {
                "text": "Menu : Applies the selected function to the R (red) channel.",
                "type": "MenuPar",
                "name": "funcr",
                "items": []
            },
            {
                "text": "Menu : Applies the selected function to the G (green) channel.",
                "type": "MenuPar",
                "name": "funcg",
                "items": []
            },
            {
                "text": "Menu : Applies the selected function to the B (blue) channel.",
                "type": "MenuPar",
                "name": "funcb",
                "items": []
            },
            {
                "text": "Menu : Applies the selected function to the A (alpha) channel.",
                "type": "MenuPar",
                "name": "funca",
                "items": []
            },
            {
                "text": "Float : Supplies the base value for functions like 'Log Base N' and 'Base ^ Input'",
                "type": "FloatPar",
                "name": "baseval",
                "items": []
            },
            {
                "text": "Float : Supplies the exponent value for the function 'Input ^ Base'.",
                "type": "FloatPar",
                "name": "expval",
                "items": []
            },
            {
                "text": "Float : Allows setting the output to a specific constant value using the 'Constant' function.",
                "type": "FloatPar",
                "name": "constval",
                "items": []
            },
            {
                "text": "Menu : Determines whether the input values are measured in degrees, radians, etc for functions that require an angle input e.g. sine, cosine, etc.",
                "type": "MenuPar",
                "name": "angunit",
                "items": []
            },
            {
                "text": "Toggle : When enabled, output values that would otherwise be invalid will be replaced with the value of the 'Error Value' parameter. For example, when using the log function, the output will be replaced whenever the input value is less than zero.",
                "type": "TogglePar",
                "name": "replace",
                "items": []
            },
            {
                "text": "Float : The output value to use when an input error is detected e.g. log(-1).",
                "type": "FloatPar",
                "name": "errval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "functionTOP",
        "opLabel": "Function",
        "opClass": "functionTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The Function TOP can perform mathematical operations like sin, cos, or exp on the color values of the input image.",
        "long": "The Function TOP can perform mathematical operations like sin, cos, or exp on the color values of the input image. Different functions can be performed on each color channel. Some functions will take an additional value from the Base, Exponent or Constant Value parameters, and some functions take an additional input value from the second input image.\n    \nFor some functions, you can use the 'Replace Errors' parameter to insert a new value for values that would otherwise be undefined e.g. log(-1)\n    \n===== Supported functions: =====\n* ''Input'' - Pass along the input value unchanged\n* ''Constant'' - Replace the input with the value of the 'Constant' parameter.\n* ''Square Root'' - Find the square root of the input value i.e. sqrt(x).\n* ''Absolute Value'' - Get the absolute value of the input i.e. abs(x).\n* ''Sign'' - Returns -1 if the input value is below 0, 0 if it equals 0, and 1 if it's greater than zero.\n* ''Cosine'' - Returns the cosine of the input. <sup>1</sup>\n* ''Sine'' - Returns the sine of the input. <sup>1</sup>\n* ''Tangent'' - Returns the tangent of the input. <sup>1</sup>\n* ''Arccosine'' - Returns the arccosine of the input i.e. acos(x). <sup>1</sup>\n* ''Arcsine'' - Returns the sine of the input i.e. asin(x). <sup>1</sup>\n* ''Arctan (Input1)'' - Returns the arctangent of the input i.e. atan(x). <sup>1</sup>\n* ''Arctan (Input1 / Input2)'' - Returns the arctangent of input1 over input2 i.e. atan(x,y). <sup>1</sup>\n* ''Hyperbolic Cosine'' - Returns the hyperbolic cosine of the input i.e. cosh(x). <sup>1</sup>\n* ''Hyperbolic Sine'' - Returns the sine of the input i.e. sinh(x). <sup>1</sup>\n* ''Hyperbolic Tangent'' - Returns the tangent of the input i.e. tanh(x). <sup>1</sup>\n* ''Log Base 10'' - Returns the base 10 logarithm of the input i.e. log10(x).\n* ''Log Base 2'' - Returns the base 2 logarithm of the input i.e. log2(x).\n* ''Log Base N'' - Returns the base N logarithm of the input, where N is set by the 'Base Value' parameter.\n* ''Natural Log'' - Returns the natural log of the input i.e. ln(x).\n* ''Exponent'' - Returns e to the power of the input i.e. e^x.\n* ''Exponent 2'' - Returns 2 to the power of the input i.e. 2^x.\n* ''Exponent 10'' - Returns 10 to the power of the input i.e. 10^x.\n* ''Base Power'' - Returns the 'Base Value' parameter to the power of x. <sup>2</sup>\n* ''Input1 ^ Exponent'' - Returns the input value to the power of the exponent parameter. <sup>2</sup>\n* ''Input1 ^ Input2'' - Returns the value of input 1 to the power of input 2. <sup>2</sup>\n* ''dB to Power'' - Converts decibels to power.\n* ''Power to dB'' - Converts power to decibels. The result will be an error if the value is less than or equal to zero.\n* ''dB to Amplitude'' - Converts decibels to amplitude.\n* ''Amplitude to dB'' - Converts amplitude to decibels. The result will be an error if the value is less than or equal to zero.\n\n<sup>1</sup> The unit of the input for this function is determined by the 'Angle Units' parameter e.g. degrees, radians, etc.\n\n<sup>2</sup> Using a negative exponent i.e. pow(x, -2) will produce an error value since negative exponents are undefined according to the GLSL specifications.",
        "opCategories": ""
    },
    "glslmultiTOP": {
        "label": "glslmultiTOP",
        "members": [
            {
                "text": "Menu : Pick what version of GLSL to compile the shader with.",
                "type": "MenuPar",
                "name": "glslversion",
                "items": []
            },
            {
                "text": "Menu : Choose what type of shader you are writing, vertex/pixel shader, or a compute shader.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "DAT : ",
                "type": "DATPar",
                "name": "predat",
                "items": []
            },
            {
                "text": "DAT : Points to the [[DAT]] holding the Vertex Shader. Drag & Drop a DAT here, or manually enter the path to the DAT.",
                "type": "DATPar",
                "name": "vertexdat",
                "items": []
            },
            {
                "text": "DAT : Points to the [[DAT]] holding the Pixel Shader. Drag & Drop a DAT here, or manually enter the path to the DAT.",
                "type": "DATPar",
                "name": "pixeldat",
                "items": []
            },
            {
                "text": "DAT : Points to the [[DAT]] holding the [[Compute Shader]]. Drag & Drop a DAT here, or manually enter the path to the DAT.",
                "type": "DATPar",
                "name": "computedat",
                "items": []
            },
            {
                "text": "Pulse : When this button is pressed the node will try to pre-fill all it's uniform parameter with uniforms that are declare in the shader. Note that the shader compiler will likely not expose uniforms that are unused.",
                "type": "PulsePar",
                "name": "loaduniformnames",
                "items": []
            },
            {
                "text": "Toggle : Automatically set the dispatch size based on the compute shader's local size and the output texture resolution. Ensures at least one thread per pixel will execute.",
                "type": "TogglePar",
                "name": "autodispatchsize",
                "items": []
            },
            {
                "text": "Int : The dispatch size to use when executing a compute shader.",
                "type": "IntPar",
                "name": "dispatchsize",
                "items": []
            },
            {
                "text": "Menu : Controls how the output textures will be accessed. If the textures will be read from (such as using previous frame's values), then the access should be changed to Read-Write instead of Write Only.",
                "type": "MenuPar",
                "name": "outputaccess",
                "items": []
            },
            {
                "text": "Menu : Specify what type of texture to create. When creating  a 3D texture the TOP will render once for every slice of the output. Refer to [[Write a GLSL TOP#3D Textures and 2D Texture Arrays | 3D Textures and 2D Texture Arrays]] for more info.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : Set the depth of the 3D texture from the '''Input''' or the '''Custom Depth''' parameter.",
                "type": "MenuPar",
                "name": "depth",
                "items": []
            },
            {
                "text": "Int : Manually set the depth of the 3D texture, otherwise it will use the depth of the input.",
                "type": "IntPar",
                "name": "customdepth",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "clearoutputs",
                "items": []
            },
            {
                "text": "RGBA : ",
                "type": "RGBAPar",
                "name": "clearvaluer",
                "items": []
            },
            {
                "text": "RGBA : ",
                "type": "RGBAPar",
                "name": "clearvalueg",
                "items": []
            },
            {
                "text": "RGBA : ",
                "type": "RGBAPar",
                "name": "clearvalueb",
                "items": []
            },
            {
                "text": "RGBA : ",
                "type": "RGBAPar",
                "name": "clearvaluea",
                "items": []
            },
            {
                "text": "Menu : Determines how the node's input(s) are passed into the shader for use when creating a 3D Texture. By default all of the inputs are passed to each slice. When using the '''N inputs per Slice''' mode, the first N inputs are passed to the first slice, the next N inputs are passed the second slice, and so on. When it runs out of inputs it loops back to the first input. N is selected by the parameter '''N Value'''.",
                "type": "MenuPar",
                "name": "inputmapping",
                "items": []
            },
            {
                "text": "Int : Determines how many inputs are passed to the shader per slice when using the '''N inputs per Slice''' mode for '''Input Mapping'''. If for example this is set to 2, then the first 2 inputs will be passed to the first slice, the next 2 inputs will be passed the second slice, and so on. It will loop back to the start of the inputs if it runs out before it reaches the last slice.",
                "type": "IntPar",
                "name": "nval",
                "items": []
            },
            {
                "text": "Menu : Controls what is returned from your texture sampling functions when the U and V texture coordinates (called S and T in the shader) are outside [0-1] range.",
                "type": "MenuPar",
                "name": "inputextenduv",
                "items": []
            },
            {
                "text": "Menu : Controls what is returned from your texture sampling functions when the W texture coordinate (called W in the shader) are outside [0-1] range. Only useful for [[3D Texture]].",
                "type": "MenuPar",
                "name": "inputextendw",
                "items": []
            },
            {
                "text": "Int : Any shader you write can output to more than one RGBA buffer at a time. Turn up this value to have more color buffers allocated for you, and refer to [Write_a_GLSL_TOP#Outputting_to_Multiple_Color_Buffers Write a GLSL TOP] for more information on using this feature.",
                "type": "IntPar",
                "name": "numcolorbufs",
                "items": []
            },
            {
                "text": "Str : The uniform name, as declared in the shader",
                "type": "StrPar",
                "name": "uniname0",
                "items": []
            },
            {
                "text": "XYZ : The value(s) to give the uniform.",
                "type": "XYZPar",
                "name": "value0x",
                "items": []
            },
            {
                "text": "XYZ : The value(s) to give the uniform.",
                "type": "XYZPar",
                "name": "value0y",
                "items": []
            },
            {
                "text": "XYZ : The value(s) to give the uniform.",
                "type": "XYZPar",
                "name": "value0z",
                "items": []
            },
            {
                "text": "Str : The name of the uniform. You can send up to 4 channels into the GLSL shader in a single uniform. The number of channels is determined by the float/vec2/vec3/vec4 menu to the right of the name. For a CHOP with a single channel declare your uniform as a float, for one with two channels declare your uniform as a vec2, etc. The data is interleaved in the uniform. I.e the .x component is the 1st channel, .y is the 2nd channel, etc.",
                "type": "StrPar",
                "name": "chopuniname0",
                "items": []
            },
            {
                "text": "Menu : The data type of the uniform in the shader.",
                "type": "MenuPar",
                "name": "chopunitype0",
                "items": []
            },
            {
                "text": "CHOP : The channels from this CHOP will be sent to the GLSL shader.",
                "type": "CHOPPar",
                "name": "chop0",
                "items": []
            },
            {
                "text": "Menu : The type of the uniform.",
                "type": "MenuPar",
                "name": "choparraytype0",
                "items": []
            },
            {
                "text": "Str : The name of the matrix uniform.",
                "type": "StrPar",
                "name": "matuniname0",
                "items": []
            },
            {
                "text": "OP : The value to assign the matrix. For valid ways to specify this, see the [[Matrix Parameters]] article.",
                "type": "OPPar",
                "name": "matvalue0",
                "items": []
            },
            {
                "text": "Str : The name of the uniform.",
                "type": "StrPar",
                "name": "acname0",
                "items": []
            },
            {
                "text": "Menu : Specifies how the atomic counters receive their initial value, either through a single default value or a CHOP.",
                "type": "MenuPar",
                "name": "acinitval0",
                "items": []
            },
            {
                "text": "Int : Specifies a single value that all atomic counters in this binding will be initialized to.",
                "type": "IntPar",
                "name": "acsingleval0",
                "items": []
            },
            {
                "text": "CHOP : A reference to the CHOP that will determine the initial values of the atomic counters in this binding. The CHOP will be spanned in track order, so the values from the first track will be read in order first, then the next track (if there is one) and so on. If there are more initial values to fill than there are values in the CHOP then they will all be set to 0. Atomic counters will be initialized from low to high offsets.",
                "type": "CHOPPar",
                "name": "acchopval0",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "glslmultiTOP_Class",
        "opLabel": "GLSL Multi",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "glslmulti",
        "opFilter": "True",
        "long": "The GLSL Multi TOP renders a GLSL shader into a TOP image. Its parameters and functionality are identical to the [[GLSL TOP]], except it allows for more than 3 inputs.<br>Refer to the [[GLSL TOP]] help page for more information.",
        "short": "The GLSL Multi TOP renders a GLSL shader into a TOP image.",
        "opCategories": ""
    },
    "glslTOP": {
        "label": "glslTOP",
        "members": [
            {
                "text": "Menu : Pick what version of GLSL to compile the shader with.",
                "type": "MenuPar",
                "name": "glslversion",
                "items": []
            },
            {
                "text": "Menu : Choose what type of shader you are writing, vertex/pixel shader, or a compute shader.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "DAT : Use this DAT to place preprocessor directives at the start of your shader, such as #extension. This is required since these need to be the first lines in the shader, and TouchDesigner will be adding code to the start of your shader to declare uniforms/functions which would appear before #extension directives located in the main shader.",
                "type": "DATPar",
                "name": "predat",
                "items": []
            },
            {
                "text": "DAT : Points to the [[DAT]] holding the Vertex Shader. Drag & Drop a DAT here, or manually enter the path to the DAT.",
                "type": "DATPar",
                "name": "vertexdat",
                "items": []
            },
            {
                "text": "DAT : Points to the [[DAT]] holding the Pixel Shader. Drag & Drop a DAT here, or manually enter the path to the DAT.",
                "type": "DATPar",
                "name": "pixeldat",
                "items": []
            },
            {
                "text": "DAT : Points to the [[DAT]] holding the [[Compute Shader]]. Drag & Drop a DAT here, or manually enter the path to the DAT.",
                "type": "DATPar",
                "name": "computedat",
                "items": []
            },
            {
                "text": "Pulse : When this button is pressed the node will try to pre-fill all it's uniform parameter with uniforms that are declare in the shader. Note that the shader compiler will likely not expose uniforms that are unused.",
                "type": "PulsePar",
                "name": "loaduniformnames",
                "items": []
            },
            {
                "text": "Toggle : Automatically set the dispatch size based on the compute shader's local size and the output texture resolution. Ensures at least one thread per pixel will execute.",
                "type": "TogglePar",
                "name": "autodispatchsize",
                "items": []
            },
            {
                "text": "Int : The dispatch size to use when executing a compute shader.",
                "type": "IntPar",
                "name": "dispatchsize",
                "items": []
            },
            {
                "text": "Menu : Controls how the output textures will be accessed. If the textures will be read from (such as using previous frame's values), then the access should be changed to Read-Write instead of Write Only.",
                "type": "MenuPar",
                "name": "outputaccess",
                "items": []
            },
            {
                "text": "Menu : Specify what type of texture to create. When creating  a 3D texture the TOP will render once for every slice of the output. Refer to [[Write a GLSL TOP#3D Textures and 2D Texture Arrays | 3D Textures and 2D Texture Arrays]] for more info.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : Set the depth of the 3D texture from the '''Input''' or the '''Custom Depth''' parameter.",
                "type": "MenuPar",
                "name": "depth",
                "items": []
            },
            {
                "text": "Int : Manually set the depth of the 3D texture, otherwise it will use the depth of the input.",
                "type": "IntPar",
                "name": "customdepth",
                "items": []
            },
            {
                "text": "Toggle : When using a Compute Shader, this controls if the output texture should be cleared at the start of each cook. Otherwise the data from the previous cook will stay in the texture, and pixels can be left as-is in the Compute Shader.",
                "type": "TogglePar",
                "name": "clearoutputs",
                "items": []
            },
            {
                "text": "RGBA : The color value to clear all pixels to at the start of the cook.",
                "type": "RGBAPar",
                "name": "clearvaluer",
                "items": []
            },
            {
                "text": "RGBA : The color value to clear all pixels to at the start of the cook.",
                "type": "RGBAPar",
                "name": "clearvalueg",
                "items": []
            },
            {
                "text": "RGBA : The color value to clear all pixels to at the start of the cook.",
                "type": "RGBAPar",
                "name": "clearvalueb",
                "items": []
            },
            {
                "text": "RGBA : The color value to clear all pixels to at the start of the cook.",
                "type": "RGBAPar",
                "name": "clearvaluea",
                "items": []
            },
            {
                "text": "Menu : Determines how the node's input(s) are passed into the shader for use when creating a 3D Texture. By default all of the inputs are passed to each slice. When using the '''N inputs per Slice''' mode, the first N inputs are passed to the first slice, the next N inputs are passed the second slice, and so on. When it runs out of inputs it loops back to the first input. N is selected by the parameter '''N Value'''.",
                "type": "MenuPar",
                "name": "inputmapping",
                "items": []
            },
            {
                "text": "Int : Determines how many inputs are passed to the shader per slice when using the '''N inputs per Slice''' mode for '''Input Mapping'''. If for example this is set to 2, then the first 2 inputs will be passed to the first slice, the next 2 inputs will be passed the second slice, and so on. It will loop back to the start of the inputs if it runs out before it reaches the last slice.",
                "type": "IntPar",
                "name": "nval",
                "items": []
            },
            {
                "text": "Menu : Controls what is returned from your texture sampling functions when the U and V texture coordinates (called S and T in the shader) are outside [0-1] range.",
                "type": "MenuPar",
                "name": "inputextenduv",
                "items": []
            },
            {
                "text": "Menu : Controls what is returned from your texture sampling functions when the W texture coordinate (called W in the shader) are outside [0-1] range. Only useful for [[3D Texture]].",
                "type": "MenuPar",
                "name": "inputextendw",
                "items": []
            },
            {
                "text": "Int : Any shader you write can output to more than one RGBA buffer at a time. Turn up this value to have more color buffers allocated for you, and refer to [Write_a_GLSL_TOP#Outputting_to_Multiple_Color_Buffers Write a GLSL TOP] for more information on using this feature.",
                "type": "IntPar",
                "name": "numcolorbufs",
                "items": []
            },
            {
                "text": "Str : The uniform name, as declared in the shader",
                "type": "StrPar",
                "name": "uniname0",
                "items": []
            },
            {
                "text": "XYZ : The value(s) to give the uniform.",
                "type": "XYZPar",
                "name": "value0x",
                "items": []
            },
            {
                "text": "XYZ : The value(s) to give the uniform.",
                "type": "XYZPar",
                "name": "value0y",
                "items": []
            },
            {
                "text": "XYZ : The value(s) to give the uniform.",
                "type": "XYZPar",
                "name": "value0z",
                "items": []
            },
            {
                "text": "Str : The name of the uniform. You can send up to 4 channels into the GLSL shader in a single uniform. The number of channels is determined by the float/vec2/vec3/vec4 menu to the right of the name. For a CHOP with a single channel declare your uniform as a float, for one with two channels declare your uniform as a vec2, etc. The data is interleaved in the uniform. I.e the .x component is the 1st channel, .y is the 2nd channel, etc.",
                "type": "StrPar",
                "name": "chopuniname0",
                "items": []
            },
            {
                "text": "Menu : The data type of the uniform in the shader.",
                "type": "MenuPar",
                "name": "chopunitype0",
                "items": []
            },
            {
                "text": "CHOP : The channels from this CHOP will be sent to the GLSL shader.",
                "type": "CHOPPar",
                "name": "chop0",
                "items": []
            },
            {
                "text": "Menu : The type of the uniform.",
                "type": "MenuPar",
                "name": "choparraytype0",
                "items": []
            },
            {
                "text": "Str : The name of the matrix uniform.",
                "type": "StrPar",
                "name": "matuniname0",
                "items": []
            },
            {
                "text": "OP : The value to assign the matrix. For valid ways to specify this, see the [[Matrix Parameters]] article.",
                "type": "OPPar",
                "name": "matvalue0",
                "items": []
            },
            {
                "text": "Str : The name of the uniform.",
                "type": "StrPar",
                "name": "acname0",
                "items": []
            },
            {
                "text": "Menu : Specifies how the atomic counters receive their initial value, either through a single default value or a CHOP.",
                "type": "MenuPar",
                "name": "acinitval0",
                "items": []
            },
            {
                "text": "Int : Specifies a single value that all atomic counters in this binding will be initialized to.",
                "type": "IntPar",
                "name": "acsingleval0",
                "items": []
            },
            {
                "text": "CHOP : A reference to the CHOP that will determine the initial values of the atomic counters in this binding. The CHOP will be spanned in track order, so the values from the first track will be read in order first, then the next track (if there is one) and so on. If there are more initial values to fill than there are values in the CHOP then they will all be set to 0. Atomic counters will be initialized from low to high offsets.",
                "type": "CHOPPar",
                "name": "acchopval0",
                "items": []
            },
            {
                "text": "Str : The constant name, as declared in the shader.",
                "type": "StrPar",
                "name": "constname0",
                "items": []
            },
            {
                "text": "Int : The value to give the constant.",
                "type": "IntPar",
                "name": "constvalue0",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "glslTOP_Class",
        "opLabel": "GLSL",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "glsl",
        "opFilter": "True",
        "long": "The GLSL TOP renders a GLSL [[shader]] into a TOP image. Use the Info DAT to check for compile errors in your shaders.\t\t\n\t\t\t\nThe GLSL TOP can act as a pixel shader, or the more general and complex [[Compute Shader]]. Caveat: Compute Shaders need GLSL 4.30 or later.\t\t\t\n\t\t\t\nRefer to the [[Write a GLSL TOP]] article for more info on using this TOP.\t\t\t\n\t\t\t\nThe GLSL TOP has one docked compute shader as well as a normal GLSL shader. Change he Mode to Compute Shader. it will use the <code>glsl1_compute</code> DAT.\t\t\t\n\t\t\t\nSee the [[:Category:GLSL|GLSL Category]] for more information, and [[Compute Shader]].",
        "short": "The GLSL TOP renders a GLSL [[shader]] into a TOP image.",
        "opCategories": ""
    },
    "hsvadjustTOP": {
        "label": "hsvadjustTOP",
        "members": [
            {
                "text": "RGB : The start color is the hue that the HSV adjustment is centered around. When adjusting a small hue range, this is the color that will be altered. In the example image above, the Start Color color is cyan with a hue value of 180.",
                "type": "RGBPar",
                "name": "startcolorr",
                "items": []
            },
            {
                "text": "RGB : The start color is the hue that the HSV adjustment is centered around. When adjusting a small hue range, this is the color that will be altered. In the example image above, the Start Color color is cyan with a hue value of 180.",
                "type": "RGBPar",
                "name": "startcolorg",
                "items": []
            },
            {
                "text": "RGB : The start color is the hue that the HSV adjustment is centered around. When adjusting a small hue range, this is the color that will be altered. In the example image above, the Start Color color is cyan with a hue value of 180.",
                "type": "RGBPar",
                "name": "startcolorb",
                "items": []
            },
            {
                "text": "Float : This is the range of color from the Start Color that will be adjusted. A range of 1 will only adjust the colors that are the same as the start color. A range of 360 will adjust all colors. For example, a range of 20 and a Start Color of 180 will adjust colors in the hue range of 170-190.",
                "type": "FloatPar",
                "name": "huerange",
                "items": []
            },
            {
                "text": "Float : This controls the falloff from the Hue Range. Higher values give more falloff, blending the hue range softly from hues that are adjusted to hues that are not.",
                "type": "FloatPar",
                "name": "huefalloff",
                "items": []
            },
            {
                "text": "Float : This is the range of saturation to adjust from the saturation of the Start Color. The Range is from 0 to 1.",
                "type": "FloatPar",
                "name": "saturationrange",
                "items": []
            },
            {
                "text": "Float : This controls the falloff from the Saturation Range selected.",
                "type": "FloatPar",
                "name": "saturationfalloff",
                "items": []
            },
            {
                "text": "Float : This is the range of value to adjust from the value of the Start Color. The Range is from 0 to 1.",
                "type": "FloatPar",
                "name": "valuerange",
                "items": []
            },
            {
                "text": "Float : This controls the falloff from the Value Range selected.",
                "type": "FloatPar",
                "name": "valuefalloff",
                "items": []
            },
            {
                "text": "Float : Adjust the hues selected above. The Hue Offset ranges from 0 to 360. For example, if the initial pixel color is 180 then a Hue Offset of 100 will change the hue  of 180 (cyan) to be a hue of 280 (violet).",
                "type": "FloatPar",
                "name": "hueoffset",
                "items": []
            },
            {
                "text": "Float : Adjusts the saturations selected above. This will multiply the saturation values specified by Saturation Range and Falloff parameters above. Setting this to 0 will reduce the selected saturation to 0, setting it to 1 will maintain the current saturation values, and setting it to 2 will make the selected saturation twice as saturated.",
                "type": "FloatPar",
                "name": "saturationmult",
                "items": []
            },
            {
                "text": "Float : Adjusts the values selected above. This will multiply the values specified by Value Range and Falloff parameters above.",
                "type": "FloatPar",
                "name": "valuemult",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The HSV Adjust TOP adjust color values using hue, saturation, and value controls. If you change the Hue Offset, Saturation Multiplier and Value Multiplier without changing any of the other parameters then you will modify the color of all pixels in the image. The other parameters are used to narrow the range of pixels you want to modify based on their hue, saturation and value. For example if you leave the Hue Range untouched but reduce the saturation range, you will cause the TOP to modify only pixels who fall into the new saturation range. The range is the Start Color's saturation + the Range + the Falloff, in this example.",
        "opLabel": "HSV Adjust",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "short": "The HSV Adjust TOP adjust color values using hue, saturation, and value controls.",
        "opType": "hsvadj",
        "opFilter": "True",
        "opClass": "hsvadjustTOP_Class",
        "opCategories": ""
    },
    "hsvtorgbTOP": {
        "label": "hsvtorgbTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "hsvrgb",
        "opLabel": "HSV to RGB",
        "opLicense": "Non-Commercial",
        "opClass": "hsvtorgbTOP_Class",
        "opFilter": "True",
        "short": "",
        "long": "",
        "opCategories": ""
    },
    "importselectTOP": {
        "label": "importselectTOP",
        "members": [
            {
                "text": "comp : Specify the import parent (eg. USD/FBX COMP) to search for the asset. When no COMP is specified it will by default search in the first import parent in its path.",
                "type": "compPar",
                "name": "parent",
                "items": []
            },
            {
                "text": "minimenu dynamicmenu : Specifies a path to the texture image.",
                "type": "minimenu dynamicmenuPar",
                "name": "texture",
                "items": []
            },
            {
                "text": "pulse : Reloads the asset from the import parent.",
                "type": "pulsePar",
                "name": "reload",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "importselectTOP",
        "opLabel": "Import Select",
        "opClass": "importselectTOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Import Select TOP loads the texture map images such as Color Map, Normal Map, Metallic Map and so forth that are defined in [[FBX COMP]] or [[USD COMP]].",
        "long": "The Import Select TOP loads the texture map images such as Color Map, Normal Map, Metallic Map and so forth that are defined in [[FBX COMP]] or [[USD COMP]]. The image binaries can be encoded within the importing file (e.g. </code>.usdz</code> format) or specified as an external asset with an valid path.\n    \nSee also: [[FBX COMP]], [[USD COMP]]",
        "opCategories": ""
    },
    "inTOP": {
        "label": "inTOP",
        "members": [
            {
                "text": "Str : Creates a pop-up label when the cursor rolls over this Component input.",
                "type": "StrPar",
                "name": "label",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "inTOP_Class",
        "opLabel": "In",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "in",
        "opFilter": "True",
        "long": "The In TOP is used to create a TOP input in a Component. Component inputs are positioned alphanumerically on the left side of the Component.",
        "short": "The In TOP is used to create a TOP input in a Component.",
        "opCategories": ""
    },
    "insideTOP": {
        "label": "insideTOP",
        "members": [
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]].",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "insideTOP_Class",
        "opLabel": "Inside",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "inside",
        "opFilter": "True",
        "long": "The Inside TOP places Input1 'inside' Input2. The alpha of Input2 is used to determine what parts of the Input1 image are visible.",
        "short": "The Inside TOP places Input1 'inside' Input2.",
        "opCategories": ""
    },
    "kinectazureselectTOP": {
        "label": "kinectazureselectTOP",
        "members": [
            {
                "text": "Toggle : Controls whether this TOP is retrieving image data from the device. The primary [[Kinect Azure TOP]] must also be active to receive data.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "TOP : The name of the primary [[Kinect Azure TOP]] that is configuring the camera. The primary TOP controls which camera the select TOP receives data from, as well as all device configuration such as resolution, framerate, etc.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Menu : A list of available image types to capture from the device and display in this TOP. All image types have a second version that is mapped (aligned) to the image space of the other camera so that color and depth image data can be matched. The resolution of the image is controlled by the Color Resolution or Depth Mode parameters of the primary [[Kinect Azure TOP]].",
                "type": "MenuPar",
                "name": "image",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the current image will be remapped to align with images from the other camera. For example, use this feature to create a color camera image that maps to the pixels of the depth camera. The current depth mode and color resolution will be used to do the remapping. Note: Remapping the point cloud image can create artifacts in the distribution of points due to gaps in the remapping algorithm.",
                "type": "TogglePar",
                "name": "remapimage",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the image produced will be delayed so that it corresponds to the most recent data from the body tracking system.",
                "type": "TogglePar",
                "name": "bodyimage",
                "items": []
            },
            {
                "text": "Toggle : Flip the image in the horizontal axis.",
                "type": "TogglePar",
                "name": "mirrorimage",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "kinectazureselectTOP",
        "opLabel": "Kinect Azure Select",
        "opClass": "kinectazureselectTOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows 10 April 2018 or newer",
        "hardware": "An NVIDIA GEFORCE GTX 1070 or better graphics card is required to obtain efficient body tracking data from the camera, although a CPU-only mode can be enabled using the parameters.",
        "short": "The Kinect Azure Select TOP can be used to capture additional images from a Microsoft Kinect Azure camera that is controlled by a [[Kinect Azure TOP]].",
        "long": "The Kinect Azure Select TOP can be used to capture additional images from a Microsoft Kinect Azure camera that is controlled by a [[Kinect Azure TOP]].\n\nThis TOP must be used along with a [[Kinect Azure TOP]].",
        "opCategories": ""
    },
    "kinectazureTOP": {
        "label": "kinectazureTOP",
        "members": [
            {
                "text": "Toggle : Enable or disable the camera. '''Note''' Disabling this TOP will also disable any other operators ([[Kinect Azure Select TOP]] or [[Kinect Azure CHOP]]) that rely on it.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : The serial number of the connected Kinect Azure camera. The TOP will automatically fill the list with all available cameras. Note: Only one Kinect Azure TOP should be connected to a single camera.",
                "type": "StrMenuPar",
                "name": "sensor",
                "items": []
            },
            {
                "text": "Menu : The resolution of images captured by the color camera. Different resolutions may have different aspect ratios. Note: 4096 x 3072 is not supported at 30 FPS.",
                "type": "MenuPar",
                "name": "colorres",
                "items": []
            },
            {
                "text": "Menu : The depth mode controls which of the Kinect's two depth cameras (Wide or Narrow FOV) are used to produce the depth image and whether any 'binning' is used to process the data. In 'binned' modes, 2x2 blocks of pixels are combined to produce a filter, lower resolution image. Note: Body tracking is not supported when using the Passive IR depth mode.",
                "type": "MenuPar",
                "name": "depthmode",
                "items": []
            },
            {
                "text": "Menu : Controls the frame rate of both the color and depth cameras. Some higher camera resolutions are not supported when running at 30FPS. Lower framerates can produce brighter color images in low light conditions.",
                "type": "MenuPar",
                "name": "fps",
                "items": []
            },
            {
                "text": "Toggle : When enabled, body tracking calculations will be done on the CPU rather than on the graphics card. This method is much slower, but does not require a high-powered graphics card to function.",
                "type": "TogglePar",
                "name": "cpu",
                "items": []
            },
            {
                "text": "File : The file path to the onnx model that performs body tracking features. TouchDesigner includes the regular and lite models that are part of the Kinect Azure SDK.",
                "type": "FilePar",
                "name": "modelpath",
                "items": []
            },
            {
                "text": "Menu : Determines how the body tracking model is processed. The default mode runs mostly on the GPU (supports Nvidia, AMD and Intel), but this can also be switched to a CPU mode when a compatible GPU is not available.",
                "type": "MenuPar",
                "name": "proccessingmode",
                "items": []
            },
            {
                "text": "Int : The device number of the GPU to use when there are multiple GPUs in the system. The ordering system may be dependent on the GPU manufacturer.",
                "type": "IntPar",
                "name": "gpu",
                "items": []
            },
            {
                "text": "Menu : Used to indicate when the camera is mounted in a non-upright position. This can help improve body-tracking results.",
                "type": "MenuPar",
                "name": "orientation",
                "items": []
            },
            {
                "text": "Menu : A list of available image types to capture from the device and display in this TOP. All image types have a second version that is mapped (aligned) to the image space of the other camera so that color and depth image data can be matched. The resolution of the image is controlled by the Color Resolution or Depth Mode parameters depending on the type of image selected. Use a [[Kinect Azure Select TOP]] to access additional image types from the same camera.",
                "type": "MenuPar",
                "name": "image",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the current image will be remapped to align with images from the other camera. For example, use this feature to create a color camera image that maps to the pixels of the depth camera.\nThe current depth mode and color resolution will be used to do the remapping.\nNote: Remapping the point cloud image can create artifacts in the distribution of points due to gaps in the remapping algorithm.",
                "type": "TogglePar",
                "name": "remapimage",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the image produced will be delayed so that it corresponds to the most recent data in the body tracking system. The amount of delay may fluctuate based on the power of the processor doing the body tracking and the complexity of the scene. A [[Kinect Azure Select TOP]] can be used at the same time to retrieve the real-time image stream.",
                "type": "TogglePar",
                "name": "bodyimage",
                "items": []
            },
            {
                "text": "Toggle : Flip the image in the horizontal axis.",
                "type": "TogglePar",
                "name": "mirrorimage",
                "items": []
            },
            {
                "text": "Toggle : Enable to allow setting the exposure time manually. When disabled, the camera will automatically choose an exposure based on the light levels and frame rate.\nNote: This feature may not work correctly due to issues in the current Kinect SDK.",
                "type": "TogglePar",
                "name": "manualexposure",
                "items": []
            },
            {
                "text": "Int : Adjust the exposure time of the color image measured in microseconds. The time must be less than one frame.\nNote: This feature may not work correctly due to issues in the current Kinect SDK.",
                "type": "IntPar",
                "name": "exposure",
                "items": []
            },
            {
                "text": "Toggle : Enable to allow setting the camera white balance manually.",
                "type": "TogglePar",
                "name": "manualwhitebalance",
                "items": []
            },
            {
                "text": "Int : Select the temperature in degrees Kelvin used to set the white balance of the image. The value is rounded to the nearest 10 degrees.",
                "type": "IntPar",
                "name": "whitebalance",
                "items": []
            },
            {
                "text": "Int : Used to adjust the brightness of the image from 0 to 255. 128 is the default.",
                "type": "IntPar",
                "name": "brightness",
                "items": []
            },
            {
                "text": "Int : Conrtols the contrast of the color image.",
                "type": "IntPar",
                "name": "contrast",
                "items": []
            },
            {
                "text": "Int : Controls the saturation of the color image.",
                "type": "IntPar",
                "name": "saturation",
                "items": []
            },
            {
                "text": "Int : Adjusts the sharpness of the color image.",
                "type": "IntPar",
                "name": "sharpness",
                "items": []
            },
            {
                "text": "Int : The gain of the color image.",
                "type": "IntPar",
                "name": "gain",
                "items": []
            },
            {
                "text": "Toggle : Enables compensation for bright back lighting in a scene.",
                "type": "TogglePar",
                "name": "backlight",
                "items": []
            },
            {
                "text": "Menu : Select the frequency of the power supply for use in the cameras noise cancellation system.",
                "type": "MenuPar",
                "name": "powerfreq",
                "items": []
            },
            {
                "text": "Int : A delay in microseconds between when the depth and color images are captured. The delay must be less than one frame in length based on the current framerate.",
                "type": "IntPar",
                "name": "depthdelay",
                "items": []
            },
            {
                "text": "Menu : When using more than one Kinect Azure camera, this setting can be used to determine which unit is the master and which are subordinates.",
                "type": "MenuPar",
                "name": "syncmode",
                "items": []
            },
            {
                "text": "Int : A delay in microseconds between when the master unit captures an image and when this device captures an image. (Only applicable for subordinate devices).",
                "type": "IntPar",
                "name": "subdelay",
                "items": []
            },
            {
                "text": "Toggle : Enable or disable the camera. '''Note''' Disabling this TOP will also disable any other operators ([[Kinect Azure Select TOP]] or [[Kinect Azure CHOP]]) that rely on it.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : The serial number of the connected Kinect Azure camera. The TOP will automatically fill the list with all available cameras. Note: Only one Kinect Azure TOP should be connected to a single camera.",
                "type": "StrMenuPar",
                "name": "sensor",
                "items": []
            },
            {
                "text": "Menu : Controls the frame rate of both the color and depth cameras. Some higher camera resolutions are not supported when running at 30FPS. Lower framerates can produce brighter color images in low light conditions.",
                "type": "MenuPar",
                "name": "fps",
                "items": []
            },
            {
                "text": "Menu : The resolution of images captured by the color camera. Different resolutions may have different aspect ratios. Note: 4096 x 3072 is not supported at 30 FPS.",
                "type": "MenuPar",
                "name": "colorres",
                "items": []
            },
            {
                "text": "Menu : The depth mode controls which of the Kinect's two depth cameras (Wide or Narrow FOV) are used to produce the depth image and whether any 'binning' is used to process the data. In 'binned' modes, 2x2 blocks of pixels are combined to produce a filter, lower resolution image. Note: Body tracking is not supported when using the Passive IR depth mode.",
                "type": "MenuPar",
                "name": "depthmode",
                "items": []
            },
            {
                "text": "File : The file path to the onnx model that performs body tracking features. TouchDesigner includes the regular and lite models that are part of the Kinect Azure SDK.",
                "type": "FilePar",
                "name": "modelpath",
                "items": []
            },
            {
                "text": "Menu : Determines how the body tracking model is processed. The default mode runs mostly on the GPU (supports Nvidia, AMD and Intel), but this can also be switched to a CPU mode when a compatible GPU is not available.",
                "type": "MenuPar",
                "name": "proccessingmode",
                "items": []
            },
            {
                "text": "Int : The device number of the GPU to use when there are multiple GPUs in the system. The ordering system may be dependent on the GPU manufacturer.",
                "type": "IntPar",
                "name": "gpu",
                "items": []
            },
            {
                "text": "Menu : Used to indicate when the camera is mounted in a non-upright position. This can help improve body-tracking results.",
                "type": "MenuPar",
                "name": "orientation",
                "items": []
            },
            {
                "text": "Menu : A list of available image types to capture from the device and display in this TOP. All image types have a second version that is mapped (aligned) to the image space of the other camera so that color and depth image data can be matched. The resolution of the image is controlled by the Color Resolution or Depth Mode parameters depending on the type of image selected. Use a [[Kinect Azure Select TOP]] to access additional image types from the same camera.",
                "type": "MenuPar",
                "name": "image",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the current image will be remapped to align with images from the other camera. For example, use this feature to create a color camera image that maps to the pixels of the depth camera.\nThe current depth mode and color resolution will be used to do the remapping.\nNote: Remapping the point cloud image can create artifacts in the distribution of points due to gaps in the remapping algorithm.",
                "type": "TogglePar",
                "name": "remapimage",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the image produced will be delayed so that it corresponds to the most recent data in the body tracking system. The amount of delay may fluctuate based on the power of the processor doing the body tracking and the complexity of the scene. A [[Kinect Azure Select TOP]] can be used at the same time to retrieve the real-time image stream.",
                "type": "TogglePar",
                "name": "bodyimage",
                "items": []
            },
            {
                "text": "Toggle : Flip the image in the horizontal axis.",
                "type": "TogglePar",
                "name": "mirrorimage",
                "items": []
            },
            {
                "text": "Toggle : When enabled, body tracking calculations will be done on the CPU rather than on the graphics card. This method is much slower, but does not require a high-powered graphics card to function.",
                "type": "TogglePar",
                "name": "cpu",
                "items": []
            },
            {
                "text": "Toggle : Enable to allow setting the exposure time manually. When disabled, the camera will automatically choose an exposure based on the light levels and frame rate.\nNote: This feature may not work correctly due to issues in the current Kinect SDK.",
                "type": "TogglePar",
                "name": "manualexposure",
                "items": []
            },
            {
                "text": "Int : Adjust the exposure time of the color image measured in microseconds. The time must be less than one frame.\nNote: This feature may not work correctly due to issues in the current Kinect SDK.",
                "type": "IntPar",
                "name": "exposure",
                "items": []
            },
            {
                "text": "Toggle : Enable to allow setting the camera white balance manually.",
                "type": "TogglePar",
                "name": "manualwhitebalance",
                "items": []
            },
            {
                "text": "Int : Select the temperature in degrees Kelvin used to set the white balance of the image. The value is rounded to the nearest 10 degrees.",
                "type": "IntPar",
                "name": "whitebalance",
                "items": []
            },
            {
                "text": "Int : Used to adjust the brightness of the image from 0 to 255. 128 is the default.",
                "type": "IntPar",
                "name": "brightness",
                "items": []
            },
            {
                "text": "Int : Conrtols the contrast of the color image.",
                "type": "IntPar",
                "name": "contrast",
                "items": []
            },
            {
                "text": "Int : Controls the saturation of the color image.",
                "type": "IntPar",
                "name": "saturation",
                "items": []
            },
            {
                "text": "Int : Adjusts the sharpness of the color image.",
                "type": "IntPar",
                "name": "sharpness",
                "items": []
            },
            {
                "text": "Int : The gain of the color image.",
                "type": "IntPar",
                "name": "gain",
                "items": []
            },
            {
                "text": "Toggle : Enables compensation for bright back lighting in a scene.",
                "type": "TogglePar",
                "name": "backlight",
                "items": []
            },
            {
                "text": "Menu : Select the frequency of the power supply for use in the cameras noise cancellation system.",
                "type": "MenuPar",
                "name": "powerfreq",
                "items": []
            },
            {
                "text": "Int : A delay in microseconds between when the depth and color images are captured. The delay must be less than one frame in length based on the current framerate.",
                "type": "IntPar",
                "name": "depthdelay",
                "items": []
            },
            {
                "text": "Menu : When using more than one Kinect Azure camera, this setting can be used to determine which unit is the master and which are subordinates.",
                "type": "MenuPar",
                "name": "syncmode",
                "items": []
            },
            {
                "text": "Int : A delay in microseconds between when the master unit captures an image and when this device captures an image. (Only applicable for subordinate devices).",
                "type": "IntPar",
                "name": "subdelay",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "kinectazureTOP",
        "opLabel": "Kinect Azure",
        "opClass": "kinectazureTOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows 10 April 2018 or newer",
        "hardware": "An NVIDIA GEFORCE GTX 1070 or better graphics card is required to obtain efficient body tracking data from the camera, although a CPU-only mode can be enabled using the parameters.",
        "short": "The Kinect Azure TOP can be used to configure and capture data from a Microsoft Kinect Azure camera.",
        "long": "The Kinect Azure TOP can be used to configure and capture data from a Microsoft Kinect Azure camera. \n    \nThe TOP can be used to configure the settings of the camera (resolution, frame rate, synchronization, etc) as well to retrieve captured images from either its color or depth cameras. Image data from one camera can be remapped (aligned) to the other camera in order to match color and depth information. Only one Kinect Azure TOP can be connected to a single Kinect camera. To retrieve additional images from the same camera, use a [[Kinect Azure Select TOP]].\n    \nThe Kinect Azure can also extract body tracking information and skeleton positions using the depth camera image. To access this data, use a [[Kinect Azure CHOP]] and set its Kinect TOP parameter to the primary [[Kinect Azure TOP]] that is connected to the device.\n\n'''TIP:''' See Elburz' video on using KinectAzure's point clouds and a bunch of Azure general tips. [https://www.youtube.com/watch?v=P_PjAr2Yzao Kinect Azure Point Cloud in TouchDesigner Tutorial] on the Interactive and Immersive HQ.\n\nSee also [[Kinect Azure CHOP]], [[Kinect Azure Select TOP]], [[Palette:pointRender]], [[Palette:kinectCalibration]], [[Palette:kinectRecorder]], [[Palette:kinectPointcloud]].",
        "opCategories": ""
    },
    "kinectTOP": {
        "label": "kinectTOP",
        "members": [
            {
                "text": "Toggle : When 'On' data is captured from the Kinect sensor.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Choose between Kinect  v1 or Kinect v2 sensors.",
                "type": "MenuPar",
                "name": "hwversion",
                "items": []
            },
            {
                "text": "StrMenu : Selects which Kinect sensor to use. Only available when using Kinect v1.",
                "type": "StrMenuPar",
                "name": "sensor",
                "items": []
            },
            {
                "text": "Menu : Selects between the Color, Depth, Infrared, Player Index, or Color Point Cloud modes.",
                "type": "MenuPar",
                "name": "image",
                "items": []
            },
            {
                "text": "Menu : Only used for Kinect 1 devices. Selects the resolution of the camera capture.",
                "type": "MenuPar",
                "name": "camerares",
                "items": []
            },
            {
                "text": "Menu : Only used for Kinect 1 devices. Specify whether to track full skeleton or seated skeleton.",
                "type": "MenuPar",
                "name": "skeleton",
                "items": []
            },
            {
                "text": "Toggle : Only used for Kinect 1 devices. Enables near mode for the depth camera, which allows the depth camera to see objects as close as 40cm to the camera (instead of the default 80cm).",
                "type": "TogglePar",
                "name": "neardepthmode",
                "items": []
            },
            {
                "text": "Toggle : Flips the image in the y-axis.",
                "type": "TogglePar",
                "name": "mirrorimage",
                "items": []
            },
            {
                "text": "Toggle : Only used for Kinect 2 devices. Enabling this will remap images that are natively from the depth camera (Depth, Infrared, Player Index) to be in the space and resolution of the Color camera instead.",
                "type": "TogglePar",
                "name": "remap",
                "items": []
            },
            {
                "text": "Float : Only used for Kinect 1 devices. For depth pixels that are too close to resolve, this pixel value will be output instead.",
                "type": "FloatPar",
                "name": "tooclosevalue",
                "items": []
            },
            {
                "text": "Float : Only used for Kinect 1 devices. For depth pixels that are too far to resolve, this pixel value will be output instead.",
                "type": "FloatPar",
                "name": "toofarvalue",
                "items": []
            },
            {
                "text": "Float : For depth pixels whose depth can not be determined, output this value instead.",
                "type": "FloatPar",
                "name": "unknownvalue",
                "items": []
            },
            {
                "text": "Menu : When using the 'Color Point Cloud' some pixel's position can not be determined. This parameter controls what value to assign those pixels instead.",
                "type": "MenuPar",
                "name": "unknownpointvalue",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "kinectTOP_Class",
        "opLabel": "Kinect",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "kinect",
        "opFilter": "False",
        "os": "Microsoft Windows",
        "hardware": "This TOP only supports the '''Kinect for Windows''' hardware and the '''Kinect 2''', ''not'' Kinect for Xbox hardware.",
        "long": "The Kinect TOP captures video from the [[Kinect]] depth camera or RGB color camera. \t\t\n\nTo use a Kinect 2 device you need to install the [https://www.microsoft.com/en-ca/download/details.aspx?id=44561 Kinect for Windows 2.0 SDK] or [https://www.microsoft.com/en-ca/download/details.aspx?id=44559 runtime].\t\t\t\n\t\t\t\nTo use the original Kinect 1 device you will need to install the [http://www.microsoft.com/en-ca/download/details.aspx?id=40277 Kinect Runtime 1.8] for builds greater than 12000, or [http://www.microsoft.com/en-us/download/details.aspx?id=36997 Kinect Runtime 1.7] for builds below 12000.\t\t\t\n\nKinect 2 supports color point clouds - getting the camera space positions of the color pixels, outputted as a 32-bit float RGB texture with XYZ in RGB. For use in making point clouds renders.\t\t\t\n\t\t\t\nSee also [[Kinect CHOP]], [[Kinect]] and [[Kinect1]].",
        "short": "The Kinect TOP captures video from the [[Kinect]] depth camera or RGB color camera.",
        "opCategories": ""
    },
    "layoutTOP": {
        "label": "layoutTOP",
        "members": [
            {
                "text": "TOP : Specify the path(s) to a TOP to include in the layout.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Toggle : When 'off', the resolution of the first wired input is used, or a custom resolution can be specified on the Common page. When 'on' and the output resolution is 'Use Input', the Layout TOP's resolution is the first input's resolution scaled up by number of columns horiontally, and the number of rows vertically. For example, if there are 4 input textures and the first one is 1280x720 and Align Left to Right is selected, then the grid size is 4x1 and so the final resolution will be 5120x720 (ie. (1280*4)x(720*1)). However whether off or on, each texture gets an allotted space of the same size. How the texture fits into that space is determined using the Fit parameter.",
                "type": "TogglePar",
                "name": "scaleres",
                "items": []
            },
            {
                "text": "Menu : The menu determines how the inputs are laid out, in row, column , or grid format.",
                "type": "MenuPar",
                "name": "align",
                "items": []
            },
            {
                "text": "Menu : Determines how the input images are fit to the space they are given. Depending on the setting, it will either fit the entire image inside the space given or crop some of the image off.",
                "type": "MenuPar",
                "name": "fit",
                "items": []
            },
            {
                "text": "Int : Maximum number of rows until a new column is started.",
                "type": "IntPar",
                "name": "maxrows",
                "items": []
            },
            {
                "text": "Int : Maximum number of columns until a new row is started.",
                "type": "IntPar",
                "name": "maxcols",
                "items": []
            },
            {
                "text": "RGBA : The color of the border around each input.",
                "type": "RGBAPar",
                "name": "bcolorr",
                "items": []
            },
            {
                "text": "RGBA : The color of the border around each input.",
                "type": "RGBAPar",
                "name": "bcolorg",
                "items": []
            },
            {
                "text": "RGBA : The color of the border around each input.",
                "type": "RGBAPar",
                "name": "bcolorb",
                "items": []
            },
            {
                "text": "RGBA : The color of the border around each input.",
                "type": "RGBAPar",
                "name": "bcolora",
                "items": []
            },
            {
                "text": "Float : The border width for each input. The borders will scale down the input.",
                "type": "FloatPar",
                "name": "borders",
                "items": []
            },
            {
                "text": "RGBA : Color and alpha for the space not covered by the input images.",
                "type": "RGBAPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGBA : Color and alpha for the space not covered by the input images.",
                "type": "RGBAPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGBA : Color and alpha for the space not covered by the input images.",
                "type": "RGBAPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "RGBA : Color and alpha for the space not covered by the input images.",
                "type": "RGBAPar",
                "name": "bgcolora",
                "items": []
            },
            {
                "text": "Toggle : This option allows the Background Color to be pre-multiplied by alpha.",
                "type": "TogglePar",
                "name": "premultrgbbyalpha",
                "items": []
            },
            {
                "text": "Toggle : Fill any area with the background color if it has alpha less than 1.",
                "type": "TogglePar",
                "name": "compover",
                "items": []
            },
            {
                "text": "Menu : The menu attached to this parameter allows you to specify the order in which the changes to your inputs will take place. Changing the Transform order will change where things go much the same way as going a block and turning east gets you to a different place than turning east and then going a block.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "XY : The two fields for Translate allows you to specify transforms in x and y axes for each input image.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : The two fields for Translate allows you to specify transforms in x and y axes for each input image.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "Float : The field for rotation allows you to specify the amount of rotation for each input image.",
                "type": "FloatPar",
                "name": "rotate",
                "items": []
            },
            {
                "text": "XY : The two fields for Scale allows you to specify transforms in x and y axes for each input image.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : The two fields for Scale allows you to specify transforms in x and y axes for each input image.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "layout",
        "opLabel": "Layout",
        "opLicense": "Non-Commercial",
        "opClass": "layoutTOP_Class",
        "opFilter": "True",
        "short": "The Layout TOP positions multiple input TOPs into rows, columns, or grids.",
        "long": "The Layout TOP positions multiple input TOPs into rows, columns, or grids. It can either fit all the TOPs into a specific resolution (determined by the Common page) by scaling the inputs, or it can scale its own resolution to be larger to accomodate the native resolution of the inputs.\n    \nEach input image gets equal area of the output, and the Fit menu determines how each image fits into its designated area.\n\nMultiple inputs can be wired into the Layout TOP, or the TOP parameter can contain paths to multiple TOPs. In the final layout, the TOPs specified in the TOP parameter will appear before the TOPs of the wired inputs if both are used.",
        "opCategories": ""
    },
    "leapmotionTOP": {
        "label": "leapmotionTOP",
        "members": [
            {
                "text": "Toggle : If set, this TOP will capture data from the cameras.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select between Leap Motion V2 or V4/V5 SDKs for tracking. V5 offers the fastest and most stable tracking, V2 offers some legacy features like gestures.",
                "type": "MenuPar",
                "name": "api",
                "items": []
            },
            {
                "text": "Folder : This parameter should point to the location of the library file (.dll on Windows) that corresponds to the selected API version. The dll file can be found in the driver kit downloaded from the Ultra Leap website inside the 'LeapSDK/lib/x64' folder. For V2, the file will be called 'Leap.dll' and for V4/5, it is called 'LeapC.dll'. '''Note:''' This is only applicable for Windows, on MacOS follow the instructions in the '''Installation''' section above for copying the libLeap.dylib file.\n\nFor Gemini V5, first install the tracking software, then set this parameter to C:\\Program Files\\Ultraleap\\LeapSDK\\lib\\x64 where it will find the LeapC.dll file.",
                "type": "FolderPar",
                "name": "libfolder",
                "items": []
            },
            {
                "text": "StrMenu : Select between the two cameras in the Leap Motion Controller.",
                "type": "StrMenuPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "Toggle : Flips the image in X.",
                "type": "TogglePar",
                "name": "flipx",
                "items": []
            },
            {
                "text": "Toggle : Flips the image in Y.",
                "type": "TogglePar",
                "name": "flipy",
                "items": []
            },
            {
                "text": "Toggle : Corrects the image for lens distortion.",
                "type": "TogglePar",
                "name": "correction",
                "items": []
            },
            {
                "text": "Menu : Switches the device to '''H'''ead '''M'''ounted '''D'''isplay mode.",
                "type": "MenuPar",
                "name": "hmd",
                "items": []
            },
            {
                "text": "Toggle : If set, this TOP will capture data from the cameras.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select between Leap Motion V2 or V4/V5 SDKs for tracking. V5 offers the fastest and most stable tracking, V2 offers some legacy features like gestures.",
                "type": "MenuPar",
                "name": "api",
                "items": []
            },
            {
                "text": "Folder : This parameter should point to the location of the library file (.dll on Windows) that corresponds to the selected API version. The dll file can be found in the driver kit downloaded from the Ultra Leap website inside the 'LeapSDK/lib/x64' folder. For V2, the file will be called 'Leap.dll' and for V4, it is called 'LeapC.dll'.\n        \nFor Gemini V5, first install the tracking software, then set this parameter to C:\\Program Files\\Ultraleap\\LeapSDK\\lib\\x64 where it will find the LeapC.dll file.",
                "type": "FolderPar",
                "name": "libfolder",
                "items": []
            },
            {
                "text": "StrMenu : Select between the two cameras in the Leap Motion Controller.",
                "type": "StrMenuPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "Toggle : Flips the image in X.",
                "type": "TogglePar",
                "name": "flipx",
                "items": []
            },
            {
                "text": "Toggle : Flips the image in Y.",
                "type": "TogglePar",
                "name": "flipy",
                "items": []
            },
            {
                "text": "Toggle : Corrects the image for lens distortion.",
                "type": "TogglePar",
                "name": "correction",
                "items": []
            },
            {
                "text": "Menu : Switches the device to '''H'''ead '''M'''ounted '''D'''isplay mode.",
                "type": "MenuPar",
                "name": "hmd",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "leapmotionTOP_Class",
        "opLabel": "Leap Motion",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "leapmotion",
        "opFilter": "False",
        "long": "The Leap Motion TOP gets the image from the [[Leap Motion]] controller's cameras. To enable this feature the option '''Allow Images''' must be turned on in the Leap Motion Control Panel.\n\t\t\n==== Licensing for Leap Motion ====\nTouchDesigner does not include a license to use the Leap Motion hardware or software. Make sure to check with the [https://www.ultraleap.com/ UltraLeap website] regarding any applicable licenses that you may need for your project.\n\n==== Installation ====\nAs of TouchDesigner 2022, the Leap Motion library files are no longer included with the TouchDesigner installer. These files, along with the drivers, are available from the UltraLeap website here: https://developer.leapmotion.com/releases\n* API Version 5 Gemini - Download Gemini v5.6.1\n* API Version 4 Orion - Download Orion Beta v4.1.0\n* API Version 2 Tracking - Download Orion Beta v3.2.1\n\nDepending on your operating system, there are different instructions for installing the library:\n\n'''On Windows:''' You can use the Library Folder parameter to point to the location of the LeapC.dll (Orion/Gemini) or Leap.dll (Version 2/3) files on your system. The file is installed as part of the LeapSDK and the location may vary depending on the version and options selected during installation.\n\n'''On MacOS:''' Requires legacy Mac driver available [https://developer.leapmotion.com/releases/mac-2-3-1 here]. The libLeap.dylib file must be copied into a folder where TouchDesigner can find it (the Library folder parameter is not available on MacOS). The file is available in the LeapSDK/lib folder of the driver package downloaded from UltraLeap. The file can be copied into <code>usr/local/lib</code> so that it is available to all copies of TouchDesigner on the system, or it can be copied into the frameworks folder inside the package contents of a particular TouchDesigner app i.e. <code>TouchDesigner.app/contents/frameworks</code>.\n\nSee also [[Leap Motion]], [[Leap Motion CHOP]]",
        "short": "The Leap Motion TOP gets the image from the Leap Motion Controller's cameras.",
        "opCategories": ""
    },
    "lensdistortTOP": {
        "label": "lensdistortTOP",
        "members": [
            {
                "text": "Toggle : Reverse the lens distortion. This will *mostly* undo the distortion applied by another Lens Distort TOP with the same parameters and Inverse disabled.     The lens distortion algorithm does not have a precise inverse solution, so an approximate method is used which may not match the original image precisely. The quality of the approximation varies depending on the magnitude of the distortion. Additionally, the approximation aglorithm does not use the k3 constant and any content that was lost outside the bounds of the image cannot be recreated.",
                "type": "TogglePar",
                "name": "invert",
                "items": []
            },
            {
                "text": "Float : The first radial distortion constant. The k constants move pixels towards or away from the center of the image. Values greater than 0 produce a barrel or fisheye effect, while values less than zero produce a pillow or pincushion effect. k1 has a larger effect than k3.",
                "type": "FloatPar",
                "name": "k1",
                "items": []
            },
            {
                "text": "Float : The second radial distortion constant. See K1.",
                "type": "FloatPar",
                "name": "k2",
                "items": []
            },
            {
                "text": "Float : The first tangential distortion constant. Tilts the image up and down.",
                "type": "FloatPar",
                "name": "p1",
                "items": []
            },
            {
                "text": "Float : The second tangential distortion constant. Tilts the image left or right.",
                "type": "FloatPar",
                "name": "p2",
                "items": []
            },
            {
                "text": "Float : The third radial distortion constant (not used in the inverse distortion). See K1.",
                "type": "FloatPar",
                "name": "k3",
                "items": []
            },
            {
                "text": "Float : The position in the image that should be the center of the distortion. Depending on the unit mode selected, the position can be entered as an absolute position measured from the bottom-left corner, or as a relative position measured from the center of the image. The unit mode also controls whether the position is measured in pixels or normalized coordinates.",
                "type": "FloatPar",
                "name": "center",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "centerunit",
                "items": []
            },
            {
                "text": "Float : The focal length components of the camera matrix descibed either as normalized resolution-independent values or as pixels. The focal length acts as a scalar on the other distortion parameters. The normalized unit mode can be used for systems that use millimeters or other physical units. Often abbreviated as Fx and Fy. See [https://docs.opencv.org/master/dc/dbb/tutorial_py_calibration.html OpenCV] for details.",
                "type": "FloatPar",
                "name": "focallength",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "focallengthunit",
                "items": []
            },
            {
                "text": "Menu : Determines how the transformed image is arranged inside the final output image space. This value can be useful to preserve the native pixel resolution of the input image, or ensuring a final output resolution and aspect ratio.",
                "type": "MenuPar",
                "name": "layout",
                "items": []
            },
            {
                "text": "Menu : Determines what values are used when the output image exceeds the bounds of the input image.",
                "type": "MenuPar",
                "name": "extendmode",
                "items": []
            },
            {
                "text": "Float : Determines how much of the image is preserved when calculating the optimal post transform. When zero, the optimal transform will include only the region of interest. When one, the transform will include all of the pixels from the input image. This value is equivalent to the 'alpha' value used in OpenCVs getOptimalNewCameraMatrix function.",
                "type": "FloatPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Menu : Choose whether to preform an addition transformation to the image after the lens distortion is applied. This is useful for positioning and scaling the distorted image within the final image frame and can be used to preserve parts of the input image that would be shifted out of frame by the distortion.",
                "type": "MenuPar",
                "name": "transformmode",
                "items": []
            },
            {
                "text": "Float : A new optical center position that allows for shifting the transformed image within the output image frame. Using the same value as the Optical Center parameter will result in no post distortion offset. Using the Optimal Center value will produce the same results as the Optimal transform mode.",
                "type": "FloatPar",
                "name": "newcenter",
                "items": []
            },
            {
                "text": "Menu : Determines how the new center values are interpreted.",
                "type": "MenuPar",
                "name": "newcenterunit",
                "items": []
            },
            {
                "text": "Float : A new focal length that allows for scaling the transformed image relative to output image frame. Using the same value as the Focal Lengths parameter will result in no post distortion scaling. Using the Optimal Focal Length value will produce the same results as the Optimal transform mode.",
                "type": "FloatPar",
                "name": "newfocallength",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "newfocallengthunit",
                "items": []
            },
            {
                "text": "Float : Shifts the distorted image within the output image frame.",
                "type": "FloatPar",
                "name": "centeroffset",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "centeroffsetunit",
                "items": []
            },
            {
                "text": "Float : Performs an additional post-distortion scale on the image. The scale is relative to the original camera matrix, so values greater than 1 will stretch the image, while values less than 1 will shrink it.",
                "type": "FloatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Menu : Crop the transformed image so that only part of the image will appear in the final output. Unless a custom resolution is given, the cropped region will be used to determine the final output resolution.",
                "type": "MenuPar",
                "name": "cropmode",
                "items": []
            },
            {
                "text": "XYZ : Defines a custom cropping region in the order of Left, Bottom, Right, Top. The values can either be as a fraction of the image (0-1) or as pixels of the input image size. Entering the ROI values from an attached Info CHOP will produce the same results as using the Region of Interest cropping mode.",
                "type": "XYZPar",
                "name": "cropregionx",
                "items": []
            },
            {
                "text": "XYZ : Defines a custom cropping region in the order of Left, Bottom, Right, Top. The values can either be as a fraction of the image (0-1) or as pixels of the input image size. Entering the ROI values from an attached Info CHOP will produce the same results as using the Region of Interest cropping mode.",
                "type": "XYZPar",
                "name": "cropregiony",
                "items": []
            },
            {
                "text": "XYZ : Defines a custom cropping region in the order of Left, Bottom, Right, Top. The values can either be as a fraction of the image (0-1) or as pixels of the input image size. Entering the ROI values from an attached Info CHOP will produce the same results as using the Region of Interest cropping mode.",
                "type": "XYZPar",
                "name": "cropregionz",
                "items": []
            },
            {
                "text": "Menu : The units used to interpret the values of the custom cropping region. Can be as fractions (0-1) of the image or as pixels of the input image size.",
                "type": "MenuPar",
                "name": "cropunit",
                "items": []
            },
            {
                "text": "Menu : Determines how the scale values are used.",
                "type": "MenuPar",
                "name": "scaleunit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "lensdistortTOP",
        "opLabel": "Lens Distort",
        "opClass": "lensdistortTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "Applies or removes lens distortion from an image using the Brown-Conrady model.",
        "long": "The Lens Distort TOP applies or removes lens distortion from an image using the [https://en.wikipedia.org/wiki/Distortion_(optics) Brown-Conrady model]. This can be used to rectify images taken from a physical camera, to apply distortion to a rendering for use in augmented reality (AR), or as a visual effect. \n\nThe distortion algorithm used by the Lens Distort TOP can be broken down into three components: radial distortion, tangential distortion and the camera matrix.\n\nRadial distortion shifts pixels in the output relative to their distance from the center of the image (defined by the Optical Center parameter). Radial distortion is controlled by the k1, k2 and k3 constants, with k1 having the greatest effect and k3 the least. Positive k values create a barrel or fisheye effect as if the image was wrapped around the surface of a sphere. Negative k values will bend the image inward to create a pincushion or pillow effect. The equations for radial distortion are:\n\n<syntaxhighlight>x_distorted = x * (1 + k1 * r^2 + k2 * r^4 + k3 * r^6)\n\ny_distorted = y * (1 + k1 * r^2 + k2 * r^4 + k3 * r^6)\n\nwhere, \n  r = distance from center</syntaxhighlight>\n\nTangential distortion shifts pixels as if they were on a surface being tilted away from the camera and is controlled by the p1 and p2 parameters. p1 tilts the image up and down depending on the sign, and p2 tilts the image left and right. The equations for tangential distortion are:\n\n<syntaxhighlight>x_distorted = x + (2 * p1 * x * y + p2 * (r^2 + 2 * x^2))\n\ny_distorted = y + (p1 * (r^2 + 2 * y^2) + 2 * p2 * x * y)\n\nwhere, \n  r = distance from center</syntaxhighlight>\n\nThe camera matrix is defined by the Optical Center and Focal Length parameters and is used to transform the image positions before the distortion is applied. The Optical Center values control where the center of the distortion effect is, while the Focal Length parameters act as a scale on the other effects. The camera matrix is usually represented as a 3x3 matrix:\n\n<syntaxhighlight lang=python>\nfx 0  cx\n0  fy cy\n0  0  1\n</syntaxhighlight>\n    \nDistortion values for a camera lens can be determined using [https://docs.opencv.org/master/dc/dbb/tutorial_py_calibration.html OpenCV calibration routines] or through functions for a particular camera (see [[KinectazureTOP_Class|kinectazureTOP class]]).\n\n<gallery>\nFile:Barrel Distortion.jpg|thumb|Barrel or Fisheye Radial Distortion, k > 0\nFile:Pincushion distort.jpg|thumb|Pillow or Pincushion Radial Distortion, k < 0\nFile:P1 distort.jpg|thumb|Tangential Distortion,   p1 < 0\nFile:P2 distort.jpg|thumb|Tangential Distortion,   p2 < 0\n</gallery>\n\nThe Layout page has parameters to control how the distorted (or undistorted) image is arranged inside the output image frame. These features can be helpful to preserve parts of the input image that might otherwise be projected offscreen, to preserve input image resolution, or to establish a consistent output frame when lens distortion parameters are changing.\n\nFor example, setting the Post Transform parameter to Optimal and keeping Optimal Alpha at 1, the distorted image will be scaled and shifted so that the entire input image is kept within the output frame. Switching the Layout parameter to Native Resolution, will then scale the output resolution so that no detail from the input image is lost. Attaching an [[Info CHOP]] will provide Region of Interest (ROI) bounds that can be used to crop out the original distorted image from the output image.",
        "opCategories": ""
    },
    "levelTOP": {
        "label": "levelTOP",
        "members": [
            {
                "text": "Toggle : This option will clamp pixel values in between 0 and 1. When using higher bit depth floating pixel formats, it is recommended to set it to Unclamped to allow the full range of values to be operated on. Auto should detect the pixel format as set accordingly.",
                "type": "TogglePar",
                "name": "clampinput",
                "items": []
            },
            {
                "text": "Float : Inverts the colors in the image. Black becomes white, white becomes black. Colors invert across the color wheel, so red becomes cyan, blue becomes yellow, green becomes magenta, and so on.",
                "type": "FloatPar",
                "name": "invert",
                "items": []
            },
            {
                "text": "Float : Any pixel with a value less than or equal to this will be black.",
                "type": "FloatPar",
                "name": "blacklevel",
                "items": []
            },
            {
                "text": "Float : Increases or decreases the brightness of an image. Brightness can be considered the arithmetic mean of the RGB channels. The Brightness parameter adds or subtracts an offset into the R, G, and B channels. Low brightness will result in dark tones, while high brightness will wash the color out towards white.",
                "type": "FloatPar",
                "name": "brightness1",
                "items": []
            },
            {
                "text": "Float : The Gamma parameter applies a gamma correction to the image. Gamma is the relationship between the brightness of a pixel as it appears on the screen, and the numerical value of that pixel. This is often represented by a gamma curve. The difference between brightness and gamma is that gamma also affects the ratio of red to green to blue. A straight, linear gamma curve with a value of 1 means no change.",
                "type": "FloatPar",
                "name": "gamma1",
                "items": []
            },
            {
                "text": "Float : Contrast applies a scale factor (gain) to the RGB channels. Increasing contrast will brighten the light areas and darken the dark areas of the image, making the difference between the light and dark areas of the image stronger.",
                "type": "FloatPar",
                "name": "contrast",
                "items": []
            },
            {
                "text": "Float : Any pixel below this value appears black.",
                "type": "FloatPar",
                "name": "inlow",
                "items": []
            },
            {
                "text": "Float : Any pixel above this value appears white.",
                "type": "FloatPar",
                "name": "inhigh",
                "items": []
            },
            {
                "text": "Float : Clamps pixel values to this value or higher.",
                "type": "FloatPar",
                "name": "outlow",
                "items": []
            },
            {
                "text": "Float : Clamps pixel values to this value or lower.",
                "type": "FloatPar",
                "name": "outhigh",
                "items": []
            },
            {
                "text": "Float : Clamps the minimum level of the red channel.",
                "type": "FloatPar",
                "name": "lowr",
                "items": []
            },
            {
                "text": "Float : Clamps the maximum level of the red channel.",
                "type": "FloatPar",
                "name": "highr",
                "items": []
            },
            {
                "text": "Float : Clamps the minimum level of the green channel.",
                "type": "FloatPar",
                "name": "lowg",
                "items": []
            },
            {
                "text": "Float : Clamps the maximum level of the green channel.",
                "type": "FloatPar",
                "name": "highg",
                "items": []
            },
            {
                "text": "Float : Clamps the minimum level of the blue channel.",
                "type": "FloatPar",
                "name": "lowb",
                "items": []
            },
            {
                "text": "Float : Clamps the maximum level of the blue channel.",
                "type": "FloatPar",
                "name": "highb",
                "items": []
            },
            {
                "text": "Float : Clamps the minimum level of the alpha channel.",
                "type": "FloatPar",
                "name": "lowa",
                "items": []
            },
            {
                "text": "Float : Clamps the maximum level of the alpha channel.",
                "type": "FloatPar",
                "name": "higha",
                "items": []
            },
            {
                "text": "Toggle : Turns on stepping (posterizing) and enables the parameters below.",
                "type": "TogglePar",
                "name": "stepping",
                "items": []
            },
            {
                "text": "Float : Posterizes the image into bands or stripes. Number of bands equal to the inverse of this parameter (i.e., 0.25 = 4 bands). Use a default Ramp TOP to easily see this parameter's effect.",
                "type": "FloatPar",
                "name": "stepsize",
                "items": []
            },
            {
                "text": "Float : Offsets the position of the step boundaries.",
                "type": "FloatPar",
                "name": "threshold",
                "items": []
            },
            {
                "text": "Float : Clamps the image's minimum value. (''value'' as in hue, saturation, and ''value'')",
                "type": "FloatPar",
                "name": "clamplow",
                "items": []
            },
            {
                "text": "Float : Clamps the image's maximum value. (''value'' as in hue, saturation, and ''value'')",
                "type": "FloatPar",
                "name": "clamphigh",
                "items": []
            },
            {
                "text": "Float : Softens or blends the boundaries between steps.",
                "type": "FloatPar",
                "name": "soften",
                "items": []
            },
            {
                "text": "Float : A second gamma correction that is added after the Range, RGBA, and Step page adjustments have been applied.",
                "type": "FloatPar",
                "name": "gamma2",
                "items": []
            },
            {
                "text": "Float : Adjust the opacity, or transparency, of the image.",
                "type": "FloatPar",
                "name": "opacity",
                "items": []
            },
            {
                "text": "Float : A second brightness adjustment that is added after the Range, RGBA, and Step page adjustments have been applied.",
                "type": "FloatPar",
                "name": "brightness2",
                "items": []
            },
            {
                "text": "Toggle : Clamps pixel values to this value or lower.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Float : Clamps the image's minimum value. (''value'' as in hue, saturation, and ''value'')",
                "type": "FloatPar",
                "name": "clamplow2",
                "items": []
            },
            {
                "text": "Float : Clamps the image's maximum value. (''value'' as in hue, saturation, and ''value'')",
                "type": "FloatPar",
                "name": "clamphigh2",
                "items": []
            },
            {
                "text": "Toggle : This option makes the color channels pre-multiplied by alpha.",
                "type": "TogglePar",
                "name": "premultrgbbyalpha",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "levelTOP_Class",
        "opLabel": "Level",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "level",
        "opFilter": "True",
        "long": "The Level TOP adjusts image contrast, brightness, gamma, black level, color range, quantization, opacity and more. See also the [[Luma Level TOP]] which preserves hue and saturation more accurately, but is slower.\t\n\t\t\nThe Level TOP's features have been built into one TOP to maximize performance in a single pass. It takes all its parameters to make a lookup table on the CPU, so animating parameters in the Level TOP will decrease its performance as the lookup table is recreated each frame that a parameter changes.",
        "short": "The Level TOP adjusts image contrast, brightness, gamma, black level, color range, quantization, opacity and more.",
        "opCategories": ""
    },
    "limitTOP": {
        "label": "limitTOP",
        "members": [
            {
                "text": "Menu : The wrapping method used when applying limits to the pixel values in the image.",
                "type": "MenuPar",
                "name": "minop",
                "items": []
            },
            {
                "text": "Menu : The wrapping method used when applying limits to the pixel values in the image.",
                "type": "MenuPar",
                "name": "maxop",
                "items": []
            },
            {
                "text": "Float : The minimum value that any of the channels in the output image can have.",
                "type": "FloatPar",
                "name": "min",
                "items": []
            },
            {
                "text": "Float : The maximum value that any of the channels in the output image can have.",
                "type": "FloatPar",
                "name": "max",
                "items": []
            },
            {
                "text": "Toggle : Apply an absolute value function after all other limits and quantizations are calculated e.g. all negatives are made positive.",
                "type": "TogglePar",
                "name": "positive",
                "items": []
            },
            {
                "text": "Toggle : Normalize values in the output image so that they are all scaled and shifted to fall between the Normalized Minimum and Maximum (0 to 1 by default). This operation requires multiple internal render passes and is slightly slower than other limit operations. Normalization is done after all other limits and quantizations are applied.",
                "type": "TogglePar",
                "name": "norm",
                "items": []
            },
            {
                "text": "Float : The minimum value for pixels after normalization.",
                "type": "FloatPar",
                "name": "normmin",
                "items": []
            },
            {
                "text": "Float : The maximum value for pixels after normalization.",
                "type": "FloatPar",
                "name": "normmax",
                "items": []
            },
            {
                "text": "Menu : The function used to quantize the pixel values in the output image.",
                "type": "MenuPar",
                "name": "quantvalue",
                "items": []
            },
            {
                "text": "Float : The quantization step size for pixel values.",
                "type": "FloatPar",
                "name": "vstep",
                "items": []
            },
            {
                "text": "Float : An offset for the quantization step so that it doesn't have to lie on zero.",
                "type": "FloatPar",
                "name": "voffset",
                "items": []
            },
            {
                "text": "Menu : The function used for spacial quantization e.g. quantizing the UV coordinates so that pixel values are merged into larger blocks.",
                "type": "MenuPar",
                "name": "quantpos",
                "items": []
            },
            {
                "text": "Float : The size of the spacial quantization step in UV space (0-1)",
                "type": "FloatPar",
                "name": "posstep",
                "items": []
            },
            {
                "text": "Float : An offset applied to the spacial quantization so that the steps do not have to start at 0,0 (measured in 0-1 UV space).",
                "type": "FloatPar",
                "name": "posoffset",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "limitTOP",
        "opLabel": "Limit",
        "opClass": "limitTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The Limit TOP can limit the pixel values of the input image to fall between a minimum and maximum value, and can quantize the pixels by value or position.",
        "long": "The Limit TOP can limit the pixel values of the input image to fall between a minimum and maximum value, and can quantize the pixels by value or position.\n\nLimiting a channel causes all of its values to lie within the given range. Several different methods are available to determine what happens to values outside of the Minimum/Maximum range.\n\nQuantizing pixel values will snap each channel to the closest allowable value (the \"quantized values\"). Quantizing methods are: Floor, Ceiling, and Round.\n\nQuantizing pixel positions will cause all pixels within the quantization step to take the same value. This is equivalent to lowering the image resolution and then scaling the image back to its original size with no filtering applied.",
        "opCategories": ""
    },
    "lookupTOP": {
        "label": "lookupTOP",
        "members": [
            {
                "text": "Menu : Choose to use a line from the 2nd input (defined using UV coordinates) or CHOP values to define the lookup table.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Float : The Index Range maps the index values to the lookup table's start and end and defaults to 0 and 1. The first parameter represents the start of the lookup table. When the index color has this value, it will index the start of the lookup table. The second parameter represents the end of the lookup table and behaves in the same way. '''Note:''' When the index goes outside of this range, it will '''hold''' on the first or last value of the lookup table.",
                "type": "FloatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Menu : The Index Channel controls how the color from the input is turned into a index to do the lookup. By default, the RGBA Independent option will do a separate lookup in each channel i.e. the red output channel will be based on the red value in the lookup table and the red value in the index image. For other options, like Luminance or RGBA Average, a single index value is calculated from the index color and all channels of the output image will be taken from the same pixel of the lookup table at the given index.",
                "type": "MenuPar",
                "name": "channel",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the Alpha value of the output image is retrieved independently from the lookup table based on the alpha channel of the index image (the first input). This option can reproduce the legacy behavior of using the luminance to lookup the RGB values while using the alpha to separately lookup the alpha value. This option has no effect if using the 'RGBA Independent' or 'Alpha' index channel options since those modes already use the alpha channel as an index.",
                "type": "TogglePar",
                "name": "independentalpha",
                "items": []
            },
            {
                "text": "Float : Set the UV position to use for dark end of the lookup table. In the original image connected to the first input, any pixel with a value of (0,0,0) will be replaced by the value found at this UV position in the image connected to the second input.",
                "type": "FloatPar",
                "name": "darkuv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darkuvunit",
                "items": []
            },
            {
                "text": "Float : Set the UV position to use for light end of the lookup table. In the original image connected to the first input, any pixel with a value of (1,1,1) will be replaced by the value found at this UV position in the image connected to the second input.",
                "type": "FloatPar",
                "name": "lightuv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "lightuvunit",
                "items": []
            },
            {
                "text": "CHOP : Reference the CHOP to use to define the RGBA (A is optional) values in the lookup table.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Toggle : Clamps CHOP values between 0-1.",
                "type": "TogglePar",
                "name": "clampchopvalues",
                "items": []
            },
            {
                "text": "Toggle : Outputs the lookup table itself, instead of replacing the color values of the first input.",
                "type": "TogglePar",
                "name": "displaylookup",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "lookupTOP_Class",
        "opLabel": "Lookup",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "lookup",
        "opFilter": "True",
        "long": "The Lookup TOP replaces color values in the TOP image connected to its first input with values derived from a lookup table created from its second input or a lookup table created using the CHOP parameter. When using the 2nd input, the lookup table is created by defining a line (start and end position) on the TOP image. When using a CHOP the lookup table is created directly from the CHOP's values and the 2nd input is ignored.\t\t\n\t\t\t\nThe Index Range parameter can be used to define the minimum and maximum index values that will map to the first and last values in the lookup table. When the index goes outside of this range, it will '''hold''' on the first or last value of the lookup table.\n\nSee also [[Remap TOP]], [[Displace TOP]].",
        "short": "The Lookup TOP replaces color values in the TOP image connected to its first input with values derived from a lookup table created from its second intput or a lookup table created using the CHOP parameter.",
        "opCategories": ""
    },
    "lumablurTOP": {
        "label": "lumablurTOP",
        "members": [
            {
                "text": "Menu : Determines the mathematical function used to create the blur.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : The greyscale can be any channel of the second input, or composites like luminance and RGB average.",
                "type": "MenuPar",
                "name": "widthchan",
                "items": []
            },
            {
                "text": "Float : The pixel luminance value used for the Black Filter Size parameter below.",
                "type": "FloatPar",
                "name": "blackvalue",
                "items": []
            },
            {
                "text": "Float : The pixel luminance value used for the White Filter Size parameter below.",
                "type": "FloatPar",
                "name": "whitevalue",
                "items": []
            },
            {
                "text": "Int : The amount of blur where the second input is black.",
                "type": "IntPar",
                "name": "blackwidth",
                "items": []
            },
            {
                "text": "Int : The amount of blur where the second input is white.",
                "type": "IntPar",
                "name": "whitewidth",
                "items": []
            },
            {
                "text": "Menu : Sets the extend conditions to determine what happens to the blur at the edge of the image.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "[[image:LumaBlurTOP.png|300px]]\t\t\n\t\t\t\nThe Luma Blur TOP blurs image on a per-pixel basis depending on the luminance or greyscale value of its second input.\t\t\t\n\t\t\t\nThe image is blurred with separate parameters for white and black filter sizes, which correspond to the white and black luminance values of the second input. The minimum is applied where the second input is black, and the maximum is applied where the second input is white.",
        "opLabel": "Luma Blur",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "short": "The Luma Blur TOP blurs image on a per-pixel basis depending on the luminance or greyscale value of its second input.",
        "opType": "lumablur",
        "opFilter": "True",
        "opClass": "lumablurTOP_Class",
        "opCategories": ""
    },
    "lumalevelTOP": {
        "label": "lumalevelTOP",
        "members": [
            {
                "text": "Menu : Determines the source of the image that is adjusted by the parameters. The output is determined by: \t\n <code>InColor * 1/Source * Lookup(Source)</code> \t\t\t\nLookup is the lookup table build by the parameter settings in the TOP.",
                "type": "MenuPar",
                "name": "source",
                "items": []
            },
            {
                "text": "Float : Inverts the colors in the image. Black becomes white, white becomes black. Colors invert across the color wheel, so red becomes cyan, blue becomes yellow, green becomes magenta, and so on.",
                "type": "FloatPar",
                "name": "invert",
                "items": []
            },
            {
                "text": "Float : Any pixel with a value less than or equal to this will be black.",
                "type": "FloatPar",
                "name": "blacklevel",
                "items": []
            },
            {
                "text": "Float : Increases or decreases the brightness of an image. Brightness can considered the arithmetic mean of the RGB channels. The Brightness parameter adds of subtracts an offset into the R, G, and B channels. Low brightness will result in dark tones, while high brightness will wash the color out towards white.",
                "type": "FloatPar",
                "name": "brightness1",
                "items": []
            },
            {
                "text": "Float : The Gamma parameter applies a gamma correction to the image. Gamma is the relationship between the brightness of a pixel as it appears on the screen, and the numerical value of that pixel. This is often represented by a gamma curve. The difference between brightness and gamma is that gamma also effects the ratio of red to green to blue. A straight, linear gamma curve with a value of 1 means no change.",
                "type": "FloatPar",
                "name": "gamma1",
                "items": []
            },
            {
                "text": "Float : Contrast applies a scale factor (gain) to the RGB channels. Increasing contrast will brighten the light areas and darken the dark areas of the image, making the difference between the light and dark areas of the image stronger.",
                "type": "FloatPar",
                "name": "contrast",
                "items": []
            },
            {
                "text": "Float : Any pixel below this value appears black.",
                "type": "FloatPar",
                "name": "inlow",
                "items": []
            },
            {
                "text": "Float : Any pixel above this value appears white.",
                "type": "FloatPar",
                "name": "inhigh",
                "items": []
            },
            {
                "text": "Float : Clamps pixel values to this value or higher.",
                "type": "FloatPar",
                "name": "outlow",
                "items": []
            },
            {
                "text": "Float : Clamps pixel values to this value or lower.",
                "type": "FloatPar",
                "name": "outhigh",
                "items": []
            },
            {
                "text": "Float : Posterizes the image into bands or stripes. Number of bands equal to the inverse of this parameter. (ie. 0.25 = 4 bands) Use a dafault Ramp TOP to easily see this parameter's effect.",
                "type": "FloatPar",
                "name": "stepsize",
                "items": []
            },
            {
                "text": "Float : Offsets the position of the step boundaries.",
                "type": "FloatPar",
                "name": "threshold",
                "items": []
            },
            {
                "text": "Float : Clamps the image's minimum value. (''value'' as in hue, saturation, and ''value'')",
                "type": "FloatPar",
                "name": "clamplow",
                "items": []
            },
            {
                "text": "Float : Clamps the image's maximum value. (''value'' as in hue, saturation, and ''value'')",
                "type": "FloatPar",
                "name": "clamphigh",
                "items": []
            },
            {
                "text": "Float : Softens or blends the boundaries between steps.",
                "type": "FloatPar",
                "name": "soften",
                "items": []
            },
            {
                "text": "Float : A second gamma correction that is added after the Range, RGBA, and Step page adjustments have been applied.",
                "type": "FloatPar",
                "name": "gamma2",
                "items": []
            },
            {
                "text": "Float : Adjsut the opacity, or transparency, of the image.",
                "type": "FloatPar",
                "name": "opacity",
                "items": []
            },
            {
                "text": "Float : A second brightness adjustment that is added after the Range, RGBA, and Step page adjustments have been applied.",
                "type": "FloatPar",
                "name": "brightness2",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "lumalevelTOP_Class",
        "opLabel": "Luma Level",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "lumalevel",
        "opFilter": "True",
        "long": "The Luma Level TOP adjusts image brightness, gamma, black level, quantization, opacity and more. It has similar parameters to the [[Level TOP]], but it maintains the hue and saturation more accurately when you use Gamma and Black Level. \t\t\n\t\t\t\nIn the Level TOP, lowering the gamma will raise the saturation and shift the hue. Luma Level preserves saturation and hue.\t\t\t\n\t\t\t\nIt also includes a Source parameter which allows the level adjustment to be applied only to certain parts of the image. For example, if source is set to Luminance, then the adjustments made with the Luma Level's parameters will be applied to the luminance of the image (ie. Invert = 1 would invert the luminance of the image, not the color).",
        "short": "The Luma Level TOP adjusts image brightness, gamma, black level, quantization, opacity and more.",
        "opCategories": ""
    },
    "mathTOP": {
        "label": "mathTOP",
        "members": [
            {
                "text": "Menu : A menu of unary operations that are performed on each channel as it comes in to the Math TOP include:",
                "type": "MenuPar",
                "name": "preop",
                "items": []
            },
            {
                "text": "Menu : A choice of operations is performed between the channels of the input TOP. Input and output channels are selected by the 'Combine Channels Input' and 'Combine Channels Output' parameters below. The Nth pixel of one channel is combined with the Nth pixel of other channels.",
                "type": "MenuPar",
                "name": "chanop",
                "items": []
            },
            {
                "text": "Menu : A menu (same as Channel Pre OP) is performed as the finale stage upon the channels resulting from the above operations.",
                "type": "MenuPar",
                "name": "postop",
                "items": []
            },
            {
                "text": "Menu : The resulting values can be converted to integers.",
                "type": "MenuPar",
                "name": "integer",
                "items": []
            },
            {
                "text": "Menu : Select which channels are included in the input.",
                "type": "MenuPar",
                "name": "inputmask",
                "items": []
            },
            {
                "text": "Menu : Select which channels are included in the output result.",
                "type": "MenuPar",
                "name": "outputchannels",
                "items": []
            },
            {
                "text": "Float : First, add this value to each pixel of each channel.",
                "type": "FloatPar",
                "name": "preoff",
                "items": []
            },
            {
                "text": "Float : Then multiply by this value.",
                "type": "FloatPar",
                "name": "gain",
                "items": []
            },
            {
                "text": "Float : Then add this value.",
                "type": "FloatPar",
                "name": "postoff",
                "items": []
            },
            {
                "text": "Menu : The math operation performed.",
                "type": "MenuPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Float : Working on all channels, converts the specified From Range (low-high range) into the To Range below.",
                "type": "FloatPar",
                "name": "fromrange",
                "items": []
            },
            {
                "text": "Float : Working on all channels, converts the specified From Range (low-high range) above into this To Range.",
                "type": "FloatPar",
                "name": "torange",
                "items": []
            },
            {
                "text": "Float : Working on the red channel, converts the specified From Range (low-high range) into the To Range below.",
                "type": "FloatPar",
                "name": "fromranger",
                "items": []
            },
            {
                "text": "Float : Working on the red channel, converts the specified From Range (low-high range) above into this To Range.",
                "type": "FloatPar",
                "name": "toranger",
                "items": []
            },
            {
                "text": "Float : Working on the green channel, converts the specified From Range (low-high range) into the To Range below.",
                "type": "FloatPar",
                "name": "fromrangeg",
                "items": []
            },
            {
                "text": "Float : Working on the green channel, converts the specified From Range (low-high range) above into this To Range.",
                "type": "FloatPar",
                "name": "torangeg",
                "items": []
            },
            {
                "text": "Float : Working on the blue channel, converts the specified From Range (low-high range) into the To Range below.",
                "type": "FloatPar",
                "name": "fromrangeb",
                "items": []
            },
            {
                "text": "Float : Working on the blue channel, converts the specified From Range (low-high range) above into this To Range.",
                "type": "FloatPar",
                "name": "torangeb",
                "items": []
            },
            {
                "text": "Float : Working on the alpha channel, converts the specified From Range (low-high range) into the To Range below.",
                "type": "FloatPar",
                "name": "fromrangea",
                "items": []
            },
            {
                "text": "Float : Working on the alpha channel, converts the specified From Range (low-high range) above into this To Range.",
                "type": "FloatPar",
                "name": "torangea",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "mathTOP_Class",
        "opLabel": "Math",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "math",
        "opFilter": "True",
        "long": "The Math TOP performs specific mathematical operations on the pixels of the input image.",
        "short": "The Math TOP performs specific mathematical operations on the pixels of the input image.",
        "opCategories": ""
    },
    "matteTOP": {
        "label": "matteTOP",
        "members": [
            {
                "text": "Float : Changes which image is composited over the other. This has the same effect as physically swapping input1 and input2. Also the same as inverting the alpha channel to input3.",
                "type": "FloatPar",
                "name": "switchinputs",
                "items": []
            },
            {
                "text": "Menu : Select which channel from input3 is used to create the matte.",
                "type": "MenuPar",
                "name": "mattechannel",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "matteTOP_Class",
        "opLabel": "Matte",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "matte",
        "opFilter": "True",
        "long": "The Matte TOP composites input1 over input2 using the specified channel of input3 as a matte. Using the default setting of Matte Channel = Alpha, white (one) pixels in input3's alpha channel will draw input1 over input2, black (or zero) will make input1 transparent, leaving the input2 image at that pixel.",
        "short": "The Matte TOP composites input1 over input2 using a specified channel of input3 as a matte.",
        "opCategories": ""
    },
    "mirrorTOP": {
        "label": "mirrorTOP",
        "members": [
            {
                "text": "joinpair float : The pivot point determines where in the image the Rotate parameter will rotate around.",
                "type": "joinpair floatPar",
                "name": "pivot",
                "items": []
            },
            {
                "text": "nolabel shortvalues dropmenu : Specify the units used to position the pivot point.",
                "type": "nolabel shortvalues dropmenuPar",
                "name": "pivotunit",
                "items": []
            },
            {
                "text": "anglejack : Rotates a copy of the image around the pivot point specified above.",
                "type": "anglejackPar",
                "name": "rotate",
                "items": []
            },
            {
                "text": "dropmenu : This parameter determines what happens at the edge of the image.",
                "type": "dropmenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "toggle : Flips the image in X.",
                "type": "togglePar",
                "name": "flipx",
                "items": []
            },
            {
                "text": "toggle : Flips the image in Y.",
                "type": "togglePar",
                "name": "flipy",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "mirrorTOP",
        "opLabel": "Mirror",
        "opClass": "mirrorTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "Mirrors part of an image on top of itself.",
        "long": "Mirrors part of an image on top of itself.",
        "opCategories": ""
    },
    "monochromeTOP": {
        "label": "monochromeTOP",
        "members": [
            {
                "text": "Float : Adjust the amount of color left in the image. 0 is full color, 1 is full greyscale.",
                "type": "FloatPar",
                "name": "mono",
                "items": []
            },
            {
                "text": "Menu : This menu selects how the monochrome conversion is calculated for the RGB channels.",
                "type": "MenuPar",
                "name": "rgb",
                "items": []
            },
            {
                "text": "Menu : This menu selects how the monochrome conversion is calculated for the alpha channel.",
                "type": "MenuPar",
                "name": "alpha",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "monochromeTOP_Class",
        "opLabel": "Monochrome",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "mono",
        "opFilter": "True",
        "long": "The Monochrome TOP changes an image to greyscale colors. You can choose from a number of different methods to convert the image to greyscale using the RGB and Alpha menus.",
        "short": "The Monochrome TOP changes an image to greyscale colors.",
        "opCategories": ""
    },
    "mosysTOP": {
        "label": "mosysTOP",
        "members": [
            {
                "text": "CHOP : The path to a MoSys CHOP that contains the channel data used to calculate the lens distortion.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "mosysTOP",
        "opLabel": "MoSys",
        "opClass": "mosysTOP_Class",
        "opFilter": "True",
        "opLicense": "Pro",
        "opCategories": "",
        "os": "",
        "hardware": "",
        "short": "The MoSys TOP works with MoSys camera tracking systems to perform simulated lens distortion using channels from a connected [[MoSys CHOP]].",
        "long": "The MoSys TOP works with MoSys camera tracking systems to perform simulated lens distortion using channels from a connected [[MoSys CHOP]]."
    },
    "moviefileinTOP": {
        "label": "moviefileinTOP",
        "members": [
            {
                "text": "File : The path and name of the image or movie file to load. Image and movie formats are those found in [[File Types]].  You can specify files on the internet using <code>http://</code> ... \t\n\t\t\t\nTo treat a folder of images as if they are one movie, specify the folder containing the images instead of a filename. All the files must be the same resolution. It will treat all stills/movies in that folder as if each is a frame in one movie. The order of the images is the alphanumeric. By default the first image has an index of 0, second is 1, etc, regardless of their file names. Overriding the sample rate on the Trim parameter page will let you playback the image sequence at any frame rate.  \t\t\t\n\t\t\t\nUsing an <code>info.xml</code> file in the directory containing a sequence of images allows you to specify the frames per second and an audio file to be used with the sequence of images. Example xml file:\t\t\t\n<syntaxhighlight lang=xml>\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?>\n  <Settings>\n      <attributes fps=\"30.0\" />\n      <audio filename=\"audio.wav\" />\n  </Settings>\n</syntaxhighlight>\nURLs can be used to fetch images and movies. The image or movie is downloaded to the user's Derivative temp directory and is read into the Movie File In TOP.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : Change from 0 to 1 to force the image to reload, useful when the file changes or did not exist at first.",
                "type": "TogglePar",
                "name": "reload",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "reloadpulse",
                "items": []
            },
            {
                "text": "Menu : Specifies the method used to play the movie, there are 3 options.",
                "type": "MenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "Toggle : Movie plays when 1, movie stops when 0.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : This is a speed multiplier which only works when Play Mode is ''Sequential''. A value of 1 is the default playback speed. A value of 2 is double speed, 0.5 is half speed and so on. Negative values will play the movie backwards.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Toggle : Jumps to Cue Point when set to 1. Only available when Play Mode is Sequential.",
                "type": "TogglePar",
                "name": "cue",
                "items": []
            },
            {
                "text": "Pulse : Instantly jumps to the Cue Point position in the movie.",
                "type": "PulsePar",
                "name": "cuepulse",
                "items": []
            },
            {
                "text": "Float : Set any index in the movie as a point to jump to.",
                "type": "FloatPar",
                "name": "cuepoint",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "cuepointunit",
                "items": []
            },
            {
                "text": "Menu : Customize the Cue parameter's behavior.",
                "type": "MenuPar",
                "name": "cuebehavior",
                "items": []
            },
            {
                "text": "Float : This parameter explicitly sets the movie position when Play Mode is set to Specify Index. The units menu on the right lets you specify the index in the following units: Index, Frames, Seconds, and Fraction (percentage). For example, assume you have a movie that internally is 25 fps, and the timeline that is 60 fps. If you set Units to Index and the parameter value to 25, you get the image that is 1 second into the movie. If you set the Units to Frames and set the value to 60 you get the same image at 1 second into the movie.",
                "type": "FloatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "indexunit",
                "items": []
            },
            {
                "text": "Float : Crossfades the beginning and end of the movie together to create a smooth transition when looping. If the movie uses Trim options, it will crossfade Trim Start with Trim End positions.",
                "type": "FloatPar",
                "name": "loopcrossfade",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "loopcrossfadeunit",
                "items": []
            },
            {
                "text": "Int : Sets how many frames to skip before displaying next frame. For example, a StepSize of 30 will display every 30th frame. This timing of movie playback does not change, so with a Step Size of 30 and a sample rate of 30, a new frame will be displayed every second.",
                "type": "IntPar",
                "name": "stepsize",
                "items": []
            },
            {
                "text": "Menu : This menu helps you determine how to treat the audio as the end of a movie approaches. This is needed because of all the cases of playing a movie, like when driving with an index, the TOP will not know if you intend to loop it or not.",
                "type": "MenuPar",
                "name": "audioloop",
                "items": []
            },
            {
                "text": "Menu : Determines how an image sequence is ordered.",
                "type": "MenuPar",
                "name": "imageindexing",
                "items": []
            },
            {
                "text": "Toggle : Interpolates between frames based based on exact time. For example, if the index (in frames) is 1.5, then frames 1 and 2 will be blended 50-50. If the index is 1.7 then 30% of frame 1 is blended with 70% of frame 2 and so on.",
                "type": "TogglePar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Menu : For movies that are stored as fields, where each image is made of two images interleaved together. A 30-frame per second movie would contain 60 fields per second. For each image, the even scanlines of the first field are interleaved with the odd scanlines of the second field. The Movie File In TOP has several ways of dealing with this:",
                "type": "MenuPar",
                "name": "deinterlace",
                "items": []
            },
            {
                "text": "Menu : Where fields are extracted one field at a time, this will extract the Even field first by default, otehrwise it will extract the odd field first. The video industry has not standardized on one or the other.",
                "type": "MenuPar",
                "name": "precedence",
                "items": []
            },
            {
                "text": "Toggle : If enabled, the image/movie will have it's height halved, and the R channel from the pixels on the bottom half will be treated as if they were the alpha channel for the top half. Useful for cases where the image format does not support alpha natively.",
                "type": "TogglePar",
                "name": "bottomhalfalpha",
                "items": []
            },
            {
                "text": "Menu : Premultiplies the image.",
                "type": "MenuPar",
                "name": "multalpha",
                "items": []
            },
            {
                "text": "Toggle : If the input image is 8-bit and [[sRGB]] color space, enable this to have treated as such.",
                "type": "TogglePar",
                "name": "inputsrgb",
                "items": []
            },
            {
                "text": "Menu : When the file can not be loaded for some reason, select what to display instead.",
                "type": "MenuPar",
                "name": "loadingerrorimage",
                "items": []
            },
            {
                "text": "Toggle : Enables the parameters below to set trim in and out points.",
                "type": "TogglePar",
                "name": "trim",
                "items": []
            },
            {
                "text": "Float : Trim the starting point of the movie.",
                "type": "FloatPar",
                "name": "tstart",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "tstartunit",
                "items": []
            },
            {
                "text": "Float : Trim the ending point of the movie.",
                "type": "FloatPar",
                "name": "tend",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "tendunit",
                "items": []
            },
            {
                "text": "Menu : Determines how the Movie File In TOP handles movie positions that lie before the Trim Start position. For example, if Trim Start is set to 1, and the movie's current index is -10, the Extend Left menu determines how the movie position is calculated.",
                "type": "MenuPar",
                "name": "textendleft",
                "items": []
            },
            {
                "text": "Menu : Determines how the Movie File In TOP handles movie positions that lie after the Trim End position. For example, if Trim End is set to 20, and the movie's current index is 25, the Extend Right menu determines how the movie position is calculated.",
                "type": "MenuPar",
                "name": "textendright",
                "items": []
            },
            {
                "text": "Toggle : Turn On to change the sample rate of the movie. When loading an image sequence, use these parameters to set the playback speed for the sequence.",
                "type": "TogglePar",
                "name": "overridesample",
                "items": []
            },
            {
                "text": "Float : Set the sample rate for playback when 'Override Sample Rate' above is On.",
                "type": "FloatPar",
                "name": "samplerate",
                "items": []
            },
            {
                "text": "Int : Sets how many video frames TouchDesigner reads ahead and stores in memory. The Movie File In TOP will read and decode frames of the movie into CPU memory before they are used, this can eliminate pops or stutters in playback that occur from some frames taking too long to decode, other resources accessing the hard drive, or movie looping. When reading a sequence of image, having more Pre Read Frames will allow multiple images to be decode at the same time. This allows playback of heavy file formats such as .exr in real-time, assuming the machine has enough CPU cores.",
                "type": "IntPar",
                "name": "prereadframes",
                "items": []
            },
            {
                "text": "Int : The time (in milliseconds) TouchDesigner will wait for a frame from the hard drive before giving up. If the Disk Read Timeout time is reached, that frame is simply skipped. This also works for network files that are downloaded via http://.",
                "type": "IntPar",
                "name": "frametimeout",
                "items": []
            },
            {
                "text": "Menu : When on, if the Disk Read Timeout is reached TouchDesigner will use the latest available frame in place of the skipped frame.",
                "type": "MenuPar",
                "name": "frametimeoutstrat",
                "items": []
            },
            {
                "text": "Toggle : If this parameter is turned on, then for the first loaded frame the Frame Read Timeout will be ignored, and it will always wait for the first frame to ensure the node always starts up with a valid image.",
                "type": "TogglePar",
                "name": "alwaysloadinitial",
                "items": []
            },
            {
                "text": "Int : The time (in milliseconds) TouchDesigner will wait for a movie to open. If the Disk Open Timout is reached, the Movie File In TOP will stop waiting and make its image all black, with a grey square in the bottom right corner. If the file still isn't opened the next time the TOP cooks, it'll wait again, and do the same. It'll keep doing this until the file is opened, or the open fails.",
                "type": "IntPar",
                "name": "opentimeout",
                "items": []
            },
            {
                "text": "Menu : When on, if the Disk Read Timeout is reached TouchDesigner will use the latest available frame in place of the skipped frame.",
                "type": "MenuPar",
                "name": "uselatestontimeout",
                "items": []
            },
            {
                "text": "Toggle : When enabled, this will use OpenGL features to upload movie images to the GPU asynchronously. This will reduce the cook time of the Movie File In TOP considerably (in the performance monitor the lines that say \"Uploading Image to GPU\" will go down to almost nothing). There is a GPU memory cost to using this feature however. It uses up another (Width * Height * 4 * Read Ahead Size) bytes of GPU memory. If you are having poor results with this feature, make sure your graphics drivers are up to date.",
                "type": "TogglePar",
                "name": "asyncupload",
                "items": []
            },
            {
                "text": "Toggle : Image will not update when set to 0. Movie index will continue to move forward but the output image will not update. This is useful when you are using a Movie Audio CHOP to get audio from the movie, but you don't care about the video.",
                "type": "TogglePar",
                "name": "updateimage",
                "items": []
            },
            {
                "text": "Int : Limit the maximum number of CPUs that will be used to decode certain video codecs that are capable of multi-CPU decoding, such as H264/H265 and Cineform.\tNote that this does not affect multi-threaded decoding for image sequence playback, which is instead controlled by increasing the Pre-Read Frame parameter.",
                "type": "IntPar",
                "name": "maxdecodecpus",
                "items": []
            },
            {
                "text": "Toggle : This option should be used when playing back files that require very high SSD read speeds such as high resolution (4K+) HAP Q files. It greatly improves read performance in those cases. It should not be used for low resolution or low data rate files such as 1080p H264 files. This mode uses what is known as unbuffered reading, which reads directly from the disk into CPU memory owned by TouchDesigner, bypassing a cached memory area owned by the OS. When this option is on, ever read from the file will access the drive. When this option is off it's possible a previous read to the disk may be still reside in the cached memory owned by the OS, and avoid the disk access.",
                "type": "TogglePar",
                "name": "highperfread",
                "items": []
            },
            {
                "text": "Float : When doing high performance reads, this parameter controls the size of the read operations that are done on disk. Whatever the largest operation the codec asks to be done, this is multiplied by the read factor and all subsequent reads will read that much data instead. This can result in higher throughput depending on the drives. For example if a request is made to read 1MB and the factor is set to 3, then instead the operations will read 3MB from the disk and the extra 2MB read will be ready for the next frame and will likely already have the next 2 frames available in CPU RAM.",
                "type": "FloatPar",
                "name": "highperfreadfactor",
                "items": []
            },
            {
                "text": "Toggle : Controls if this node should use hardware decoding via the Nvidia hardware decoder chip. You can check if hardware decoding is being used using the Info CHOP, 'hardware_decode' channel. This parameter does nothing for Hap and NotchLC codecs, which are always hardware decoded.",
                "type": "TogglePar",
                "name": "hwdecode",
                "items": []
            },
            {
                "text": "File : The path and name of the image or movie file to load. Image and movie formats are those found in [[File Types]].  You can specify files on the internet using <code>http://</code> ... \t\n\t\t\t\nTo treat a folder of images as if they are one movie, specify the folder containing the images instead of a filename. All the files must be the same resolution. It will treat all stills/movies in that folder as if each is a frame in one movie. The order of the images is the alphanumeric. By default the first image has an index of 0, second is 1, etc, regardless of their file names. Overriding the sample rate on the Trim parameter page will let you playback the image sequence at any frame rate.  \t\t\t\n\t\t\t\nUsing an <code>info.xml</code> file in the directory containing a sequence of images allows you to specify the frames per second and an audio file to be used with the sequence of images. Example xml file:\t\t\t\n<syntaxhighlight lang=xml>\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?>\n  <Settings>\n      <attributes fps=\"30.0\" />\n      <audio filename=\"audio.wav\" />\n  </Settings>\n</syntaxhighlight>\nURLs can be used to fetch images and movies. The image or movie is downloaded to the user's Derivative temp directory and is read into the Movie File In TOP.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : Change from 0 to 1 to force the image to reload, useful when the file changes or did not exist at first.",
                "type": "TogglePar",
                "name": "reload",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "reloadpulse",
                "items": []
            },
            {
                "text": "Menu : Specifies the method used to play the movie, there are 3 options.",
                "type": "MenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "Toggle : Movie plays when 1, movie stops when 0.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : This is a speed multiplier which only works when Play Mode is ''Sequential''. A value of 1 is the default playback speed. A value of 2 is double speed, 0.5 is half speed and so on. Negative values will play the movie backwards.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Toggle : Jumps to Cue Point when set to 1. Only available when Play Mode is Sequential.",
                "type": "TogglePar",
                "name": "cue",
                "items": []
            },
            {
                "text": "Pulse : Instantly jumps to the Cue Point position in the movie.",
                "type": "PulsePar",
                "name": "cuepulse",
                "items": []
            },
            {
                "text": "Float : Set any index in the movie as a point to jump to.",
                "type": "FloatPar",
                "name": "cuepoint",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "cuepointunit",
                "items": []
            },
            {
                "text": "Menu : Customize the Cue parameter's behavior.",
                "type": "MenuPar",
                "name": "cuebehavior",
                "items": []
            },
            {
                "text": "Float : This parameter explicitly sets the movie position when Play Mode is set to Specify Index. The units menu on the right lets you specify the index in the following units: Index, Frames, Seconds, and Fraction (percentage). For example, assume you have a movie that internally is 25 fps, and the timeline that is 60 fps. If you set Units to Index and the parameter value to 25, you get the image that is 1 second into the movie. If you set the Units to Frames and set the value to 60 you get the same image at 1 second into the movie.",
                "type": "FloatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "indexunit",
                "items": []
            },
            {
                "text": "Float : Crossfades the beginning and end of the movie together to create a smooth transition when looping. If the movie uses Trim options, it will crossfade Trim Start with Trim End positions.",
                "type": "FloatPar",
                "name": "loopcrossfade",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "loopcrossfadeunit",
                "items": []
            },
            {
                "text": "Int : Sets how many frames to skip before displaying next frame. For example, a StepSize of 30 will display every 30th frame. This timing of movie playback does not change, so with a Step Size of 30 and a sample rate of 30, a new frame will be displayed every second.",
                "type": "IntPar",
                "name": "stepsize",
                "items": []
            },
            {
                "text": "Menu : This menu helps you determine how to treat the audio as the end of a movie approaches. This is needed because of all the cases of playing a movie, like when driving with an index, the TOP will not know if you intend to loop it or not.",
                "type": "MenuPar",
                "name": "audioloop",
                "items": []
            },
            {
                "text": "Menu : Determines how an image sequence is ordered.",
                "type": "MenuPar",
                "name": "imageindexing",
                "items": []
            },
            {
                "text": "Str : Set the movie index with a reference to a timecode. Should be a reference to either a CHOP with channels 'hour', 'second', 'minute', 'frame', a DAT with a timecode string in its first cell, or a [[Timecode Class]] object.",
                "type": "StrPar",
                "name": "timecodeop",
                "items": []
            },
            {
                "text": "Toggle : Interpolates between frames based based on exact time. For example, if the index (in frames) is 1.5, then frames 1 and 2 will be blended 50-50. If the index is 1.7 then 30% of frame 1 is blended with 70% of frame 2 and so on.",
                "type": "TogglePar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Menu : For movies that are stored as fields, where each image is made of two images interleaved together. A 30-frame per second movie would contain 60 fields per second. For each image, the even scanlines of the first field are interleaved with the odd scanlines of the second field. The Movie File In TOP has several ways of dealing with this:",
                "type": "MenuPar",
                "name": "deinterlace",
                "items": []
            },
            {
                "text": "Menu : Where fields are extracted one field at a time, this will extract the Even field first by default, otehrwise it will extract the odd field first. The video industry has not standardized on one or the other.",
                "type": "MenuPar",
                "name": "precedence",
                "items": []
            },
            {
                "text": "Toggle : If enabled, the image/movie will have it's height halved, and the R channel from the pixels on the bottom half will be treated as if they were the alpha channel for the top half. Useful for cases where the image format does not support alpha natively.",
                "type": "TogglePar",
                "name": "bottomhalfalpha",
                "items": []
            },
            {
                "text": "Menu : Premultiplies the image.",
                "type": "MenuPar",
                "name": "multalpha",
                "items": []
            },
            {
                "text": "Toggle : If the input image is 8-bit and [[sRGB]] color space, enable this to have treated as such.",
                "type": "TogglePar",
                "name": "inputsrgb",
                "items": []
            },
            {
                "text": "Menu : When the file can not be loaded for some reason, select what to display instead.",
                "type": "MenuPar",
                "name": "loadingerrorimage",
                "items": []
            },
            {
                "text": "Toggle : Enables the parameters below to set trim in and out points.",
                "type": "TogglePar",
                "name": "trim",
                "items": []
            },
            {
                "text": "Float : Trim the starting point of the movie.",
                "type": "FloatPar",
                "name": "tstart",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "tstartunit",
                "items": []
            },
            {
                "text": "Float : Trim the ending point of the movie.",
                "type": "FloatPar",
                "name": "tend",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Index, Frames, Seconds, and Fraction (percentage).",
                "type": "MenuPar",
                "name": "tendunit",
                "items": []
            },
            {
                "text": "Menu : Determines how the Movie File In TOP handles movie positions that lie before the Trim Start position. For example, if Trim Start is set to 1, and the movie's current index is -10, the Extend Left menu determines how the movie position is calculated.",
                "type": "MenuPar",
                "name": "textendleft",
                "items": []
            },
            {
                "text": "Menu : Determines how the Movie File In TOP handles movie positions that lie after the Trim End position. For example, if Trim End is set to 20, and the movie's current index is 25, the Extend Right menu determines how the movie position is calculated.",
                "type": "MenuPar",
                "name": "textendright",
                "items": []
            },
            {
                "text": "Toggle : Turn On to change the sample rate of the movie. When loading an image sequence, use these parameters to set the playback speed for the sequence.",
                "type": "TogglePar",
                "name": "overridesample",
                "items": []
            },
            {
                "text": "Float : Set the sample rate for playback when 'Override Sample Rate' above is On.",
                "type": "FloatPar",
                "name": "samplerate",
                "items": []
            },
            {
                "text": "Int : Sets how many video frames TouchDesigner reads ahead and stores in memory. The Movie File In TOP will read and decode frames of the movie into CPU memory before they are used, this can eliminate pops or stutters in playback that occur from some frames taking too long to decode, other resources accessing the hard drive, or movie looping. When reading a sequence of image, having more Pre Read Frames will allow multiple images to be decode at the same time. This allows playback of heavy file formats such as .exr in real-time, assuming the machine has enough CPU cores.",
                "type": "IntPar",
                "name": "prereadframes",
                "items": []
            },
            {
                "text": "Int : The time (in milliseconds) TouchDesigner will wait for a frame from the hard drive before giving up. If the Disk Read Timeout time is reached, that frame is simply skipped. This also works for network files that are downloaded via http://.",
                "type": "IntPar",
                "name": "frametimeout",
                "items": []
            },
            {
                "text": "Menu : When on, if the Disk Read Timeout is reached TouchDesigner will use the latest available frame in place of the skipped frame.",
                "type": "MenuPar",
                "name": "frametimeoutstrat",
                "items": []
            },
            {
                "text": "Toggle : If this parameter is turned on, then for the first loaded frame the Frame Read Timeout will be ignored, and it will always wait for the first frame to ensure the node always starts up with a valid image.",
                "type": "TogglePar",
                "name": "alwaysloadinitial",
                "items": []
            },
            {
                "text": "Int : The time (in milliseconds) TouchDesigner will wait for a movie to open. If the Disk Open Timout is reached, the Movie File In TOP will stop waiting and make its image all black, with a grey square in the bottom right corner. If the file still isn't opened the next time the TOP cooks, it'll wait again, and do the same. It'll keep doing this until the file is opened, or the open fails.",
                "type": "IntPar",
                "name": "opentimeout",
                "items": []
            },
            {
                "text": "Menu : When on, if the Disk Read Timeout is reached TouchDesigner will use the latest available frame in place of the skipped frame.",
                "type": "MenuPar",
                "name": "uselatestontimeout",
                "items": []
            },
            {
                "text": "Toggle : When enabled, this will use OpenGL features to upload movie images to the GPU asynchronously. This will reduce the cook time of the Movie File In TOP considerably (in the performance monitor the lines that say \"Uploading Image to GPU\" will go down to almost nothing). There is a GPU memory cost to using this feature however. It uses up another (Width * Height * 4 * Read Ahead Size) bytes of GPU memory. If you are having poor results with this feature, make sure your graphics drivers are up to date.",
                "type": "TogglePar",
                "name": "asyncupload",
                "items": []
            },
            {
                "text": "Toggle : Image will not update when set to 0. Movie index will continue to move forward but the output image will not update. This is useful when you are using a Movie Audio CHOP to get audio from the movie, but you don't care about the video.",
                "type": "TogglePar",
                "name": "updateimage",
                "items": []
            },
            {
                "text": "Int : Limit the maximum number of CPUs that will be used to decode certain video codecs that are capable of multi-CPU decoding, such as H264/H265 and Cineform.\tNote that this does not affect multi-threaded decoding for image sequence playback, which is instead controlled by increasing the Pre-Read Frame parameter.",
                "type": "IntPar",
                "name": "maxdecodecpus",
                "items": []
            },
            {
                "text": "Toggle : This option should be used when playing back files that require very high SSD read speeds such as high resolution (4K+) HAP Q files. It greatly improves read performance in those cases. It should not be used for low resolution or low data rate files such as 1080p H264 files.",
                "type": "TogglePar",
                "name": "highperfread",
                "items": []
            },
            {
                "text": "Float : When doing high performance reads, this parameter controls the size of the read operations that are done on disk. Whatever the largest operation the codec asks to be done, this is multiplied by the read factor and all subsequent reads will read that much data instead. This can result in higher throughput depending on the drives. For example if a request is made to read 1MB and the factor is set to 3, then instead the operations will read 3MB from the disk and the extra 2MB read will be ready for the next frame and will likely already have the next 2 frames available in CPU RAM.",
                "type": "FloatPar",
                "name": "highperfreadfactor",
                "items": []
            },
            {
                "text": "Toggle : Controls if this node should use hardware decoding via the Nvidia hardware decoder chip. You can check if hardware decoding is being used using the Info CHOP, 'hardware_decode' channel. This parameter does nothing for Hap and NotchLC codecs, which are always hardware decoded.",
                "type": "TogglePar",
                "name": "hwdecode",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "moviefileinTOP_Class",
        "opLabel": "Movie File In",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "moviefilein",
        "opFilter": "False",
        "long": "The Movie File In TOP loads movies, still images, or a sequence of still images into TOPs. It will read images in <code>.jpg</code>, <code>.gif</code>, <code>.tif</code>, or <code>.bmp</code> format. It will read movies in QuickTime's <code>.mov</code> format, <code>.mp4</code>, <code>.mpg</code>, <code>.mpeg</code>, <code>.avi</code>, <code>.wmv</code>, <code>.dpx</code>, [[GoPro Cineform|Cineform]] and [[Hap]] Q formats (including Hap Q with Alpha).  \n    \nIt also supports the [[NotchLC]] codec, [[EXR]] files (<code>.exr</code>) and some <code>.swf</code> and <code>.flv</code> Flash files as well as DXT1/3/5 and RG compressed <code>.dds</code> files. Images and movies can also be fetched from the web by using <code>http://</code> to specify a URL.\n\nAccess the hardware decoder on Nvidia GPUs with the Hardware Decode parameter on the 'Tune' page. This supports 10 and 12-bit H264/H265s and YUV 444 files on supporting hardware, converted into 16-bit pixel channels. Other codecs that this also decodes include VP8, VP9, JPEG, AV1, VC1.\nMore information [https://developer.nvidia.com/video-encode-and-decode-gpu-support-matrix-new here.]\n\nWhen reading file formats that support higher bit depths such as 10-bit/16-bit/32-bit, an appropriate pixel format will be automatically used as long as the 'Pixel Format' menu on the Common page is left as 'Use Input'. i.e. a 16-bit file will cause each pixel to have 16-bits per color channel automatically.\n\nFor a complete list, see [[File Types]].\t\t\t\n\t\t\t\nExamine the state of a Movie File In TOP by attaching an [[Info CHOP]] to it (see below on Info CHOP). This will show info like movie length, resolution, the number of images per second (the <code>sample_rate</code> channel), and whether there is audio in the file.  It also shows dynamic information like movie open status, current frame, readahead frames and queue size, dropped frame count, CPU decode time and GPU upload time.\t\t\n\nNote that a movie's \"images per second\" (sample_rate) may be different than the timeline's frames per second. When referring to the movie's \"index\", it's in reference to the sequence of images in the movie file, not related to the global project frame rate.\n\t\t\t\nSee also the page on Movie File In TOP optimizations [[Movie Playback]], plus [[Hap]], [[Movie File Out TOP]] and [[GoPro Cineform|Cineform]].",
        "short": "The Movie File In TOP loads movies, still images, or a sequence of still images into TOPs.",
        "opCategories": ""
    },
    "moviefileoutTOP": {
        "label": "moviefileoutTOP",
        "members": [
            {
                "text": "Menu : Output either a movie, image, image sequence, or stop-frame movie.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : Select the video compression codec used to encode the movie.",
                "type": "MenuPar",
                "name": "videocodec",
                "items": []
            },
            {
                "text": "Menu : Choose what file type to use when <span class=\"tipTextTOP\">Type</span> is set to Image.",
                "type": "MenuPar",
                "name": "imagefiletype",
                "items": []
            },
            {
                "text": "Toggle : When enabled, me.fileSuffix will be a unique suffix when used in the file parameter.",
                "type": "TogglePar",
                "name": "uniquesuff",
                "items": []
            },
            {
                "text": "Int : N is the index used in me.fileSuffix. When unique suffix is enabled, N specifies the starting index to increment from when calculating a unique suffix/name.",
                "type": "IntPar",
                "name": "n",
                "items": []
            },
            {
                "text": "File : Sets the path and filename of the movie file that is saved out. The filename must include the file extension such as .mov/.mp4 etc. For movies, generally the .mov file extension will work with the most codecs.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Menu : Options for the pixel format based on the <span class=\"tipTextTOP\">Video Codec</span> selected.",
                "type": "MenuPar",
                "name": "moviepixelformat",
                "items": []
            },
            {
                "text": "CHOP : Specify a CHOP to use as the audio track for the movie. Drag & Drop a CHOP here or manually enter the CHOP's path. '''The CHOP needs to be [[Time_Slice|time-sliced]]'''.",
                "type": "CHOPPar",
                "name": "audiochop",
                "items": []
            },
            {
                "text": "Menu : Select the audio compression codec used to encode the audio.",
                "type": "MenuPar",
                "name": "audiocodec",
                "items": []
            },
            {
                "text": "Menu : The bitrate to write the audio out at.",
                "type": "MenuPar",
                "name": "audiobitrate",
                "items": []
            },
            {
                "text": "Float : Select the quality of the movie compression. NOTE: Some codecs can not output lossless compression.",
                "type": "FloatPar",
                "name": "quality",
                "items": []
            },
            {
                "text": "Float : The frame rate of the movie file created.",
                "type": "FloatPar",
                "name": "fps",
                "items": []
            },
            {
                "text": "Toggle : When this parameter is set to 1, the movie will be recording.",
                "type": "TogglePar",
                "name": "record",
                "items": []
            },
            {
                "text": "Toggle : Pauses the recording.",
                "type": "TogglePar",
                "name": "pause",
                "items": []
            },
            {
                "text": "Pulse : Adds a single frame to the output for each click of the button.  Pause must be '''On''' to enable the Add Frame parameter.",
                "type": "PulsePar",
                "name": "addframe",
                "items": []
            },
            {
                "text": "Int : When outputting sequences of images, this controls the maximum number of threads can be used to output images (one thread per image).",
                "type": "IntPar",
                "name": "maxthread",
                "items": []
            },
            {
                "text": "DAT : The path to a Table DAT that stores header metadata that should be written to the output image or movie file. Header data is written as key-value pairs with the first column storing the keys and the second column storing the associated values. '''Note:''' Currently only supported for EXR files. '''Warning:''' Files may fail to save if the header data conflicts with system headers.",
                "type": "DATPar",
                "name": "headerdat",
                "items": []
            },
            {
                "text": "TOP : When enabled, an additional header will be added to the file that indicates the contents are point data rather than images. This header is used to automatically load the file into a [[Point File In TOP]] rather than a [[Movie File In TOP]] when dragging and dropping.",
                "type": "TOPPar",
                "name": "pointcloud",
                "items": []
            },
            {
                "text": "TOP : The path to the TOP used to specify addition channels to the EXR file. The first 4 channels specified above come from the input connected to the Movie File Out TOP, this TOPs RGBA data can be assigned unique names in the EXR file using the Red, Green, Blue, Alpha parameters below.",
                "type": "TOPPar",
                "name": "inputtop0",
                "items": []
            },
            {
                "text": "Str : Name assigned to the specified TOP's Red channel.",
                "type": "StrPar",
                "name": "inputr0",
                "items": []
            },
            {
                "text": "Str : Name assigned to the specified TOP's Green channel.",
                "type": "StrPar",
                "name": "inputg0",
                "items": []
            },
            {
                "text": "Str : Name assigned to the specified TOP's Blue channel.",
                "type": "StrPar",
                "name": "inputb0",
                "items": []
            },
            {
                "text": "Str : Name assigned to the specified TOP's Alpha channel.",
                "type": "StrPar",
                "name": "inputa0",
                "items": []
            },
            {
                "text": "Toggle : When this is on playback will stall until the file is opened and ready to receive frames, to make sure the frame that was inputted when Record was turned on gets recorded. When this is off recording may start on a later frame, after the file has been opened. Turning this off can avoid a stall in playback, if missing recording some frames at the start is acceptable.",
                "type": "TogglePar",
                "name": "stallforopen",
                "items": []
            },
            {
                "text": "Menu : Select the H.264 profile to use.",
                "type": "MenuPar",
                "name": "profile",
                "items": []
            },
            {
                "text": "Menu : Select from the available presets.",
                "type": "MenuPar",
                "name": "preset",
                "items": []
            },
            {
                "text": "Menu : Select between Constant or Variable bit rate, and regular or high quality bit rate modes.",
                "type": "MenuPar",
                "name": "bitratemode",
                "items": []
            },
            {
                "text": "Float : Set the average bitrate target for the encoding.",
                "type": "FloatPar",
                "name": "avgbitrate",
                "items": []
            },
            {
                "text": "Float : Set the peak bitrate allowed for the encoding.",
                "type": "FloatPar",
                "name": "peakbitrate",
                "items": []
            },
            {
                "text": "Int : Set the number of frames between key-frames (I-frames) while encoding.",
                "type": "IntPar",
                "name": "keyframeinterval",
                "items": []
            },
            {
                "text": "Menu : This setting can effect the final size of the compressed video but depends greatly on the complexity of the scene being encoded. The menu entries refers to the distance between pixels (quarter distance, half distance, or full distance which is a full pixel) as the motion vector precision for motion estimation during video compression. Quarter pixel precision can increase the quality of the motion prediction signal over half pixel precision, and this can sometimes result in better overall size compression if the improved prediction signal can offset the additional bits it takes to encode the higher precision motion vectors.",
                "type": "MenuPar",
                "name": "motionpredict",
                "items": []
            },
            {
                "text": "Toggle : Enables frame slicing in the encoding which can control error resiliance of the video. See [https://en.wikipedia.org/wiki/Flexible_Macroblock_Ordering Flexible Macroblock Ordering] for additional information.",
                "type": "TogglePar",
                "name": "frameslicing",
                "items": []
            },
            {
                "text": "Int : The number of slices to use when Frame Slicing is On.",
                "type": "IntPar",
                "name": "numslices",
                "items": []
            },
            {
                "text": "Menu : Select the EntropyMode to use for H.264.",
                "type": "MenuPar",
                "name": "entropymode",
                "items": []
            },
            {
                "text": "Toggle : [[Hap]] uses a secondary CPU compression stage usually. Encoding video without this compression will result in faster playback, but potentially larger file sizes (which would require faster drives to play back).",
                "type": "TogglePar",
                "name": "hapsecondarycompression",
                "items": []
            },
            {
                "text": "Toggle : When this mode is enabled no file will be written out. This allows testing the performance of all the encoding operations, except for writting the file out to disk. This can be used to remove the disk write speed as a variable when testing encoding performance.",
                "type": "TogglePar",
                "name": "encodetestmode",
                "items": []
            },
            {
                "text": "Toggle : When saving out .dds file, mipmaps can be included if this is enabled. This is primarily used for the [[PreFilter Map TOP]], which will encode special information into the mipmap levels of the texture which needs to be maintained.",
                "type": "TogglePar",
                "name": "mipmaps",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Movie File Out TOP saves a TOP stream out to a movie file (<code>.mov</code>/<code>.mp4</code>) using a variety of codecs, including the H.264/H.265, [[Hap|Hap Q]], [[NotchLC]] and Animation video codecs. It can also save single frame images, image sequences, or stop-frame movies. \t\t\n\t\t\t\nThe [[Export Movie Dialog]] is a user interface built around the Movie File Out TOP.\t\t\t\n\t\t\t\nTo record movies with audio using the Movie File Out TOP, a [[Time_Slicing|Time Sliced]] CHOP with mono or stereo channels of audio is required. If TouchDesigner is running at a lower frame rate than the target video frame rate and a CHOP is specified for audio, the Movie File Out TOP will automatically repeat video frames to ensure the video and audio stay in sync.\t\t\t\n\t\t\t\nRecording a movie without frame drops can be done in non-realtime by turning off the Realtime flag at the top of the user interface.\t\t\t\t\nThe length of the video is not predetermined and depends on the amount of time the Record parameter is on. \t\n\nYou can record a sequence of <code>.tif</code> or <code>.exr</code> files by setting the Type parameter to Image Sequence. When Image File Type is set to OpenEXR, the EXR page has options to record any number of color channels from multiple TOPs into an EXR image file, and can create it with metadata that would get read by a [[Point File In TOP]].\n\t\t\t\n'''H264/H265 NOTE:''' Encoding movies in H.264/H.265 codec is only available with a [[TouchDesigner Commercial|Commercial]] or [[TouchDesigner Pro|Pro]] license. Nvidia graphic hardware is also required.\t\t\t\n\t\n'''*** WARNING - GPU Driver Timeout on long GPU activities ***''' Encoding some formats at high-resolution may be a slow, GPU-intensive operation. Generally only the RGBA BC7 mode for HapQ can suffer from this though. Consequently it will usually take longer than the default 2 seconds per frame that Windows gives the GPU driver to complete an operation. If you see a message saying that Windows has reset the GPU driver, this is the issue you are running into. To fix the issue, create this registry value:\t\t\t\n<code>HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\GraphicsDrivers\\TdrDelay</code><br>\t\t\t\nThe value should be of type <code>REG_DWORD</code>. The value is the number of seconds an operation can take before the OS resets the GPU driver. Set it to something larger, like 20-40 (seconds), depending on the resolution you intend to encode. You must reboot your machine for this setting to take effect. If you still get driver resets, make it even larger.\t\t\t\n\nRecording still images and stop-frame animation can be done by changing the 'Type' parameter. Then the 'Add Frame' pulse button can be pulsed manually or via a script to cause the frames to be written.\n\nSee also [[Movie File In TOP]], [[Recording Movies with Audio]].",
        "short": "The Movie File Out TOP saves a TOP stream out to a [http://www.apple.com/quicktime/ QuickTime] or MP4 (<code>.mp4</code>) movie in a variety of formats, plus the Animation, Cineform and Hap Q video codecs.",
        "opLicense": "Non-Commercial",
        "opLabel": "Movie File Out",
        "opFilter": "True",
        "opType": "moviefileout",
        "opClass": "moviefileoutTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "multiplyTOP": {
        "label": "multiplyTOP",
        "members": [
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]]",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Multiply TOP performs a multiply operation on Input1 and Input2.",
        "short": "The Multiply TOP performs a multiply operation on Input1 and Input2.",
        "opLicense": "Non-Commercial",
        "opLabel": "Multiply",
        "opFilter": "True",
        "opType": "multiply",
        "opClass": "multiplyTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "ncamTOP": {
        "label": "ncamTOP",
        "members": [
            {
                "text": "Toggle : Turn this parameter off to stop receiving image data from the Ncam server. The Ncam server only sends the image streams that are requested by active TOPs. Deactivating the TOP does not deactivate the CHOP.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "CHOP : A link to the Ncam CHOP that is connected to the Ncam server. An Ncam CHOP is required for the TOP to receive any data, but more than one TOP can be connected to the same CHOP.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Menu : Select what type of output this TOP should produce. Some output modes like 'Composite' and 'Distort Input' require an input image from another TOP. Not all image streams may be available from the Ncam server. If a stream is not available, the TOP will produce an error.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "ncamTOP",
        "opLabel": "Ncam",
        "opClass": "ncamTOP_Class",
        "opFilter": "False",
        "opLicense": "Pro",
        "short": "The Ncam TOP can receive image data from an external Ncam Reality tracking system for use in virtual production.",
        "long": "The Ncam TOP can receive image data from an external Ncam Reality tracking system for use in virtual production. To receive data, the TOP must reference an [[Ncam CHOP]] that is connected to the Ncam server. The type of image displayed in the TOP is chosen using the Output parameter. Multiple image streams may be available depending on the server settings, and additional Ncam TOPs can be used to access more than one stream.\n    \nPossible image streams include the primary film stream captured by the external camera, a lens distortion map, and a depth image. The lens distortion map is a 32 bit floating point image where the R and G channels contain coordinates of where that pixel's color data should be taken from. The distortion map is used to warp a rendered image so that it matches the optical properties of an image captured with a physical lens.\n\nThe lens distortion map can be applied to a rendered image by connecting a TOP with the rendered content to the Ncam TOP's input and setting the Output parameter to 'Distort Input'. Additionally, the rendered content can be distorted and composited onto the film content using the 'Composite' option.",
        "opCategories": ""
    },
    "ndiinTOP": {
        "label": "ndiinTOP",
        "members": [
            {
                "text": "Toggle : Receives image data while Active is on.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : Select which source stream to use.",
                "type": "StrMenuPar",
                "name": "name",
                "items": []
            },
            {
                "text": "Str : By default NDI searches using mDNS, which is usually limited to locate networks. To find sources available on machines not reachable by mDNS, this parameter can be filled with a space-separated list of one or more IP address.",
                "type": "StrPar",
                "name": "extraips",
                "items": []
            },
            {
                "text": "Menu : Choose High or Low bandwidth option.",
                "type": "MenuPar",
                "name": "bandwidth",
                "items": []
            },
            {
                "text": "Toggle : <nowiki>Enable hardware decode for NDI|HX encoded video streams. Hardware decoding is not supported for native NDI codec, only NDI|HX (which is H264).</nowiki> The [[NDI Out TOP]] and other software based NDI solutions can only send native NDI, not <nowiki>NDI|HX. Currently only some hardware capture devices support streaming NDI|HX</nowiki>.",
                "type": "TogglePar",
                "name": "hwdecode",
                "items": []
            },
            {
                "text": "Menu : Choose Native or 8-bit pixel format.",
                "type": "MenuPar",
                "name": "inputpixelformat",
                "items": []
            },
            {
                "text": "DAT : Sources can tag themselves as part of one or more 'Groups'. Fill in rows of this table with the names of one or more groups this node is interested in to limited the 'Sources' listed as available.",
                "type": "DATPar",
                "name": "grouptable",
                "items": []
            },
            {
                "text": "Float : The length of the audio buffer in seconds. Audio output is delayed by this amount. For example, if the Buffer Length is 0.1 then the sound will occur 100ms = 0.1 seconds later than received (to keep the buffer full).",
                "type": "FloatPar",
                "name": "audiobuflen",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The NDI In TOP will obtain its image data over IP from other DI\u00ae (Network Data Interface) enabled applications. The [[NDI|NDI\u00ae]] protocol is created by [http://www.newtek.com/ndi/applications/ Newtek].\n    \nAttach an [[Audio NDI CHOP]] to the NDI In DAT to extract audio from the NDI stream. \n\nMetadata can also be sent to the NDI In TOP from an [[NDI Out TOP]] or another system that has attached metadata to the NDI stream. Attach an [[Info DAT]] to the NDI In DAT to get the metadata as text. It is in an XML format. To better see and access the XML, attach an [[XML DAT]] to the Info DAT. \n\nBut you can also send a table-format DAT in the [[NDI Out TOP]] and it will be received in the Info DAT as a table.  \n\nTo send metadata in an NDI stream, see the NDI Out TOP's Metadata DAT parameter.\n\nTo see details of the available NDI streams, use the [[NDI DAT]].\n\t\t\nSee also [[NDI]], [[NDI Out TOP]] and [[NDI DAT]].\n\n'''NOTE for Windows OS - If experiencing connection issues, check Windows firewall settings.'''",
        "short": "The NDI In TOP will obtain its image data over IP from other [[NDI|NDI\u00ae (Network Data Interface)]] enabled applications.",
        "opLabel": "NDI In",
        "opFilter": "False",
        "opType": "ndiin",
        "opClass": "ndiinTOP_Class",
        "opFamily": "TOP",
        "opLicense": "",
        "opCategories": ""
    },
    "ndioutTOP": {
        "label": "ndioutTOP",
        "members": [
            {
                "text": "Toggle : Makes itself available as a source and sends out image data when active.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : Specify the name for this source.",
                "type": "StrPar",
                "name": "name",
                "items": []
            },
            {
                "text": "Str : If this source fails while receivers are connected to it, they will instead try to connect to the specified Failover Source. This format of this should be <code>MACHINENAME (SourceName)</code>. This format is the same as you would see the source listed in the NDI In TOP.",
                "type": "StrPar",
                "name": "failovername",
                "items": []
            },
            {
                "text": "Float : Specify the frame rate to send at. Note that NDI uses the FPS partially as a guide to control how to compress the frames. The higher the FPS, the more compressed the frames will be. So for example sending at 1 FPS will result in higher image quality that sending at 30 FPS.",
                "type": "FloatPar",
                "name": "fps",
                "items": []
            },
            {
                "text": "Menu : When the NDI sending thread isn't able to keep up due to insufficient system resources (usually available CPU time), this controls the resulting behavior of the node.",
                "type": "MenuPar",
                "name": "lowperformancebehavior",
                "items": []
            },
            {
                "text": "Menu : Controls the pixel format the output is encoded into.",
                "type": "MenuPar",
                "name": "outputpixelformat",
                "items": []
            },
            {
                "text": "Toggle : Also sends the alpha channel when this is turned on. If this is off the alpha will be 1.0.",
                "type": "TogglePar",
                "name": "includealpha",
                "items": []
            },
            {
                "text": "DAT : Can be DAT table with a column with the header 'groups'. Each cell listed under that heading is added as one of the NDI groups this output annouces itself as part of.",
                "type": "DATPar",
                "name": "grouptable",
                "items": []
            },
            {
                "text": "CHOP : Specify the [[CHOP]] (containing audio data) to send out on the NDI stream.",
                "type": "CHOPPar",
                "name": "audiochop",
                "items": []
            },
            {
                "text": "DAT : Specify the [[DAT]] (containing the metadata in table format '''or''' valid XML format) to send out on the NDI stream. The metadata can be read in by the [[NDI In TOP]] using an Info DAT.",
                "type": "DATPar",
                "name": "metadata",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The NDI Out TOP will send image and audio data over IP to other [[NDI|Newtek NDI\u00ae (Network Data Interface)]] enabled applications. The [[NDI|NDI\u00ae]] protocol is created by [http://www.newtek.com/ndi/applications/ Newtek].\t\n\t\t\nSee also [[NDI]], [[NDI In TOP]] and [[NDI DAT]].\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "short": "The NDI Out TOP will send image and audio data over IP to other [[NDI|NDI (Network Data Interface)]] enabled applications.",
        "opLicense": "Non-Commercial",
        "opLabel": "NDI Out",
        "opFilter": "True",
        "opType": "ndiout",
        "opClass": "ndioutTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "noiseTOP": {
        "label": "noiseTOP",
        "members": [
            {
                "text": "Menu : The noise function used to generate noise. The functions available are:",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Float : Any number, integer or non-integer, which starts the random number generator. Each number gives completely different noise patterns, but with similar characteristics.",
                "type": "FloatPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Float : The approximate separation between peaks of a noise cycle. It is expressed in Units. Increasing the period stretches the noise pattern out.\t\n\t\t\t\nPeriod is the opposite of frequency. If the period is 2 seconds, the base frequency is 0.5 cycles per second, or 0.5Hz for short. Hz refers to Hertz, the electrical and audio engineer of the 19th century, not the car guy.\t\t\t\n\t\t\t\nIf the Type is set to Random, setting this to zero will produce completely random noise. Otherwise, the period should be greater than zero.",
                "type": "FloatPar",
                "name": "period",
                "items": []
            },
            {
                "text": "Int : The number of higher frequency components to layer on top of the base frequency. The higher this number, the bumpier the noise will be (as long as roughness is not set to zero). 0 harmonics give the base shape.",
                "type": "IntPar",
                "name": "harmon",
                "items": []
            },
            {
                "text": "Float : The factor by which the frequency of the harmonics are increased. It is normally 2. A spread of 3 and a base frequency of 0.1Hz will produce harmonics at 0.3Hz, 0.9Hz, 2.7Hz, etc.. This parameter is only valid for the Harmonic Summation type.",
                "type": "FloatPar",
                "name": "spread",
                "items": []
            },
            {
                "text": "Float : Amount of the Harmonic Gain layered on top of the base frequency.",
                "type": "FloatPar",
                "name": "gain",
                "items": []
            },
            {
                "text": "Float : Controls the effect of the higher frequency noise. When roughness is zero, all harmonics above the base frequency have no effect. At one, all harmonics are equal in amplitude to the base frequency. When roughness is between one and zero, the amplitude of higher harmonics drops off exponentially from the base frequency.\t\n\t\t\t\nThe default roughness is 0.5. This means the amplitude of the first harmonic is 0.5 of the base frequency, the second is 0.25, the third is 0.125. The harmonics are added to the base to give the final shape. The Harmonics parameter and the Roughness parameter must both be non-zero to see the harmonic effects.",
                "type": "FloatPar",
                "name": "rough",
                "items": []
            },
            {
                "text": "Float : Pushes the noise values toward 0, or +1 and -1. (It raises the value to the power of the exponent.) Exponents greater than one will pull the channel toward zero, and powers less than one will pull peaks towards +1 and -1. It is used to reshape the channels.",
                "type": "FloatPar",
                "name": "exp",
                "items": []
            },
            {
                "text": "Float : Defines the noise value's amplitude (a scale on the values output).",
                "type": "FloatPar",
                "name": "amp",
                "items": []
            },
            {
                "text": "Float : Defines the midpoint color of the noise pattern, the default is 0.5 grey.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Toggle : Toggle color or monochrome noise.",
                "type": "TogglePar",
                "name": "mono",
                "items": []
            },
            {
                "text": "Toggle : Controls if the noise takes aspect ratio into account when calculating it's noise coordinates. When this is off, the noise will stretch to fit a non-square aspect ratio texture.",
                "type": "TogglePar",
                "name": "aspectcorrect",
                "items": []
            },
            {
                "text": "Menu : The menu attached to this parameter allows you to specify the order in which the transforms will take place. Changing the Transform order will change where things go much the same way as going a block and turning east gets you to a different place than turning east and then going a block.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : The rotational matrix presented when you click on this option allows you to set the transform order for the rotations. As with transform order (above), changing the order in which the rotations take place will alter the final position.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : Translate the sampling plane through the noise space.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Translate the sampling plane through the noise space.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Translate the sampling plane through the noise space.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : Rotate the sampling plane in the noise space.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : Rotate the sampling plane in the noise space.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : Rotate the sampling plane in the noise space.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : Scale the sampling plane.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : Scale the sampling plane.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : Scale the sampling plane.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : Control the pivot for the transform of the sampling plane.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : Control the pivot for the transform of the sampling plane.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : Control the pivot for the transform of the sampling plane.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            },
            {
                "text": "Float : When doing 4D noise, this applies a translation to the 4th coordinate. The previous transformation parameters do not affect the 4th coordinate.",
                "type": "FloatPar",
                "name": "t4d",
                "items": []
            },
            {
                "text": "Float : When doing 4D noise, this applies a scale to the 4th coordinate.",
                "type": "FloatPar",
                "name": "s4d",
                "items": []
            },
            {
                "text": "Menu : When an input is connected to the Noise TOP, the noise pattern is placed over the input image using UV coordinates and the settings from this menu.",
                "type": "MenuPar",
                "name": "rgb",
                "items": []
            },
            {
                "text": "Float : Adjusts how much of the input image is added to the output.",
                "type": "FloatPar",
                "name": "inputscale",
                "items": []
            },
            {
                "text": "Float : Adjusts how much of the noise is added to the output.",
                "type": "FloatPar",
                "name": "noisescale",
                "items": []
            },
            {
                "text": "Menu : Sets the alpha channel for the output image.",
                "type": "MenuPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Toggle : Dithers the output to help deal with banding and other artifacts created by precision limitations of 8-bit displays.",
                "type": "TogglePar",
                "name": "dither",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Noise TOP generates a variety of noise patterns including perlin, simplex, sparse, alligator and random. Some types of noise run on the CPU, while others are calculated on the GPU. The ones that are calculated on the GPU will have GPU in their name.\n \nThe first input can be combined with the generated noise in various ways depending on the parameters.\n\nThe second input can be used to specify noise coordinates per-pixel. Without a 2nd input connected, the noise coordinates are the 0-1 texture coordinates of the output texture, i.e, the position of the pixel in the output texture. With a 2nd input connected the position of the pixel in the output texture is used to look-up into the 2nd input, and the RGBA of the 2nd input for that sampled pixel will be used as the XYZ and W for the noise coordinate.",
        "short": "The Noise TOP generates a variety of noise patterns including perlin, simplex, sparse, alligator and random.",
        "opLicense": "Non-Commercial",
        "opLabel": "Noise",
        "opFilter": "False",
        "opType": "noise",
        "opClass": "noiseTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "normalmapTOP": {
        "label": "normalmapTOP",
        "members": [
            {
                "text": "Menu : This menu selects how the edges in the image are found. The edges will appear raised or depressed in the output image depending on their slope.",
                "type": "MenuPar",
                "name": "source",
                "items": []
            },
            {
                "text": "Menu : Determines what pixels to use when calculating the slope at each pixel in the image.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Float : When sampling the image, this determines the distance from each pixel to the sample pixel. When units are set to pixels, it is the number of pixels away from the current pixel which is sampled to find edges. A <span class=\"tipTextTOP\">Sample Step</span> of 3 would sample pixels 3 pixels away to look for edges.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Sample Step parameter.",
                "type": "MenuPar",
                "name": "offsetunit",
                "items": []
            },
            {
                "text": "Toggle : Creates a Height Map in the Alpha Channel.",
                "type": "TogglePar",
                "name": "heightmap",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Normal Map TOP takes an input image and creates a normal map by finding edges in the image. This can then be used for bump mapping (See [[Phong MAT]] and [[PBR MAT]]).\n    \nSee also [[Normal Mapping]].",
        "short": "The Normal Map TOP takes an input image and creates a normal map by finding edges in the image.",
        "opLicense": "Non-Commercial",
        "opLabel": "Normal Map",
        "opFilter": "True",
        "opType": "normal",
        "opClass": "normalmapTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "notchTOP": {
        "label": "notchTOP",
        "members": [
            {
                "text": "Toggle : The active state of the node/block. When active, the node will actively render the block. If disabled, the node will release its instance of the block, and unload it if there are no other instances (ie. no other Notch TOPs with the same block). This will allow the block (<code>.dfxdll</code>) to become editable again. If re-activated, the block will be reloaded along with any changes.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : When enabled, all parameters will be cleared. When disabled, it will keep parameter values for exposed parameters of the same name when the Notch Block file changes.",
                "type": "TogglePar",
                "name": "clearparams",
                "items": []
            },
            {
                "text": "File : Specify the .dfxdll file (ie. Notch Block).",
                "type": "FilePar",
                "name": "block",
                "items": []
            },
            {
                "text": "StrMenu : The layer used as the output to the Notch TOP.",
                "type": "StrMenuPar",
                "name": "layer",
                "items": []
            },
            {
                "text": "Menu : A menu to specify the method used for playback of the block.",
                "type": "MenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "Pulse : Initialize the playback of the block. This will reset it to the start, but not move forward with playback.",
                "type": "PulsePar",
                "name": "init",
                "items": []
            },
            {
                "text": "Pulse : Start the playback of the block. This will reset it to the start and begin playback.",
                "type": "PulsePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : Enable playback of the block. When disabled and in Sequential mode the playback will be paused.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : The speed of the playback.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Float : The index of the playback when Index mode is selected.",
                "type": "FloatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Index parameter.",
                "type": "MenuPar",
                "name": "indexunit",
                "items": []
            },
            {
                "text": "Pulse : Purge Video RAM used by the block.",
                "type": "PulsePar",
                "name": "purge",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Notch TOP will load a Notch Block (extension <code>.dfxdll</code>) compiled from [https://www.notch.one/products/notch-builder/ Notch Builder]. For Commercial and Educational licenses there is a limit of 2 active blocks at a resolution 1920x1080.",
        "opLicense": "Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Notch",
        "opClass": "notchTOP_Class",
        "opType": "notch",
        "os": "Microsoft Windows",
        "long": "The Notch TOP will load a Notch Block (extension <code>.dfxdll</code>) compiled from [https://www.notch.one/products/notch-builder/ Notch Builder]. For Commercial and Educational licenses there is a limit of 2 active blocks at a resolution 1920x1080.\n\n'''Note: [https://www.wibu.com/support/user/user-software.html CodeMeter Runtime] v7.60+ is now required to load Notch blocks.''' \n\nLoading the Notch Block into the Notch TOP will generate custom parameters for all the exposed properties in the block. They are split up by page, with each page representing a layer of the block. The output layer can be selected using the 'Layer' parameter.\n\nThe custom parameter labels will be generated using the Exposed Name of the exposed property with any special characters or spaces removed. If the Unique Identifier is custom (and not the default auto-generated value) then it will be used as the name of the custom parameter instead. Using a custom Unique Identifier on all exposed properties is recommended for TouchDesigner.\n\nSee also: [[Notch]]",
        "opCategories": ""
    },
    "nullTOP": {
        "label": "nullTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Null TOP has no effect on the image. It is an instance of the TOP connected to its input. The Null TOP is often used when making reference to a TOP network, allowing new TOPs to be added to the network (upstream) without the need to update the reference.",
        "short": "The Null TOP has no effect on the image. It is an instance of the TOP connected to its input.",
        "opLicense": "Non-Commercial",
        "opLabel": "Null",
        "opFilter": "True",
        "opType": "null",
        "opClass": "nullTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "nvidiabackgroundTOP": {
        "label": "nvidiabackgroundTOP",
        "members": [
            {
                "text": "Folder : The location of the AI model files used to perform the image segmentation. By default, these files are included inside the Config/Models folder inside your TouchDesigner installation folder. You can use this parameter to point to an alternative folder with compatible model files.",
                "type": "FolderPar",
                "name": "modelfolder",
                "items": []
            },
            {
                "text": "Menu : Select the GPU device to run the AI models on. The GPU must be a Nvidia RTX compatible card.",
                "type": "MenuPar",
                "name": "gpu",
                "items": []
            },
            {
                "text": "Menu : Choose which mode to run the AI model in.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "nvidiabackgroundTOP",
        "opLabel": "Nvidia Background",
        "opClass": "nvidiabackgroundTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This TOP uses the AI Green Screening module from the [https://developer.nvidia.com/maxine Nvidia Maxine Video Effects] engine and requires a 20 or 30 series Nvidia RTX card to operate. 40 series cards are not currently supported.",
        "short": "The Nvidia Background TOP uses AI to generates a monochrome key image that separates a person from the background.",
        "long": "The Nvidia Background TOP performs AI image segmentation to separate a person from the background of a given image. Unlike the [[RGB Key TOP]] or the [[Chroma Key TOP]], the background top uses AI to identify the foreground and background portions of the image and does not require a solid background color. The output of the node is a monochrome key image where white pixels indicate the foreground person and black pixels represent the background. Commonly, this key image is used to replace the background of the source image using the [[Matte TOP]] or other compositing nodes.\n\nDue to the time it takes to run the AI model, the output of the Background TOP will be multiple frames behind the original image when processing a video input. For accurate compositing you will want to match the output key image with the original frame that was used to produce it. An easy way to do this is to use a [[Cache TOP]] with the Output Index set to a negative number of frames. When placed between the source video and the compositor input, this will delay the source image so that it synchronizes with the key image.\n\nTip: The AI model is tuned for a single person sitting in front of a webcam. Videos including full body images, multiple people or indirect camera angles may not perform well.\n\nTip: In addition to selecting Performance using the mode parameter, you can also reduce GPU load by reducing the resolution of the input image. The [[Blur TOP]] and [[Level TOP]] may also be useful to refine the output key image before compositing.",
        "opCategories": ""
    },
    "nvidiadenoiseTOP": {
        "label": "nvidiadenoiseTOP",
        "members": [
            {
                "text": "Folder : The location of the AI model files used to perform the image segmentation. By default, these files are included inside the Config/Models folder inside your TouchDesigner installation folder. You can use this parameter to point to an alternative folder with compatible model files.",
                "type": "FolderPar",
                "name": "modelfolder",
                "items": []
            },
            {
                "text": "Menu : Select the GPU device to run the AI models on. The GPU must be a Nvidia RTX compatible card.",
                "type": "MenuPar",
                "name": "gpu",
                "items": []
            },
            {
                "text": "Menu : Choose the type of noise to remove from the source image.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Menu : Choose how much noise to remove from the image. Removing more noise may also remove original details from the source.",
                "type": "MenuPar",
                "name": "strength",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "nvidiadenoiseTOP",
        "opLabel": "Nvidia Denoise",
        "opClass": "nvidiadenoiseTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This TOP uses the [https://developer.nvidia.com/maxine Nvidia Maxine Video Effects] engine and requires a 20 or 30 series Nvidia RTX card to operate. 40 series cards are not currently supported.",
        "short": "The Nvidia Denoise TOP uses AI models to remove different types of noise from a still image or movie.",
        "long": "The Nvidia Denoise TOP uses AI models to remove different types of noise from a still image or movie while retaining original details and crispness. The TOP will reduce different types of noise depending on the setting of the Mode parameter. Each mode can also be set to a low or high strength level to control how much noise is removed. \n\nThe denoising engine only supports videos with a ''width from 80-1920 pixels'' and ''height from 90-1080 pixels''.",
        "opCategories": ""
    },
    "flexTOP": {
        "label": "flexTOP",
        "members": [
            {
                "text": "OBJ : The Actor COMP to grab simulation data from.",
                "type": "OBJPar",
                "name": "comp",
                "items": []
            },
            {
                "text": "Menu : The simulation data to return.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "flexTOP",
        "opLabel": "Nvidia Flex",
        "opClass": "flexTOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This feature is only available on systems with a Nvidia GPU.",
        "short": "The Nvidia Flex TOP can grab the Nvidia Flex simulation data of an [[Actor COMP]]. The Actor COMP must be in a valid [[Flex|Nvidia Flex]] simulation (ie. controlled by an [[Nvidia Flex Solver COMP]]).",
        "long": "The Nvidia Flex TOP can grab the Nvidia Flex simulation data of an [[Actor COMP]]. The Actor COMP must be in a valid [[Flex|Nvidia Flex]] simulation (ie. controlled by an [[Nvidia Flex Solver COMP]]). \n\n\tThe data will be stored in the texture with each color channel storing a data component. Eg. For positional data the resulting texture is 32-bit float RGBA with x positions in the red channel, y positions in the green channel, and z positions in the blue channel.\n\n\tSee also: [[Flex]], [[Nvidia Flex Solver COMP]], [[Actor COMP]], [[Force COMP]]",
        "opCategories": ""
    },
    "flowTOP": {
        "label": "flowTOP",
        "members": [
            {
                "text": "Pulse : Initializes the simulation.",
                "type": "PulsePar",
                "name": "initialize",
                "items": []
            },
            {
                "text": "Pulse : Starts the simulation playback.",
                "type": "PulsePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : The simulation only steps forward when Play = On, when off the simulation is paused.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "OBJ : Specify the [[Camera COMP]] to view the simulation from. Note: Must be camera with Projection = Perspective.",
                "type": "OBJPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "OBJ : Specify the [[Nvidia Flow Emitter COMP]]s to include in the simulation.",
                "type": "OBJPar",
                "name": "emitters",
                "items": []
            },
            {
                "text": "XYZ : The position of the simulation volume's center, in the world. The simulation cannot extend outside of the volume.",
                "type": "XYZPar",
                "name": "simpositionx",
                "items": []
            },
            {
                "text": "XYZ : The position of the simulation volume's center, in the world. The simulation cannot extend outside of the volume.",
                "type": "XYZPar",
                "name": "simpositiony",
                "items": []
            },
            {
                "text": "XYZ : The position of the simulation volume's center, in the world. The simulation cannot extend outside of the volume.",
                "type": "XYZPar",
                "name": "simpositionz",
                "items": []
            },
            {
                "text": "XYZ : The size of the simulation volume in the world. The simulation cannot extend outside of the volume. Also controls the size of simulation blocks, so the total number of blocks in the volume stays the same. Smaller size blocks will require more blocks for the same size simulation. This increases accuracy but makes the simulation more taxing on the GPU as there are more blocks to calculate.",
                "type": "XYZPar",
                "name": "simsizex",
                "items": []
            },
            {
                "text": "XYZ : The size of the simulation volume in the world. The simulation cannot extend outside of the volume. Also controls the size of simulation blocks, so the total number of blocks in the volume stays the same. Smaller size blocks will require more blocks for the same size simulation. This increases accuracy but makes the simulation more taxing on the GPU as there are more blocks to calculate.",
                "type": "XYZPar",
                "name": "simsizey",
                "items": []
            },
            {
                "text": "XYZ : The size of the simulation volume in the world. The simulation cannot extend outside of the volume. Also controls the size of simulation blocks, so the total number of blocks in the volume stays the same. Smaller size blocks will require more blocks for the same size simulation. This increases accuracy but makes the simulation more taxing on the GPU as there are more blocks to calculate.",
                "type": "XYZPar",
                "name": "simsizez",
                "items": []
            },
            {
                "text": "Float : Controls relative memory usage, the fraction of the total simulation blocks that will be allocated. Most simulations will not fill the simulation volume uniformly, so only a small value is needed. High values will cause extremely high memory usage.",
                "type": "FloatPar",
                "name": "memusage",
                "items": []
            },
            {
                "text": "Toggle : Displays the simulation blocks being used. Useful for debugging or optimizing your Flow simulation. Also shows the edges of the simulation volume.",
                "type": "TogglePar",
                "name": "showblocks",
                "items": []
            },
            {
                "text": "Toggle : Displays the bounds of the emitters.",
                "type": "TogglePar",
                "name": "showemitbounds",
                "items": []
            },
            {
                "text": "Toggle : Displays the shapes of the emitters.",
                "type": "TogglePar",
                "name": "showshapes",
                "items": []
            },
            {
                "text": "Float : Controls the update rate of the simulation.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Int : Maximum number of simulation steps per update. A higher number of steps will increase quality for fast moving object at the cost of performance.",
                "type": "IntPar",
                "name": "maxsteps",
                "items": []
            },
            {
                "text": "XYZ : Gravity direction for use with Buoyancy parameter, where amount controls strength of buoyancy force.",
                "type": "XYZPar",
                "name": "gravityx",
                "items": []
            },
            {
                "text": "XYZ : Gravity direction for use with Buoyancy parameter, where amount controls strength of buoyancy force.",
                "type": "XYZPar",
                "name": "gravityy",
                "items": []
            },
            {
                "text": "XYZ : Gravity direction for use with Buoyancy parameter, where amount controls strength of buoyancy force.",
                "type": "XYZPar",
                "name": "gravityz",
                "items": []
            },
            {
                "text": "Float : Higher values reduce velocity faster. Uses exponential decay curve.",
                "type": "FloatPar",
                "name": "veldamping",
                "items": []
            },
            {
                "text": "Float : Compared to damping, fade reduces low velocity values faster. Fade velocity rate is in units per second.",
                "type": "FloatPar",
                "name": "velfade",
                "items": []
            },
            {
                "text": "Float : Higher values reduce smoke faster. Uses exponential decay curve.",
                "type": "FloatPar",
                "name": "smokedamping",
                "items": []
            },
            {
                "text": "Float : Compared to damping, fade reduces low smoke values faster. Fade velocity rate is in units per second.",
                "type": "FloatPar",
                "name": "smokefade",
                "items": []
            },
            {
                "text": "Float : Higher values reduce temperature faster. Uses exponential decay curve.",
                "type": "FloatPar",
                "name": "tempdamping",
                "items": []
            },
            {
                "text": "Float : Compared to damping, fade reduces low temperature values faster. Fade velocity rate is in units per second.",
                "type": "FloatPar",
                "name": "tempfade",
                "items": []
            },
            {
                "text": "Float : Higher values reduce fuel faster. Uses exponential decay curve.",
                "type": "FloatPar",
                "name": "fueldamping",
                "items": []
            },
            {
                "text": "Float : Compared to damping, fade reduces low fuel values faster. Fade velocity rate is in units per second.",
                "type": "FloatPar",
                "name": "fuelfade",
                "items": []
            },
            {
                "text": "Float : Controls amount of rotation turbulence as a multiplier, a value of 0 will result in no vorticity. High values increase turbulent flow while low values increase laminar flow.",
                "type": "FloatPar",
                "name": "vortstrength",
                "items": []
            },
            {
                "text": "Float : Amount of vorticity added from velocity.",
                "type": "FloatPar",
                "name": "vortfromvel",
                "items": []
            },
            {
                "text": "Float : Amount of vorticity added from smoke.",
                "type": "FloatPar",
                "name": "vortfromsmoke",
                "items": []
            },
            {
                "text": "Float : Amount of vorticity added from temperature.",
                "type": "FloatPar",
                "name": "vortfromtemp",
                "items": []
            },
            {
                "text": "Float : Amount of vorticity added from fuel.",
                "type": "FloatPar",
                "name": "vortfromfuel",
                "items": []
            },
            {
                "text": "Float : The baseline vorticity in the simulation.",
                "type": "FloatPar",
                "name": "vortconstant",
                "items": []
            },
            {
                "text": "Float : Specify the minimum temperature required for combustion.",
                "type": "FloatPar",
                "name": "ignitiontemp",
                "items": []
            },
            {
                "text": "Float : Control how much fuel is burned for a given temperature level. Lower Burn per Temp may result in some fuel not burning completely at a certain temperature.",
                "type": "FloatPar",
                "name": "burnpertemp",
                "items": []
            },
            {
                "text": "Float : Controls amount of smoke generated for each unit of combustion (per burn).",
                "type": "FloatPar",
                "name": "smokeperburn",
                "items": []
            },
            {
                "text": "Float : Controls amount of temperature generated for each unit of combustion (per burn).",
                "type": "FloatPar",
                "name": "tempperburn",
                "items": []
            },
            {
                "text": "Float : Controls amount of fuel used for each unit of combustion (per burn).",
                "type": "FloatPar",
                "name": "fuelperburn",
                "items": []
            },
            {
                "text": "Float : Works in conjunction with the parameter Gravity above which sets a vector for use by Buoyancy. Higher values result in greater effect by the Gravity parameter.",
                "type": "FloatPar",
                "name": "buoyancy",
                "items": []
            },
            {
                "text": "Float : The rate of cooling in the system, exponential.",
                "type": "FloatPar",
                "name": "coolingrate",
                "items": []
            },
            {
                "text": "Float : Controls the amount the system's gaseous volume expands.",
                "type": "FloatPar",
                "name": "expansion",
                "items": []
            },
            {
                "text": "Toggle : Enables Volume shadow rendering for the simulation. Shadowing generates light intensity values that overwrite the \"burn\" channel of the grid. Values range from 0 to 1, where 0 is fully shadowed. Shadow visibilty can be controlled by enabling 'Override Emitter Intensity Mask' or by adjusting the 'Burn Intensity Mask', 'Burn Alpha Mask', and 'Burn Color Mask' in [[Nvidia Flow Emitter COMP]]",
                "type": "TogglePar",
                "name": "enableshadow",
                "items": []
            },
            {
                "text": "Toggle : Displays the volume shadow blocks being used. Useful for debugging or optimizing.",
                "type": "TogglePar",
                "name": "drawshadowdebug",
                "items": []
            },
            {
                "text": "Toggle : Automatically adjusts the emitters' render material, so volume shadows are visible. Will override 'Burn Intensity Mask' and 'Intensity Bias' of emitters.",
                "type": "TogglePar",
                "name": "overrideemitter",
                "items": []
            },
            {
                "text": "OBJ : The light source used to generate volume shadow. The light should be a shadow caster. Only the position and orientation of the light are used, color and intensity are ignored.",
                "type": "OBJPar",
                "name": "light",
                "items": []
            },
            {
                "text": "Int : The resolution of the shadow map volume texture. The texture is allocated as a cube, so there will be space for shadowresolution^3 blocks.",
                "type": "IntPar",
                "name": "shadowresolution",
                "items": []
            },
            {
                "text": "Float : The initial fraction of volume shadow blocks to allocate memory for.",
                "type": "FloatPar",
                "name": "shadowminusage",
                "items": []
            },
            {
                "text": "Float : The maximum fraction of volume shadow blocks to allocate memory for.",
                "type": "FloatPar",
                "name": "shadowmaxusage",
                "items": []
            },
            {
                "text": "Float : Scales how dark the shadow will be.",
                "type": "FloatPar",
                "name": "shadowintensityscale",
                "items": []
            },
            {
                "text": "Float : A lower limit for shadow intensity.",
                "type": "FloatPar",
                "name": "shadowminintensity",
                "items": []
            },
            {
                "text": "Float : Allows the burn value in the simulation to control the blend strength of the shadow. Postive values mean burn increases the blend strength, negative values mean burn decreases the blend strength",
                "type": "FloatPar",
                "name": "shadowburnmask",
                "items": []
            },
            {
                "text": "Float : Allows the smoke value in the simulation to control the blend strength of the shadow. Postive values mean smoke increases the blend strength, negative values mean smoke decreases the blend strength",
                "type": "FloatPar",
                "name": "shadowsmokemask",
                "items": []
            },
            {
                "text": "Float : Allows the temperature value in the simulation to control the blend strength of the shadow. Postive values mean temp increases the blend strength, negative values mean temp decreases the blend strength",
                "type": "FloatPar",
                "name": "shadowtempmask",
                "items": []
            },
            {
                "text": "Float : Allows the fuel value in the simulation to control the blend strength of the shadow. Postive values mean fuel increases the blend strength, negative values mean fuel decreases the blend strength",
                "type": "FloatPar",
                "name": "shadowfuelmask",
                "items": []
            },
            {
                "text": "Float : An offset that increases or decreases the blend strength by a constant amount. Parts of the grid with a blend value over 1 will have shadows. Parts of the grid with blend value under 1 will not have shadows. Blend values between 0 and 1 scale the strength of shadow.",
                "type": "FloatPar",
                "name": "shadowblendbias",
                "items": []
            },
            {
                "text": "Pulse : Initializes the simulation.",
                "type": "PulsePar",
                "name": "initialize",
                "items": []
            },
            {
                "text": "Pulse : Starts the simulation playback.",
                "type": "PulsePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : The simulation only steps forward when Play = On, when off the simulation is paused.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "OBJ : Specify the [[Camera COMP]] to view the simulation from. Note: Must be camera with Projection = Perspective.",
                "type": "OBJPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "OBJ : Specify the [[Nvidia Flow Emitter COMP]]s to include in the simulation.",
                "type": "OBJPar",
                "name": "emitters",
                "items": []
            },
            {
                "text": "XYZ : The position of the simulation volume's center, in the world. The simulation cannot extend outside of the volume.",
                "type": "XYZPar",
                "name": "simpositionx",
                "items": []
            },
            {
                "text": "XYZ : The position of the simulation volume's center, in the world. The simulation cannot extend outside of the volume.",
                "type": "XYZPar",
                "name": "simpositiony",
                "items": []
            },
            {
                "text": "XYZ : The position of the simulation volume's center, in the world. The simulation cannot extend outside of the volume.",
                "type": "XYZPar",
                "name": "simpositionz",
                "items": []
            },
            {
                "text": "XYZ : The size of the simulation volume in the world. The simulation cannot extend outside of the volume. Also controls the size of simulation blocks, so the total number of blocks in the volume stays the same. Smaller size blocks will require more blocks for the same size simulation. This increases accuracy but makes the simulation more taxing on the GPU as there are more blocks to calculate.",
                "type": "XYZPar",
                "name": "simsizex",
                "items": []
            },
            {
                "text": "XYZ : The size of the simulation volume in the world. The simulation cannot extend outside of the volume. Also controls the size of simulation blocks, so the total number of blocks in the volume stays the same. Smaller size blocks will require more blocks for the same size simulation. This increases accuracy but makes the simulation more taxing on the GPU as there are more blocks to calculate.",
                "type": "XYZPar",
                "name": "simsizey",
                "items": []
            },
            {
                "text": "XYZ : The size of the simulation volume in the world. The simulation cannot extend outside of the volume. Also controls the size of simulation blocks, so the total number of blocks in the volume stays the same. Smaller size blocks will require more blocks for the same size simulation. This increases accuracy but makes the simulation more taxing on the GPU as there are more blocks to calculate.",
                "type": "XYZPar",
                "name": "simsizez",
                "items": []
            },
            {
                "text": "Float : Controls relative memory usage, the fraction of the total simulation blocks that will be allocated. Most simulations will not fill the simulation volume uniformly, so only a small value is needed. High values will cause extremely high memory usage.",
                "type": "FloatPar",
                "name": "memusage",
                "items": []
            },
            {
                "text": "Toggle : Displays the simulation blocks being used. Useful for debugging or optimizing your Flow simulation. Also shows the edges of the simulation volume.",
                "type": "TogglePar",
                "name": "showblocks",
                "items": []
            },
            {
                "text": "Toggle : Displays the bounds of the emitters.",
                "type": "TogglePar",
                "name": "showemitbounds",
                "items": []
            },
            {
                "text": "Toggle : Displays the shapes of the emitters.",
                "type": "TogglePar",
                "name": "showshapes",
                "items": []
            },
            {
                "text": "Float : Controls the update rate of the simulation.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Int : Maximum number of simulation steps per update. A higher number of steps will increase quality for fast moving object at the cost of performance.",
                "type": "IntPar",
                "name": "maxsteps",
                "items": []
            },
            {
                "text": "Int : Provides two debug render modes in addition to the default of Density. Debug Density gives a \"rainbow\" render, where density is mapped to a colour, and Dubug Velocity converts velocity xyz to an rgb colour.",
                "type": "IntPar",
                "name": "rendermode",
                "items": []
            },
            {
                "text": "XYZ : Gravity direction for use with Buoyancy parameter, where amount controls strength of buoyancy force.",
                "type": "XYZPar",
                "name": "gravityx",
                "items": []
            },
            {
                "text": "XYZ : Gravity direction for use with Buoyancy parameter, where amount controls strength of buoyancy force.",
                "type": "XYZPar",
                "name": "gravityy",
                "items": []
            },
            {
                "text": "XYZ : Gravity direction for use with Buoyancy parameter, where amount controls strength of buoyancy force.",
                "type": "XYZPar",
                "name": "gravityz",
                "items": []
            },
            {
                "text": "Float : Higher values reduce velocity faster. Uses exponential decay curve.",
                "type": "FloatPar",
                "name": "veldamping",
                "items": []
            },
            {
                "text": "Float : Compared to damping, fade reduces low velocity values faster. Fade velocity rate is in units per second.",
                "type": "FloatPar",
                "name": "velfade",
                "items": []
            },
            {
                "text": "Float : Higher values make a sharper appearance, but with more artifacts.",
                "type": "FloatPar",
                "name": "velmaccormackblend",
                "items": []
            },
            {
                "text": "Float : Higher values reduce smoke faster. Uses exponential decay curve.",
                "type": "FloatPar",
                "name": "smokedamping",
                "items": []
            },
            {
                "text": "Float : Compared to damping, fade reduces low smoke values faster. Fade velocity rate is in units per second.",
                "type": "FloatPar",
                "name": "smokefade",
                "items": []
            },
            {
                "text": "Float : Higher values make a sharper appearance, but with more artifacts.",
                "type": "FloatPar",
                "name": "smokemaccormackblend",
                "items": []
            },
            {
                "text": "Float : Higher values reduce temperature faster. Uses exponential decay curve.",
                "type": "FloatPar",
                "name": "tempdamping",
                "items": []
            },
            {
                "text": "Float : Compared to damping, fade reduces low temperature values faster. Fade velocity rate is in units per second.",
                "type": "FloatPar",
                "name": "tempfade",
                "items": []
            },
            {
                "text": "Float : Higher values reduce fuel faster. Uses exponential decay curve.",
                "type": "FloatPar",
                "name": "fueldamping",
                "items": []
            },
            {
                "text": "Float : Compared to damping, fade reduces low fuel values faster. Fade velocity rate is in units per second.",
                "type": "FloatPar",
                "name": "fuelfade",
                "items": []
            },
            {
                "text": "Float : Controls amount of rotation turbulence as a multiplier, a value of 0 will result in no vorticity. High values increase turbulent flow while low values increase laminar flow.",
                "type": "FloatPar",
                "name": "vortstrength",
                "items": []
            },
            {
                "text": "Float : Amount of vorticity added from velocity.",
                "type": "FloatPar",
                "name": "vortfromvel",
                "items": []
            },
            {
                "text": "Float : Amount of vorticity added from smoke.",
                "type": "FloatPar",
                "name": "vortfromsmoke",
                "items": []
            },
            {
                "text": "Float : Amount of vorticity added from temperature.",
                "type": "FloatPar",
                "name": "vortfromtemp",
                "items": []
            },
            {
                "text": "Float : Amount of vorticity added from fuel.",
                "type": "FloatPar",
                "name": "vortfromfuel",
                "items": []
            },
            {
                "text": "Float : The baseline vorticity in the simulation.",
                "type": "FloatPar",
                "name": "vortconstant",
                "items": []
            },
            {
                "text": "Float : Specify the minimum temperature required for combustion.",
                "type": "FloatPar",
                "name": "ignitiontemp",
                "items": []
            },
            {
                "text": "Float : Control how much fuel is burned for a given temperature level. Lower Burn per Temp may result in some fuel not burning completely at a certain temperature.",
                "type": "FloatPar",
                "name": "burnpertemp",
                "items": []
            },
            {
                "text": "Float : Controls amount of smoke generated for each unit of combustion (per burn).",
                "type": "FloatPar",
                "name": "smokeperburn",
                "items": []
            },
            {
                "text": "Float : Controls amount of temperature generated for each unit of combustion (per burn).",
                "type": "FloatPar",
                "name": "tempperburn",
                "items": []
            },
            {
                "text": "Float : Controls amount of fuel used for each unit of combustion (per burn).",
                "type": "FloatPar",
                "name": "fuelperburn",
                "items": []
            },
            {
                "text": "Float : Works in conjunction with the parameter Gravity above which sets a vector for use by Buoyancy. Higher values result in greater effect by the Gravity parameter.",
                "type": "FloatPar",
                "name": "buoyancy",
                "items": []
            },
            {
                "text": "Float : The rate of cooling in the system, exponential.",
                "type": "FloatPar",
                "name": "coolingrate",
                "items": []
            },
            {
                "text": "Float : Controls the amount the system's gaseous volume expands.",
                "type": "FloatPar",
                "name": "expansion",
                "items": []
            },
            {
                "text": "Float : If zero, block allocation and deallocation depend on an internal threshold and weighting of Velocity. If non-zero,  block allocation and deallocation will be affected by the value of Velocity Alloc Threshold.",
                "type": "FloatPar",
                "name": "velallocweight",
                "items": []
            },
            {
                "text": "Float : If Velocity Alloc Weight is non-zero, block allocation and deallocation is based on this value. In particular, if the velocity magnitude is below this threshold, the block will be deallocated, unless smoke and fuel thresholding (see below) are active.",
                "type": "FloatPar",
                "name": "velallocthreshold",
                "items": []
            },
            {
                "text": "Float : If zero, block allocation and deallocation depend on an internal threshold and weighting of Smoke density. If non-zero, smoke density affects block allocation and deallocation based on the value of Smoke Alloc Threshold.",
                "type": "FloatPar",
                "name": "smokeallocweight",
                "items": []
            },
            {
                "text": "Float : If Smoke Alloc Weight is non-zero, block allocation and deallocation is based on this value. In particular, if the Smoke density is below this threshold, the block will be deallocated, unless velocity and fuel thresholding are active.",
                "type": "FloatPar",
                "name": "smokeallocthreshold",
                "items": []
            },
            {
                "text": "Float : If zero, block allocation and deallocation depend on an internal threshold and weighting of fuel density. If non-zero, fuel density affects block allocation and deallocation based on the value of Fuel Alloc Threshold.",
                "type": "FloatPar",
                "name": "fuelallocweight",
                "items": []
            },
            {
                "text": "Float : If Fuel Alloc Weight is non-zero, block allocation and deallocation is based on this value. In particular, if the Smoke density is below this threshold, the block will be deallocated, unless velocity and smoke thresholding are active.",
                "type": "FloatPar",
                "name": "fuelallocthreshold",
                "items": []
            },
            {
                "text": "Toggle : Enables Volume shadow rendering for the simulation. Shadowing generates light intensity values that overwrite the \"burn\" channel of the grid. Values range from 0 to 1, where 0 is fully shadowed. Shadow visibilty can be controlled by enabling 'Override Emitter Intensity Mask' or by adjusting the 'Burn Intensity Mask', 'Burn Alpha Mask', and 'Burn Color Mask' in [[Nvidia Flow Emitter COMP]]",
                "type": "TogglePar",
                "name": "enableshadow",
                "items": []
            },
            {
                "text": "Toggle : Displays the volume shadow blocks being used. Useful for debugging or optimizing.",
                "type": "TogglePar",
                "name": "drawshadowdebug",
                "items": []
            },
            {
                "text": "Toggle : Automatically adjusts the emitters' render material, so volume shadows are visible. Will override 'Burn Intensity Mask' and 'Intensity Bias' of emitters.",
                "type": "TogglePar",
                "name": "overrideemitter",
                "items": []
            },
            {
                "text": "OBJ : The light source used to generate volume shadow. The light should be a shadow caster. Only the position and orientation of the light are used, color and intensity are ignored.",
                "type": "OBJPar",
                "name": "light",
                "items": []
            },
            {
                "text": "Int : The resolution of the shadow map volume texture. The texture is allocated as a cube, so there will be space for shadowresolution^3 blocks.",
                "type": "IntPar",
                "name": "shadowresolution",
                "items": []
            },
            {
                "text": "Float : The initial fraction of volume shadow blocks to allocate memory for.",
                "type": "FloatPar",
                "name": "shadowminusage",
                "items": []
            },
            {
                "text": "Float : The maximum fraction of volume shadow blocks to allocate memory for.",
                "type": "FloatPar",
                "name": "shadowmaxusage",
                "items": []
            },
            {
                "text": "Float : Scales how dark the shadow will be.",
                "type": "FloatPar",
                "name": "shadowintensityscale",
                "items": []
            },
            {
                "text": "Float : A lower limit for shadow intensity.",
                "type": "FloatPar",
                "name": "shadowminintensity",
                "items": []
            },
            {
                "text": "Float : Allows the burn value in the simulation to control the blend strength of the shadow. Postive values mean burn increases the blend strength, negative values mean burn decreases the blend strength",
                "type": "FloatPar",
                "name": "shadowburnmask",
                "items": []
            },
            {
                "text": "Float : Allows the smoke value in the simulation to control the blend strength of the shadow. Postive values mean smoke increases the blend strength, negative values mean smoke decreases the blend strength",
                "type": "FloatPar",
                "name": "shadowsmokemask",
                "items": []
            },
            {
                "text": "Float : Allows the temperature value in the simulation to control the blend strength of the shadow. Postive values mean temp increases the blend strength, negative values mean temp decreases the blend strength",
                "type": "FloatPar",
                "name": "shadowtempmask",
                "items": []
            },
            {
                "text": "Float : Allows the fuel value in the simulation to control the blend strength of the shadow. Postive values mean fuel increases the blend strength, negative values mean fuel decreases the blend strength",
                "type": "FloatPar",
                "name": "shadowfuelmask",
                "items": []
            },
            {
                "text": "Float : An offset that increases or decreases the blend strength by a constant amount. Parts of the grid with a blend value over 1 will have shadows. Parts of the grid with blend value under 1 will not have shadows. Blend values between 0 and 1 scale the strength of shadow.",
                "type": "FloatPar",
                "name": "shadowblendbias",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "flowTOP",
        "opLabel": "Nvidia Flow",
        "opClass": "flowTOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This operator only works with '''Nvidia GPUs'''.",
        "short": "The Nvidia Flow TOP calculates the Flow simulation and renders it.",
        "long": "NVIDIA Flow is a volumetric fluid based simulation of a burning gas system. The user controls the 3 main factors of temperature, fuel, and smoke to create fire and smoke simulations. \n\nThe Nvidia Flow TOP calculates the Flow simulation and renders it. It requires a [[Nvidia Flow Emitter COMP]] to emit gas into the Flow simulation. \n\nSee also [[Nvidia Flow Emitter COMP]], [[Nvidia Flow]].\n\nRead more here [https://docs.nvidia.com/gameworks/content/artisttools/Flow/index.html Nvidia Flow Artist Tools]",
        "opCategories": ""
    },
    "nvidiaupscalerTOP": {
        "label": "nvidiaupscalerTOP",
        "members": [
            {
                "text": "Folder : The location of the AI model files used to perform the image super-resolution. By default, these files are included inside the Config/Models folder inside your TouchDesigner installation folder. You can use this parameter to point to an alternative folder with compatible model files.",
                "type": "FolderPar",
                "name": "modelfolder",
                "items": []
            },
            {
                "text": "Menu : Select the GPU device to run the AI models on. The GPU must be a Nvidia RTX compatible card.",
                "type": "MenuPar",
                "name": "gpu",
                "items": []
            },
            {
                "text": "Menu : Choose the mode (Upscale or Super-Resolution) and factor by which the resolution will increase.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Float : Choose how much to enhance the input. Strength 0 implies no enhacement, only upscaling. Strength 1 implies the maximum enhancement. The default is 0.4.",
                "type": "FloatPar",
                "name": "strength",
                "items": []
            },
            {
                "text": "Toggle : Toggle artifact reduction. This should be enabled when the input image has undergone lossy video compression.",
                "type": "TogglePar",
                "name": "artifactreduction",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "nvidiaupscalerTOP",
        "opLabel": "Nvidia Upscaler",
        "opClass": "nvidiaupscalerTOP_Class",
        "opFilter": "True",
        "opLicense": "TouchDesigner Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This TOP uses the [https://developer.nvidia.com/maxine Nvidia Maxine Video Effects] engine and requires a 20 series or later Nvidia card to operate.",
        "short": "The Nvidia Upscaler TOP upscales the resolution of an input video.",
        "long": "The Nvidia Upscaler TOP upscales the resolution of an input video. It can run either the [https://docs.nvidia.com/deeplearning/maxine/vfx-sdk-programming-guide/index.html#upscale-filter Upscale Filter] or [https://docs.nvidia.com/deeplearning/maxine/vfx-sdk-programming-guide/index.html#super-res-filter Super-Resolution Filter]. The Upscale Filter is faster and offers a Strength parameter. The Super Resolution mode is higher quality and doesn't offer a Strength parameter, but it does have an optional Artifact Reduction toggle. Refer to the Table [https://docs.nvidia.com/deeplearning/maxine/vfx-sdk-programming-guide/index.html#upscale-filter Scale and Resolution Support for Input Videos] for the requirements of the input resolution.",
        "opCategories": ""
    },
    "oakselectTOP": {
        "label": "oakselectTOP",
        "members": [
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "CHOP : ",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "StrMenu : ",
                "type": "StrMenuPar",
                "name": "stream",
                "items": []
            },
            {
                "text": "Int : The Cache Size parameter works like the Queue Size parameter on the [[OAK Select CHOP]]. Picking 2 is a good default choice because it enables TouchDesigner to show an image to the user while asynchronously writing new data into the remaining buffer.",
                "type": "IntPar",
                "name": "cachesize",
                "items": []
            },
            {
                "text": "Float : This parameter mimics the Output Index parameter of a [[Cache TOP]]. When using a more complex depthai pipeline such as the hand tracking example, the hand tracking data will arrive at TouchDesigner with greater latency than the RGB images. By using a negative output index, the images can be delayed so that they better align with the tracking data.",
                "type": "FloatPar",
                "name": "outputindex",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "outputindexunit",
                "items": []
            },
            {
                "text": "Float : When the stream is a depth image (and the stream name actually contains the word \"depth\"), it can be helpful to limit the maximum \"z-depth\" of the image. This value is measured in meters.",
                "type": "FloatPar",
                "name": "limitmax",
                "items": []
            },
            {
                "text": "Menu : TouchDesigner can apply basic image-processing that depthai does not yet do. For example, if the Output Format is \"Point Cloud\", the stream is a depth stream, and the stream name contains \"depth\", then the image in the OAK Select will be a 32-bit XYZ point cloud derived from the depth image and the camera's intrinsic matrix.",
                "type": "MenuPar",
                "name": "outputformat",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "oakselectTOP",
        "opLabel": "OAK Select",
        "opClass": "oakselectTOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "Receives image streams from the OAK Camera",
        "long": "The OAK Select can receive images of many different formats from the OAK Camera. These formats include RGB, monochrome, depth images, and XYZ [[Point Clouds]].\n    \nSee Also: [[OAK-D]] [[OAK Device CHOP]] [[OAK Select CHOP]]"
    },
    "oculusriftTOP": {
        "label": "oculusriftTOP",
        "members": [
            {
                "text": "Toggle : Controls if an image is being output to the device.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select what will be displayed in the debug HUD in the headset.",
                "type": "MenuPar",
                "name": "debugperfhud",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Oculus Rift TOP connects to an [[Oculus Rift]] device and applies a distortion to input textures based on the device's calibration parameters. There are separate inputs for each eye.\t\t\n\t\t\t\nSee also [[Oculus Rift]]",
        "short": "The Oculus Rift TOP connects to an [[Oculus Rift]] device and applies a distortion to input textures based on the device's calibration parameters.",
        "opLicense": "Non-Commercial",
        "opLabel": "Oculus Rift",
        "opFilter": "True",
        "opType": "oculusrift",
        "opClass": "oculusriftTOP_Class",
        "opFamily": "TOP",
        "os": "Microsoft Windows",
        "opCategories": ""
    },
    "opviewerTOP": {
        "label": "opviewerTOP",
        "members": [
            {
                "text": "OP : Determines which operator's viewer to use. Drag & drop any operator on this parameter or type in the path directly.",
                "type": "OPPar",
                "name": "opviewer",
                "items": []
            },
            {
                "text": "Toggle : This option is being deprecated.  Please see [[OP Viewer COMP]] for its replacement.",
                "type": "TogglePar",
                "name": "allowpanel",
                "items": []
            },
            {
                "text": "Toggle : Uses the alpha channel to determine transparency in the texture.",
                "type": "TogglePar",
                "name": "preservealpha",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The OP Viewer TOP can display the [[Node Viewer]] for any other operator as a TOP image. If the operator source is a [[Panel Component]], panel interaction through the TOP image is also supported.",
        "short": "The OP Viewer TOP can display the [[Node Viewer]] for any other operator as a TOP image.",
        "opLicense": "Non-Commercial",
        "opLabel": "OP Viewer",
        "opFilter": "False",
        "opType": "opview",
        "opClass": "opviewerTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "opencolorioTOP": {
        "label": "opencolorioTOP",
        "members": [
            {
                "text": "File : File holding all the relevant information, such as lookup tables, transforms, color spaces, views, and displays. Several sample configurations are provided in the application installation folder /Samples/OpenColorIO.",
                "type": "FilePar",
                "name": "config",
                "items": []
            },
            {
                "text": "Pulse : Manually reload the configuration file.",
                "type": "PulsePar",
                "name": "reloadconfig",
                "items": []
            },
            {
                "text": "Toggle : Toggle this transform's effect on or off. Color space transforms convert an image from one color space to another.",
                "type": "TogglePar",
                "name": "usecolorspacetransform",
                "items": []
            },
            {
                "text": "StrMenu : Specify the input color space, the color space of the incoming image.",
                "type": "StrMenuPar",
                "name": "incolorspace",
                "items": []
            },
            {
                "text": "StrMenu : Specify the output color space. The image will be converted to this color space from the input color space.",
                "type": "StrMenuPar",
                "name": "outcolorspace",
                "items": []
            },
            {
                "text": "Toggle : Toggle this transform's effect on or off. File transforms apply individual color space conversion files. Various file formats are supported, spi1d and spi3d to name a couple.",
                "type": "TogglePar",
                "name": "usefiletransform",
                "items": []
            },
            {
                "text": "File : The file to be loaded. \t\nNote that the file will expect a certain color space and file transforms do not internally handle this, so ensure that the image is in the correct color space before applying the transform or you will get incorrect results.",
                "type": "FilePar",
                "name": "filesource",
                "items": []
            },
            {
                "text": "Menu : Interpolation method of the file.",
                "type": "MenuPar",
                "name": "interpolation",
                "items": []
            },
            {
                "text": "Menu : The direction of the transform. To invert the transform, select Inverse.",
                "type": "MenuPar",
                "name": "filedirection",
                "items": []
            },
            {
                "text": "Menu : Color Decision List - Select this transform's effect on the image, either manually using parameter values or using a color correction file (.cc). https://en.wikipedia.org/wiki/ASC_CDL",
                "type": "MenuPar",
                "name": "cdlmode",
                "items": []
            },
            {
                "text": "XYZ : Adjust the gain.",
                "type": "XYZPar",
                "name": "slopex",
                "items": []
            },
            {
                "text": "XYZ : Adjust the gain.",
                "type": "XYZPar",
                "name": "slopey",
                "items": []
            },
            {
                "text": "XYZ : Adjust the gain.",
                "type": "XYZPar",
                "name": "slopez",
                "items": []
            },
            {
                "text": "XYZ : Adjust the offset.",
                "type": "XYZPar",
                "name": "offsetx",
                "items": []
            },
            {
                "text": "XYZ : Adjust the offset.",
                "type": "XYZPar",
                "name": "offsety",
                "items": []
            },
            {
                "text": "XYZ : Adjust the offset.",
                "type": "XYZPar",
                "name": "offsetz",
                "items": []
            },
            {
                "text": "XYZ : Adjust the gamma.",
                "type": "XYZPar",
                "name": "powerx",
                "items": []
            },
            {
                "text": "XYZ : Adjust the gamma.",
                "type": "XYZPar",
                "name": "powery",
                "items": []
            },
            {
                "text": "XYZ : Adjust the gamma.",
                "type": "XYZPar",
                "name": "powerz",
                "items": []
            },
            {
                "text": "Float : Adjust the saturation.",
                "type": "FloatPar",
                "name": "saturation",
                "items": []
            },
            {
                "text": "Menu : The direction of the transform. To invert the transform, select Inverse.",
                "type": "MenuPar",
                "name": "cdldirection",
                "items": []
            },
            {
                "text": "File : The slope, offset, power, and saturation information can instead be loaded from a color correction file (.cc).",
                "type": "FilePar",
                "name": "ccfile",
                "items": []
            },
            {
                "text": "Toggle : Toggle a display transform. Display transforms allow for color space conversion onto specific display devices.",
                "type": "TogglePar",
                "name": "useoutput",
                "items": []
            },
            {
                "text": "Float : Adjust exposure applied before the display transform.",
                "type": "FloatPar",
                "name": "gain",
                "items": []
            },
            {
                "text": "StrMenu : Color space of the device that will be used to view the image.",
                "type": "StrMenuPar",
                "name": "display",
                "items": []
            },
            {
                "text": "StrMenu : Specifies the color space transform to be applied to the image.",
                "type": "StrMenuPar",
                "name": "view",
                "items": []
            },
            {
                "text": "StrMenu : Specifies the input color space.",
                "type": "StrMenuPar",
                "name": "colorspace",
                "items": []
            },
            {
                "text": "Float : Adjust amount of gamma correction applied after the display transform.",
                "type": "FloatPar",
                "name": "gamma",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The OpenColorIO TOP utilizes the OpenColorIO library (http://opencolorio.org/) to apply various transforms and lookup tables to your textures and images. The default order that the transforms are applied is: Color Space, File, CDL, Output (Display).<br><br>\t\t\nThis order can be changed using multiple OpenColorIO TOPs in a chain, with any unnecessary transforms toggled off.\t<br><br>\nThe color space of TouchDesigner TOPs is linear, so generally, images inported to TouchDesigner have to be converted to linear, if they are non-linearly encoded.",
        "short": "The OpenColorIO TOP utilizes the OpenColorIO library (http://opencolorio.org/) to apply various transforms and lookup tables to your textures and images.",
        "opLicense": "Non-Commercial",
        "opLabel": "OpenColorIO",
        "opFilter": "True",
        "opType": "ocio",
        "opClass": "opencolorioTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "openvrTOP": {
        "label": "openvrTOP",
        "members": [
            {
                "text": "Toggle : Control if this node is outputting data to the OpenVR driver.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The OpenVR TOP takes two images, one for the left eye and one for the right eye, and outputs it to the connected VR device. You usually want to have SteamVR running when using the OpenVR TOP, to ensure everything is connected and functioning properly.\n\nSee also [[OpenVR]], [[OpenVR CHOP]], [[OpenVR SOP]], [[Audio Render CHOP]]",
        "short": "See also [[OpenVR]], [[OpenVR CHOP]], [[OpenVR SOP]], [[Audio Render CHOP]]",
        "opLicense": "Non-Commercial",
        "opLabel": "OpenVR",
        "opFilter": "True",
        "opType": "openvr",
        "opClass": "openvrTOP_Class",
        "opFamily": "TOP",
        "os": "Microsoft Windows",
        "opCategories": ""
    },
    "opticalflowTOP": {
        "label": "opticalflowTOP",
        "members": [
            {
                "text": "Menu : Determines the output resolution. A smaller grid corresponds to a larger output image. [https://en.wikipedia.org/wiki/Turing_(microarchitecture) Turing GPUs] only support `4x4`, whereas newer GPUs can use any option.",
                "type": "MenuPar",
                "name": "gridsize",
                "items": []
            },
            {
                "text": "Menu : Specify the optical flow model. Higher quality is slower to compute, and low quality is faster to compute.",
                "type": "MenuPar",
                "name": "quality",
                "items": []
            },
            {
                "text": "Toggle : Toggle whether the \"cost\" of the optical flow is output in the blue channel of the TOP. Higher cost means higher uncertainty in the optical flow estimate in the RG channels. The cost values are integers between 0 and 255.",
                "type": "TogglePar",
                "name": "costoutput",
                "items": []
            },
            {
                "text": "XY : A post-multiply for the optical flow in the RG channels, allowing control of output intensity.",
                "type": "XYPar",
                "name": "gainx",
                "items": []
            },
            {
                "text": "XY : A post-multiply for the optical flow in the RG channels, allowing control of output intensity.",
                "type": "XYPar",
                "name": "gainy",
                "items": []
            },
            {
                "text": "Toggle : The Optical Flow TOP works in both real-time mode and non-real-time mode. However, if you have a video source whose frame rate differs from the project rate, you might be able to get better optical flow results with Manual Timing enabled. For every input video frame, you would need a timestamp in seconds to drive the `timestamp` parameter on the TOP. Some TOPs related to video streaming have this `timestamp` channel when an [[Info CHOP]] is placed on them.",
                "type": "TogglePar",
                "name": "manualtiming",
                "items": []
            },
            {
                "text": "Float : This is a timestamp in seconds of the video frame. See the discussion of Manual Timing in the parameter above.",
                "type": "FloatPar",
                "name": "timestamp",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "opticalflowTOP",
        "opLabel": "Optical Flow",
        "opClass": "opticalflowTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "os": "Microsoft Windows",
        "hardware": "This operator currently only works with '''Nvidia GPUs'''.",
        "short": "",
        "long": "Optical Flow detects patterns of motion in its input. The motion detected in the X-direction is output in the red (R) channel, while the motion in the Y-direction is output in the green (G) channel.\n    \nThe pixel values stored in the red and green channels are 32-bit floating point numbers. A value of 1.0 in a pixel of the red channel means that the horizontal motion of what is at that part of the image is moving left-to-right at 1 screen-width per second. In a 16x9 image, a green value of 1.0 at that pixel means the motion is upward at 1 screen-width per second, or 1 * 16/9 = 1.77 times the screen height per second.\n \nThe values can be scaled with the Gain parameters. The TOP can drive forces in the particlesGpu component."
    },
    "ousterselectTOP": {
        "label": "ousterselectTOP",
        "members": [
            {
                "text": "TOP : A link to the [[Ouster TOP]] that is receiving data from the sensor.",
                "type": "TOPPar",
                "name": "oustertop",
                "items": []
            },
            {
                "text": "Menu : Use this parameter to determine how data is arranged in the output image. The layout of data is generally not important when used as a point cloud.",
                "type": "MenuPar",
                "name": "layout",
                "items": []
            },
            {
                "text": "Menu : Select what sensor data will be placed into the red channel of the output image.",
                "type": "MenuPar",
                "name": "redchannel",
                "items": []
            },
            {
                "text": "Menu : Select what sensor data will be placed into the green channel of the output image.",
                "type": "MenuPar",
                "name": "greenchannel",
                "items": []
            },
            {
                "text": "Menu : Select what sensor data will be placed into the blue channel of the output image.",
                "type": "MenuPar",
                "name": "bluechannel",
                "items": []
            },
            {
                "text": "Menu : Select what sensor data will be placed into the alpha channel of the output image.",
                "type": "MenuPar",
                "name": "alphachannel",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "ousterselectTOP",
        "opLabel": "Ouster Select",
        "opClass": "ousterselectTOP_Class",
        "opFilter": "False",
        "opLicense": "Commercial",
        "short": "The Ouster Select TOP can be used to create additional output images from sensor data collected by an [[Ouster TOP]].",
        "long": "The Ouster Select TOP can be used to create additional output images from sensor data collected by an [[Ouster TOP]]. Each output image contains 4 channels of 32bit floating point data encoded into the red, green, blue and alpha channels of the image. Available sensor data channels include: Range, Intensity, Reflectivity and Noise as well as 3D XYZ position values. Raw range data is measured in millimeters, while XYZ positions are calculated using a table of beam azimuth and altitude angles and then converted to meters.\n    \nSee also: [[Ouster TOP]]",
        "opCategories": ""
    },
    "ousterTOP": {
        "label": "ousterTOP",
        "members": [
            {
                "text": "Toggle : Enables connections with the device.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The IP address or the name of the Ouster device. The address is only required during configuraton. The device will request an address from the local DHCP server when it is connected to the network. The name of the device is printed on the top of the sensor in the format \"os-#####\", where ##### is the serial number e.g. \"os-991900123456\". You can determine the IP address using the ping command and the device name e.g. ping -4 os-991900123456. For more information see the Ouster User Guide at [https://www.ouster.io/downloads Ouster.io].",
                "type": "StrPar",
                "name": "deviceaddress",
                "items": []
            },
            {
                "text": "Int : The UDP port number to receive lidar data.",
                "type": "IntPar",
                "name": "lidarport",
                "items": []
            },
            {
                "text": "Int : The UDP port number to receive data from the inertial measurement unit (IMU) on the device. The IMU data can be accessed by connecting the Ouster TOP to an [[Info CHOP]].",
                "type": "IntPar",
                "name": "imuport",
                "items": []
            },
            {
                "text": "Int : The TCP/IP port number to use to send configuration commands to the device.",
                "type": "IntPar",
                "name": "commandport",
                "items": []
            },
            {
                "text": "StrMenu : The IP address where the sensor should send the lidar and IMU data to. If the parameter is blank, the address of the current machine will be used. This field should only be necessary if the sending machine has more than one IP address or if you wish to send the lidar data to a different machine than the one you are configuring it on.",
                "type": "StrMenuPar",
                "name": "targetaddress",
                "items": []
            },
            {
                "text": "StrMenu : An IP address for the current machine that should be used to connect to the device with. If the address is left blank, the default network address will be used.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Menu : Select a scanning mode to set the sensor's horizontal resolution and number of revolutions per second. The vertical resolution is determined by the hardware e.g. an OS1-64 sensor has vertical resolution of 64 pixels (samples).",
                "type": "MenuPar",
                "name": "scanmode",
                "items": []
            },
            {
                "text": "Toggle : Enable this toggle to have the Ouster TOP set the configuration properties of the device. If the device has already been configured to the correct mode and network connections than this can be disabled to save some processing time.",
                "type": "TogglePar",
                "name": "configdevice",
                "items": []
            },
            {
                "text": "Menu : Use this parameter to determine how data is arranged in the output image. The layout of data is generally not important when used as a point cloud.",
                "type": "MenuPar",
                "name": "layout",
                "items": []
            },
            {
                "text": "Menu : Select what sensor data will be placed into the red channel of the output image.",
                "type": "MenuPar",
                "name": "redchannel",
                "items": []
            },
            {
                "text": "Menu : Select what sensor data will be placed into the green channel of the output image.",
                "type": "MenuPar",
                "name": "greenchannel",
                "items": []
            },
            {
                "text": "Menu : Select what sensor data will be placed into the blue channel of the output image.",
                "type": "MenuPar",
                "name": "bluechannel",
                "items": []
            },
            {
                "text": "Menu : Select what sensor data will be placed into the alpha channel of the output image.",
                "type": "MenuPar",
                "name": "alphachannel",
                "items": []
            },
            {
                "text": "Menu : Select how the sensor generates timestamp information.",
                "type": "MenuPar",
                "name": "timemode",
                "items": []
            },
            {
                "text": "Menu : The polarity of the SYNC_PULSE_IN signal to use.",
                "type": "MenuPar",
                "name": "pulseinpolarity",
                "items": []
            },
            {
                "text": "Menu : Determines how the sensor uses the SYNC_PULSE_OUT signal.",
                "type": "MenuPar",
                "name": "iomode",
                "items": []
            },
            {
                "text": "Menu : Polarity of the output signal pulse.",
                "type": "MenuPar",
                "name": "pulseoutpolarity",
                "items": []
            },
            {
                "text": "Int : Frequency of the output pulse in Hz (must be greater than 0).",
                "type": "IntPar",
                "name": "pulseoutfrequency",
                "items": []
            },
            {
                "text": "Int : The encoder angle at which to output a signal pulse. Measured in degrees less than 360.",
                "type": "IntPar",
                "name": "pulseoutangle",
                "items": []
            },
            {
                "text": "Int : Width of the output signal pulse in mm.",
                "type": "IntPar",
                "name": "pulseoutwidth",
                "items": []
            },
            {
                "text": "Menu : Sets the polarity of the NMEA URT input $GPRMC messages. Set to 'Active High' if UART is active high, idle low, and the start bit is after a falling edge.",
                "type": "MenuPar",
                "name": "nmeainpolarity",
                "items": []
            },
            {
                "text": "Toggle : Turn off, if the NMEA UART input $GPRMC messages should be ignored if valid character is not set, and turn on if messages should be used for time syncing regardless of the valid character.",
                "type": "TogglePar",
                "name": "nmeaignorevalidchar",
                "items": []
            },
            {
                "text": "Menu : The baud rate for the incoming NMEA URT input $GPRMC messages.",
                "type": "MenuPar",
                "name": "nmeabaudrate",
                "items": []
            },
            {
                "text": "Int : An integer number of leap seconds that will be added to the UDP timestamp when calculating seconds since 00:00:00 Thursday, 1 Jan 1970. Set to 0 for Unix Epoch Time.",
                "type": "IntPar",
                "name": "nmealeapseconds",
                "items": []
            },
            {
                "text": "Toggle : Tell the sensor to automatically begin sending data when it turns on. The default is On.",
                "type": "TogglePar",
                "name": "autostart",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "ousterTOP_Class",
        "short": "The Ouster TOP is used to send and receive data with an Ouster Imaging Lidar.",
        "opFilter": "False",
        "opLabel": "Ouster",
        "opFamily": "TOP",
        "opType": "ouster",
        "opLicense": "Commercial",
        "long": "[[Ouster]] makes LIDAR devices for scanning 3D environments. The [[Ouster TOP]] sends and receives data with an Ouster Imaging Lidar, converting to point cloud data on the GPU. For more information see the user guides at [https://www.ouster.io/resources Ouster.io]\n\n'''Requirements:'''\n* The TOP currently supports Ouster devices using version 2.0 firmware or higher. \n* Access to your local network to connect with the sensor device. Check your firewall settings if you have trouble accessing the device.\n* High resolution scanning modes require up to 130Mbps of bandwidth. Gigabit Ethernet hardware is required for full operation. Insufficient bandwidth will cause broken images and missing frames.\n\n'''Features include:'''\n* Additional sensor data like IMU (Inertial Measurement Unit - the gyroscope and accelerometer), packet counts, matrices via Info CHOP and Info DAT.\n* Visual Panoramic and Scan Order capture formats selectable in 'Image Layout' parameter.\n* Flexible X, Y, Z, Range, Intensity and Noise plane mapping to RGBA GPU Image Channels\n* Time Sync Mode for supporting multiple devices in the same area (Internal OSC, Sync Pulse In, PTP 1588)\n* Auto startup features\n\n'''Connection Instructions:'''</br>\nTo connect to the sensor, you will need either the IP addressed assigned by the local DHCP server or the name of the device. The name is based on the serial number that is usually printed on the top of the sensor in the format \"os-############\". This name can be entered directly into the Device Address parameter (see parameter help below). You can also connect to the device through a web browser using the IP or name in the format <code>http://os-###########/</code>. The web interface allows you to check the status of the device and gives additional error information.\n\nOnce the device is configured, it will continue to send output to the target IP address so it is not required to enter the device address again unless you need to change the configuration.\n\nRange data collected from the device is presented as 32bit floating point values in the RGBA channels of the output image. Output can be arranged either in chronological scan order or as a panoramic image using the Image Layout parameter. IMU data from the device can be accessed by connecting an [[Info CHOP]]. If more than 4 output channels are needed, you can use a [[Ouster Select TOP]] to create additional output images.\n\n'''Note:''' All 3D coordinates are transformed into TouchDesigner space where Y is up and X and Z represent the ground plane. This is different from the original coordinate space defined in the Ouster documentation.\n\nThe lookup tables used to convert the range values into 3D points can be accessed with an [[Info DAT]].\n\nSee also: [[Ouster Select TOP]]",
        "opCategories": ""
    },
    "outTOP": {
        "label": "outTOP",
        "members": [
            {
                "text": "Str : Creates a pop-up label when the cursor rolls over this Component output.",
                "type": "StrPar",
                "name": "label",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Out TOP is used to create a TOP output in a Component. Component outputs are positioned alphanumerically on the right side of the Component.",
        "short": "The Out TOP is used to create a TOP output in a Component.",
        "opLicense": "Non-Commercial",
        "opLabel": "Out",
        "opFilter": "True",
        "opType": "out",
        "opClass": "outTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "outsideTOP": {
        "label": "outsideTOP",
        "members": [
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]]",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Outside TOP places Input1 'outside' Input2. Input1 is visible in the output wherever Input2's alpha is &lt;1. This is the opposite operation to the Inside TOP.",
        "short": "The Outside TOP places Input1 'outside' Input2.",
        "opLicense": "Non-Commercial",
        "opLabel": "Outside",
        "opFilter": "True",
        "opType": "outside",
        "opClass": "outsideTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "overTOP": {
        "label": "overTOP",
        "members": [
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]]",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Over TOP places Input1 'over' Input2. The alpha of Input1 is used to determine what parts of the Input2 image are visible in the result.",
        "short": "The Over TOP places Input1 'over' Input2.",
        "opLicense": "Non-Commercial",
        "opLabel": "Over",
        "opFilter": "True",
        "opType": "over",
        "opClass": "overTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "packTOP": {
        "label": "packTOP",
        "members": [
            {
                "text": "Menu : Controls the direction and behavior of the packing/unpacking.",
                "type": "MenuPar",
                "name": "packtype",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Pack TOP can be used to pack 32-bit floating point values into a larger 8-bit texture, so it can saved in a lossless format such as .tiff or Animation codec. The Pack TOP can then later be used to unpack these values back to 32-bit floats. This is useful for things such as point cloud data from the [[Kinect TOP]], or [[RealSense TOP]].",
        "short": "The Pack TOP can be used to pack 32-bit floating point values into a larger 8-bit texture, so it can saved in a lossless format such as .tiff or Animation codec.",
        "opLicense": "Non-Commercial",
        "opLabel": "Pack",
        "opFilter": "True",
        "opType": "pack",
        "opClass": "packTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "photoshopinTOP": {
        "label": "photoshopinTOP",
        "members": [
            {
                "text": "Toggle : While on, the TOP will receive data from Photoshop.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The IP address of the computer that Photoshop is running on.  If Photoshop is running on the same computer as TouchDesigner, <code>localhost</code> can be used in this parameter.  Otherwise, Photoshop's Remote Connection dialog (shown above) will show the IP address required.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Str : Enter the password specified in Photoshop's Remote Connection dialog.",
                "type": "StrPar",
                "name": "password",
                "items": []
            },
            {
                "text": "Menu : Determines what format the Photoshop stream is transferred with.",
                "type": "MenuPar",
                "name": "imageformat",
                "items": []
            },
            {
                "text": "Str : This parameter can be used to lock the Photoshop In TOP's input to a particular file that is open in Photoshop.",
                "type": "StrPar",
                "name": "lockeddocument",
                "items": []
            },
            {
                "text": "Pulse : click this button to lock the Photoshop In TOP's input to the currently active file in Photoshop.  Clicking this button fills out the parameter above Locked Document Name.",
                "type": "PulsePar",
                "name": "locktocurrent",
                "items": []
            },
            {
                "text": "Pulse : Clears the Locked Document Name parameter.  When unlocked, the Photoshop In TOP will grab whichever document is currently active in Photoshop.",
                "type": "PulsePar",
                "name": "unlock",
                "items": []
            },
            {
                "text": "Menu : Determines how the image is updated.",
                "type": "MenuPar",
                "name": "updatemode",
                "items": []
            },
            {
                "text": "Float : The maximum update rate of the image when Update Mode is set to automatic.",
                "type": "FloatPar",
                "name": "maxupdaterate",
                "items": []
            },
            {
                "text": "Pulse : Click to anually update the image.",
                "type": "PulsePar",
                "name": "update",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Photoshop In TOP can stream the output from Photoshop into TouchDesigner.  Photoshop can be running on the same computer as TouchDesigner or any other computer on the network.  Photoshop can be running on a Windows or Mac computer.  If the <span class=\"tipTextTOP\">Lock Document Name</span> parameter is left empty, then the TOP will grab whichever document is currently active in Photoshop.\n\t\t\t\n===<div class=\"subSectionLineTOP\">Photoshop Setup</div>===\t\t\t\n\t\t\t\nTo connect to the Photoshop In TOP, a remote connection must be setup in the Photoshop application.\t\t\t\n\t\t\t \n# Open a file in Photoshop.\t\t\t\n# Under the '''Edit''' menu, select '''Remote Connections...'''\t\t\t\n# In the dialog that opens, enter a '''Service Name''' and '''Password'''.  Then turn on the '''Enable Remote Connections''' checkbox.\t\t\t\n# Photoshop is now ready to connect to TouchDesigner.  The image below shows the Remote Connections dialog in Photoshop.\t\t\t\n\t\t\t\n\t\t\t\n[[image:RemoteConnections.png]].",
        "short": "The Photoshop In TOP can stream the output from Photoshop into TouchDesigner.",
        "opLicense": "Non-Commercial",
        "opLabel": "Photoshop In",
        "opFilter": "False",
        "opType": "photoshopin",
        "opClass": "photoshopinTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "pointfileinTOP": {
        "label": "pointfileinTOP",
        "members": [
            {
                "text": "File : The path and name of the point file to load. Point file formats are those found in [[File Types]].  You can specify files on the internet using <code>http://</code> ... \t\n\t\t\t\nTo treat a folder of files as an animation, specify the folder containing the files instead of a filename. All of the files must be the same resolution. It will treat each file in that folder as one frame in the animation. The order of the files is alphanumeric. By default the first file has an index of 0, second is 1, etc, regardless of their file names. Overriding the sample rate on the Trim parameter page will let you playback the animation at any frame rate.  \t\t\t\n\t\t\t\nUsing an <code>info.xml</code> file in the directory containing a sequence of files allows you to specify the frames per second. Example xml file:\t\t\t\n<syntaxhighlight lang=xml>\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\" ?>\n  <Settings>\n      <attributes fps=\"30.0\" />\n  </Settings>\n</syntaxhighlight>\nURLs can be used to fetch files. The file is downloaded to the user's Derivative temp directory and is read into the Point File In TOP.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : Change from 0 to 1 to force the file to reload. Useful when the file changes or did not exist at first.",
                "type": "TogglePar",
                "name": "reload",
                "items": []
            },
            {
                "text": "Pulse : Immediately reload the point data file.",
                "type": "PulsePar",
                "name": "reloadpulse",
                "items": []
            },
            {
                "text": "Menu : Select one of the available point data channels to place it into the red channel of the output image. Selecting One or Zero will place the constance value into the output channel.",
                "type": "MenuPar",
                "name": "red",
                "items": []
            },
            {
                "text": "Menu : Select one of the available point data channels to place it into the green channel of the output image. Selecting One or Zero will place the constance value into the output channel.",
                "type": "MenuPar",
                "name": "green",
                "items": []
            },
            {
                "text": "Menu : Select one of the available point data channels to place it into the blue channel of the output image. Selecting One or Zero will place the constance value into the output channel.",
                "type": "MenuPar",
                "name": "blue",
                "items": []
            },
            {
                "text": "Menu : Select one of the available point data channels to place it into the alpha channel of the output image. Selecting One or Zero will place the constance value into the output channel.",
                "type": "MenuPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Menu : Specifies the method used to play the animation, there are 3 options.",
                "type": "MenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "Toggle : Animation plays when 1, stops when 0.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : This is a speed multiplier which only works when Play Mode is ''Sequential''. A value of 1 is the default playback speed. A value of 2 is double speed, 0.5 is half speed and so on. Negative values will play the animation backwards.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Toggle : Jumps to Cue Point when set to 1. Only available when Play Mode is Sequential.",
                "type": "TogglePar",
                "name": "cue",
                "items": []
            },
            {
                "text": "Pulse : ",
                "type": "PulsePar",
                "name": "cuepulse",
                "items": []
            },
            {
                "text": "Float : Set any index in the animation as a point to jump to.",
                "type": "FloatPar",
                "name": "cuepoint",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "cuepointunit",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "cuebehavior",
                "items": []
            },
            {
                "text": "Float : This parameter explicitly sets the file sequence position when Play Mode is set to Specify Index. The units menu on the right lets you specify the index in the following units: Index, Frames, Seconds, and Fraction (percentage). For example, assume you have a sequence that internally is 25 fps, and the timeline that is 60 fps. If you set Units to Index and the parameter value to 25, you get the image that is 1 second into the sequence. If you set the Units to Frames and set the value to 60 you get the same image at 1 second into the movie.",
                "type": "FloatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "indexunit",
                "items": []
            },
            {
                "text": "Float : Crossfades the beginning and end of the animation together to create a smooth transition when looping. If the movie uses Trim options, it will crossfade Trim Start with Trim End positions.",
                "type": "FloatPar",
                "name": "loopcrossfade",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "loopcrossfadeunit",
                "items": []
            },
            {
                "text": "Int : Sets how many frames to skip before displaying next frame. For example, a StepSize of 30 will display every 30th frame. The timing of the animation playback does not change, so with a Step Size of 30 and a sample rate of 30, a new frame will be displayed every second.",
                "type": "IntPar",
                "name": "stepsize",
                "items": []
            },
            {
                "text": "Menu : This menu helps you determine how to treat the audio as the end of an animation approaches. This is needed because in some cases of playing an animation, like when driving with an index, the TOP will not know if you intend to loop it or not.",
                "type": "MenuPar",
                "name": "audioloop",
                "items": []
            },
            {
                "text": "Menu : Determines how a file sequence is ordered.",
                "type": "MenuPar",
                "name": "imageindexing",
                "items": []
            },
            {
                "text": "Toggle : Interpolates between frames based based on exact time. For example, if the index (in frames) is 1.5, then frames 1 and 2 will be blended 50-50. If the index is 1.7 then 30% of frame 1 is blended with 70% of frame 2 and so on.",
                "type": "TogglePar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "loadingerrorimage",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "trim",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "tstart",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "tstartunit",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "tend",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "tendunit",
                "items": []
            },
            {
                "text": "Menu : Determines how the Point File In TOP handles animation positions that lie before the Trim Start position. For example, if Trim Start is set to 1, and the animation's current index is -10, the Extend Left menu determines how the animation position is calculated.",
                "type": "MenuPar",
                "name": "textendleft",
                "items": []
            },
            {
                "text": "Menu : Determines how the Point File In TOP handles animation positions that lie after the Trim End position. For example, if Trim End is set to 20, and the animation's current index is 25, the Extend Right menu determines how the movie position is calculated.",
                "type": "MenuPar",
                "name": "textendright",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "overridesample",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "samplerate",
                "items": []
            },
            {
                "text": "Int : Sets how many animation frames TouchDesigner reads ahead and stores in memory. The Point File In TOP will read and decode frames of the animation into CPU memory before they are used, this can eliminate pops or stutters in playback that occur from some frames taking too long to decode, other resources accessing the hard drive, or looping. When reading a sequence of files, having more Pre-Read Frames will allow multiple files to be decode at the same time. This allows playback of heavy file formats such as .exr in real-time, assuming the machine has enough CPU cores.",
                "type": "IntPar",
                "name": "prereadframes",
                "items": []
            },
            {
                "text": "Int : The time (in milliseconds) TouchDesigner will wait for a frame from the hard drive before giving up. If the Disk Read Timeout time is reached, that frame is simply skipped. This also works for network files that are downloaded via http://.",
                "type": "IntPar",
                "name": "frametimeout",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "frametimeoutstrat",
                "items": []
            },
            {
                "text": "Toggle : If this parameter is turned on, then for the first loaded frame the Frame Read Timeout will be ignored, and it will always wait for the first frame to ensure the node always starts up with a valid image.",
                "type": "TogglePar",
                "name": "alwaysloadinitial",
                "items": []
            },
            {
                "text": "Int : The time (in milliseconds) TouchDesigner will wait for a file to open. If the Disk Open Timout is reached, the Point File In TOP will stop waiting and make its image all black, with a grey square in the bottom right corner. If the file still isn't opened the next time the TOP cooks, it'll wait again, and do the same. It'll keep doing this until the file is opened, or the open fails.",
                "type": "IntPar",
                "name": "opentimeout",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "asyncupload",
                "items": []
            },
            {
                "text": "Toggle : Image will not update when set to 0. Animation index will continue to move forward but the output image will not update.",
                "type": "TogglePar",
                "name": "updateimage",
                "items": []
            },
            {
                "text": "Int : Limit the maximum number of CPUs that will be used to decode certain file codecs that are capable of multi-CPU decoding.",
                "type": "IntPar",
                "name": "maxdecodecpus",
                "items": []
            },
            {
                "text": "Toggle : This option should be used when playing back files that require very high SSD read speeds. It greatly improves read performance in those cases. It should not be used for low resolution or low data rate files.",
                "type": "TogglePar",
                "name": "highperfread",
                "items": []
            },
            {
                "text": "Float : When doing high performance reads, this parameter controls the size of the read operations that are done on disk. Whatever the largest operation the codec asks to be done, this is multiplied by the read factor and all subsequent reads will read that much data instead. This can result in higher throughput depending on the drives. For example if a request is made to read 1MB and the factor is set to 3, then instead the operations will read 3MB from the disk and the extra 2MB read will be ready for the next frame and will likely already have the next 2 frames available in CPU RAM.",
                "type": "FloatPar",
                "name": "highperfreadfactor",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "hwdecode",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "pointfileinTOP",
        "opLabel": "Point File In",
        "opClass": "pointfileinTOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Point File In TOP loads 3D point data into TOPs from either a single file or a sequence of files.",
        "long": "The Point File In TOP loads 3D point data into TOPs from either a single file or a sequence of files. Points are composed of one or more floating point values such as XYZ positions, RGB color values, 3D normals, scanner intensity, etc. The Point File in TOP will load all available point data, but only four channels can be placed into the output image. By default, the first four point data channels are placed into the red, green, blue and alpha channels respectively; however, you can assign any point channel to a colour channel using the parameters on the Point Data page. Attach a [[Point File Select TOP]] to create additional output images from the same source file.\n        \nThe Point File In TOP will read point data from various mesh and floating point data files including: <code>.obj</code>, <code>.ply</code>, <code>.fits</code> (astronomy format), and <code>.exr</code>. It can also load ASCII point files (<code>.xyz</code>, <code>.pts</code>, <code>.csv</code>, <code>.txt</code>, etc) with one point per line and comma or space separated fields. The first line in ASCII point files can either be the number of points, the names of the point fields or the first point in the file.\n\nFor a complete list, see [[File Types]]. The [[OpenEXR]] file format is generally best to use as it is binary, can be read in multi-frame file sequences that uses TouchDesigner's movie file pre-reading and buffering, and can be written from TouchDesigner's [[Movie File Out TOP]] with unlimited numbers of channels.\n\t\t\t\nExamine the state of a Point File In TOP by attaching an [[Info CHOP]]. This will show information like the number of points, fields per point and the number of frames. It also shows dynamic information like the file open status, current frame, readahead frames and queue size, dropped frame count, CPU decode time and GPU upload time.\n\n'''Headers''': If the file contains any additional header data, this can be viewed by attaching an [[Info DAT]]. Header data is stored as key-value pairs with the keys in the first column and the corresponding data in the second column, which can easily be interpreted with python.\n\nAll of the ASCII point list formats are loaded the same way whether their extention is <code>txt</code>, <code>csv</code>, <code>xyz</code>, etc.  The parser looks for the first separating character (comma, space or tab) and then uses that to delimit the rest of the file. It will ignore delimiters that are inside single or double quotes. There are a few special rules depending on the delimiter style e.g. multiple spaces are merged together, but a comma at the end of a line indicates a blank field afterwards. Once a delimiter is established, The first line can be the number of points, but it is ignored. If the next line are strings then it is treated as a row of headers (channel names). Each row after that is considered a point.\n\nSee also [[OpenEXR]].",
        "opCategories": ""
    },
    "pointfileselectTOP": {
        "label": "pointfileselectTOP",
        "members": [
            {
                "text": "TOP : A link to the [[Point File In TOP]] that contains the original point file data.",
                "type": "TOPPar",
                "name": "pointfileintop",
                "items": []
            },
            {
                "text": "Menu : Select one of the available point data channels to place it into the red channel of the output image. Selecting One or Zero will place the constance value into the output channel.",
                "type": "MenuPar",
                "name": "red",
                "items": []
            },
            {
                "text": "Menu : Select one of the available point data channels to place it into the green channel of the output image. Selecting One or Zero will place the constance value into the output channel.",
                "type": "MenuPar",
                "name": "green",
                "items": []
            },
            {
                "text": "Menu : Select one of the available point data channels to place it into the blue channel of the output image. Selecting One or Zero will place the constance value into the output channel.",
                "type": "MenuPar",
                "name": "blue",
                "items": []
            },
            {
                "text": "Menu : Select one of the available point data channels to place it into the alpha channel of the output image. Selecting One or Zero will place the constance value into the output channel.",
                "type": "MenuPar",
                "name": "alpha",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "pointfileselectTOP",
        "opLabel": "Point File Select",
        "opClass": "pointfileselectTOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Point File Select TOP allows you to create additional output images from a point file loaded into a [[Point File In TOP]].",
        "long": "The Point File Select TOP allows you to create additional output images from a point file loaded into a [[Point File In TOP]]. This TOP is useful if your point data file has more than 4 channels e.g. XYZ position and RGB colors. It is more efficient to use a Point File Select TOP rather than a second [[Point File In TOP]] since the file will only be loaded once.",
        "opCategories": ""
    },
    "pointtransformTOP": {
        "label": "pointtransformTOP",
        "members": [
            {
                "text": "Menu : Choose if the RGB channels of the input texture should be treated as positions or vectors. Vectors will not have the translation portion of the transform applied to them, and can be normalized before and/or after the transformation is applied.",
                "type": "MenuPar",
                "name": "inputtype",
                "items": []
            },
            {
                "text": "Toggle : RGB input vectors are rescaled to a length of one before they are transformed.",
                "type": "TogglePar",
                "name": "innormalize",
                "items": []
            },
            {
                "text": "Toggle : RGB vectors are rescaled to a length of one after they are transformed.",
                "type": "TogglePar",
                "name": "outnormalize",
                "items": []
            },
            {
                "text": "Menu : Changes the order that the translate, rotate and scale operations are performed on the input. Analogous to how you would end up in different locations if you were to move a block and turn east, versus turning east and then moving a block.  In matrix math terms, if we use the 'multiply vector on the right' (column vector) convention, a transform order of Scale, Rotate, Translate would be written as T * R * S * Position",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : As with transform order (above), changing the order in which the rotations take place will alter the final position and orientation. A Rotation order of Rx Ry Rz would create the final rotation matrix as follows R = Rz * Ry * Rx",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : Move the input positions in the X, Y and Z axes. If the input is set to 'Vector', the translate values will have no effect.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Move the input positions in the X, Y and Z axes. If the input is set to 'Vector', the translate values will have no effect.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Move the input positions in the X, Y and Z axes. If the input is set to 'Vector', the translate values will have no effect.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : Rotate the input RGB values around the corresponding X, Y and Z axes. Angles are given in degrees.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : Rotate the input RGB values around the corresponding X, Y and Z axes. Angles are given in degrees.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : Rotate the input RGB values around the corresponding X, Y and Z axes. Angles are given in degrees.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : Scale the input RGB values in the corresponding X, Y and Z axes. If 'Normalize Output' is on, then all output values will be rescaled to a length of one regardless of the scale values.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : Scale the input RGB values in the corresponding X, Y and Z axes. If 'Normalize Output' is on, then all output values will be rescaled to a length of one regardless of the scale values.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : Scale the input RGB values in the corresponding X, Y and Z axes. If 'Normalize Output' is on, then all output values will be rescaled to a length of one regardless of the scale values.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : The pivot is the point about which the input points or vectors are scaled and rotated. Altering the pivot point produces different results depending on the transformation performed on the object.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : The pivot is the point about which the input points or vectors are scaled and rotated. Altering the pivot point produces different results depending on the transformation performed on the object.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : The pivot is the point about which the input points or vectors are scaled and rotated. Altering the pivot point produces different results depending on the transformation performed on the object.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            },
            {
                "text": "Float : Scale the input values along all axes simultaneously.",
                "type": "FloatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Toggle : Invert the transformation i.e. preform the reverse movements.",
                "type": "TogglePar",
                "name": "invert",
                "items": []
            },
            {
                "text": "Object : Allows you to orient your input points by naming the object you would like them to Look At, or point to. Once you have designated this object to look at, it will continue to face that object, even if you move it.",
                "type": "ObjectPar",
                "name": "lookat",
                "items": []
            },
            {
                "text": "XYZ : When orienting an object towards the 'Look At' target, the Up Vector is used to determine where the positive Y axis points.",
                "type": "XYZPar",
                "name": "upvectorx",
                "items": []
            },
            {
                "text": "XYZ : When orienting an object towards the 'Look At' target, the Up Vector is used to determine where the positive Y axis points.",
                "type": "XYZPar",
                "name": "upvectory",
                "items": []
            },
            {
                "text": "XYZ : When orienting an object towards the 'Look At' target, the Up Vector is used to determine where the positive Y axis points.",
                "type": "XYZPar",
                "name": "upvectorz",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "forwarddir",
                "items": []
            },
            {
                "text": "CHOP : Path to a CHOP node with channels describing a 3D transformation. These channels may come from a [[Transform CHOP]] or another CHOP with the correct channels defined.",
                "type": "CHOPPar",
                "name": "chopinput",
                "items": []
            },
            {
                "text": "Menu : Controls whether the transformation from the given CHOP is applied to the input values before or after the transformation describe by this node.",
                "type": "MenuPar",
                "name": "multiplyorder",
                "items": []
            },
            {
                "text": "Menu : Select how to use the colors of the second input image as weights for transforming the points of the first input.",
                "type": "MenuPar",
                "name": "weightchannel",
                "items": []
            },
            {
                "text": "Float : Set the range of weight values used to control how much of the transformation is applied to a point. Points with the minimum weight will '''not''' be transformed, while points with the maximum weight will be '''fully''' transformed. A linear interpolation is applied to points with weights that fall between the minimum and maximum.",
                "type": "FloatPar",
                "name": "weightrange",
                "items": []
            },
            {
                "text": "Menu : Determines the order that align operations are performed on the input points. '''Note''': Unlike Scaling on the transform page, the alignment scale is always done relative to the center of the point cloud so that the point cloud's center does not change.",
                "type": "MenuPar",
                "name": "alignxformorder",
                "items": []
            },
            {
                "text": "OP : A path to a TOP or SOP node used to align the input points after the transformation. '''Note''' Using another point cloud TOP as a reference will incur additional performance costs because of the need to calculate the dimensions of the reference points.",
                "type": "OPPar",
                "name": "alignref",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alignopord",
                "items": []
            },
            {
                "text": "Menu : Determines the final position of points along the X axis i.e. shifts values in the red channel.",
                "type": "MenuPar",
                "name": "aligntx",
                "items": []
            },
            {
                "text": "Menu : Determines how the points are aligned relative to the dimensions of the input points.",
                "type": "MenuPar",
                "name": "fromx",
                "items": []
            },
            {
                "text": "Menu : Determines how the final points are aligned relative to the reference node.",
                "type": "MenuPar",
                "name": "tox",
                "items": []
            },
            {
                "text": "Menu : Determines the final position of points along the Y axis i.e. shifts values in the green channel.",
                "type": "MenuPar",
                "name": "alignty",
                "items": []
            },
            {
                "text": "Menu : Determines how the points are aligned relative to the dimensions of the input points.",
                "type": "MenuPar",
                "name": "fromy",
                "items": []
            },
            {
                "text": "Menu : Determines how the final points are aligned relative to the reference node.",
                "type": "MenuPar",
                "name": "toy",
                "items": []
            },
            {
                "text": "Menu : Determines the final position of points along the Z axis i.e. shifts values in the blue channel.",
                "type": "MenuPar",
                "name": "aligntz",
                "items": []
            },
            {
                "text": "Menu : Determines how the points are aligned relative to the dimensions of the input points.",
                "type": "MenuPar",
                "name": "fromz",
                "items": []
            },
            {
                "text": "Menu : Determines how the final points are aligned relative to the reference node.",
                "type": "MenuPar",
                "name": "toz",
                "items": []
            },
            {
                "text": "Menu : The Align Scale can be used to resize the point cloud to fit inside the given bounds. Scaling can be done per axis (maintaining proportions or stretching), or on all axes.",
                "type": "MenuPar",
                "name": "alignscale",
                "items": []
            },
            {
                "text": "Menu : The point cloud is resized based on its width in the X axis.",
                "type": "MenuPar",
                "name": "alignscalex",
                "items": []
            },
            {
                "text": "Menu : The point cloud is resized based on its height in the Y axis.",
                "type": "MenuPar",
                "name": "alignscaley",
                "items": []
            },
            {
                "text": "Menu : The point cloud is resized based on its depth in the Z axis.",
                "type": "MenuPar",
                "name": "alignscalez",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "pointtransformTOP",
        "opLabel": "Point Transform",
        "opClass": "pointtransformTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The Point Transform TOP treats the RGB values of the input image as a point cloud of XYZ positions or vectors and performs 3D transformations and alignments.",
        "long": "The Point Transform TOP treats the RGB values of the input image as a point cloud of XYZ positions or vectors and performs 3D transformations and alignments. When the input type is set to 'Vector', translations are ignored and only rotation and scaling operations are performed. The alpha channel, if present, is passed along to the output image unchanged.\n\nTransformations can be defined directly on the Transform page, taken from an input CHOP (see [[Transform CHOP]]), using the Look At parameter, or as a combination of any of those methods.\n\nThe Align page allows you to move or scale the point cloud relative to the origin, a 1x1x1 cube, or to a reference object. For example, you can scale the cloud to fit inside another point cloud or piece of geometry, or you can align the point cloud to sit on the XZ plane, or directly beside another cloud.\n\nThe second input can optionally be used as a weight map to control how much of the transformation is applied to each individual point.",
        "opCategories": ""
    },
    "prefiltermapTOP": {
        "label": "prefiltermapTOP",
        "members": [
            {
                "text": "Menu : Select between calculating the PreFilter for the Diffuse Map or Specular Map.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The PreFilter TOP uses spherical harmonics to calculate a Pre-Filtered Diffuse Map or Pre-Filtered Specular Map for use in the [[Environment Light COMP]].\nThe output of the PreFilter Map TOP can not have further processing done to them before being used by the Environment Light.",
        "short": "The PreFilter TOP calculates a Pre-Filtered Diffuse Map or Pre-Filtered Specular Map for use in the Environment Light COMP.",
        "opLicense": "Non-Commercial",
        "opLabel": "PreFilter Map",
        "opFilter": "True",
        "opType": "prefiltermap",
        "opClass": "prefiltermapTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "projectionTOP": {
        "label": "projectionTOP",
        "members": [
            {
                "text": "Menu : At this time the only option is a Cube Map input. You can generate a Cube Map by rendering one using the [[Render TOP]], or converting 2D images into one using the [[Cube Map TOP]].",
                "type": "MenuPar",
                "name": "input",
                "items": []
            },
            {
                "text": "Menu : Select output format from the menu.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Float : Only enabled in Fish-Eye output mode to specify the field of view of the Fish-Eye camera.",
                "type": "FloatPar",
                "name": "fov",
                "items": []
            },
            {
                "text": "XYZ : Use this parameter to rotate the map on any axis.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : Use this parameter to rotate the map on any axis.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : Use this parameter to rotate the map on any axis.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Projection TOP takes an image, often created with a [[Render TOP]], in a [[Cube Map]], Equirectangular, Fish Eye or Dual Paraboloid format, and converts that to a Fisheye or Equirectangular projection suitable for domes, or a Cube Map format. For Equirectangular images, u-v horizontal-vertical is the latitude-longitude, suitable for spheres. This produces superior-quality when it's based on the cube maps.\t\t\n\t\t\t\nFor every pixel of output, it takes one sample from the input cube map. Better anti-aliasing may be achieved by rendering double-resolution and scaling down to your desired resolution with the High Quality Resize option of the [[Resolution TOP]]\n\nWhen converting to a Equirectangular image, it is recommended you set the output resolution to a 2x1 aspect ratio, like 4096x2038. Fish Eyes are best output as a 1x1 aspect ratio.\t\t\t\n\t\t\t\n[[Image:ProjectionTOP.2.jpg|800px]]",
        "short": "TThe Projection TOP takes an image, often created with a [[Render TOP]], in a [[Cube Map]], Equirectangular, Fish Eye or Dual Paraboloid format, and converts that to a Fisheye or Equirectangular projection suitable for domes, or a Cube Map format. For Equirectangular images, u-v horizontal-vertical is the latitude-longitude, suitable for spheres. This produces superior-quality when it's based on the cube maps.",
        "opLicense": "Non-Commercial",
        "opLabel": "Projection",
        "opFilter": "True",
        "opType": "projection",
        "opClass": "projectionTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "rampTOP": {
        "label": "rampTOP",
        "members": [
            {
                "text": "DAT : Specifies the DAT which defines the entries in the ramp.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "Float : The color and alpha of each ramp keyframe can be set here. Select between an HSV or RGB colorpicker, or click the \"+\" button to open a color dialog box with predefined colors.",
                "type": "FloatPar",
                "name": "color",
                "items": []
            },
            {
                "text": "Menu : The type of ramp, choose between vertical, horizontal, radial, and circular.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Float : Sets the center point for radial and circular ramps.",
                "type": "FloatPar",
                "name": "position",
                "items": []
            },
            {
                "text": "Float : Offsets the beginning of the ramp.",
                "type": "FloatPar",
                "name": "phase",
                "items": []
            },
            {
                "text": "Float : Adjusts the length of the ramp, similar to a UV scaling.",
                "type": "FloatPar",
                "name": "period",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the ramp beyond the defined range. This parameter determines what happens at the edges of the ramp.",
                "type": "MenuPar",
                "name": "extendleft",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the ramp beyond the defined range. This parameter determines what happens at the edges of the ramp.",
                "type": "MenuPar",
                "name": "extendright",
                "items": []
            },
            {
                "text": "Menu : Change type of interpolation between the color keyframes in the ramp.",
                "type": "MenuPar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Float : Only enabled when using Hermite interpolation. Adjusts the tension bias of the Hermite curve used for interpolation.",
                "type": "FloatPar",
                "name": "tension",
                "items": []
            },
            {
                "text": "Int : Sets level of anti-aliasing for Radial and Circular type ramps.",
                "type": "IntPar",
                "name": "antialias",
                "items": []
            },
            {
                "text": "Menu : Adjusts the fit of Radial and Circular type ramps based on aspect ratio.",
                "type": "MenuPar",
                "name": "fitaspect",
                "items": []
            },
            {
                "text": "Toggle : Dithers the ramp to help deal with banding and other artifacts created by precision limitations.",
                "type": "TogglePar",
                "name": "dither",
                "items": []
            },
            {
                "text": "Toggle : Premultiplies the image.",
                "type": "TogglePar",
                "name": "multrgbbyalpha",
                "items": []
            },
            {
                "text": "Toggle : Turning this On will composite the input with the image.",
                "type": "TogglePar",
                "name": "compoverinput",
                "items": []
            },
            {
                "text": "Menu : Choose which composite operation is performed from this menu. Search the web for 'blend modes' for more detailed information on the effects of each type.",
                "type": "MenuPar",
                "name": "operand",
                "items": []
            },
            {
                "text": "Toggle : Swaps the order of the composite with the input.",
                "type": "TogglePar",
                "name": "swaporder",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Ramp TOP allows you to interactively create vertical, horizontal, radial, and circular ramps. Using the ramp bar and the color picker, you can add as many color tabs to the ramp as you like, each with its own color and alpha values. Click on a color tab to select it and change its color. Click elsewhere on the ramp bar to add another color keyframe. Drag a color tab off the ramp bar to delete it.\t\t\n\t\t\t\nThe data for each color keyframe in the ramp is held in the [[DAT]] specified by the <span class=\"tipTextTOP\">DAT</span> parameter. Each row in this DAT (in [[Table DAT|Table Format]]) represents a color keyframe entry in the ramp. The first column is the color keyframe's position on the ramp, the range is 0-1. The next 4 columns are the RGBA value for the color keyframe at that position. The DAT can be edited directly and the ramp will update in real-time.",
        "short": "The Ramp TOP allows you to interactively create vertical, horizontal, radial, and circular ramps.",
        "opLicense": "Non-Commercial",
        "opLabel": "Ramp",
        "opFilter": "False",
        "opType": "ramp",
        "opClass": "rampTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "realsenseTOP": {
        "label": "realsenseTOP",
        "members": [
            {
                "text": "Toggle : When set to 1 the TOP captures the image stream from the camera.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the model of device to use.",
                "type": "MenuPar",
                "name": "model",
                "items": []
            },
            {
                "text": "StrMenu : Select which device to use.",
                "type": "StrMenuPar",
                "name": "sensor",
                "items": []
            },
            {
                "text": "Menu : Select the image type to output.",
                "type": "MenuPar",
                "name": "image",
                "items": []
            },
            {
                "text": "StrMenu : Select the resolution of the video. Currently only usable for the Color image.",
                "type": "StrMenuPar",
                "name": "colorres",
                "items": []
            },
            {
                "text": "Float : The depth value pixels with a value of 1 will be set to. Specified in Meters. Pixels with a depth larger than this will be clamped to 1 for fixed point texture output, or go above 1 for floating point output.",
                "type": "FloatPar",
                "name": "maxdepth",
                "items": []
            },
            {
                "text": "Toggle : Flip the image horizontally.",
                "type": "TogglePar",
                "name": "mirrorimage",
                "items": []
            },
            {
                "text": "Toggle : Use the default Motion Range Tradeoff specified by the device.",
                "type": "TogglePar",
                "name": "defaulttradeoff",
                "items": []
            },
            {
                "text": "Int : Specifies the tradeoff between motion and range. Value is from 0 (short exposure, short range, and better motion) to 100 (long exposure and long range).",
                "type": "IntPar",
                "name": "tradeoff",
                "items": []
            },
            {
                "text": "CHOP : Channels specified in this CHOP allow for setting all of the options that the RealSense camera supports. Channel names should be the same as the C enumeration, with the RS2_OPTION_ prefix removed, and all lowercase. E.g RS2_OPTION_ENABLE_AUTO_EXPOSURE can be set by using a channel named \"enable_auto_exposure\". A list of options can be found [https://intelrealsense.github.io/librealsense/doxygen/rs__option_8h.html here.]",
                "type": "CHOPPar",
                "name": "optionschop",
                "items": []
            },
            {
                "text": "Toggle : When enabled, performs skeleton tracking using the [https://www.intelrealsense.com/skeleton-tracking/ Cubemos Skeleton Tracking API]. The results can be fetched via the [[RealSense CHOP]]. A Cubemos license is required for usage. A trial license is available.",
                "type": "TogglePar",
                "name": "skeltracking",
                "items": []
            },
            {
                "text": "Toggle : When enabled, will search for the license and model files in the default location (LOCALAPPDATA). For the files to appear there the Cubemos SDK will need to be installed. If a specific license directory or model file is desired then this can be disabled.",
                "type": "TogglePar",
                "name": "usedefaultpaths",
                "items": []
            },
            {
                "text": "Folder : Specify the directory with the license files (activation_key.json and cubemos_license.json).",
                "type": "FolderPar",
                "name": "licensedir",
                "items": []
            },
            {
                "text": "File : Specify the model file (.cubemos)",
                "type": "FilePar",
                "name": "modelfile",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "[[RealSense]] is a tracking device from Intel. The RealSense TOP connects to Intel [[RealSense]] devices and outputs color, depth and IR data from it.\n    \n<!--'''NOTE:''' D415, D435, D435i, T265 and L515 cameras are currently disabled on macOS due to bugs in the [https://github.com/IntelRealSense/librealsense Intel librealsense API].\n-->\nSee also [[RealSense]] for hardware information and installation instruction, and the [[RealSense CHOP]].",
        "short": "The RealSense TOP connects to Intel [[RealSense]] devices and outputs color, depth and IR data from it.",
        "opLicense": "Non-Commercial",
        "opLabel": "RealSense",
        "opFilter": "False",
        "opType": "realsense",
        "opClass": "realsenseTOP_Class",
        "opFamily": "TOP",
        "hardware": "The [https://github.com/IntelRealSense/librealsense/releases librealsense SDK v2.50.0] does not look like it will be updated for Apple Silicon, so it is not an option to add to these builds.",
        "opCategories": ""
    },
    "rectangleTOP": {
        "label": "rectangleTOP",
        "members": [
            {
                "text": "XY : Width and Height of the rectangle to draw.",
                "type": "XYPar",
                "name": "sizex",
                "items": []
            },
            {
                "text": "XY : Width and Height of the rectangle to draw.",
                "type": "XYPar",
                "name": "sizey",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "sizeunit",
                "items": []
            },
            {
                "text": "Float : Rotates the shape by the specified number of degrees.",
                "type": "FloatPar",
                "name": "rotate",
                "items": []
            },
            {
                "text": "XY : Coordinates of the center of the shape. (0,0) corresponds to a perfectly centered shape.",
                "type": "XYPar",
                "name": "centerx",
                "items": []
            },
            {
                "text": "XY : Coordinates of the center of the shape. (0,0) corresponds to a perfectly centered shape.",
                "type": "XYPar",
                "name": "centery",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "centerunit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the rectangle.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the rectangle.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "RGB : Color to use for the fill of the shape.",
                "type": "RGBPar",
                "name": "fillcolorr",
                "items": []
            },
            {
                "text": "RGB : Color to use for the fill of the shape.",
                "type": "RGBPar",
                "name": "fillcolorg",
                "items": []
            },
            {
                "text": "RGB : Color to use for the fill of the shape.",
                "type": "RGBPar",
                "name": "fillcolorb",
                "items": []
            },
            {
                "text": "Float : Alpha of the fill color.",
                "type": "FloatPar",
                "name": "fillalpha",
                "items": []
            },
            {
                "text": "RGB : Color to use for the border of the shape.",
                "type": "RGBPar",
                "name": "borderr",
                "items": []
            },
            {
                "text": "RGB : Color to use for the border of the shape.",
                "type": "RGBPar",
                "name": "borderg",
                "items": []
            },
            {
                "text": "RGB : Color to use for the border of the shape.",
                "type": "RGBPar",
                "name": "borderb",
                "items": []
            },
            {
                "text": "Float : Alpha of the border color.",
                "type": "FloatPar",
                "name": "borderalpha",
                "items": []
            },
            {
                "text": "RGB : Color to use for the background.",
                "type": "RGBPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGB : Color to use for the background.",
                "type": "RGBPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGB : Color to use for the background.",
                "type": "RGBPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "Float : Alpha of the background color.",
                "type": "FloatPar",
                "name": "bgalpha",
                "items": []
            },
            {
                "text": "Toggle : Multiplies the RGB values by the Alpha values",
                "type": "TogglePar",
                "name": "multrgbbyalpha",
                "items": []
            },
            {
                "text": "Float : Width of the border to draw on the shape.",
                "type": "FloatPar",
                "name": "borderwidth",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "borderwidthunit",
                "items": []
            },
            {
                "text": "Float : Value from 0 to 1 indicating the fraction of the border that extends beyond the radius of the shape. Effectively sets the radius to <code>radius + borderoffset*borderwidth</code>.",
                "type": "FloatPar",
                "name": "borderoffset",
                "items": []
            },
            {
                "text": "Float : Specifies the radius to be used for rounding the corners of the rectangle.",
                "type": "FloatPar",
                "name": "cornerradius",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "cornerradiusunit",
                "items": []
            },
            {
                "text": "Toggle : When on, the shape will be anti-aliased.",
                "type": "TogglePar",
                "name": "antialias",
                "items": []
            },
            {
                "text": "Float : Specifies the amount that the background color should be blended into the shape.",
                "type": "FloatPar",
                "name": "softness",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "softnessunit",
                "items": []
            },
            {
                "text": "Toggle : Turning this On will composite the input with the image.",
                "type": "TogglePar",
                "name": "compoverinput",
                "items": []
            },
            {
                "text": "Menu : Choose which composite operation is performed from this menu. Search the web for 'blend modes' for more detailed information on the effects of each type.",
                "type": "MenuPar",
                "name": "operand",
                "items": []
            },
            {
                "text": "Toggle : Swaps the order of the composite with the input.",
                "type": "TogglePar",
                "name": "swaporder",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Rectangle TOP can be used to generate Rectangles with rounded corners.\t\t\n\t\t\t\nThe shapes can be customized with different sizes, rotation and positioning. An optional border can be added to the shape. Background, border and fill colors can all be set independently. Anti-aliasing can be turned on or off.",
        "short": "The Rectangle TOP can be used to generate Rectangles with rounded corners.",
        "opLicense": "Non-Commercial",
        "opLabel": "Rectangle",
        "opFilter": "False",
        "opType": "rectangle",
        "opClass": "rectangleTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "remapTOP": {
        "label": "remapTOP",
        "members": [
            {
                "text": "Menu : Select which of the second input's channels to use for the horizontal warp of the first input.",
                "type": "MenuPar",
                "name": "horzsource",
                "items": []
            },
            {
                "text": "Menu : Select which of the second input's channels to use for the vertical warp of the first input.",
                "type": "MenuPar",
                "name": "vertsource",
                "items": []
            },
            {
                "text": "Toggle : Reverses the direction of the horizontal warp. A pixel value of 0 for the horizontal warp will mean that it fetches a pixel from the right most column of the first input.",
                "type": "TogglePar",
                "name": "fliphorz",
                "items": []
            },
            {
                "text": "Toggle : Reverses the direction of the vertical warp. A pixel value of 0 for the vertical warp will mean that it fetches a pixel from the top most row of the first input.",
                "type": "TogglePar",
                "name": "flipvert",
                "items": []
            },
            {
                "text": "Menu : Controls what is returned from your first input when the second input's values are outside the [0-1] range.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Remap TOP uses the second input to warp the first input. For every pixel of the output, it uses the red channel and green channel of the second input to choose which pixel to pick from the first input. Red == 0  will pick from the left column of pixels, red == 1 will pick from the right column of pixels. Green == 0  will pick from the bottom row of pixels, green == 1 will pick from the top row of pixels. Red == .5 and green == .5 will pick from the middle pixel of the first input.  Pixels from the first input are interpolated.\t\t\n\t\t\t\nIt is best that the second input contain a 16-bit-per-channel image or better, like 32-bit floats. Otherwise if the second input is 8-bits per color channel, the output images will be steppy: there are only 256x256 pixels from the first input that will be sampled. See the Pixel Format parameter on the Common page of the TOP feeding into the Remap TOP second input, and see its current pixel format settings with the MMB Info popup on the TOP.\n\t\t\t\nNote: The [[Displace TOP]] does the same thing if you set the Vertical Source to Green the UV Weight parameter set to 0, and the Displace Weight set to .5.  The Displace TOP does more general warping, whereas the Remap TOP is often used for warping images with other tools like the Stitcher component in the [[Palette]], or for projection mapping.\n\t\t\t\nSee also: [[Displace TOP]], [[Lookup TOP]]",
        "short": "The Remap TOP uses the second input to warp the first input.",
        "opLicense": "Non-Commercial",
        "opLabel": "Remap",
        "opFilter": "True",
        "opType": "remap",
        "opClass": "remapTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "renderpassTOP": {
        "label": "renderpassTOP",
        "members": [
            {
                "text": "TOP : The network path to the [[Render TOP]] used as input. This parameter can be used as an alternate to connecting a Render or Render Pass TOP to the Render Pass's input connector. Makes it easier to select a render from another network.",
                "type": "TOPPar",
                "name": "renderinput",
                "items": []
            },
            {
                "text": "OBJ : Specifies which [[Camera COMP|Cameras]] to look through when rendering the scene.",
                "type": "OBJPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "OP : Specifies which [[Geometry COMP|Geometry]] will be included in the rendered scene. You can use [[Pattern Matching]] to specify objects using patterns. Example: <code>geo* ^geo7</code> will render all Geometry components whose names start with <code>geo</code> except <code>geo7</code>.",
                "type": "OPPar",
                "name": "geometry",
                "items": []
            },
            {
                "text": "OBJ : Specifies which [[Light COMP|Lights]] will be used to render the scene. You can use [[Pattern Matching]] here as well.",
                "type": "OBJPar",
                "name": "lights",
                "items": []
            },
            {
                "text": "Toggle : Clears the values that are currently in the color buffer (coming from the TOP that is wired to the input of this node).",
                "type": "TogglePar",
                "name": "cleartocamcolor",
                "items": []
            },
            {
                "text": "Toggle : Clears the values that are currently in the depth buffer (coming from the TOP that is wired to the input of this node).",
                "type": "TogglePar",
                "name": "cleardepth",
                "items": []
            },
            {
                "text": "Toggle : When Render Mode is Cube Map, specify which sides if the cube map are rendered, +X, +Y, or +Z.",
                "type": "TogglePar",
                "name": "posside",
                "items": []
            },
            {
                "text": "Toggle : When Render Mode is Cube Map, specify which sides if the cube map are rendered, -X, -Y, or -Z.",
                "type": "TogglePar",
                "name": "negside",
                "items": []
            },
            {
                "text": "Menu : Refer to to the same parameter in the [[Render TOP]]s help page.",
                "type": "MenuPar",
                "name": "transparency",
                "items": []
            },
            {
                "text": "Toggle : Refer to to the same parameter in the [[Render TOP]]s help page.",
                "type": "TogglePar",
                "name": "depthpeel",
                "items": []
            },
            {
                "text": "Int : Refer to to the same parameter in the [[Render TOP]]s help page.",
                "type": "IntPar",
                "name": "transpeellayers",
                "items": []
            },
            {
                "text": "Toggle : Enables rendering; 1 = on, 0 = off.",
                "type": "TogglePar",
                "name": "render",
                "items": []
            },
            {
                "text": "Toggle : Dithers the rendering to help deal with banding and other artifacts created by precision limitations of 8-bit displays.",
                "type": "TogglePar",
                "name": "dither",
                "items": []
            },
            {
                "text": "Toggle : This is an optimization if you don't actually need the color result from this pass. Turning this off avoids a copy from the offscreen render buffer to the TOP's texture. When anti-aliasing is enabled turning this off will also avoid 'resolving' the anti-aliasing.",
                "type": "TogglePar",
                "name": "coloroutputneeded",
                "items": []
            },
            {
                "text": "Toggle : This will cause the render to only draw depth values to the depth buffer. No color values will be created. To make use of the depth buffer, use the [[Depth TOP]].",
                "type": "TogglePar",
                "name": "drawdepthonly",
                "items": []
            },
            {
                "text": "Menu : Controls if blending (as enabled by the MAT common page setting) will be enabled for extra buffers beyond the first one. Often the extra buffers are used to write other types of information such as normals or positions, where blending wouldn't be desirable.",
                "type": "MenuPar",
                "name": "allowbufblending",
                "items": []
            },
            {
                "text": "Menu : Front Faces, Back Faces, Both Faces, Neither. Will cause the render to avoid rendering certain polygon faces depending on their orientation to the camera. Refer to [[Back-Face Culling]] for more information.",
                "type": "MenuPar",
                "name": "cullface",
                "items": []
            },
            {
                "text": "MAT : This allows you to specific a material that will be applied to every Geometry that is rendered in the Render TOP. It is useful for pre-processing passes where we are outputting infoformation about the geometry rather then lighting them and outputting RGB.",
                "type": "MATPar",
                "name": "overridemat",
                "items": []
            },
            {
                "text": "Toggle : This feature pushes the polygons back into space a tiny fraction. This is useful when you are rendering two polygons directly ontop of each other and are experiencing [[Z-Fighting]]. Refer to [[Polygon Depth Offset]] for more information. This is also an important feature when doing shadows.",
                "type": "TogglePar",
                "name": "polygonoffset",
                "items": []
            },
            {
                "text": "Float : Refer to to the same parameter in the [[Render TOP]]s help page.",
                "type": "FloatPar",
                "name": "polygonoffsetfactor",
                "items": []
            },
            {
                "text": "Float : Refer to to the same parameter in the [[Render TOP]]s help page.",
                "type": "FloatPar",
                "name": "polygonoffsetunits",
                "items": []
            },
            {
                "text": "Toggle : This feature visually shows the overdraw in the scene. Refer to the [[Early Depth-Test]] article for more information. In particular the Analyzing Overdraw section.",
                "type": "TogglePar",
                "name": "overdraw",
                "items": []
            },
            {
                "text": "Int : This value quantizes the outputted color value to some # of overdraws. Refer to the [[Early Depth-Test]] for more information.",
                "type": "IntPar",
                "name": "overdrawlimit",
                "items": []
            },
            {
                "text": "Float : Positions the left edge of the rendered image.",
                "type": "FloatPar",
                "name": "cropleft",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "cropleftunit",
                "items": []
            },
            {
                "text": "Float : Positions the right edge of the rendered image.",
                "type": "FloatPar",
                "name": "cropright",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "croprightunit",
                "items": []
            },
            {
                "text": "Float : Positions the bottom edge of the rendered image.",
                "type": "FloatPar",
                "name": "cropbottom",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "cropbottomunit",
                "items": []
            },
            {
                "text": "Float : Positions the top edge of the rendered image.",
                "type": "FloatPar",
                "name": "croptop",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "croptopunit",
                "items": []
            },
            {
                "text": "Str : This is the sampler name that the GLSL program will use to sample from this TOP. The samplers need to be declared as the same dimensions as the TOP (sampler2D for a 2D TOP, sampler3D for 3D TOP).",
                "type": "StrPar",
                "name": "sampler0",
                "items": []
            },
            {
                "text": "TOP : This is the TOP that will be referenced by the above sampler name above it.",
                "type": "TOPPar",
                "name": "top0",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0filter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0anisotropy",
                "items": []
            },
            {
                "text": "Str : The uniform name, as declared in the shader.",
                "type": "StrPar",
                "name": "uniname0",
                "items": []
            },
            {
                "text": "XYZ : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZPar",
                "name": "value0x",
                "items": []
            },
            {
                "text": "XYZ : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZPar",
                "name": "value0y",
                "items": []
            },
            {
                "text": "XYZ : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZPar",
                "name": "value0z",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Render Pass TOP is used along with a [[Render TOP]] to achieve multipass rendering. It can build upon its inputs render by using the existing depth/color information in the framebuffers, or it can optionally clear one or both of the depth/color buffers before it does its render.",
        "short": "The Render Pass TOP is used along with a [[Render TOP]] to achieve multipass rendering.",
        "opLicense": "Non-Commercial",
        "opLabel": "Render Pass",
        "opFilter": "True",
        "opType": "renderpass",
        "opClass": "renderpassTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "renderselectTOP": {
        "label": "renderselectTOP",
        "members": [
            {
                "text": "TOP : Specify the TOP to use as a source. Currently [[Render TOP]], [[GLSL TOP]] and [[CPlusPlus TOP]]s are valid TOPs to select from.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Int : Specify which color buffer to select. Refer to the \"# of Color Buffers\" parameter in the Render TOP for more information.",
                "type": "IntPar",
                "name": "colorbufindex",
                "items": []
            },
            {
                "text": "Int : When multiple cameras are listed in the Render TOP's Camera parameter, this selects which cameras's output to select.",
                "type": "IntPar",
                "name": "cameraindex",
                "items": []
            },
            {
                "text": "Int : When the \"Depth Peel\" feature of the Render TOP is on, this selects out the specified peel layer.",
                "type": "IntPar",
                "name": "peellayerindex",
                "items": []
            },
            {
                "text": "Toggle : Accesses the Image Output of the [[Render TOP]]. Image Output must be enabled on the GLSL page of the Render TOP.",
                "type": "TogglePar",
                "name": "imageoutput",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Render Select TOP allows you to select one of the color buffers from any [[Render TOP]].",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Render Select",
        "opClass": "renderselectTOP_Class",
        "opType": "renderselect",
        "long": "The Render Select TOP allows you to select one of the color buffers from any [[Render TOP]].",
        "opCategories": ""
    },
    "renderTOP": {
        "label": "renderTOP",
        "members": [
            {
                "text": "OBJ : Specifies which [[Camera COMP|Cameras]] to look through when rendering the scene. You can specify multiple cameras and retrieve each camera image using the Render Select TOP.",
                "type": "OBJPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "Menu : Helps the Render TOP optimize rendering when multiple cameras are used. Controls the [[Multi-Camera Rendering]] behavior for this node.",
                "type": "MenuPar",
                "name": "multicamerahint",
                "items": []
            },
            {
                "text": "OP : Specifies which [[Geometry COMP|Geometry]] will be included in the rendered scene. You can use [[Pattern Matching]] to specify objects using patterns. Example: <code>geo* ^geo7</code> will render all Geometry components whose names start with <code>geo</code> except <code>geo7</code>.",
                "type": "OPPar",
                "name": "geometry",
                "items": []
            },
            {
                "text": "OBJ : Specifies which [[Light COMP|Lights]] will be used to render the scene. You can use [[Pattern Matching]] here as well.",
                "type": "OBJPar",
                "name": "lights",
                "items": []
            },
            {
                "text": "Menu : Sets the level of anti-aliasing in the scene. Setting this to higher values uses more graphics memory.",
                "type": "MenuPar",
                "name": "antialias",
                "items": []
            },
            {
                "text": "Menu : You can render different projections:  normal 2D, Cube Map, Fish Eye (180), or Dual Paraboloid. The Cube Map renders 6 views as needed for environment maps in the [[Phong MAT]] and [[Environment Light COMP]]. \t\t\n\t\t\t\t\nSee also the [[Cube Map TOP]] and the [[Projection TOP]].",
                "type": "MenuPar",
                "name": "rendermode",
                "items": []
            },
            {
                "text": "Toggle : When Render Mode is Cube Map, specify which sides if the cube map are rendered, +X, +Y, or +Z.",
                "type": "TogglePar",
                "name": "posside",
                "items": []
            },
            {
                "text": "Toggle : When Render Mode is Cube Map, specify which sides if the cube map are rendered, -X, -Y, or -Z.",
                "type": "TogglePar",
                "name": "negside",
                "items": []
            },
            {
                "text": "Menu : When Render Mode is UV Unwrap Coord, select which Texture Layer the coordinates are rendered to,",
                "type": "MenuPar",
                "name": "uvunwrapcoord",
                "items": []
            },
            {
                "text": "Menu : Helps to render transparent geometry in proper depth order. This eliminates the need to sort the geometry based on distance from camera. This process is multi-pass. For every pixel the closest surface is rendered in the first pass, the second closest surface second, up to the number of passes specified by the <span class=\"tipTextTOP\">Transparency Passes</span> parameter below. Turning this option on will disable some advanced features in the Render TOP, as well as anti-aliasing.\t\t\n\t\t\t\t\nThe feature is a pixel-based approach, not object-based. So its performance is not directly related to the number of objects, but rather how they are layered.\t\t\t\t\n\t\t\t\t\nIt uses a technique called Depth Peeling. First you render the normal frame. On your next render you peel away all of the pixels you saw in the first frame, and reveal the pixels underneath them. The next frame you do the same, peeling away the pixels you could see from the 2nd render. And so on. Once all of the renders are done, you re composite each layer Over the other, starting at the farthest back layer.\t\t\t\t\n\t\t\t\t\nIf you take a sphere for example, you'll need to do 2 passes, the first one for the front of the sphere, and then 2nd will be the inside of the sphere.\t\t\t\t\n\t\t\t\t\nIf you have 10 spheres, one behind the other. You'll need 19-20 passes to get the correct image.\t\t\t\t\n\t\t\t\t\nIf you have 10 spheres, each next to each other across the screen, you'll only need 2 passes.\t\t\t\t\n\t\t\t\t\nIn reality though you will only need 3-5 passes to get an image that's acceptable. It may not be 100% correct, but it'll look pretty close to correct.\t\t\t\t\n\t\t\t\t\nEach pass is a full render, so each pass adds significant overhead.",
                "type": "MenuPar",
                "name": "transparency",
                "items": []
            },
            {
                "text": "Toggle : Depth peeling is a technique used as part of Order-Independent Transparency, but this parameter allows you to use it in a different way. This parameter enables rendering depth-peels, but without combining all the layers using blending to create order independent transparency. Instead is keeps all the layers separate and they can be retrieved using a [[Render Select TOP]]. Depth peeling is done by first rendering rendering geometry normally and saving that image and depth. Then another render is done but the closest pixels that were occluded by the previous pass are written to the color buffer instead. This can be done multiple times, each time peeling back farther into the scene. If you are rendering a sphere the first render will be the outside of the sphere, and the second peel layer will be the back-inside of the sphere.",
                "type": "TogglePar",
                "name": "depthpeel",
                "items": []
            },
            {
                "text": "Int : Number of passes the renderer will use when <span class=\"tipTextTOP\">Order Independant Transparency</span> is turned on.",
                "type": "IntPar",
                "name": "transpeellayers",
                "items": []
            },
            {
                "text": "Toggle : Enables rendering; 1 = on, 0 = off.",
                "type": "TogglePar",
                "name": "render",
                "items": []
            },
            {
                "text": "Toggle : Dithers the rendering to help deal with banding and other artifacts created by precision limitations of 8-bit displays.",
                "type": "TogglePar",
                "name": "dither",
                "items": []
            },
            {
                "text": "Toggle : This is an optimization if you don't actually need the color result from this pass. Turning this off avoids a copy from the offscreen render buffer to the TOP's texture. When anti-aliasing is enabled, turning this off will also avoid 'resolving' the anti-aliasing.",
                "type": "TogglePar",
                "name": "coloroutputneeded",
                "items": []
            },
            {
                "text": "Toggle : This will cause the render to only draw depth values to the depth buffer. No color values will be created.  To make use of the depth buffer, use the [[Depth TOP]].",
                "type": "TogglePar",
                "name": "drawdepthonly",
                "items": []
            },
            {
                "text": "Int : Any shader you write can output to more than one RGBA buffer at a time. For GLSL 3.3+ you would use the layout(location = 1) specifier on an out variable in the pixel shader to write to the 2nd buffer. In GLSL 1.2 instead of writing to <code>gl_FragColor</code> in your shader, you write to <code>gl_FragData[i]</code> where i is the color buffer index you want to write the value to.",
                "type": "IntPar",
                "name": "numcolorbufs",
                "items": []
            },
            {
                "text": "Toggle : Controls if blending (as enabled by the MAT common page setting) will be enabled for extra buffers beyond the first one. Often the extra buffers are used to write other types of information such as normals or positions, where blending wouldn't be desirable.",
                "type": "TogglePar",
                "name": "allowbufblending",
                "items": []
            },
            {
                "text": "Menu : Use either a 24-bit Fixed-Point or 32-bit Floating-Point depth buffer (single channel image).",
                "type": "MenuPar",
                "name": "depthformat",
                "items": []
            },
            {
                "text": "Menu : Front Faces, Back Faces, Both Faces, Neither. Will cause the render to avoid rendering certain polygon faces depending on their orientation to the camera. Refer to [[Back-Face Culling]] for more information.",
                "type": "MenuPar",
                "name": "cullface",
                "items": []
            },
            {
                "text": "MAT : This allows you to specify a material that will be applied to every Geometry that is rendered in the Render TOP. It is useful for pre-processing passes where we are outputting information about the geometry rather then lighting them and outputting RGB.",
                "type": "MATPar",
                "name": "overridemat",
                "items": []
            },
            {
                "text": "Toggle : This feature pushes the polygons back into space a tiny fraction. This is useful when you are rendering two polygons directly ontop of each other and are experiencing [[Z-Fighting]]. Refer to [[Polygon Depth Offset]] for more information. This is also an important feature when doing shadows.",
                "type": "TogglePar",
                "name": "polygonoffset",
                "items": []
            },
            {
                "text": "Float : Adds an offset to the Z value that depends on how sloped the surface is to the viewer.",
                "type": "FloatPar",
                "name": "polygonoffsetfactor",
                "items": []
            },
            {
                "text": "Float : Adds a constant offset to the Z value.",
                "type": "FloatPar",
                "name": "polygonoffsetunits",
                "items": []
            },
            {
                "text": "Toggle : This feature visually shows the overdraw in the scene. Refer to the [[Early Depth-Test]] article for more information. In particular the Analyzing Overdraw section.",
                "type": "TogglePar",
                "name": "overdraw",
                "items": []
            },
            {
                "text": "Int : This value quantizes the outputted color value to some # of overdraws. Refer to the [[Early Depth-Test]] for more information.",
                "type": "IntPar",
                "name": "overdrawlimit",
                "items": []
            },
            {
                "text": "Float : Positions the left edge of the rendered image.",
                "type": "FloatPar",
                "name": "cropleft",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "cropleftunit",
                "items": []
            },
            {
                "text": "Float : Positions the right edge of the rendered image.",
                "type": "FloatPar",
                "name": "cropright",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "croprightunit",
                "items": []
            },
            {
                "text": "Float : Positions the bottom edge of the rendered image.",
                "type": "FloatPar",
                "name": "cropbottom",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "cropbottomunit",
                "items": []
            },
            {
                "text": "Float : Positions the top edge of the rendered image.",
                "type": "FloatPar",
                "name": "croptop",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "croptopunit",
                "items": []
            },
            {
                "text": "Toggle : Image Output allows you to read/write arbitrary data to a <code>image2D</code>, <code>image3D</code> etc, GLSL uniform using imageStore() and imageLoad() GLSL. This allows for extra data to be stored/loaded during the render process, to be used later. The uniforms will be named one of these arrays, depending on the type of image output selected <code>mTD2DImageOutputs[], mTD2DArrayImageOutputs[], mTD3DImageOutputs[], mTDCubeImageOutputs[]</code>. Since only one image ouptut is currently supported, index [0] should always be used to access these. The buffer is cleared to 0 before every render.",
                "type": "TogglePar",
                "name": "imageoutput",
                "items": []
            },
            {
                "text": "Int : The resolution of the image output. This does not need to be the same as the resolution the main Render is doing.",
                "type": "IntPar",
                "name": "imageres",
                "items": []
            },
            {
                "text": "Menu : Format used to store data for each channel in the image (ie. R, G, B, and A). Refer to [[Pixel Formats]] for more information.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "Menu : Specify what type of texture to create with the image output.",
                "type": "MenuPar",
                "name": "imagetype",
                "items": []
            },
            {
                "text": "Int : Set the depth when output Type is 2D Texture Array or 3D Texture.",
                "type": "IntPar",
                "name": "imagedepth",
                "items": []
            },
            {
                "text": "Menu : Controls how the output textures will be accessed. If the textures will be read from (such as using values generated by other shader executions within the same frame), then the access should be changed to Read-Write instead of Write Only.",
                "type": "MenuPar",
                "name": "imageaccess",
                "items": []
            },
            {
                "text": "Str : This is the sampler name that the GLSL program will use to sample from this TOP. The samplers need to be declared as the same dimensions as the TOP (sampler2D for a 2D TOP, sampler3D for 3D TOP).",
                "type": "StrPar",
                "name": "sampler0",
                "items": []
            },
            {
                "text": "TOP : This is the TOP that will be referenced by the above sampler name above it.",
                "type": "TOPPar",
                "name": "top0",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0filter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0anisotropy",
                "items": []
            },
            {
                "text": "Str : The uniform name, as declared in the shader.",
                "type": "StrPar",
                "name": "uniname0",
                "items": []
            },
            {
                "text": "XYZ : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZPar",
                "name": "value0x",
                "items": []
            },
            {
                "text": "XYZ : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZPar",
                "name": "value0y",
                "items": []
            },
            {
                "text": "XYZ : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZPar",
                "name": "value0z",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Render TOP is used to render all 3D scenes in TouchDesigner. You need to give it a [[Camera COMP|Camera]] object and a [[Geometry COMP|Geometry]] object as a minimum. \t\t\t\n\t\t\t\t\nThe Geometry object needs to have a [[MAT|Material]] assigned to it. Materials can be pre-packaged ones like the [[Phong MAT|Phong]] material, or they can be OpenGL GLSL shaders. All textures and bump maps in TouchDesigner materials are TOPs, i.e. files must be read in via [[Movie File In TOP]]s.\t\t\t\t\n\t\t\t\t\nRendering in TouchDesigner ties in nicely with compositing via the Render TOP and all other TOPs.\t\t\t\t\n\t\t\t\t\nThe Render TOP renders in many RGBA and single-channel formats, in 8-bit fixed-point up to to 32-bit floating point per pixel component.\t\t\t\t\n\t\t\t\t\nIt can render transparent surfaces correctly using Multi-Pass Depth Peeling. See below: Order Independent Transparency.\t\t\t\t\n\t\t\t\t\nMultiple Cameras: The Render TOP is able to render multiple cameras (more quickly than separately) in a single node. You specify multiple cameras in one Camera parameter, and use Render Select TOP to pull out those camera results. This feature is even faster on GPUs that support [[Multi-Camera Rendering]].\t\t\t\t\n\t\t\t\t\n\t\t\t\t\nSee also [[Rendering]], all the articles in the [http://www.derivative.ca/wiki/index.php?title=Category:Rendering Rendering Category], the [[Render Pass TOP]], and the troubleshooting page [[Why is My Render Black]].\t\t\t\t\n\t\t\t\t\nNOTE: If you are doing non-realtime GPU-intensive renders (ones that take multiple seconds to render a single SOP), see the note in Windows GPU Driver Timeouts in the [[Movie File Out TOP]].",
        "short": "The Render TOP is used to render all 3D scenes in TouchDesigner.",
        "opLicense": "Non-Commercial",
        "opLabel": "Render",
        "opFilter": "False",
        "opType": "render",
        "opClass": "renderTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "renderstreaminTOP": {
        "label": "renderstreaminTOP",
        "members": [
            {
                "text": "Toggle : Controls if this node is pulling image data from RenderStream.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The name of the image to pull from RenderStream.",
                "type": "StrPar",
                "name": "name",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "renderstreaminTOP",
        "opLabel": "RenderStream In",
        "opClass": "renderstreaminTOP_Class",
        "opFilter": "False",
        "opLicense": "Pro",
        "opCategories": "",
        "os": "Microsoft Windows",
        "short": "",
        "long": "This node brings in image data sent over the [[RenderStream]] protocol from [https://www.disguise.one/en/products/renderstream/ Disguise]. The actual setup and sync of the RenderStream connection is done with the [[RenderStream In CHOP]].\n    \nSee also [[RenderStream In CHOP]], [[RenderStream Out TOP]], [[RenderStream]]."
    },
    "renderstreamoutTOP": {
        "label": "renderstreamoutTOP",
        "members": [
            {
                "text": "Toggle : Controls if this node sends data out to RenderStream.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Int : The stream index to send to.",
                "type": "IntPar",
                "name": "streamindex",
                "items": []
            },
            {
                "text": "CHOP : A CHOP that contains channels of information that will be sent along with the image to be shown for profiling information in the D3 user interface.",
                "type": "CHOPPar",
                "name": "profilechop",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "renderstreamoutTOP",
        "opLabel": "RenderStream Out",
        "opClass": "renderstreamoutTOP_Class",
        "opFilter": "True",
        "opLicense": "Pro",
        "opCategories": "",
        "os": "Microsoft Windows",
        "short": "",
        "long": "Send image data out to [[RenderStream]]. The actual setup and sync of the RenderStream connection is done with the [[RenderStream In CHOP]].\n    \nSee also [[RenderStream In CHOP]], [[RenderStream In TOP]], [[RenderStream]]."
    },
    "reorderTOP": {
        "label": "reorderTOP",
        "members": [
            {
                "text": "Menu : Specify which input and channel is used as the red channel in the output image.",
                "type": "MenuPar",
                "name": "outputred",
                "items": []
            },
            {
                "text": "Menu : The channel to use from the selected input to use as the red channel in the output image.",
                "type": "MenuPar",
                "name": "outputredchan",
                "items": []
            },
            {
                "text": "Menu : Specify which input and channel is used as the green channel in the output image.",
                "type": "MenuPar",
                "name": "outputgreen",
                "items": []
            },
            {
                "text": "Menu : The channel to use from the selected input to use as the green channel in the output image.",
                "type": "MenuPar",
                "name": "outputgreenchan",
                "items": []
            },
            {
                "text": "Menu : Specify which input and channel is used as the blue channel in the output image.",
                "type": "MenuPar",
                "name": "outputblue",
                "items": []
            },
            {
                "text": "Menu : The channel to use from the selected input to use as the blue channel in the output image.",
                "type": "MenuPar",
                "name": "outputbluechan",
                "items": []
            },
            {
                "text": "Menu : Specify which input and channel is used as the alpha channel in the output image.",
                "type": "MenuPar",
                "name": "outputalpha",
                "items": []
            },
            {
                "text": "Menu : The channel to use from the selected input to use as the alpha channel in the output image.",
                "type": "MenuPar",
                "name": "outputalphachan",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Reorder TOP is a multi-input TOP which lets you choose any of the input channels for the R, G, B, and A output.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Reorder",
        "opClass": "reorderTOP_Class",
        "opType": "reorder",
        "long": "The Reorder TOP is a multi-input TOP which lets you choose any of the input channels for the R, G, B, and A output. It also gives the option of outputting one, zero or the input luminance to any of the output channels.\t\n\t\t\nSee also [[Channel Mix TOP]].",
        "opCategories": ""
    },
    "resolutionTOP": {
        "label": "resolutionTOP",
        "members": [
            {
                "text": "Toggle : Uses weighted averages of multiple-pixels when scaling down the image.",
                "type": "TogglePar",
                "name": "highqualresize",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Resolution TOP changes the resolution of the TOP image.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Resolution",
        "opClass": "resolutionTOP_Class",
        "opType": "res",
        "long": "The Resolution TOP changes the resolution of the TOP image. This can also be done on the Common page of most other TOPs.",
        "opCategories": ""
    },
    "rgbkeyTOP": {
        "label": "rgbkeyTOP",
        "members": [
            {
                "text": "Float : The minimum red value that is added to the key. 0 = min, 1 = max.",
                "type": "FloatPar",
                "name": "redmin",
                "items": []
            },
            {
                "text": "Float : The maximum red value that is added to the key. 0 = min, 1 = max.",
                "type": "FloatPar",
                "name": "redmax",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Red Min setting.",
                "type": "FloatPar",
                "name": "rsoftlow",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Red Max setting.",
                "type": "FloatPar",
                "name": "rsofthigh",
                "items": []
            },
            {
                "text": "Float : The minimum green value that is added to the key. 0 = min, 1 = max.",
                "type": "FloatPar",
                "name": "greenmin",
                "items": []
            },
            {
                "text": "Float : The maximum green value that is added to the key. 0 = min, 1 = max.",
                "type": "FloatPar",
                "name": "greenmax",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Green Min setting.",
                "type": "FloatPar",
                "name": "gsoftlow",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Green Max setting.",
                "type": "FloatPar",
                "name": "gsofthigh",
                "items": []
            },
            {
                "text": "Float : The minimum blue value that is added to the key. 0 = min, 1 = max.",
                "type": "FloatPar",
                "name": "bluemin",
                "items": []
            },
            {
                "text": "Float : The maximum blue value that is added to the key. 0 = min, 1 = max.",
                "type": "FloatPar",
                "name": "bluemax",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Blue Min setting.",
                "type": "FloatPar",
                "name": "bsoftlow",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the Blue Max setting.",
                "type": "FloatPar",
                "name": "bsofthigh",
                "items": []
            },
            {
                "text": "Float : Inverts the key that is created.",
                "type": "FloatPar",
                "name": "invert",
                "items": []
            },
            {
                "text": "Menu : Determines the output of the RGB channels from the RGB Key TOP.",
                "type": "MenuPar",
                "name": "rgbout",
                "items": []
            },
            {
                "text": "Menu : Determines the output of the Alpha channel from the RGB Key TOP.",
                "type": "MenuPar",
                "name": "alphaout",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The RGB Key TOP pulls a key from the image using Red, Green, and Blue channel settings. If a pixel falls between the Min and Max parameters for all three settings, then it is included in the key.",
        "short": "The RGB Key TOP pulls a key from the image using Red, Green, and Blue channel settings.",
        "opLicense": "Non-Commercial",
        "opLabel": "RGB Key",
        "opFilter": "True",
        "opType": "rgbkey",
        "opClass": "rgbkeyTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "rgbtohsvTOP": {
        "label": "rgbtohsvTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The RGV to HSV TOP converts the image from RGB to HSV colorspace. The R channel becomes Hue, the G channel becomes Saturation, and the B channel becomes Value.",
        "short": "The RGV to HSV TOP converts the image from RGB to HSV colorspace.",
        "opLicense": "Non-Commercial",
        "opLabel": "RGB to HSV",
        "opFilter": "True",
        "opType": "rgbhsv",
        "opClass": "rgbtohsvTOP_Class",
        "opFamily": "TOP",
        "opCategories": ""
    },
    "scalabledisplayTOP": {
        "label": "scalabledisplayTOP",
        "members": [
            {
                "text": "File : Specify the location of the Scalable Displays Calibration Data file.",
                "type": "FilePar",
                "name": "configfile",
                "items": []
            },
            {
                "text": "Float : Sets the near value.",
                "type": "FloatPar",
                "name": "near",
                "items": []
            },
            {
                "text": "Float : Sets the far value.",
                "type": "FloatPar",
                "name": "far",
                "items": []
            },
            {
                "text": "Float : Sets the eye point for dynamic (ie. POL) files.",
                "type": "FloatPar",
                "name": "eyepoint",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Scalable Display TOP lets you load calibration data retrieved from running the [http://www.scalabledisplay.com/ Scalable Display Calibration Software].",
        "opLicense": "Pro",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Scalable Display",
        "opClass": "scalabledisplayTOP_Class",
        "opType": "scalabledisplay",
        "os": "Microsoft Windows",
        "long": "The Scalable Display TOP lets you load calibration data retrieved from running the [http://www.scalabledisplay.com/ Scalable Display Calibration Software].\t\t\n \t\t\nPlease refer to [[How-to calibrate your projector with Scalable Displays]] for a complete guide on TouchDesigners integration of the Scalable Displays SDK.\t\t\n\t\t\nUse the <code>projection</code> and <code>cameraTransform</code> python members of this node in a [[Camera COMP]] to make use of the camera information contained in the configuration file.\n\nSee also [[Projection Mapping]], [[Vioso]], [[Palette:kantanMapper|kantanMapper]], [[Palette:camSchnappr|camSchnappr]], [[Palette:projectorBlend|projectorBlend]]",
        "opCategories": ""
    },
    "screengrabTOP": {
        "label": "screengrabTOP",
        "members": [
            {
                "text": "Toggle : When On, the TOP will grab the screen contents.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Pulse : Instantly grab the frame. Useful when Active is Off to update the screen-grabbed image for an single frame capture.",
                "type": "PulsePar",
                "name": "activepulse",
                "items": []
            },
            {
                "text": "StrMenu : Select which source to grab, the 'Full Desktop' canvas, a specific display, or an individual application (Windows only).",
                "type": "StrMenuPar",
                "name": "source",
                "items": []
            },
            {
                "text": "Pulse : Click this button to refresh the source list in the menu above after connecting or disconnecting displays or opening or closing application windows.",
                "type": "PulsePar",
                "name": "refreshsource",
                "items": []
            },
            {
                "text": "Float : Sets the left edge of the area to be grabbed.",
                "type": "FloatPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "leftunit",
                "items": []
            },
            {
                "text": "Float : Sets the right edge of the area to be grabbed.",
                "type": "FloatPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "rightunit",
                "items": []
            },
            {
                "text": "Float : Sets the bottom edge of the area to be grabbed. (Bottom = 0)",
                "type": "FloatPar",
                "name": "bottom",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "bottomunit",
                "items": []
            },
            {
                "text": "Float : Sets the top edge of the area to be grabbed.",
                "type": "FloatPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "topunit",
                "items": []
            },
            {
                "text": "Toggle : Faster when On but may not work on some systems (Optimus equipped laptops are problematic).",
                "type": "TogglePar",
                "name": "delayed",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Screen Grab TOP turns the main screen output into a TOP image.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Screen Grab",
        "opClass": "screengrabTOP_Class",
        "opType": "screengrab",
        "long": "The Screen Grab TOP turns the main screen output into a TOP image. It can be captured in real-time while you work.",
        "opCategories": ""
    },
    "screenTOP": {
        "label": "screenTOP",
        "members": [
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]]",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Screen TOP brightens the underlying layers depending on how bright the screened layer's pixels are.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Screen",
        "opClass": "screenTOP_Class",
        "opType": "screen",
        "long": "The Screen TOP brightens the underlying layers depending on how bright the screened layer's pixels are. If the screened pixel is black, it will look completely transparent. A white pixel will be white.",
        "opCategories": ""
    },
    "scriptTOP": {
        "label": "scriptTOP",
        "members": [
            {
                "text": "DAT : Specifies the DAT which holds the callbacks.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Pulse : Clicking the button runs the <code>setupParameters()</code> callback function.",
                "type": "PulsePar",
                "name": "setuppars",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "scriptTOP",
        "opLabel": "Script",
        "opClass": "scriptTOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "Generates a TOP image via a Python script.",
        "long": "The Script TOP can be used to generate a TOP image using a Python script. The core feature it exposes is <code>copyNumpyArray</code>, which takes a NumPy array as input, and fills the TOP with the given image. How the NumPy array is generated is entirely up to the script writter, custom code, OpenCV, etc. \n\nThe source can be 3 or 4 channels for <code>copyNumpyArray()</code>.\n\nThe [[Script CHOP]] enables numPy arrays to be converted into the CHOP's channels.  Also any CHOP can get its channels converted into numPy arrays. (May 2021)\n\nSee <code>numPyArray()</code> in [[TOP Class]]., [[Script DAT]].\n\nSee also [[Script CHOP]], [[Script SOP]]",
        "opCategories": ""
    },
    "selectTOP": {
        "label": "selectTOP",
        "members": [
            {
                "text": "TOP : The path of the TOP being referenced. Drag & drop any TOP here, or manually enter the path to the TOP.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Select TOP allows you to reference a TOP from any other location in TouchDesigner.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Select",
        "opClass": "selectTOP_Class",
        "opType": "select",
        "long": "The Select TOP allows you to reference a TOP from any other location in TouchDesigner. To save graphics memory, the Select TOP creates an instance of the TOP references.",
        "opCategories": ""
    },
    "sharedmeminTOP": {
        "label": "sharedmeminTOP",
        "members": [
            {
                "text": "Str : The name of the memory block it reads from.",
                "type": "StrPar",
                "name": "name",
                "items": []
            },
            {
                "text": "Menu : Reads from a '''Local''' or a '''Global''' memory location.",
                "type": "MenuPar",
                "name": "memtype",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Shared Mem In TOP will read image data from a shared memory block.",
        "opLicense": "Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Shared Mem In",
        "opClass": "sharedmeminTOP_Class",
        "opType": "sharedmemin",
        "long": "The Shared Mem In TOP will read image data from a shared memory block. This memory block can be created by another TouchDesigner process or a 3rd party application.\t\t\t\n\t\t\t\nSee [[Using Shared Memory in TouchDesigner]] and [[Shared Mem Out TOP]].",
        "opCategories": ""
    },
    "sharedmemoutTOP": {
        "label": "sharedmemoutTOP",
        "members": [
            {
                "text": "Toggle : When active, the TOP cooks its inputs and writes to the memory block.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : Name of the memory block that it writes to.",
                "type": "StrPar",
                "name": "name",
                "items": []
            },
            {
                "text": "Menu : Writes to a '''Local''' or a '''Global''' memory location.",
                "type": "MenuPar",
                "name": "memtype",
                "items": []
            },
            {
                "text": "Menu : Select between Immediate(Slow) and Next Frame(Fast) for better performance.",
                "type": "MenuPar",
                "name": "downloadtype",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Shared Mem Out TOP will write image data out to a shared memory block for use by other TouchDesigner processes or other 3rd party applications.",
        "opLicense": "Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Shared Mem Out",
        "opClass": "sharedmemoutTOP_Class",
        "opType": "sharedmemout",
        "long": "The Shared Mem Out TOP will write image data out to a shared memory block for use by other TouchDesigner processes or other 3rd party applications.\t\t\t\n\t\t\t\nSee [[Using Shared Memory in TouchDesigner]] and [[Shared Mem In TOP]].",
        "opCategories": ""
    },
    "slopeTOP": {
        "label": "slopeTOP",
        "members": [
            {
                "text": "Menu : Select which method is used to calculate the slope of the Red channel. Horizontal and Vertical options let you calculate the slope by sampling points horizontally or vertically.",
                "type": "MenuPar",
                "name": "red",
                "items": []
            },
            {
                "text": "Menu : Select which method is used to calulate the slope of the Green channel. Horizontal and Vertical options let you calculate the slope by sampling points horizontally or vertically.",
                "type": "MenuPar",
                "name": "green",
                "items": []
            },
            {
                "text": "Menu : Select which method is used to calulate the slope of the Blue channel. Horizontal and Vertical options let you calculate the slope by sampling points horizontally or vertically.",
                "type": "MenuPar",
                "name": "blue",
                "items": []
            },
            {
                "text": "Menu : Select which method is used to calculate the slope of the Alpha channel. Horizontal and Vertical options let you calculate the slope by sampling points horizontally or vertically.",
                "type": "MenuPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Menu : Determines what pixels to use when calculating the slope at each pixel in the image.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Float : Sets the value to output when the slope is zero, similar to a midpoint. Default is .5 since 8-bit pxels are 0 to 1. But with Pixel Format et to 32-bit Float you should set this to 0, and look at the view in Normalized Split mode.",
                "type": "FloatPar",
                "name": "zeropoint",
                "items": []
            },
            {
                "text": "Float : Set the strength of the output using this multiplier. Higher values result in higher slope values.",
                "type": "FloatPar",
                "name": "strength",
                "items": []
            },
            {
                "text": "Float : When sampling the image, this determines the distance from each pixel to the sample pixel. When units are set to pixels, it is the number of pixels away from the current pixel which is sampled to find edges. A <span class=\"tipTextTOP\">Sample Step</span> of 3 would sample pixels 3 pixels away to look for edges.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "offsetunit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Slope TOP generates pixels that represent the difference between its value and its neighbouring pixels' values.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Slope",
        "opClass": "slopeTOP_Class",
        "opType": "slope",
        "long": "The Slope TOP generates pixels that represent the difference between its value and its neighbouring pixels' values. Given that default RGBA pixel values are between 0 and 1, the value of .5 means the neighbor's values are the same as the pixel's value. Values output in the red channel that are above .5 indicate the values are increasing left-to-right. Values output in the blue channel that are above .5 indicate the values are increasing bottom-to-top.\t\n    \nHowever it's more clear if you switch the Pixel Format parameter to 32-bit float RGBA so you get a proper representation of negative numbers. Also set the Zero Point parameter to 0, and view the TOP view as Normalized Split to see a good representation of negative numbers.",
        "opCategories": ""
    },
    "spectrumTOP": {
        "label": "spectrumTOP",
        "members": [
            {
                "text": "Menu : Selects the transform mode (ie. direction). Either DFT or IDFT.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Menu : Selects the coordinate system for output/input in the DFT/IDFT cases respectively.",
                "type": "MenuPar",
                "name": "coord",
                "items": []
            },
            {
                "text": "Menu : Selects which channel of the input TOP to use for the discrete fourier transform.",
                "type": "MenuPar",
                "name": "chan",
                "items": []
            },
            {
                "text": "Toggle : When enabled, will perform the DFT/IDFT by row.",
                "type": "TogglePar",
                "name": "transrows",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "TOP",
        "opType": "spectrumTOP",
        "opLabel": "Spectrum",
        "opClass": "spectrumTOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This operator only works with Nvidia GPUs.",
        "short": "The Spectrum TOP uses CUDA and OpenCV's DFT operation to perform discrete fourier transforms (DFT) or inverse discrete fourier transforms (IDFT) on a TOP input.",
        "long": "The Spectrum TOP uses CUDA and OpenCV's DFT operation to perform discrete fourier transforms (DFT) or inverse discrete fourier transforms (IDFT) on a TOP input.",
        "opCategories": ""
    },
    "ssaoTOP": {
        "label": "ssaoTOP",
        "members": [
            {
                "text": "Menu : Determines the visual quality of the results. The higher the quality, the more computationally expensive it is.",
                "type": "MenuPar",
                "name": "quality",
                "items": []
            },
            {
                "text": "Int : For each pixel, rays are sent out in random directions to see if there is a surface nearby that would occlude the ambient light to this pixel. This parameter controls how many rays are sent out per pixel.",
                "type": "IntPar",
                "name": "sampledirs",
                "items": []
            },
            {
                "text": "Int : Since this is a 2D pixel-based operation, the rays need to sample multiple neighboring pixels along its path to check for points of interest. This parameter controls how many of these samples each ray does.",
                "type": "IntPar",
                "name": "samplesteps",
                "items": []
            },
            {
                "text": "Float : This parameter biases the angle of the rays so they don't travel too close to the plane that the starting point lays on (as determined by the point's normal).",
                "type": "FloatPar",
                "name": "surfaceavoid",
                "items": []
            },
            {
                "text": "Menu : The SSAO pass can be set to Full, Half, or Quarter the resolution of the input image.",
                "type": "MenuPar",
                "name": "ssaopassres",
                "items": []
            },
            {
                "text": "Float : The distance it searches from the current point for occluders (in object space units).",
                "type": "FloatPar",
                "name": "ssaoradius",
                "items": []
            },
            {
                "text": "Float : Controls the contrast of the SSAO contribution.",
                "type": "FloatPar",
                "name": "contrast",
                "items": []
            },
            {
                "text": "Float : Controls the attenuation of the ambient lighting.",
                "type": "FloatPar",
                "name": "attenuation",
                "items": []
            },
            {
                "text": "Float : To avoid the ambient occlusion from bleeding across the edges of objects onto other objects, an edge detect is done using the depth buffer to figure where one object ends and the next one begins. This parameter controls how sensitive the edge detection is.",
                "type": "FloatPar",
                "name": "edgethresh",
                "items": []
            },
            {
                "text": "Float : The amount of blur in pixels.",
                "type": "FloatPar",
                "name": "blurradius",
                "items": []
            },
            {
                "text": "Float : Controls the sharpness of the blur operation.",
                "type": "FloatPar",
                "name": "blursharpness",
                "items": []
            },
            {
                "text": "Toggle : By default the final ambient occlusion result will be multiplied by the color output of the Render TOP. You can just output the ambient occlusion results by turning this parameter off.",
                "type": "TogglePar",
                "name": "combinewithcolor",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The SSAO TOP performs Screen Space Ambient Occlusion on the output of a [[Render TOP]] or [[Render Pass TOP]].",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "SSAO",
        "opClass": "ssaoTOP_Class",
        "opType": "ssao",
        "long": "The SSAO TOP performs Screen Space Ambient Occlusion on the output of a [[Render TOP]] or [[Render Pass TOP]]. Because this technique requires access to the [[Depth Buffer]], no other TOP can be in between the Render/RenderPass TOP and the SSAO TOP. Screen Space Ambient Occlusion is a real-time rendering trick that creates an approximation of ambient occlusion by using the [[Depth Buffer]] of the rendered scene. It is done as 2D post-processes, so the complexity of the scene has no bearing on how expensive it is. This is in comparison to true ambient occlusion which becomes more expensive with each new object that is rendered. There are two parts to a SSAO technique. First a SSAO pass is done that determines how much ambient occlusion each pixel is affected by. This result tends to be very noisy. A blur operation is then performed to even out this noise.",
        "opCategories": ""
    },
    "stypeTOP": {
        "label": "stypeTOP",
        "members": [
            {
                "text": "CHOP : Reference to a CHOP that outputs the lens distortion parameters. This can be a [[Stype CHOP]] or another operator that has the channels ''k1'', ''k2'', ''centerx'', ''centery'', ''pawidth'' and ''paheight'' defined. See [[Stype CHOP]] for more information on these channels.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Float : Only enabled when the ''CHOP Node'' parameter does not reference a [[Stype CHOP]]. This parameter indicates if any padding has been provided on the source image and then crops the output accordingly. See the [[Stype CHOP]] for more information on padding.",
                "type": "FloatPar",
                "name": "padding",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "stypeTOP_Class",
        "opLabel": "Stype",
        "opFamily": "TOP",
        "opLicense": "Pro",
        "opType": "stype",
        "opFilter": "False",
        "long": "The Stype TOP works with [[Stype]] ('''RedSpy''') camera trackers to perform simulated lens distortion using channels from a connected CHOP. \t\t\n\t\t\t\n'''NOTE:''' This CHOP works with [https://www.stype.tv Stype] hardware.\t\nSee also [[Stype]] and [[Stype CHOP]].",
        "short": "The Stype TOP performs simulated lens distortion using channels from a connected CHOP.",
        "opCategories": ""
    },
    "substanceselectTOP": {
        "label": "substanceselectTOP",
        "members": [
            {
                "text": "TOP : Reference a specific [[Substance TOP]] from which to select a texture.",
                "type": "TOPPar",
                "name": "substance",
                "items": []
            },
            {
                "text": "StrMenu : Choose which texture is being grabbed from the [[Substance TOP]].",
                "type": "StrMenuPar",
                "name": "output",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Substance Select TOP allows you to select a single texture out of the [[Substance TOP]] for further filtering and manipulation in TOPs.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Substance Select",
        "opClass": "substanceselectTOP_Class",
        "opType": "subselect",
        "long": "The Substance Select TOP allows you to select a single texture out of the [[Substance TOP]] for further filtering and manipulation in TOPs.",
        "opCategories": ""
    },
    "substanceTOP": {
        "label": "substanceTOP",
        "members": [
            {
                "text": "File : Specify the .sbsar material file from Substance Designer.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Pulse : Reloads the file from disk.",
                "type": "PulsePar",
                "name": "reloadconfig",
                "items": []
            },
            {
                "text": "StrMenu : Specify which graph in the <code>.sbsar</code> file to use. See [https://support.allegorithmic.com/documentation/display/SD41/Graphs+and+Sub-Graphs Substance's Graph Help] for more details.",
                "type": "StrMenuPar",
                "name": "graph",
                "items": []
            },
            {
                "text": "StrMenu : Choose what the output of the TOP will be. Grid Preview can be used to see all the texture maps inside the material at once.",
                "type": "StrMenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Toggle : Inverts the normal map coming from the sbsar file. This parameter should be used when the normal map in the sbsar is -Y (DirectX) since normal map usage in TouchDesigner expects the normal map as Y+ (OpenGL).",
                "type": "TogglePar",
                "name": "invertnormal",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "There is a tight integration between TouchDesigner and [http://www.allegorithmic.com/products/substance-designer Allegorithmic's Substance Designer], a material creation package that is also node-based and has extensive material libraries.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Substance",
        "opClass": "substanceTOP_Class",
        "opType": "substance",
        "long": "There is a tight integration between TouchDesigner and [http://www.allegorithmic.com/products/substance-designer Allegorithmic's Substance Designer], a material creation package that is also node-based and has extensive material libraries. The Substance TOP allows you to load <code>.sbsar</code> files from [https://www.allegorithmic.com/products/substance-designer Substance Designer] to use with the [[PBR MAT|PBR Material]].\t\n\t\t\nThe Substance TOP will load a material from a <code>.sbsar</code> file saved out from Substance Designer giving you access to all the parametric settings of the material inside TouchDesigner via automatically-generated parameters. Adjusting the parameters in TouchDesigner causes the materials to update on the fly. \t\t\n\t\t\nThe Substance TOP outputs multiple images, one for each layer, typically five or more for base color, roughness, metallic, etc. The Substance TOP can be dragged to the PBR material which assigns all the layers to the appropriate PBR layers. Alternately, the [[Substance Select TOP]] can extract a single layer to which you can apply any TOP image operations, then assign the result to one of the PBR layer parameters.",
        "opCategories": ""
    },
    "subtractTOP": {
        "label": "subtractTOP",
        "members": [
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]].",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Subtract TOP composites the input images together by subtracting the pixel values.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Subtract",
        "opClass": "subtractTOP_Class",
        "opType": "sub",
        "long": "The Subtract TOP composites the input images together by subtracting the pixel values.\t\t\n\t\t\t\nOutput = Input1 - Input2. The pixel values below 0 are clammped to 0.",
        "opCategories": ""
    },
    "svgTOP": {
        "label": "svgTOP",
        "members": [
            {
                "text": "File : The path and name of the SVG file to load. File format .svg supported.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "DAT : Not currently used.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "Toggle : Change from 0 to 1 to force the file to reload, useful when the file changes or did not exist at first.",
                "type": "TogglePar",
                "name": "reload",
                "items": []
            },
            {
                "text": "Menu : Sets the level of anti-aliasing in the scene. Setting this to higher values uses more graphics memory.",
                "type": "MenuPar",
                "name": "antialias",
                "items": []
            },
            {
                "text": "RGB : Sets the background color in the image.",
                "type": "RGBPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGB : Sets the background color in the image.",
                "type": "RGBPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGB : Sets the background color in the image.",
                "type": "RGBPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "Float : Sets the background alpha in the image.",
                "type": "FloatPar",
                "name": "bgalpha",
                "items": []
            },
            {
                "text": "Menu : The menu attached to this parameter allows you to specify the order in which the changes to your TOP will take place. Changing the Transform order will change where things go much the same way as going a block and turning east gets you to a different place than turning east and then going a block.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : The rotational matrix presented when you click on this option allows you to set the transform order for the TOP's rotations. As with transform order (above), changing the order in which the TOP's rotations take place will alter the TOP's final position.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XY : The two fields for Translate allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : The two fields for Translate allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XYZ : The three fields for Rotate allow you to specify the amount of rotation along any of the three axes.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : The three fields for Rotate allow you to specify the amount of rotation along any of the three axes.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : The three fields for Rotate allow you to specify the amount of rotation along any of the three axes.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XY : The two fields for Scale allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : The two fields for Scale allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : The Pivot point edit fields allow you to define the point about which the TOP scales and rotates. Altering the pivot point of a TOP produces different results depending on the transformation performed on the TOP image.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of a TOP image is located at <code>-1,-1</code> and you wanted to scale the image by <code>0.5</code> (reduce its size by 50%), then the TOP would scale toward the pivot point and appear to slide down and to the left.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : The Pivot point edit fields allow you to define the point about which the TOP scales and rotates. Altering the pivot point of a TOP produces different results depending on the transformation performed on the TOP image.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of a TOP image is located at <code>-1,-1</code> and you wanted to scale the image by <code>0.5</code> (reduce its size by 50%), then the TOP would scale toward the pivot point and appear to slide down and to the left.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The SVG TOP loads [https://en.wikipedia.org/wiki/Scalable_Vector_Graphics SVG] files into TouchDesigner.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "SVG",
        "opClass": "svgTOP_Class",
        "opType": "svg",
        "long": "The SVG TOP has been deprecated and no longer works. Try [[palette:webSvg]] as an alternative.\t\t\n\t\t\t\nSee also the [[Web Render TOP]].",
        "opCategories": ""
    },
    "switchTOP": {
        "label": "switchTOP",
        "members": [
            {
                "text": "Float : Selects which input to pass though to the output. The first input is 0.",
                "type": "FloatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Toggle : Blends the input images when using floating point numbers in the <span class=\"tipTextTOP\">Input </span>parameter.",
                "type": "TogglePar",
                "name": "blend",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Switch TOP is a multi-input operator which lets you switch which input is passed through using the <span class=\"tipTextTOP\">Input</span> parameter.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Switch",
        "opClass": "switchTOP_Class",
        "opType": "switch",
        "long": "The Switch TOP is a multi-input operator which lets you switch which input is passed through using the <span class=\"tipTextTOP\">Input</span> parameter.",
        "opCategories": ""
    },
    "syphonspoutinTOP": {
        "label": "syphonspoutinTOP",
        "members": [
            {
                "text": "Toggle : Spout has a external utility that allows selecting from the list of senders running, and flagging one as the global 'Active' sender. Enabling this parameter will make the node use that sender instead of the one listed in the 'Sender Name' parameter.",
                "type": "TogglePar",
                "name": "usespoutactivesender",
                "items": []
            },
            {
                "text": "StrMenu : The name of the Syphon/Spout sender you wish to receive.",
                "type": "StrMenuPar",
                "name": "sendername",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Syphon Spout In TOP will obtain its texture image via shared memory from other applications that support the [http://spout.zeal.co/ Spout framework] on Windows or [http://syphon.v002.info/ Syphon] on macOS.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Syphon Spout In",
        "opClass": "syphonspoutinTOP_Class",
        "opType": "syphonspoutin",
        "long": "'''Note:''' For Spout on Windows, an Nvidia or AMD GPU is required, Intel does not work.\n    \nThe Syphon Spout In TOP will obtain its texture image via shared memory from other applications that support the [http://spout.zeal.co/ Spout framework] on Windows or [http://syphon.v002.info/ Syphon] on macOS. Since this uses shared memory, it only works on the computer it's running on and does not transmit textures across a network to another computer. To send textures to another computer, see [[Touch In TOP]] and [[Touch Out TOP]], or [[NDI In TOP]] and [[NDI Out TOP]].\t\n\t\t\nYou can download a Spout setup package at http://spout.zeal.co/ for testing and example applications.\t\t\nYou can download a [https://github.com/Syphon/Simple/releases/download/public-beta-2/Syphon.Demo.Apps.Public.Beta.2.dmg Syphon simple server] setup to testing.\t\t\n\t\t\nBy default Spout on Windows is limited to 10 senders active on the computer. This limit can be changed by setting the Windows registry DWORD:<br>\t\t\nHKEY_CURRENT_USER\\\\Software\\\\Leading Edge\\\\Spout\\\\MaxSenders\t\t\n\t\t\nSee also: [[Syphon Spout Out TOP]]",
        "opCategories": ""
    },
    "syphonspoutoutTOP": {
        "label": "syphonspoutoutTOP",
        "members": [
            {
                "text": "Toggle : Turns the sending on or off.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The name of the Syphon/Spout sender you wish to output. This can be any text string.",
                "type": "StrPar",
                "name": "sendername",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Syphon Spout Out TOP will share its input texture with other applications that support the [http://spout.zeal.co/ Spout framework] on Windows or [http://syphon.v002.info/ Syphon] on macOS.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Syphon Spout Out",
        "opClass": "syphonspoutoutTOP_Class",
        "opType": "syphonspoutout",
        "long": "'''Note:''' For Spout on Windows, an Nvidia or AMD GPU is required, Intel does not work.\n    \nThe Syphon Spout Out TOP will share its input texture with other applications that support the [http://spout.zeal.co/ Spout framework] on Windows or [http://syphon.v002.info/ Syphon] on macOS. Since this uses shared memory, it only works on the computer it's running on and does not transmit textures across a network to another computer. Spout can send textures in various pixel formats up to and including 32-bit float RGBA. Syphon is limited to 8-bit RGBA. To send textures to another computer, see [[Touch In TOP]] and [[Touch Out TOP]], or [[NDI In TOP]] and [[NDI Out TOP]].\t\n\t\t\nYou can download a Spout setup package at http://spout.zeal.co/ for testing and example applications.\t\t\nYou can download a [https://github.com/Syphon/Simple/releases/download/public-beta-2/Syphon.Demo.Apps.Public.Beta.2.dmg Syphon simple server] setup for testing on macOS.\t\t\n\t\t\nBy default Spout on Windows is limited to 10 senders active on the computer. This limit can be changed by setting the Windows registry DWORD:<br>\t\t\nHKEY_CURRENT_USER\\\\Software\\\\Leading Edge\\\\Spout\\\\MaxSenders\t\t\n\t\t\nSee also: [[Syphon Spout In TOP]]",
        "opCategories": ""
    },
    "textTOP": {
        "label": "textTOP",
        "members": [
            {
                "text": "PanelCOMP : Specifies a [[Field COMP|Field Component]] to use as the source of the text. The font and style of the text displayed in the Field Component are set using the parameters in the Text TOP.",
                "type": "PanelCOMPPar",
                "name": "field",
                "items": []
            },
            {
                "text": "DAT : Specifies a DAT to use for the source of the text. Drag and Drop a DAT onto this field, or manually enter the DAT's path.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "Int : The row number (starting from 0) of the cell, if the DAT is a table.",
                "type": "IntPar",
                "name": "rowindex",
                "items": []
            },
            {
                "text": "Int : The column number of the cell, if the DAT is a table.",
                "type": "IntPar",
                "name": "colindex",
                "items": []
            },
            {
                "text": "DAT : A Table DAT that allows you to specify and position text by pixel, with the lower left corner being at 0, 0.  Column headers must include <code>position1</code> or <code>x</code>, <code>position2</code> or <code>y</code>, and <code>text</code>.  A sample table can be:\t\t\n\t\t\t\t\n x\ty\ttext\t\t\n 0\t0\tlower left text\t\t\n 100\t100\tsomewhere in the middle",
                "type": "DATPar",
                "name": "specdat",
                "items": []
            },
            {
                "text": "Str : A string of text. It optionally can be followed by a numeric value and another post-string, as set with <span class=\"tipTextTOP\">Value</span> and <span class=\"tipTextTOP\">Post Text</span> below. If newlines or tabs are desired, the recommended way is to change this parameter to expression mode, and specify a Python string that includes \\n or \\t to signify newlines and tabs. E.g 'First Line\\nSecond Line'.",
                "type": "StrPar",
                "name": "text",
                "items": []
            },
            {
                "text": "Toggle : In older builds the syntax \\XXX (E.g \\200 would be character 200), \\t, \\n as well as [] and {} (to position strings) was parsed in the string. This is now deprecated. For specifying characters codes, \\t and \\n [https://docs.python.org/3.3/howto/unicode.html Python syntax should be used instead.]. The 'Specification DAT' should be used to position strings instead of [], {}. This parameter can be enabled to turn back on this legacy parsing though. If this is enabled and you want to display the characters <code>\\ [ ] { }</code>, you must precede them with a <code>\\</code>.'''",
                "type": "TogglePar",
                "name": "legacyparsing",
                "items": []
            },
            {
                "text": "Toggle : Enables the <span class=\"tipTextTOP\">Value</span> field defined below. This value is inserted between the <span class=\"tipTextTOP\">Text</span> string and the <span class=\"tipTextTOP\">Post Text</span> string.",
                "type": "TogglePar",
                "name": "appendvalue",
                "items": []
            },
            {
                "text": "Float : The numeric value to display.",
                "type": "FloatPar",
                "name": "valuetouse",
                "items": []
            },
            {
                "text": "Int : The total number of digits in the value displayed.",
                "type": "IntPar",
                "name": "totaldigits",
                "items": []
            },
            {
                "text": "Int : The number of digits displayed after the decimal place.",
                "type": "IntPar",
                "name": "decimaldigits",
                "items": []
            },
            {
                "text": "Str : The text string appended after Text and Value (if present).",
                "type": "StrPar",
                "name": "posttext",
                "items": []
            },
            {
                "text": "Toggle : Allows portions of the strings to be replaced by CHOP values via a syntax similar to C-style printf()/sprintf(). More details of the syntax are provided in the next parameter, 'CHOP' .",
                "type": "TogglePar",
                "name": "chopvaluereplace",
                "items": []
            },
            {
                "text": "CHOP : The CHOP containing all the values to insert in the <span class=\"tipTextTOP\">Text</span> strings. The Text TOP will repeat the Text string until all CHOP channels are displayed. They are displayed by using a special syntax in your <span class=\"tipTextTOP\">Text</span> string, defined as string starting with <code>%</code>, for example <code>%4d</code>:\t\t\n\t\t\t\t\n<blockquote>\t\t\t\t\n<code> %[flags][width][.precision][type]</code>\t\t\t\t\n</blockquote>\t\t\t\t\n* <code>flags</code> (optional) - Alignment options.\t\t\t\t\n** - : left align (text is right aligned by default)\t\t\t\t\n** 0 : pad the left side with zeros\t\t\t\t\n* <code>width</code> (optional) - Total number of digits in the number displayed.\t\t\t\t\n* <code>precision</code> (optional) - Number of digits after the decimal place.\t\t\t\t\n* <code>type</code> - Number format.\t\t\t\t\n** d : integer\t\t\t\t\n** f : float\t\t\t\t\n** g : double, exponential format is used only when the exponent of the value is less than ?4.\t\t\t\t\n\t\t\t\t\nDrag and Drop a CHOP onto this field, or manually enter the CHOP's path.\t\t\t\t\n\t\t\t\t\n[[image:TextTOPCHOPValue.jpg]]",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Toggle : When checked text is automatically line wrapped so it doesn't extend outside the TOP's borders.  When using Word Wrap and Auto-Size together, the text will first word-wrap based on the specified font size, then auto size the resulting block of text.",
                "type": "TogglePar",
                "name": "wordwrap",
                "items": []
            },
            {
                "text": "Toggle : Enables smart quotes which use a left (opening) quotation mark and a right (closing) quotation mark instead of straight quotes.",
                "type": "TogglePar",
                "name": "smartquote",
                "items": []
            },
            {
                "text": "StrMenu : Select the font for the text from this drop down menu. All fonts are provided by Windows, any [http://en.wikipedia.org/wiki/TrueType TrueType] font that is loaded into Windows can be used.",
                "type": "StrMenuPar",
                "name": "font",
                "items": []
            },
            {
                "text": "File : Specify any TrueType font file (<code>.ttf file</code>) to use for the text.  When using a font file, the Font menu above is disabled.",
                "type": "FilePar",
                "name": "fontfile",
                "items": []
            },
            {
                "text": "Menu : The display method used.",
                "type": "MenuPar",
                "name": "dispmethod",
                "items": []
            },
            {
                "text": "StrMenu : Smoothes out the edges of the text. Not available for Texture Display Mode.",
                "type": "StrMenuPar",
                "name": "antialias",
                "items": []
            },
            {
                "text": "Int : Controls the width of the outline when using Stroke Display Method.",
                "type": "IntPar",
                "name": "strokewidth",
                "items": []
            },
            {
                "text": "Toggle : Displays the text in '''bold'''.",
                "type": "TogglePar",
                "name": "bold",
                "items": []
            },
            {
                "text": "Toggle : Displays the text in ''Italic''.",
                "type": "TogglePar",
                "name": "italic",
                "items": []
            },
            {
                "text": "Menu : Automatically controls font size using one of the following 3 options. When using this feature along with Word Wrap turned on, it will first word-wrap the text based on the specified font size, then auto size the resulting block of text.",
                "type": "MenuPar",
                "name": "fontautosize",
                "items": []
            },
            {
                "text": "Float : Sets the font size in X (horizontal). '''Note:''' Floating point font sizes are permissable when using ''Polygon'' and ''Outline'' <span class=\"tipTextTOP\">Display Methods</span>.",
                "type": "FloatPar",
                "name": "fontsizex",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction, Fraction Aspect or Points (font point size).\tA Point is defined using the Windows conventions for 100% scaling, which is 96 pixels to 72 points. That is, a point size of 10 is the same as a pixel size of 10*(96/72) = 13.333.",
                "type": "MenuPar",
                "name": "fontsizexunit",
                "items": []
            },
            {
                "text": "Float : Sets the font size in Y (vertical). '''Note:''' Floating point font sizes are permissable when using ''Polygon'' and ''Outline'' <span class=\"tipTextTOP\">Display Methods</span>.",
                "type": "FloatPar",
                "name": "fontsizey",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction, Fraction Aspect or Points (font point size).",
                "type": "MenuPar",
                "name": "fontsizeyunit",
                "items": []
            },
            {
                "text": "Toggle : Ignores Y value in Font Size. Sets both X and Y size to <span class=\"tipTextTOP\">Font Size</span> X.",
                "type": "TogglePar",
                "name": "keepfontratio",
                "items": []
            },
            {
                "text": "menu : Language type hint to help format the glyphs correctly.",
                "type": "menuPar",
                "name": "breaklang",
                "items": []
            },
            {
                "text": "Menu : Use to set whether the language reads Left to Right or Right to Left.",
                "type": "MenuPar",
                "name": "readingdirection",
                "items": []
            },
            {
                "text": "Float : The amount of space to add between letters in X and Y. Tracking is way of adding an arbitrary offset between letters. There already is a default offset associated with each font so the letters are flush against each other. The Tracking parameter this adds to that and allows for a Y offset.",
                "type": "FloatPar",
                "name": "tracking",
                "items": []
            },
            {
                "text": "Float : The starting position of the text in X and Y.\t\t\n\t\t\t\t\n<span class=\"tipTextTOP\">TIP:</span> Inside the Text and Post Text fields the position can be overridden by using brackets.\t\t\t\t\n\t\t\t\t\n* '''[x,y]''' - <code>\"bleh[x,y]newtext\"</code> will place ''newtext'' at position (x,y) on the screen.\t\t\t\t\n* '''{X,Y}''' - <code>\"bleh{(+/-)x,(+/-)y}newtext\"</code> will offset ''newtext'' x,y from current position.\t\t\t\t\n* '''\\n''' - using <code>\"\\n\"</code> causes the text to move down to the next line and reset its position. (i.e. New Line and Carriage Return)",
                "type": "FloatPar",
                "name": "position",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "positionunit",
                "items": []
            },
            {
                "text": "Float : Determines the amount of space between lines of text.",
                "type": "FloatPar",
                "name": "linespacing",
                "items": []
            },
            {
                "text": "Menu : Select the units for this parameter from Pixels, Fraction (0-1), Fraction Aspect (0-1 considering aspect ratio).",
                "type": "MenuPar",
                "name": "linespacingunit",
                "items": []
            },
            {
                "text": "menu : Sets the horizontal alignment.",
                "type": "menuPar",
                "name": "alignx",
                "items": []
            },
            {
                "text": "menu : Determines how horizontal alignment is calculated.",
                "type": "menuPar",
                "name": "alignxmode",
                "items": []
            },
            {
                "text": "Menu : Sets the vertical alignment.",
                "type": "MenuPar",
                "name": "aligny",
                "items": []
            },
            {
                "text": "menu : Determines how vertical alignment is calculated.",
                "type": "menuPar",
                "name": "alignymode",
                "items": []
            },
            {
                "text": "Float : When using Auto-Size Font, it will further shrink the text to give it a border.",
                "type": "FloatPar",
                "name": "borderspace",
                "items": []
            },
            {
                "text": "Toggle : Multiplies the RGB channels by the alpha channel.",
                "type": "TogglePar",
                "name": "multrgbbyalpha",
                "items": []
            },
            {
                "text": "RGB : RGBA values for the text displayed. (default: white (1,1,1,1))",
                "type": "RGBPar",
                "name": "fontcolorr",
                "items": []
            },
            {
                "text": "RGB : RGBA values for the text displayed. (default: white (1,1,1,1))",
                "type": "RGBPar",
                "name": "fontcolorg",
                "items": []
            },
            {
                "text": "RGB : RGBA values for the text displayed. (default: white (1,1,1,1))",
                "type": "RGBPar",
                "name": "fontcolorb",
                "items": []
            },
            {
                "text": "Float : Set the alpha value for the font.",
                "type": "FloatPar",
                "name": "fontalpha",
                "items": []
            },
            {
                "text": "RGB : RGBA values for the background. (default: black (0,0,0,0))",
                "type": "RGBPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGB : RGBA values for the background. (default: black (0,0,0,0))",
                "type": "RGBPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGB : RGBA values for the background. (default: black (0,0,0,0))",
                "type": "RGBPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "Float : Set the alpha value for the background.",
                "type": "FloatPar",
                "name": "bgalpha",
                "items": []
            },
            {
                "text": "RGB : RGBA values for border A color.",
                "type": "RGBPar",
                "name": "borderar",
                "items": []
            },
            {
                "text": "RGB : RGBA values for border A color.",
                "type": "RGBPar",
                "name": "borderag",
                "items": []
            },
            {
                "text": "RGB : RGBA values for border A color.",
                "type": "RGBPar",
                "name": "borderab",
                "items": []
            },
            {
                "text": "Float : Set the alpha value for border A.",
                "type": "FloatPar",
                "name": "borderaalpha",
                "items": []
            },
            {
                "text": "RGB : RGBA values for border B color.",
                "type": "RGBPar",
                "name": "borderbr",
                "items": []
            },
            {
                "text": "RGB : RGBA values for border B color.",
                "type": "RGBPar",
                "name": "borderbg",
                "items": []
            },
            {
                "text": "RGB : RGBA values for border B color.",
                "type": "RGBPar",
                "name": "borderbb",
                "items": []
            },
            {
                "text": "Float : Set the alpha value for border B.",
                "type": "FloatPar",
                "name": "borderbalpha",
                "items": []
            },
            {
                "text": "Menu : What color the 2 left-most pixels are. Options are 0 (no change), Border A (uses color defined in Border A), or Border B (uses color defined in Border B).",
                "type": "MenuPar",
                "name": "leftborder",
                "items": []
            },
            {
                "text": "Menu : Same as above parameter but used for an inside border.",
                "type": "MenuPar",
                "name": "leftborderi",
                "items": []
            },
            {
                "text": "Menu : What color the 2 right-most pixels are. Options are 0 (no change), Border A (uses color defined in Border A), or Border B (uses color defined in Border B).",
                "type": "MenuPar",
                "name": "rightborder",
                "items": []
            },
            {
                "text": "Menu : Same as above parameter but used for an inside border.",
                "type": "MenuPar",
                "name": "rightborderi",
                "items": []
            },
            {
                "text": "Menu : What color the 2 bottom-most pixels are. Options are 0 (no change), Border A (uses color defined in Border A), or Border B (uses color defined in Border B).",
                "type": "MenuPar",
                "name": "bottomborder",
                "items": []
            },
            {
                "text": "Menu : Same as above parameter but used for an inside border.",
                "type": "MenuPar",
                "name": "bottomborderi",
                "items": []
            },
            {
                "text": "Menu : What color the 2 top-most pixels are. Options are 0 (no change), Border A (uses color defined in Border A), or Border B (uses color defined in Border B).",
                "type": "MenuPar",
                "name": "topborder",
                "items": []
            },
            {
                "text": "Menu : Same as above parameter but used for an inside border.",
                "type": "MenuPar",
                "name": "topborderi",
                "items": []
            },
            {
                "text": "Toggle : Turning this On will composite the input with the image.",
                "type": "TogglePar",
                "name": "compoverinput",
                "items": []
            },
            {
                "text": "Menu : Choose which composite operation is performed from this menu. Search the web for 'blend modes' for more detailed information on the effects of each type.",
                "type": "MenuPar",
                "name": "operand",
                "items": []
            },
            {
                "text": "Toggle : Swaps the order of the composite with the input.",
                "type": "TogglePar",
                "name": "swaporder",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Text TOP displays text strings in an image. It allows for multiple fonts, sizes, colors, borders, character separation and line separation. The text can be displayed as bit maps, anti-aliased lines, or filled polygon characters. Any TrueType font can be rendered by the Text TOP. [[Unicode]] is supported.\tThe new Scalable Display Method uses [[Slug Library]] to render scalable, resolution independent text at the highest qulaity available in the Text TOP.\t\n\t\t\t\t\nIt can display simple text strings with embedded numeric values. It can also format lines of text and numbers in decimal or floating point format, reading the numbers from a CHOP, using special formatting characters.\t\n\nIt can also render text strings from a [[Table DAT]] via the Specification DAT parameter, where column headings are the parameter names that are to ve overidden when rendering a line of text for reach row of the table.\n\t\t\t\t\nAny [http://en.wikipedia.org/wiki/TrueType TrueType] or [http://en.wikipedia.org/wiki/OpenType OpenType] font that has been loaded into Windows can be rendered by the Text TOP. To import a new font into your Windows system, open the '''Fonts''' folder in the '''Control Panel''', then drag and drop your [[File Types| font files]] in (<code>.ttf/.otf</code> file format). Fonts can also be specified as <code>.ttf/.otf</code> file paths in the Font File parameter.\t\t\t\t\n\t\t\t\t\nYou can render '''Unicode''' text by reading the text as a python string. See [[Unicode]].\n\n'''Tip:''' You can use the [[textTOP_Class]].textWidth member to calculate the width of the text in the Text TOP.\n\t\t\t\t\nSee also: [[Field COMP]], [[Text SOP]], [[Unicode]].\t\t\t\t\n\t\t\t\t\n[[image:TextTOP.jpg]]",
        "opLabel": "Text",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "short": "The Text TOP displays text strings in an image. It allows for multiple fonts, sizes, colors, borders, character separation and line separation.",
        "opType": "text",
        "opFilter": "False",
        "opClass": "textTOP_Class",
        "opCategories": ""
    },
    "texture3dTOP": {
        "label": "texture3dTOP",
        "members": [
            {
                "text": "Menu : Specifies the texture type to create.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Toggle : When set to 1, the Texture 3D TOP will fill up it cache with images. The texture3D TOP replaces a slice of its 3d data with its input every frame. When it has filled up all of its slices it wraps around and starts overwriting the oldest slice.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : While this is set > 0, the Texture 3D TOP will replace the slice at 'Replace Index' with the input image. This allows you to replace specific slices of the 3D texture at will.",
                "type": "TogglePar",
                "name": "replacesingle",
                "items": []
            },
            {
                "text": "Pulse : Replace an image for the single frame this was pulsed.",
                "type": "PulsePar",
                "name": "replacesinglepulse",
                "items": []
            },
            {
                "text": "Int : Select the slice index that will be replaced by the input, when 'Replace Single' is turned on.",
                "type": "IntPar",
                "name": "replaceindex",
                "items": []
            },
            {
                "text": "Toggle : This feature is used to pre-setup all of the slices of the 3D texture in a single cook. When set to 1, it will fill the cache. If set to 1 during playback, it will fill immediately. If set to 1 and saved out, then next time the file is opened the cache will pre-fill. It sets up the cache by cooking its inputs at $F = 1, $F = 2, $F = 3 etc. up until the number of slice it needs to fill. Refer to [[Pre-Filling]] for more information.",
                "type": "TogglePar",
                "name": "prefill",
                "items": []
            },
            {
                "text": "Pulse : Pre-fills a single image during the frame this was pulsed.",
                "type": "PulsePar",
                "name": "prefillpulse",
                "items": []
            },
            {
                "text": "Int : The number of images the Texture 3D TOP will hold. This is the number of 3D slices in the texture.",
                "type": "IntPar",
                "name": "cachesize",
                "items": []
            },
            {
                "text": "Int : This parameter sets how many frames pass before the TOP grabs one into cache. A Sample Step of 1 will grab each consecutive frame, a Sample Step of 2 will grab every other frame, and so on.\t\n\t\t\t\nWhen Prefilling you would normally setup the inputs to the Texture 3D node in some way that is tied to $F. Such as a Movie File In TOP where set the Specify Index parameter to $F - 1 (since 0 is the first frame). Or a Noise TOP that is changing it's translation based on $F. If Step Size is 3, it would cook frame 1, 4, 7 etc.",
                "type": "IntPar",
                "name": "step",
                "items": []
            },
            {
                "text": "Toggle : When set to 1, the cache is flushed and the TOP is reset.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly empty the cache.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Texture 3D TOP creates a 3D texture map. It saves a series of images in one array of pixels.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Texture 3D",
        "opClass": "texture3dTOP_Class",
        "opType": "tex3d",
        "long": "The Texture 3D TOP creates a 3D texture map. It saves a series of images in one array of pixels. This TOP can be used with [[Time Machine TOP]], as well as materials. Using materials, a particular image in this array can be accessed by specifying a W texture coordinate, while the U and V coordinates are used to specify a texture location on that image. Refer to the '''[[3D Texture]]''' article for more information.\t\t\n\t\t\t\nThe Texture 3D TOP is similar to the [[Cache TOP]] which holds a set of images in a different form: the images are separate and you cannot use the W texture coordinate in a material to interpolate to access all of them in a shader.\t\t\t\n\t\t\t\nThe Texture 3D TOP replaces one slice of its 3D data with its input every frame. When it has filled up all of its slices it wraps around and starts overwriting the oldest slice.\t\t\t\n\t\t\t\nThe Texture 3D TOP can also create a '''[[2D Texture Array]]'''. 2D Texture arrays are much like 3d textures, except are sampled using a non-normalized w texture coordinate. (i.e, 0 is the first slice, 1 is the 2nd slice, 2 is the 3rd slice etc.). Texture arrays also don't support blending between different slices when sampling at coordinate that falls between two slices. This a much faster alternative to 3d textures when interpolation between slices is not required. The non-normalized w coordinate makes it very easy to directly access a particular slice in the array. 2D Texture arrays also don't have a concept of w extend mode: they only work in their 0->(N-1) range.\n\t\t\t\n[[Lock Flag|Locking]] the Texture 3D TOP preserves the entire 3D and 2D array in a [[.toe]] or [[.tox]] file.",
        "opCategories": ""
    },
    "thresholdTOP": {
        "label": "thresholdTOP",
        "members": [
            {
                "text": "Menu : Select the operation to compare the Threshold parameter to.",
                "type": "MenuPar",
                "name": "comparator",
                "items": []
            },
            {
                "text": "Menu : Determines which part of the image used to calculate threshold. This parameter determines the output for the R, G, and B channels.",
                "type": "MenuPar",
                "name": "rgb",
                "items": []
            },
            {
                "text": "Float : Using the function selected in the Comparator parameter, any pixel that satisfies this value will be set to 0. For example, if Comparator = Less then any pixel less than this Threshold value will be set to 0.",
                "type": "FloatPar",
                "name": "threshold",
                "items": []
            },
            {
                "text": "Menu : This parameter determines the output for the alpha channel.",
                "type": "MenuPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Float : The rate of falloff at the threshold value. As this value set set larger, pixels near the threshold value will be set to something between 0-1.",
                "type": "FloatPar",
                "name": "soften",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Threshold TOP creates a matte with pixel values set to 0 for pixels below the threshold value, and 1 for pixels greater than or equal to the threshold value.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Threshold",
        "opClass": "thresholdTOP_Class",
        "opType": "thresh",
        "long": "The Threshold TOP creates a matte with pixel values set to 0 for pixels below the threshold value, and 1 for pixels greater than or equal to the threshold value.",
        "opCategories": ""
    },
    "tileTOP": {
        "label": "tileTOP",
        "members": [
            {
                "text": "Float : Positions the left edge of the image.",
                "type": "FloatPar",
                "name": "cropleft",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "cropleftunit",
                "items": []
            },
            {
                "text": "Float : Positions the right edge of the image.",
                "type": "FloatPar",
                "name": "cropright",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "croprightunit",
                "items": []
            },
            {
                "text": "Float : Positions the bottom edge of the image.",
                "type": "FloatPar",
                "name": "cropbottom",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "cropbottomunit",
                "items": []
            },
            {
                "text": "Float : Positions the top edge of the image.",
                "type": "FloatPar",
                "name": "croptop",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "croptopunit",
                "items": []
            },
            {
                "text": "Menu : This parameter determines what happens at the edges of the tiles.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Toggle : Similar to performing a flop on the image (See [http://www.derivativeinc.com/../flip/flip.asp Flip TOP]) without changing the resolution. It swaps the position of the bottom-right corner with the upper-left corner, while maintaining the original resolution and aspect ratio.",
                "type": "TogglePar",
                "name": "flop",
                "items": []
            },
            {
                "text": "Int : Number of tiles in X direction.",
                "type": "IntPar",
                "name": "repeatx",
                "items": []
            },
            {
                "text": "Int : Number of tiles in Y direction.",
                "type": "IntPar",
                "name": "repeaty",
                "items": []
            },
            {
                "text": "Toggle : Flips the image in X.",
                "type": "TogglePar",
                "name": "flipx",
                "items": []
            },
            {
                "text": "Toggle : Flips the image in Y.",
                "type": "TogglePar",
                "name": "flipy",
                "items": []
            },
            {
                "text": "Toggle : Reflects the tiles in X. '''NOTE:''' Must have Tile Y set to 2.",
                "type": "TogglePar",
                "name": "reflectx",
                "items": []
            },
            {
                "text": "Toggle : Reflects the tiles in Y. '''NOTE:''' Must have Tile X set to 2.",
                "type": "TogglePar",
                "name": "reflecty",
                "items": []
            },
            {
                "text": "Float : Blends the edges together on the right and left edges of the tiles.",
                "type": "FloatPar",
                "name": "overlapu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "overlapuunit",
                "items": []
            },
            {
                "text": "Float : Blends the edges together on the bottom and top edges of the tiles.",
                "type": "FloatPar",
                "name": "overlapv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "overlapvunit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Tile TOP tiles images in a repeating pattern.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Tile",
        "opClass": "tileTOP_Class",
        "opType": "tile",
        "long": "The Tile TOP tiles images in a repeating pattern. It also has a Crop option which crops an image by defining the position of the left, right, bottom, and top edges of the image.",
        "opCategories": ""
    },
    "timemachineTOP": {
        "label": "timemachineTOP",
        "members": [
            {
                "text": "Float : Sets the time offset for black areas of the Input 2 image.",
                "type": "FloatPar",
                "name": "blackoffset",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "blackoffsetunit",
                "items": []
            },
            {
                "text": "Float : Sets the time offset for white areas of the Input 2 image.",
                "type": "FloatPar",
                "name": "whiteoffset",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "whiteoffsetunit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Time Machine TOP combines pixels in a sequence of images stored in a [[Texture 3D TOP]]. Whereas \"morphing\" warps an image \"spatially\" (in xy), Time Machine warps images only in time (specifically, the third dimension of a 3D texture map).",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Time Machine",
        "opClass": "timemachineTOP_Class",
        "opType": "tima",
        "long": "The Time Machine TOP combines pixels in a sequence of images stored in a [[Texture 3D TOP]]. Whereas \"morphing\" warps an image \"spatially\" (in xy), Time Machine warps images only in time.\t\n\t\t\nTime Machine, originally known as \"tima\" in PRISMS, was first used in 1995 for warping effects in Ghost in the Shell, a Japanimation cyber film that heavily used PRISMS for camera perspective effects, compositing, 3D and effects.\t\t\n\t\t\nYou must connect a Texture 3D TOP to the Time Machine's first input. It uses this array of images and displays different depths of the 3D texture. \n\t\t\nThe second input determines the time offset of the output image. The second input is expected to be monochrome, but uses the red channel when it is not monochrome. By default, where there is a black pixel in the second input, it gets the oldest layer of the 3D texture.  Where there is a white pixel in the second input, it gets the most recent layer of the 3D texture.  Black Offset and White Offset adjust the range of time that the black to white parts of the image are offset within. For example, if Black Offset is -10 and White Offset is 0, then a black pixel would be 10 frames behind in time, a white pixel the current frame, and a 50% grey pixel would be 5 frames behind in time (in between the Black and White Offsets).",
        "opCategories": ""
    },
    "touchinTOP": {
        "label": "touchinTOP",
        "members": [
            {
                "text": "Str : The IP address of the computer with the transmitting Touch Out TOP. Use ''localhost'' to reference the local machine.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The TCP/IP port that the Touch Out TOP is transmitting on.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : Receives image data while Active is on.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Float : The smallest amount of queue data (represented in seconds) allowed without adjusting sampling speed.",
                "type": "FloatPar",
                "name": "mintarget",
                "items": []
            },
            {
                "text": "Float : The largest amount of queue data (represented in seconds) allowed without adjusting sampling speed.",
                "type": "FloatPar",
                "name": "maxtarget",
                "items": []
            },
            {
                "text": "Float : The maximum allowed size of the queue (represented in seconds). If the maximum queue size is exceeded, data will be removed from the front of the queue.",
                "type": "FloatPar",
                "name": "maxqueue",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Touch In TOP will read in image data send over a TCP/IP network connection from a [[Touch Out TOP]].",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Touch In",
        "opClass": "touchinTOP_Class",
        "opType": "touchin",
        "long": "The Touch In TOP will read in image data send over a TCP/IP network connection from a [[Touch Out TOP]]. The other TouchDesigner process can be on the same computer or from another computer anywhere on the connected network.\t\n\t\t\nIt can receive [[Hap|Hap Q]], Hap Q Alpha, and Uncompressed video.\t\t\n\t\t\nMake sure Windows Firewall settings are set to UNBLOCK for TouchDesigner, otherwise the data will be blocked.\t\t\n\t\t\nSee also [[Touch Out TOP]].\t\t\n\t\t\nFor other protocols over IP see [[Video Stream Out TOP]], [[Video Stream In TOP]], [[NDI Out TOP]] and [[NDI In TOP]].\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opCategories": ""
    },
    "touchoutTOP": {
        "label": "touchoutTOP",
        "members": [
            {
                "text": "Int : Which TCP/IP port to send the images on.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : Sends image data over the TCP/IP connection when active is on.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Int : This specifies how many frames pass before sending another frame.  This effectively lowers frame rate and bandwidth of the output.  For example, if the input frame rate is 60 and Send Step Size is 2, the output frame rate will be 30.",
                "type": "IntPar",
                "name": "fps",
                "items": []
            },
            {
                "text": "Menu : Choose between Uncompressed and HAP Q codecs to transmit the image stream.",
                "type": "MenuPar",
                "name": "videocodec",
                "items": []
            },
            {
                "text": "Toggle : Forces the TOP to cook every frame.",
                "type": "TogglePar",
                "name": "alwayscook",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Touch Out TOP sends a TOP image stream over TCP/IP to a Touch In TOP.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Touch Out",
        "opClass": "touchoutTOP_Class",
        "opType": "touchout",
        "long": "The Touch Out TOP sends a TOP image stream over TCP/IP to a Touch In TOP. The Touch In TOP can be in another TouchDesigner session on the same computer or on a computer anywhere on the connected network.\t\t\n\t\t\t\nIt can output [[Hap|Hap Q]], Hap Q Alpha, and Uncompressed video.\t\t\t\n\t\t\t\nMake sure Windows Firewall settings are set to UNBLOCK for TouchDesigner, otherwise the data will be blocked.\t\t\t\n\t\t\t\nSee also [[Touch In TOP]].\t\t\t\n\t\t\t\nFor other protocols over IP see [[Video Stream Out TOP]], [[Video Stream In TOP]], [[NDI Out TOP]] and [[NDI In TOP]].\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opCategories": ""
    },
    "transformTOP": {
        "label": "transformTOP",
        "members": [
            {
                "text": "Menu : The menu attached to this parameter allows you to specify the order in which the changes to your TOP will take place. Changing the Transform order will change where things go much the same way as going a block and turning east gets you to a different place than turning east and then going a block.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "XY : The two fields for Translate allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : The two fields for Translate allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "Float : The field for rotation allows you to specify the amount of rotation of the image.",
                "type": "FloatPar",
                "name": "rotate",
                "items": []
            },
            {
                "text": "XY : The two fields for Scale allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : The two fields for Scale allows you to specify transforms in x and y axes.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Grow/Shrink is a scale that is given in pixel units. A positive value will cause the image to grow that many pixels while a negative will cause the image to shrink that many pixels.",
                "type": "XYPar",
                "name": "growshrinkx",
                "items": []
            },
            {
                "text": "XY : Grow/Shrink is a scale that is given in pixel units. A positive value will cause the image to grow that many pixels while a negative will cause the image to shrink that many pixels.",
                "type": "XYPar",
                "name": "growshrinky",
                "items": []
            },
            {
                "text": "XY : The Pivot point edit fields allow you to define the point about which the TOP scales and rotates. Altering the pivot point of a TOP produces different results depending on the transformation performed on the TOP image.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of a TOP image is located at <code>-1,-1</code> and you wanted to scale the image by <code>0.5</code> (reduce its size by 50%), then the TOP would scale toward the pivot point and appear to slide down and to the left.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : The Pivot point edit fields allow you to define the point about which the TOP scales and rotates. Altering the pivot point of a TOP produces different results depending on the transformation performed on the TOP image.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of a TOP image is located at <code>-1,-1</code> and you wanted to scale the image by <code>0.5</code> (reduce its size by 50%), then the TOP would scale toward the pivot point and appear to slide down and to the left.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the image is translated or scaled down. Try scaling an image down 50% in size (Scale = 0.5,0.5) and setting the background color.",
                "type": "RGBAPar",
                "name": "bgcolorr",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the image is translated or scaled down. Try scaling an image down 50% in size (Scale = 0.5,0.5) and setting the background color.",
                "type": "RGBAPar",
                "name": "bgcolorg",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the image is translated or scaled down. Try scaling an image down 50% in size (Scale = 0.5,0.5) and setting the background color.",
                "type": "RGBAPar",
                "name": "bgcolorb",
                "items": []
            },
            {
                "text": "RGBA : Color applied behind the foreground image. The background is visible when the image is translated or scaled down. Try scaling an image down 50% in size (Scale = 0.5,0.5) and setting the background color.",
                "type": "RGBAPar",
                "name": "bgcolora",
                "items": []
            },
            {
                "text": "Toggle : This option allows the Background Color to be pre-multiplied by alpha.",
                "type": "TogglePar",
                "name": "premultrgbbyalpha",
                "items": []
            },
            {
                "text": "Toggle : Fill any area with the background color if it has alpha less than 1.",
                "type": "TogglePar",
                "name": "compover",
                "items": []
            },
            {
                "text": "Float : If the input is sampled using mipmapping, this applies a bias to which mip level(s) are used when sampling the texture. 0 means the levels that would be normally used. Negative will selected higher levels (larger textures), positive will select lower (smaller texture) levels. 1 is equal to 1 mip level. This parameter is enabled in the 'Input Smoothness' parameter is set to 'Mipmap Pixels'.",
                "type": "FloatPar",
                "name": "mipmapbias",
                "items": []
            },
            {
                "text": "Menu : This parameter determines what happens at the edges of the tiles.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Toggle : Turn this On to limit the number of tiles in the U and V directions using the parameters below.",
                "type": "TogglePar",
                "name": "limittiles",
                "items": []
            },
            {
                "text": "Float : The first Tile U parameter sets the number of tiles to repeat on the left of the source image. The second Tile U parameter sets the number of tiles to repeat on the right of the source image. The image must be scaled down (using the<span class=\"tipTextTOP\"> Scale</span> parameters on the Transform page) to view these tiles.",
                "type": "FloatPar",
                "name": "tileu",
                "items": []
            },
            {
                "text": "Float : The first Tile V parameter sets the number of tiles to repeat on the botttom of the source image. The second Tile V parameter sets the number of tiles to repeat on the top of the source image. The image must be scaled down (using the<span class=\"tipTextTOP\"> Scale</span> parameters on the Transform page) to view these tiles.",
                "type": "FloatPar",
                "name": "tilev",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Transform TOP applies 2D transformations to a TOP image like translate, scale, rotate, and multi-repeat tiling.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Transform",
        "opClass": "transformTOP_Class",
        "opType": "transform",
        "long": "The Transform TOP applies 2D transformations to a TOP image like translate, scale, rotate, and multi-repeat tiling. The background can be filled with solid color and alpha.",
        "opCategories": ""
    },
    "underTOP": {
        "label": "underTOP",
        "members": [
            {
                "text": "Menu : The selected input will become the fixed layer and the other input will be the overlay. This does not change the order of the composite (Input1 + Input2), only which layer is considered fixed and which layer is adjustable by the parameters on the Transform page. The resolution and aspect ratio of the Fixed Layer is used as the composite's final resolution and aspect ratio unless manually on the [[#Parameters - Common Page|Common Page]].",
                "type": "MenuPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Menu : Determines how the Overlay layer (Overlay layer is the input that is NOT the Fixed Layer) fills the composite.",
                "type": "MenuPar",
                "name": "prefit",
                "items": []
            },
            {
                "text": "Menu : Specify the horizontal alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyh",
                "items": []
            },
            {
                "text": "Menu : Specify the vertical alignment of the Overlay.",
                "type": "MenuPar",
                "name": "justifyv",
                "items": []
            },
            {
                "text": "Menu : Sets the extend (or repeat) conditions of the Overlay layer. This parameter determines what happens at the edges of the Overlay layer.",
                "type": "MenuPar",
                "name": "extend",
                "items": []
            },
            {
                "text": "Float : Rotates the Overlay layer. Increasing values rotate clockwise, decreasing values rotate counter-clockwise.",
                "type": "FloatPar",
                "name": "r",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XY : Translates the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Translate parameter.",
                "type": "MenuPar",
                "name": "tunit",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XY : Scales the Overlay layer in x and y.",
                "type": "XYPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XY : Allows you to define the point about which the Overlay layer scales and rotates. Altering the pivot point produces different results depending on the Transform Order.",
                "type": "XYPar",
                "name": "py",
                "items": []
            },
            {
                "text": "Menu : Sets the units used in the Pivot parameter.",
                "type": "MenuPar",
                "name": "punit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Under TOP places Input1 'under' Input2.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Under",
        "opClass": "underTOP_Class",
        "opType": "under",
        "long": "The Under TOP places Input1 'under' Input2. The alpha of Input2 is used to determine what parts of the Input1 image are visible in the result.",
        "opCategories": ""
    },
    "videodeviceinTOP": {
        "label": "videodeviceinTOP",
        "members": [
            {
                "text": "Toggle : When set to one the TOP captures the image stream from the camera or decoder.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Selects the library to use to interface with the cameras.",
                "type": "MenuPar",
                "name": "library",
                "items": []
            },
            {
                "text": "StrMenu : Select which camera or decoder you want from this menu.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Toggle : When using Allied Vision library allows you to specify the camera address by IP.",
                "type": "TogglePar",
                "name": "specifyip",
                "items": []
            },
            {
                "text": "Str : The IP address used when Specify IP above is turned on.",
                "type": "StrPar",
                "name": "ip",
                "items": []
            },
            {
                "text": "Pulse : Opens the options or control panel for the camera. NOTE: Only works when using DirectShow (WDM) cameras.",
                "type": "PulsePar",
                "name": "options",
                "items": []
            },
            {
                "text": "Menu : Sets which fields to capture.",
                "type": "MenuPar",
                "name": "deinterlace",
                "items": []
            },
            {
                "text": "Menu : When using Bob (Split) deinterlacing, this selects which field is shown first for each frame.",
                "type": "MenuPar",
                "name": "precedence",
                "items": []
            },
            {
                "text": "Int : Selects the TV channel if a TV tuner is used as the video input.",
                "type": "IntPar",
                "name": "channel",
                "items": []
            },
            {
                "text": "StrMenu : The signal format to capture input at. This is the resolution and the frame rate, as well as if the frames are progressive or interlaced. Note that when using an interlaced format, the rate refers to fields per second.",
                "type": "StrMenuPar",
                "name": "signalformat",
                "items": []
            },
            {
                "text": "Toggle : Used for cards that support quad-link formats. Quad-link esstenially takes 4 inputs and creates one single larger input out of them, for example 4 1080p inputs become a single 4K input.",
                "type": "TogglePar",
                "name": "quadlink",
                "items": []
            },
            {
                "text": "Menu : Some capture devices support pixel formats other than 8-bit. For supported devices (Blackmagic Design) this will make the node attempt to use that capability.",
                "type": "MenuPar",
                "name": "inputpixelformat",
                "items": []
            },
            {
                "text": "Menu : Controls how the frames are transferred from the input device to CPU memory, and how they are transferred from CPU memory to the GPU.",
                "type": "MenuPar",
                "name": "transfermode",
                "items": []
            },
            {
                "text": "Menu : Controls the memory type used to transfer data between the capture card and the GPU.",
                "type": "MenuPar",
                "name": "memorymode",
                "items": []
            },
            {
                "text": "Toggle : Enabling syncing of multiple Video Device In TOPs. Syncing allows multiple nodes using multiple inputs and capture cards on a single system to ensure they are outputting frames in sync. Without this each node will be free running and will possible be outputting frames that came it at different times due to internal queuing. It's important the input sources are GenLocked to ensure all of their data arrives to all of the inputs at the same time, otherwise syncing will not work. This feature is currently supported for Blackmagic, DataPath, Deltacast and BlueFish devices.",
                "type": "TogglePar",
                "name": "syncinputs",
                "items": []
            },
            {
                "text": "Int : There can be multiple sync groups active in a .toe file. Nodes will only sync to other nodes that are part of the same sync group.",
                "type": "IntPar",
                "name": "syncgroupindex",
                "items": []
            },
            {
                "text": "Float : Specified in milliseconds. The maximum difference in time two image could have arrived at be considered in-sync. Images that arrive at times more different than this offset will be considered to be part of different 'frame'.",
                "type": "FloatPar",
                "name": "maxsyncoffset",
                "items": []
            },
            {
                "text": "Float : How much time to wait for all frames in a sync group to become available before giving up trying to sync. Expressed in milliseconds. If this timeout elapses when waiting for a frame from one or more sources in the sync group, all of the nodes in the sync group will keep their current image and not output a new image, even if some new images arrived on some of the inputs.",
                "type": "FloatPar",
                "name": "synctimeout",
                "items": []
            },
            {
                "text": "Pulse : A pulse to reset the statistics in an attached [[Info CHOP]].",
                "type": "PulsePar",
                "name": "resetstats",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "preset",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "autoge",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "autogebias",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "autogelevel",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "maxgain",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "maxexposure",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "gain",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "exposure",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "cgamma",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "lgamma",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "limitfps",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "limitedfps",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "capture",
                "items": []
            },
            {
                "text": "Pulse : ",
                "type": "PulsePar",
                "name": "capturepulse",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "autowb",
                "items": []
            },
            {
                "text": "RGB : ",
                "type": "RGBPar",
                "name": "wbcoeffsr",
                "items": []
            },
            {
                "text": "RGB : ",
                "type": "RGBPar",
                "name": "wbcoeffsg",
                "items": []
            },
            {
                "text": "RGB : ",
                "type": "RGBPar",
                "name": "wbcoeffsb",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "custombandwidth",
                "items": []
            },
            {
                "text": "Int : ",
                "type": "IntPar",
                "name": "bandwidthlimit",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "camerabitdepth",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "gpudemosaic",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Video Device In TOP can be used to capture video from an external camera, capture card, capture dongle, IP camera, or video decoder connected to the system. Multiple devices can simultaneously stream video into TouchDesigner by using multiple Device In TOPs. HD-SDI video can be streamed into TouchDesigner through capture cards such and those from [[Blackmagic Design]], [[AJA]] and [[Deltacast]].\t\t\t\t\t\n\t\t\t\t\t\t\n[[image:Magewell.2.jpg]]\t\t\t\t\t\t\n[[image:Webcam2.png]]\t\t\t\t\t\t\n[[image:CaptureCard.jpg]]\t\t\t\t\t\t\n[[image:DVcam.jpg]]\t\t\t\t\t\t\n[[image:WebcamMan.jpg]]\t\t\t\t\t\t\n\t\t\t\t\t\t\nIf the device does not seem to provide a video stream but it is visible in the <span class=\"tipTextTOP\">Cameras</span> parameter menu, make sure no other applications are currently using the device.\t\n\n'''TIP''': Create an [[Info DAT]] and point it to the Video Device In TOP to see what devices are currently attached. The [[Info CHOP]] gives data for analyzing the performance of Video Device In and Out TOPs. Six channels of data help with monitoring, as well a \u201cReset Stats\u201d option clears history.\n\nDevices currently supported:\n* [[Blackmagic Design]]\t\t\t\t\t\n* [[AJA]]\n* [[Deltacast]]\n* [[Bluefish444]]\n\nAJA and Blackmagic Design devices now support 12-bit input and output formats, including AJA\u2019s ability to capture at a full 12-bit RGB 4:4:4. Furthermore, 10-bit input and output have received performance improvements and better support for a wider selection of firmware.\n\t\t\nAlso supported with native drivers are some models from Datapath SDI, Allied Vision, Imaging Development Systems (IDS), FLIR/Point Grey, and Ximea.\t\t\t\t\t\n\t\t\t\t\t\t\nFor Magewell HDMI-to-USB3 capture (highly recommended, no drivers, plug-and-play), see [http://www.magewell.com/usb-capture-hdmi Magewell].\n\n'''IP Cameras''' include models from [https://www.alliedvision.com/en/products/cameras.html Allied Vision] (PvAPI SDK models only, not Vimba SDK), [https://www.ptgrey.com/ Point Grey FLIR Flycapture2 and Spinnaker] and [https://en.ids-imaging.com/ Imaging Development Systems (IDS)]. In case of IDS's Cameras, TouchDesigner implements the ''uEye IDS Software Suite''. ''GigE Vision'' cameras are currently not supported.\n\n'''USB3 Cameras''' include models from [https://www.alliedvision.com/en/products/cameras.html Allied Vision] (PvAPI SDK models only, not Vimba SDK), [https://www.ptgrey.com/ Point Grey FLIR Flycapture2 and Spinnaker] and [https://en.ids-imaging.com/ Imaging Development Systems (IDS)]\n\nOnly a small subset of cameras from each manufacturer has been tested in-house, however it's expected that any modern camera from the supported manufacturer should work. If any issues are encountered please contact <code>support@derivative.ca</code>.\t\t\t\t\t\t\n\t\t\t\t\t\t\nSee also [[Video Device Out TOP]].",
        "opLabel": "Video Device In",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "short": "The Video Device In TOP can be used to capture video from an external camera, capture card, capture dongle, or dideo decoder connected to the system.",
        "opType": "videodevin",
        "opFilter": "False",
        "opClass": "videodeviceinTOP_Class",
        "opCategories": ""
    },
    "videodeviceoutTOP": {
        "label": "videodeviceoutTOP",
        "members": [
            {
                "text": "Toggle : Enable or disable the output card.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the driver library to use.",
                "type": "MenuPar",
                "name": "library",
                "items": []
            },
            {
                "text": "StrMenu : A menu of available video devices to output to. Set the Library parameter above prior to selecting your device.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "StrMenu : The signal format to output at. This is the resolution and the frame rate, as well as if the frames are progressive or interlaced. Note that when using an interlaced format, the rate refers to fields per second.",
                "type": "StrMenuPar",
                "name": "signalformat",
                "items": []
            },
            {
                "text": "Menu : Set the pixel format of the output when possible (depends what type of device is used).\tData may be converted to YUV colorspace depending on what the device and settings require.",
                "type": "MenuPar",
                "name": "outputpixelformat",
                "items": []
            },
            {
                "text": "Menu : Set the color space of the data sent out, for supported devices.",
                "type": "MenuPar",
                "name": "outputcolorspace",
                "items": []
            },
            {
                "text": "CHOP : If you want to embed audio data into the output, put the path to a [[Time Slice]]d CHOP here.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Menu : On AJA devices what input to use as a reference source input.",
                "type": "MenuPar",
                "name": "referencesource",
                "items": []
            },
            {
                "text": "CHOP : If you want to embed audio data into the output, put the path to a [[Time Slice]]d CHOP here.",
                "type": "CHOPPar",
                "name": "audiochop",
                "items": []
            },
            {
                "text": "Float : The length in seconds to buffer the audio data, to avoid crackles and pops.",
                "type": "FloatPar",
                "name": "bufferlength",
                "items": []
            },
            {
                "text": "Menu : Describes the number of bits of information used for each sample.",
                "type": "MenuPar",
                "name": "audiobitdepth",
                "items": []
            },
            {
                "text": "Toggle : When outputting interlaced video if you are using a source video that is also interlaced, it's likely you'll want to make sure you are keeping the odd/even fields in sync, otherwise the video will look stuttery. You can use the 'odd_field' value in the [[Info CHOP]] on the [[Movie File In TOP]] or [[Video Device In TOP]] to know if the current frame is the odd field or the even field. In general the odd field is the first frame, so you use this value in the First Field parameter to tell the Video Device Out TOP that the current frame is the first field. On the next frame you would put this value to 0 (which is also what the 'odd_frame' will go to) to tell the Video Device Out TOP that the current frame is the 2nd frame, and you now have a complete frame to output. Deinterlacing should be enabled on the Video Device In or Movie File In TOP, so that fields are fed into the network one at a time.",
                "type": "TogglePar",
                "name": "manualfield",
                "items": []
            },
            {
                "text": "Toggle : Tells the Video Device Out TOP if the current frame being given as it's input is the First or Second field in the final output image, when outputting an interlaced video. Look at the description for Manual Field Control for more information.",
                "type": "TogglePar",
                "name": "firstfield",
                "items": []
            },
            {
                "text": "CHOP : Embed timecode into the output. The CHOP should contain 4 channels named 'frame', 'second', 'minute' and 'hour'.",
                "type": "CHOPPar",
                "name": "timecodechop",
                "items": []
            },
            {
                "text": "Menu : Controls how the image data is transfered between the GPU and the output card.",
                "type": "MenuPar",
                "name": "transfermode",
                "items": []
            },
            {
                "text": "Toggle : Only currently supported on the [[Deltacast]] FLEX line of cards. This will cause multiple FLEX cards to output their content in sync with each other.",
                "type": "TogglePar",
                "name": "syncoutputs",
                "items": []
            },
            {
                "text": "Int : For different groups of cards, they can be ganged together into different sync groups by specifying the same index for multiple cards in the same group.",
                "type": "IntPar",
                "name": "syncgroupindex",
                "items": []
            },
            {
                "text": "Pulse : A pulse to reset the statistics in an attached [[Info CHOP]].",
                "type": "PulsePar",
                "name": "resetstats",
                "items": []
            },
            {
                "text": "Toggle : Enable or disable the output card.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the driver library to use.",
                "type": "MenuPar",
                "name": "library",
                "items": []
            },
            {
                "text": "StrMenu : A menu of available video devices to output to. Set the Library parameter above prior to selecting your device.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "StrMenu : The signal format to output at. This is the resolution and the frame rate, as well as if the frames are progressive or interlaced. Note that when using an interlaced format, the rate refers to fields per second.",
                "type": "StrMenuPar",
                "name": "signalformat",
                "items": []
            },
            {
                "text": "Menu : Set the pixel format of the output when possible (depends what type of device is used).\tData may be converted to YUV colorspace depending on what the device and settings require.",
                "type": "MenuPar",
                "name": "outputpixelformat",
                "items": []
            },
            {
                "text": "Menu : Set the color space of the data sent out, for supported devices.",
                "type": "MenuPar",
                "name": "outputcolorspace",
                "items": []
            },
            {
                "text": "CHOP : If you want to embed audio data into the output, put the path to a [[Time Slice]]d CHOP here.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Menu : On AJA devices what input to use as a reference source input.",
                "type": "MenuPar",
                "name": "referencesource",
                "items": []
            },
            {
                "text": "CHOP : If you want to embed audio data into the output, put the path to a [[Time Slice]]d CHOP here.",
                "type": "CHOPPar",
                "name": "audiochop",
                "items": []
            },
            {
                "text": "Float : The length in seconds to buffer the audio data, to avoid crackles and pops.",
                "type": "FloatPar",
                "name": "bufferlength",
                "items": []
            },
            {
                "text": "Menu : Describes the number of bits of information used for each sample.",
                "type": "MenuPar",
                "name": "audiobitdepth",
                "items": []
            },
            {
                "text": "Toggle : When outputting interlaced video if you are using a source video that is also interlaced, it's likely you'll want to make sure you are keeping the odd/even fields in sync, otherwise the video will look stuttery. You can use the 'odd_field' value in the [[Info CHOP]] on the [[Movie File In TOP]] or [[Video Device In TOP]] to know if the current frame is the odd field or the even field. In general the odd field is the first frame, so you use this value in the First Field parameter to tell the Video Device Out TOP that the current frame is the first field. On the next frame you would put this value to 0 (which is also what the 'odd_frame' will go to) to tell the Video Device Out TOP that the current frame is the 2nd frame, and you now have a complete frame to output. Deinterlacing should be enabled on the Video Device In or Movie File In TOP, so that fields are fed into the network one at a time.",
                "type": "TogglePar",
                "name": "manualfield",
                "items": []
            },
            {
                "text": "Toggle : Tells the Video Device Out TOP if the current frame being given as it's input is the First or Second field in the final output image, when outputting an interlaced video. Look at the description for Manual Field Control for more information.",
                "type": "TogglePar",
                "name": "firstfield",
                "items": []
            },
            {
                "text": "CHOP : Embed timecode into the output. A reference to either a CHOP with channels 'hour', 'second', 'minute', 'frame', a DAT with a timecode string in its first cell, or a [[Timecode Class]] object.",
                "type": "CHOPPar",
                "name": "timecodeop",
                "items": []
            },
            {
                "text": "Menu : Controls how the image data is transfered between the GPU and the output card.",
                "type": "MenuPar",
                "name": "transfermode",
                "items": []
            },
            {
                "text": "Toggle : Only currently supported on the [[Deltacast]] FLEX line of cards. This will cause multiple FLEX cards to output their content in sync with each other.",
                "type": "TogglePar",
                "name": "syncoutputs",
                "items": []
            },
            {
                "text": "Int : For different groups of cards, they can be ganged together into different sync groups by specifying the same index for multiple cards in the same group.",
                "type": "IntPar",
                "name": "syncgroupindex",
                "items": []
            },
            {
                "text": "Pulse : A pulse to reset the statistics in an attached [[Info CHOP]].",
                "type": "PulsePar",
                "name": "resetstats",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Video Device Out TOP routes video and audio to output devices using their native driver libraries.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Video Device Out",
        "opClass": "videodeviceoutTOP_Class",
        "opType": "videodevout",
        "long": "The Video Device Out TOP routes video to output devices using their native driver libraries.\t\t\n\t\t\t\nDevices currently supported:\t\t\t\n* [[Blackmagic Design]] devices.\t\t\t\n* [[Bluefish444]] devices.\t\t\t\n* [[AJA]] devices.\t\t\t\n* [[Deltacast]] devices.\n\nSee also [[Video Device In TOP]].",
        "opCategories": ""
    },
    "videostreaminTOP": {
        "label": "videostreaminTOP",
        "members": [
            {
                "text": "Menu : Select the mode: either a Server (for RTSP, HLS or SRT URLs), or WebRTC.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Str : The URL (address) of the stream, see summary above for specific details.",
                "type": "StrPar",
                "name": "url",
                "items": []
            },
            {
                "text": "Toggle : Reload the stream by attempting to reconnect.",
                "type": "TogglePar",
                "name": "reload",
                "items": []
            },
            {
                "text": "Pulse : Triggers the Reload immediately on release (button-up). This can be accessed in python using the pulse() method.",
                "type": "PulsePar",
                "name": "reloadpulse",
                "items": []
            },
            {
                "text": "Toggle : The stream will play forward when Play = On, it will be paused when Off.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Menu : For movies that are stored as fields, where each image is made of two images interleaved together. A 30-frame per second movie would contain 60 fields per second. For each image, the even scanlines of the first field are interleaved with the odd scanlines of the second field. The Video Stream In TOP has several ways of dealing with this:",
                "type": "MenuPar",
                "name": "deinterlace",
                "items": []
            },
            {
                "text": "Menu : Where fields are extracted one field at a time, this will extract the Even field first by default, otehrwise it will extract the odd field first. The industry has not standardized on one or the other.",
                "type": "MenuPar",
                "name": "precedence",
                "items": []
            },
            {
                "text": "Toggle : This is a way of encoding alpha into RGB-only formats like H.264. and several other QuickTime formats. You need to create your movies so that the bottom half of the image is the alpha (RGB = AAA). Turning on this features tells the Video Stream In TOP to take the bottom half of the image and put it into the alpha channel of the output. The image height will be cut in half.",
                "type": "TogglePar",
                "name": "bottomhalfalpha",
                "items": []
            },
            {
                "text": "Int : Sets how many video frames TouchDesigner reads ahead and stores in memory. Using this, smooth reading of an image stream is possible even when the disk files are fragmented. The Movie File In TOP will read frames of the movie into memory before they are used, this can eliminate pops or stutters in playback that occur from fragmented files, other resources accessing the hard drive, or movie looping.",
                "type": "IntPar",
                "name": "prereadframes",
                "items": []
            },
            {
                "text": "Int : Limit the maximum number of CPUs that will be used to decode certain codecs that are capable of multi-CPU decoding, such as H264.",
                "type": "IntPar",
                "name": "maxdecodecpus",
                "items": []
            },
            {
                "text": "Float : Specify the size of the network input buffer in kilobytes.",
                "type": "FloatPar",
                "name": "networkbuffersize",
                "items": []
            },
            {
                "text": "Int : Specify the number of 4KB chunks to assign to the network queue. This is data stored after being read off of the network input buffer.",
                "type": "IntPar",
                "name": "networkqueuesize",
                "items": []
            },
            {
                "text": "Toggle : Enables hardware decoding on Nvidia GPUs.",
                "type": "TogglePar",
                "name": "hwdecode",
                "items": []
            },
            {
                "text": "Toggle : When enabled, this will use OpenGL features to upload movie images to the GPU asynchronously. This will reduce the cook time of the Movie File In TOP considerably (in the performance monitor the lines that say \"Uploading Image to GPU\" will go down to almost nothing). There is a GPU memory cost to using this feature however. It uses up another (Width * Height * 4 * Read Ahead Size) bytes of GPU memory. If you are having poor results with this feature, make sure your graphics drivers are up to date.",
                "type": "TogglePar",
                "name": "asyncupload",
                "items": []
            },
            {
                "text": "DAT : Set the [[WebRTC DAT]] (ie. peer) to get the video stream from. Setting this will automatically populate the WebRTC Connection parameter menu with available connections.",
                "type": "DATPar",
                "name": "webrtc",
                "items": []
            },
            {
                "text": "StrMenu : Select the [[WebRTC]] peer-to-peer connection. Selecting this will automatically population the WebRTC Track parameter menu with available video input tracks.",
                "type": "StrMenuPar",
                "name": "webrtcconnection",
                "items": []
            },
            {
                "text": "StrMenu : Select the video input track that's a part of the WebRTC peer-to-peer connection.",
                "type": "StrMenuPar",
                "name": "webrtctrack",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Video Stream In TOP creates a client to receive video and audio across the network from RTSP, HLS, or SRT sources; or from a WebRTC peer via a WebRTC DAT.",
        "opLicense": "Non-Commercial",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Video Stream In",
        "opClass": "videostreaminTOP_Class",
        "opType": "videostreamin",
        "long": "The Video Stream In TOP creates a client to receive video and audio across the network from RTSP, HLS, or SRT sources; or from a WebRTC peer via a WebRTC DAT.\n\nThe URL to connect to a RTSP server is in the form:\t\t\n\t\t\t\n<code>rtsp://<ipaddress>:<port>/<streamName></code>\tfor example <code>rtsp://192.168.0.1:554/tdvidstream</code>\n\nIf the server requires a username/password, those can be specified using the form.\n\n<code>rtsp://username:password@192.168.0.1:554/tdvidstream</code>\n\nAccess '''[https://en.wikipedia.org/wiki/HTTP_Live_Streaming HLS/DASH]''' input streams via URLs that point to m3u8 files.\n\nAccess streams using '''[https://en.wikipedia.org/wiki/Secure_Reliable_Transport SRT (Secure Reliable Transport)]''' protocol with <code>srt://</code> URLs. For more information on SRT URLs, please see [[Video Stream Out TOP]].\n\nSee also [[Audio Stream In CHOP]], [[WebRTC DAT]].\n\nSRT sent in the Video Stream In TOP can include per-frame metadata making it easy to send and receive CHOP/DAT data in sync with video. Attach an [[Info DAT]] to the TOP.\n\t\t\t\nFor other protocols over IP see [[NDI|NDI (Network Data Interface)]], and [[Touch Out TOP]] / [[Touch In TOP]].\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opCategories": ""
    },
    "videostreamoutTOP": {
        "label": "videostreamoutTOP",
        "members": [
            {
                "text": "Toggle : Controls if the server is active or not. If this is Off then the port this server uses will not be tied up.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Selects if the mode works as an RTSP server, sends RTMP to a receiever such as a distribution service like YouTube or Twitch, or sends to an SRT destination.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Int : The port the server should listen on. Multiple Video Stream Out TOPs can use the same port as long as each has a unique Stream Name.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Str : The name of the stream for this node. This name is what comes after the / in the URL after the ipaddress:port combination.",
                "type": "StrPar",
                "name": "streamname",
                "items": []
            },
            {
                "text": "Toggle : Controls if RTSP server sends its video out using unicast or multicast UDP packets.",
                "type": "TogglePar",
                "name": "multicast",
                "items": []
            },
            {
                "text": "Str : The URL to sent the RTMP stream to. This should be in the format of {service url}/{stream key}. For example for twitch the URL would be something like <code>rtmp://live-yto.twitch.tv/app/live_1234567_sduhy3xJ1KJ34Eg6CjksdJLubFS7gtUY</code>. You may need to search to find the correct URL depending on your location and the service you are using.",
                "type": "StrPar",
                "name": "url",
                "items": []
            },
            {
                "text": "Pulse : For debugging, this will force the server to create a new video keyframe to send to all the clients. If clients aren't getting proper image this can be used to attempt to fix it. If you need to use this parameter please report the case to support@derivative.ca.",
                "type": "PulsePar",
                "name": "forceidr",
                "items": []
            },
            {
                "text": "Float : The FPS to send video at.",
                "type": "FloatPar",
                "name": "fps",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "videocodec",
                "items": []
            },
            {
                "text": "Menu : The H.264 profile to use to encode the frames. Some decoders can only support H.264 encoder at certain profiles.",
                "type": "MenuPar",
                "name": "profile",
                "items": []
            },
            {
                "text": "Menu : The quality level of the encoding.",
                "type": "MenuPar",
                "name": "quality",
                "items": []
            },
            {
                "text": "Int : Set the keyframe interval for the H.264 encoder.",
                "type": "IntPar",
                "name": "keyframeinterval",
                "items": []
            },
            {
                "text": "Int : ",
                "type": "IntPar",
                "name": "maxbframes",
                "items": []
            },
            {
                "text": "Int : ",
                "type": "IntPar",
                "name": "intrarefreshperiod",
                "items": []
            },
            {
                "text": "Int : ",
                "type": "IntPar",
                "name": "intrarefreshlength",
                "items": []
            },
            {
                "text": "Menu : Chooses between constant (CBR) and variable (VBR) bit rate modes. Mode streaming services prefer a constant bit rate mode.",
                "type": "MenuPar",
                "name": "bitratemode",
                "items": []
            },
            {
                "text": "Float : The target bitrate for the encoding. This is specified in Mb/s (megabits/second).",
                "type": "FloatPar",
                "name": "avgbitrate",
                "items": []
            },
            {
                "text": "OP : Send metadata from this OP with each frame of the video stream. This data can be recevied from the [[Video Stream In TOP]] using an [[Info CHOP]] and [[Info DAT]].",
                "type": "OPPar",
                "name": "perframemetadata",
                "items": []
            },
            {
                "text": "Float : The maximum bitrate for the encoding. This is specified in Mb/s (megabits/second).",
                "type": "FloatPar",
                "name": "maxbitrate",
                "items": []
            },
            {
                "text": "Int : This controls how many pieces (slices) each H.264 frame is separated into. Some decoders are able to decode multiple slices simultaneously so setting this to a value above 1 allows those decoders to run more efficiently.",
                "type": "IntPar",
                "name": "numslices",
                "items": []
            },
            {
                "text": "CHOP : A timesliced audio source to send along with the video. For RTSP, Audio will be resampled to 44100Hz before being encoded into MP3. For RTMP the sample rate must already be 44100. For WebRTC the sample rate must be 48000.",
                "type": "CHOPPar",
                "name": "audiochop",
                "items": []
            },
            {
                "text": "Menu : Set the bit rate used for encoding audio.",
                "type": "MenuPar",
                "name": "audiobitrate",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "includesilentaudio",
                "items": []
            },
            {
                "text": "DAT : Set the [[WebRTC DAT]] (ie. peer) to send the video stream over. Setting this will automatically populate the WebRTC Connection parameter menu with available connections.",
                "type": "DATPar",
                "name": "webrtc",
                "items": []
            },
            {
                "text": "StrMenu : Select the [[WebRTC]] peer-to-peer connection. Selecting this will automatically population the WebRTC Track parameter menu with available video output tracks.",
                "type": "StrMenuPar",
                "name": "webrtcconnection",
                "items": []
            },
            {
                "text": "StrMenu : Select the video output track that's a part of the WebRTC peer-to-peer connection.",
                "type": "StrMenuPar",
                "name": "webrtcvideotrack",
                "items": []
            },
            {
                "text": "StrMenu : Optionally select the audio output track that's a part of the WebRTC peer-to-peer connection, to be sent along with the video.",
                "type": "StrMenuPar",
                "name": "webrtcaudiotrack",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Video Stream Out TOP creates an RTSP server to send H.264 video and MP3 audio across the network.",
        "opLicense": "Commercial",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Video Stream Out",
        "opClass": "videostreamoutTOP_Class",
        "opType": "videostreamout",
        "long": "'''Note:''' This TOP uses the Nvidia Hardware Encoder to create the stream and therefore requires an Nvidia GPU and Windows to operate.\n    \nThe Video Stream Out TOP creates either an [[RTSP]] server, or can act as an [[RTMP]] or [[SRT]] sender, to send H.264 video and MP3 audio across the network. It uses Nvidia's hardware H264 encoder. For RTSP, it can handle multiple clients connecting to it at the same time. Multiple Video Stream Out TOPs using the same port will be handled using the same underlying RTSP server. The Video Stream Out TOP can also be used to send a video stream through [[WebRTC]] video/audio tracks.\t\n\n===== RTSP =====\nObtain the URL to connect to the Video Steam Out TOP's RTSP server by using an Info DAT or by middle clicking on the node. It will be in the form:\t\t\t\n\t\t\t\n<code>rtsp://<ipaddress>:<port>/<streamName></code>\t\t\t\n\t\t\t\ne.g.\t\t\t\n\t\t\t\n<code>rtsp://192.168.0.1:554/tdvidstream</code>\t\t\t\n\n===== RTMP =====\nTo obtain the RTMP URL stream to, you may need to search to find the correct URL depending on your location and the service you are using. This should be in the format:\n\n<code>{service url}/{stream key}</code>. \n\nFor example for Twitch the URL would be something like\n\n<code>rtmp://live-yto.twitch.tv/app/live_1234567_sduhy3xJ1KJ34Eg6CjksdJLubFS7gtUY</code>\n\nFor more information on different services checkout  [[RTMP]].\n\n===== SRT =====\n[https://en.wikipedia.org/wiki/Secure_Reliable_Transport SRT] can use either H.264 or H.265 video codec. It can also send per-frame metadata when a CHOP or DAT is specified in the Per-Frame Metadata parameter. The SRT server is settings are controlled by URL options. E.g to create a listener you'd specify the URL:\n\n<code>srt://0.0.0.0:9494?mode=listener</code>\n\nTo connect to listener, you'd do:\n\n<code>srt://127.0.0.1:9494?mode=caller</code>\n\nEither side of the connection can be the listener or the caller, it doesn't matter which is sending the video and which is receiving the video. The receiver would set their mode to be the opposite of whatever the sender is setting their mode to be.\n\nAll the options that are available are listed [https://ffmpeg.org/ffmpeg-protocols.html#srt here]. Multiple options can be set using a & as separator. E.g\n\n<code>srt://127.0.0.1:9494?mode=caller&send_buffer_size=100000</code>\n\nSRT sent from the Video Stream Out TOP can include per-frame metadata making it easy to send and receive CHOP/DAT data in sync with video. It can be read with the [[Video Stream In TOP]].\n\n\n===== Limitations =====\nRTSP streaming does not support sending directly to another RTSP server via RTP.\n\nThe maximum stream outs on a NVIDIA Geforce card is 2: The number of streams the GPU can handle is different depending on driver versions and hardware, however in general it is 2 streams max on Geforce level cards. Using a lower resolution does not avoid the 2 stream limit. Quadros can do more streams.\tRefer to [https://developer.nvidia.com/video-encode-and-decode-gpu-support-matrix-new Nvidia Video GPU Support Matrix] for more information.\n\t\t\t\nOne test using the default TouchDesigner startup file on a M6000 was able to do 13 1080p@30hz Video Stream Out TOPs.\t\t\t\n\nSee also the [[Video Stream In TOP]], [[RTMP]], [[RTSP]] and [[Video Streaming User Guide]].\t\t\t\n\t\t\t\nFor other protocols over IP see [[NDI|NDI (Network Data Interface)]], and [[Touch Out TOP]] / [[Touch In TOP]].\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opCategories": ""
    },
    "viosoTOP": {
        "label": "viosoTOP",
        "members": [
            {
                "text": "File : Specify the location of the .vwf file exported from Vioso 6.",
                "type": "FilePar",
                "name": "configfile",
                "items": []
            },
            {
                "text": "Int : Specify the index of the output projector.",
                "type": "IntPar",
                "name": "projectorindex",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Vioso TOP lets you load calibration data retrieved from running the [https://vioso.com/software/vioso6/ VIOSO 6] software.",
        "opLicense": "Pro",
        "opFamily": "TOP",
        "opFilter": "True",
        "opLabel": "Vioso",
        "opClass": "viosoTOP_Class",
        "opType": "vioso",
        "long": "The Vioso TOP lets you load calibration data retrieved from running the [https://vioso.com/software/vioso6/ VIOSO 6] software.\t\t\nPlease refer to the [[Vioso]] entry for a complete guide on TouchDesigners integration of the VIOSO 6.",
        "opCategories": ""
    },
    "webrenderTOP": {
        "label": "webrenderTOP",
        "members": [
            {
                "text": "Toggle : Enables/disables the Web Render TOP.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Source of the webpage, which can be an address via URL or File, or data from a DAT",
                "type": "MenuPar",
                "name": "source",
                "items": []
            },
            {
                "text": "File : Uniform Resource Locator or the address of the web page",
                "type": "FilePar",
                "name": "url",
                "items": []
            },
            {
                "text": "DAT : DAT",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "DAT : Reload source DAT, URL or File.",
                "type": "DATPar",
                "name": "reloadsrc",
                "items": []
            },
            {
                "text": "Pulse : Reloads the current page, the same as refreshing a web browser.",
                "type": "PulsePar",
                "name": "reload",
                "items": []
            },
            {
                "text": "Pulse : Reset the counter for the number of times the webpage has been updated (available via an Info CHOP).",
                "type": "PulsePar",
                "name": "resetcount",
                "items": []
            },
            {
                "text": "Toggle : Only shows the web page when it is full loaded.",
                "type": "TogglePar",
                "name": "updatewhenloaded",
                "items": []
            },
            {
                "text": "DAT : Cook every frame if on.  If off, the Web Render TOP will cook for a 10 additional frames after the last update received to maintain continuity.",
                "type": "DATPar",
                "name": "alwayscook",
                "items": []
            },
            {
                "text": "Toggle : Loads the webpage with a transparent background.  This option will restart the browser process.",
                "type": "TogglePar",
                "name": "transparent",
                "items": []
            },
            {
                "text": "Toggle : Let the browser process play audio if the web page contains audio.  This option will restart the browser process.",
                "type": "TogglePar",
                "name": "audio",
                "items": []
            },
            {
                "text": "Int : Sets the maximum frame rate the page will be rendered at.  Can be higher than 60 but does not guarantee a frame rate.",
                "type": "IntPar",
                "name": "maxrenderrate",
                "items": []
            },
            {
                "text": "Int : Sets the maximum number of cached images",
                "type": "IntPar",
                "name": "numbuffers",
                "items": []
            },
            {
                "text": "Toggle : On Windows, this toggles between using DirectX shared textures or shared memory.  On macOS shared texture via IOSurface is used",
                "type": "TogglePar",
                "name": "sharedtexture",
                "items": []
            },
            {
                "text": "Str : Persistent directory used by cef for storing user data.",
                "type": "StrPar",
                "name": "userdir",
                "items": []
            },
            {
                "text": "Str : Additional options that can be passed to the browser process.  This option will restart the browser process.  A list of options for the chromium browser can be found at [https://peter.sh/experiments/chromium-command-line-switches/ here].  Note that these options may change without notice with version updates.",
                "type": "StrPar",
                "name": "options",
                "items": []
            },
            {
                "text": "Toggle : Automatically restart the browser process if it died.",
                "type": "TogglePar",
                "name": "autorestart",
                "items": []
            },
            {
                "text": "Pulse : Triggers the Restart immediately on button release (button-up). This can be accessed in python using the pulse() method.",
                "type": "PulsePar",
                "name": "autorestartpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Web Render TOP takes a URL or DAT and renders a webpage via a separate browser process that uses Chromium Embedded Frameworks (CEF), and passes the result back through shared memory.",
        "opLicense": "",
        "opFamily": "TOP",
        "opFilter": "False",
        "opLabel": "Web Render",
        "opClass": "webrenderTOP_Class",
        "opType": "webrender",
        "long": "The Web Render TOP takes a URL or DAT and renders a webpage via a separate browser process that uses Chromium Embedded Frameworks, and passes the result back through shared memory. It renders non-Flash pages, including HTML, HTML5, PDF, SVG and more. Targets can be on the internet, in local files with a <code>file://</code> syntax, or a [[DAT]].\t\n\t\t\nIt is implemented with the [https://bitbucket.org/chromiumembedded/cef Chromium Embedded Frameworks] project (CEF).\t\t\n\t\t\nAttach an [[Info CHOP]] to get the loaded status <code>loaded</code> of the page, and <code>num_handle_updates</code>, the number of times the page has been rendered.\t\t\n\t\t\nAttach an [[Info DAT]] to get the shared memory <code>handle</code>, the <code>status</code> of the browser process, the <code>process_id</code>, versions for Chromium Embedded Frameworks <code>cef</code> and Chromium <code>chromium</code>, the <code>url</code> currently displayed, page <code>title</code> and <code>error</code> state of the process.\t\t\n\t\t\nSee also [[Palette:webBrowser]], [[Audio Web Render CHOP]], [[Palette:SVG]]",
        "opCategories": ""
    },
    "zedTOP": {
        "label": "zedTOP",
        "members": [
            {
                "text": "Toggle : When set to 1 the TOP captures the image stream from the camera.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : Selects which ZED camera to use.",
                "type": "StrMenuPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "Menu : Choose between Left or Right camera.",
                "type": "MenuPar",
                "name": "perspective",
                "items": []
            },
            {
                "text": "Menu : Selects between the Color, Depth, Confidence, Disparity, Normals, Point Cloud or Spatial Texture modes.",
                "type": "MenuPar",
                "name": "image",
                "items": []
            },
            {
                "text": "Menu : Selects the resolution of the camera capture.",
                "type": "MenuPar",
                "name": "cameraresolution",
                "items": []
            },
            {
                "text": "Float : Sets the frame rate of the camera capture.",
                "type": "FloatPar",
                "name": "camerafps",
                "items": []
            },
            {
                "text": "Menu : Selects betweem Standard and Fill mode.",
                "type": "MenuPar",
                "name": "sensingmode",
                "items": []
            },
            {
                "text": "Float : Sets the minimum depth in meters that will be computed.",
                "type": "FloatPar",
                "name": "mindepth",
                "items": []
            },
            {
                "text": "Float : Sets the maximum depth in meters.",
                "type": "FloatPar",
                "name": "maxdepth",
                "items": []
            },
            {
                "text": "Toggle : Enables depth stabilization for the camera.",
                "type": "TogglePar",
                "name": "depthstabilization",
                "items": []
            },
            {
                "text": "Toggle : Enabling this will remap pixel values to 0-1.",
                "type": "TogglePar",
                "name": "rerange",
                "items": []
            },
            {
                "text": "Menu : Select between World and Camera reference frames for the Point Cloud pixels.",
                "type": "MenuPar",
                "name": "referenceframe",
                "items": []
            },
            {
                "text": "Pulse : Resets the camera position used for the reference frame above.",
                "type": "PulsePar",
                "name": "resetcameraposition",
                "items": []
            },
            {
                "text": "Toggle : Flips the image in the y-axis.",
                "type": "TogglePar",
                "name": "mirrorimage",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "zedTOP_Class",
        "opLabel": "ZED",
        "opFamily": "TOP",
        "opLicense": "Non-Commercial",
        "opType": "zed",
        "opFilter": "False",
        "os": "Microsoft Windows",
        "long": "The ZED TOP captures video from the ZED depth camera. \t\t\n\t\t\t\n'''NOTE:''' This TOP works with the [https://www.stereolabs.com/zed/ Stereolabs ZED] hardware. For more information and to know what ZED SDK to install refer to the [[ZED]] article.\n\t\t\t\nIt supports point clouds - getting the camera space positions of the color pixels, outputted as a 32-bit float RGB texture with XYZ in the RGB channels. It can be used in making point clouds renders as it is in the format for [[Geometry COMP]] instancing.\t\t\t\n\t\t\t\nSee also [[ZED CHOP]] and [[ZED SOP]].",
        "short": "The ZED TOP captures video from the ZED depth camera.",
        "opCategories": ""
    },
    "abletonlinkCHOP": {
        "label": "abletonlinkCHOP",
        "members": [
            {
                "text": "Toggle : Turns the CHOP's output on or off.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : Initializes the connection to the Ableton Link session.",
                "type": "TogglePar",
                "name": "enable",
                "items": []
            },
            {
                "text": "Int : Specifies the time signature. The first number is the number of beats per measure and the second number indicates the type of note that constitutes one beat. See [http://en.wikipedia.org/wiki/Time_signature Time Signature - Wikipedia] for additional information.",
                "type": "IntPar",
                "name": "signature",
                "items": []
            },
            {
                "text": "DAT : Path to a DAT containing callbacks for each event received.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Toggle : Enables the following status channels\n* numpeers - number of Ableton Link enabled devices or app found on the network.\n* linked - if the Ableton Link CHOP is connected to the Link network.\n* waiting - if the Ableton Link CHOP is in a waiting state and not synced.\n* synced - if the Ableton Link CHOP has synced with the Link network.",
                "type": "TogglePar",
                "name": "status",
                "items": []
            },
            {
                "text": "Toggle : Outputs a 0-1 ramp each bar.",
                "type": "TogglePar",
                "name": "ramp",
                "items": []
            },
            {
                "text": "Toggle : Outputs a pulse each bar.",
                "type": "TogglePar",
                "name": "pulse",
                "items": []
            },
            {
                "text": "Toggle : Outputs a sine wave each bar.",
                "type": "TogglePar",
                "name": "sine",
                "items": []
            },
            {
                "text": "Toggle : Increases the count each bar.",
                "type": "TogglePar",
                "name": "count",
                "items": []
            },
            {
                "text": "Toggle : A ramp that counts up until the bar is reset.",
                "type": "TogglePar",
                "name": "countramp",
                "items": []
            },
            {
                "text": "Toggle : Output the current bar.",
                "type": "TogglePar",
                "name": "bar",
                "items": []
            },
            {
                "text": "Toggle : Output the current beat.",
                "type": "TogglePar",
                "name": "beat",
                "items": []
            },
            {
                "text": "Toggle : Output the current sixteenths.",
                "type": "TogglePar",
                "name": "sixteenths",
                "items": []
            },
            {
                "text": "Toggle : Outputs a 0-1 ramp each bar.",
                "type": "TogglePar",
                "name": "rampbar",
                "items": []
            },
            {
                "text": "Toggle : Outputs a 0-1 ramp each beat.",
                "type": "TogglePar",
                "name": "rampbeat",
                "items": []
            },
            {
                "text": "Toggle : Outputs the current tempo (also known as BPM).",
                "type": "TogglePar",
                "name": "tempo",
                "items": []
            },
            {
                "text": "Toggle : Outputs the total number of beats.",
                "type": "TogglePar",
                "name": "beats",
                "items": []
            },
            {
                "text": "Toggle : Outputs the current phase in the bar.",
                "type": "TogglePar",
                "name": "phase",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Ableton Link CHOP retrieves timing information from an Ableton Link supported network. For more information see:  http://www.ableton.com/en/link/",
        "opClass": "abletonlinkCHOP_Class",
        "opFilter": "True",
        "long": "The Ableton Link CHOP retrieves timing information from an Ableton Link supported network.\t\t\nFor more information see:  http://www.ableton.com/en/link/\n\nThe full support of the Ableton Live system is [[TDAbleton]], a group of components that give you access to Ableton Songs, Tracks, Chains, Parameters and MIDI.\t\t\t\n\t\t\t\nAbleton's Link FAQ is very helpful for issues on the Ableton end: https://help.ableton.com/hc/en-us/articles/209776125-Link-FAQs. \n\nOne common problem is that Ableton Link doesn't work with all sound drivers, including DirectX. The free application [http://www.asio4all.com/ ASIO4All] is an easy replacement that acts as a virtual ASIO device.\n\nSee also [[Ableton]].",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "ableton",
        "opLabel": "Ableton Link",
        "opCategories": ""
    },
    "analyzeCHOP": {
        "label": "analyzeCHOP",
        "members": [
            {
                "text": "Menu : This menu determines the function applied to the channel.",
                "type": "MenuPar",
                "name": "function",
                "items": []
            },
            {
                "text": "Toggle : If the values of the first 2 samples are v0 and v1, if v0 > v1, count it as a peak. The default is to never count the first sample as a peak.",
                "type": "TogglePar",
                "name": "allowstart",
                "items": []
            },
            {
                "text": "Toggle : If the values of the last 2 samples are vn and vm, if vm > vn, count it as a peak. The default is to never count the last sample as a peak.",
                "type": "TogglePar",
                "name": "allowend",
                "items": []
            },
            {
                "text": "Float : When no peaks are found, make this number (default is <code>-1</code>) the result that is output. When the Function is set to Peak Index or Peak Value, it is a way to detect that no peaks were found.",
                "type": "FloatPar",
                "name": "nopeakvalue",
                "items": []
            },
            {
                "text": "Toggle : Analyze instead for the First Valley, Highest Valley, and Lowest Valley, when the corresponding Function menu options are chosen.",
                "type": "TogglePar",
                "name": "valleys",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Analyze CHOP looks at the values of all the values of a channel, and outputs a single-number result into the output.",
        "opClass": "analyzeCHOP_Class",
        "opFilter": "True",
        "long": "The Analyze CHOP looks at the values of all the values of a channel, and outputs a single-number result into the output. The output is one sample long. It can analyze for maximum, average, peaks and other aspects of a channel.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "analyze",
        "opLabel": "Analyze",
        "opCategories": ""
    },
    "angleCHOP": {
        "label": "angleCHOP",
        "members": [
            {
                "text": "Menu : Units of incoming channels:",
                "type": "MenuPar",
                "name": "inunit",
                "items": []
            },
            {
                "text": "Menu : The order that rotation angles are assumed to be applied in (Euler angles as they are called). Applicable when converting to and from Quaternions or Vectors.",
                "type": "MenuPar",
                "name": "inorder",
                "items": []
            },
            {
                "text": "Menu : Units of outgoing channels:",
                "type": "MenuPar",
                "name": "outunit",
                "items": []
            },
            {
                "text": "Menu : The order that rotation angles are assumed to be applied in (Euler angles as they are called). Applicable when converting to and from Quaternions or Vectors.",
                "type": "MenuPar",
                "name": "outorder",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Angle CHOP is a general purpose converter between degrees, radians, quaternions and vectors.",
        "opClass": "angleCHOP_Class",
        "opFilter": "True",
        "long": "The Angle CHOP is a general purpose converter between degrees, radians, quaternions and vectors. Different formats assume a specific ordering of input channels.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "angle",
        "opLabel": "Angle",
        "opCategories": ""
    },
    "attributeCHOP": {
        "label": "attributeCHOP",
        "members": [
            {
                "text": "Menu : The function to perform on the attributes:",
                "type": "MenuPar",
                "name": "slerp",
                "items": []
            },
            {
                "text": "Menu : Sets the rotation order of the rotation triplet.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Attribute CHOP adds, removes or updates attributes of the input CHOP. Currently there is only one attribute type, a \"quaternion\".",
        "opClass": "attributeCHOP_Class",
        "opFilter": "True",
        "long": "The Attribute CHOP adds, removes or updates attributes of the input CHOP. Currently there is only one attribute type, a \"quaternion\". This attribute type is used to group rotation channel triplets (rx,ry,rz) together.\t\t\n\t\t\t\nRotations sometimes need to be grouped together since interpolations on independent X, Y and Z rotations do not produce smooth results. Rotations often need Quaternion interpolation to rotate through the most direct path.\t\t\t\n\t\t\t\nOperations such as resampling and blending recognize the rotation triplet with the \"quaternion\" attribute. They blend or resample the rotation channels using \"spherical linear interpolation\". Ordinary interpolation can produce poor blending results, whereas quaternion blending produces the shortest rotation path between two sets of rotations.\t\t\t\n\t\t\t\nSee some of the CHOPs that use the attribute: the [[Join CHOP]], [[Composite CHOP]] and [[Interpolate CHOP]]. Other CHOPs may quietly use the Quaternion attribute, such as the [[Object CHOP]], [[Stretch CHOP]] and the [[Resample CHOP]].\t\t\t\n\t\t\t\nThe Scope is needed to specify the channels that will be grouped.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "attribute",
        "opLabel": "Attribute",
        "opCategories": ""
    },
    "audiobandeqCHOP": {
        "label": "audiobandeqCHOP",
        "members": [
            {
                "text": "Float : As this parameter is reduced from 1 (Wet) toward 0 (Dry), it removes the effect of the filter.",
                "type": "FloatPar",
                "name": "drywet",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut centered at 25 Hz.",
                "type": "FloatPar",
                "name": "band1",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 40 Hz band.",
                "type": "FloatPar",
                "name": "band2",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 60 Hz band.",
                "type": "FloatPar",
                "name": "band3",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 90 Hz band.",
                "type": "FloatPar",
                "name": "band4",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 150 Hz band.",
                "type": "FloatPar",
                "name": "band5",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 240 Hz band.",
                "type": "FloatPar",
                "name": "band6",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 370 Hz band.",
                "type": "FloatPar",
                "name": "band7",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 590 Hz band.",
                "type": "FloatPar",
                "name": "band8",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 930 Hz band.",
                "type": "FloatPar",
                "name": "band9",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 1.5 Hz band.",
                "type": "FloatPar",
                "name": "band10",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 2.3 Hz band.",
                "type": "FloatPar",
                "name": "band11",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 3.6 Hz band.",
                "type": "FloatPar",
                "name": "band12",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 5.6 Hz band.",
                "type": "FloatPar",
                "name": "band13",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 8.9 Hz band.",
                "type": "FloatPar",
                "name": "band14",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 14 Hz band.",
                "type": "FloatPar",
                "name": "band15",
                "items": []
            },
            {
                "text": "Float : Controls boost/cut at the 22 Hz band.",
                "type": "FloatPar",
                "name": "band16",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Band EQ CHOP is a 16-band [http://en.wikipedia.org/wiki/Equalization_(audio) equalizer] which filters audio input channels in the same way that a conventional band (graphic) equalizer uses a bank of sliders to filter fixed-frequency bands of sound.",
        "opClass": "audiobandeqCHOP_Class",
        "opFilter": "True",
        "long": "The Audio Band EQ CHOP is a 16-band [http://en.wikipedia.org/wiki/Equalization_(audio) equalizer] which filters audio input channels in the same way that a conventional band (graphic) equalizer uses a bank of sliders to filter fixed-frequency bands of sound.\t\n\t\t\nThe CHOP has 16 bands from 25 Hz to 22 kHz with one parameter per band. The bandwidth per band is approximately half the frequency between the prior and next bands.\t\t\n\t\t\nSee [[Audio Filter CHOP]], [[Audio Para EQ CHOP]], [[Audio Dynamics CHOP]], [[Audio Spectrum CHOP]]",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audioband",
        "opLabel": "Audio Band EQ",
        "opCategories": ""
    },
    "audiobinauralCHOP": {
        "label": "audiobinauralCHOP",
        "members": [
            {
                "text": "Toggle : When enabled, will be actively performing binaural rendering. When disabled, the channels will be zeroed.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the input format to convert from. The input CHOP is required to have the correct number of channels (eg. 6 for 5.1 Surround).",
                "type": "MenuPar",
                "name": "inputformat",
                "items": []
            },
            {
                "text": "Int : Used in conjunction with ambisonics input format. Supports ambisonics order 1-3 Determines how many channels are required from the input. Ambisonics order 1, 2, 3 require 4, 9, 16 channels respectively.",
                "type": "IntPar",
                "name": "ambisonicsorder",
                "items": []
            },
            {
                "text": "Int : Optionally specify a listener object when using an ambisonics input. The listener's orientation will be applied before binaural rendering.",
                "type": "IntPar",
                "name": "listener",
                "items": []
            },
            {
                "text": "DAT : A DAT Table that specifies the various speakers in the setup and their position. The Table must have 3 columns named x, y, z. Each row specifies an individual speaker, and the 3 columns specify its position. Used with the Custom Setup Input Format. The mapping table will require one channel per row from the input CHOP.",
                "type": "DATPar",
                "name": "mappingtable",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "audiobinauralCHOP",
        "opLabel": "Audio Binaural",
        "opClass": "audiobinauralCHOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "",
        "long": "The Audio Binaural CHOP uses the [https://valvesoftware.github.io/steam-audio/ Steam Audio API] to convert from multi-channel speaker-based audio (eg. stereo, quadraphonic, 5.1, 7.1, etc.) to binaural using [https://en.wikipedia.org/wiki/Head-related_transfer_function HRTF]-based binaural rendering. The HRTF used is the default provided by Steam Audio. \n    \nThe Audio Binaural CHOP is useful for converting audio from a variety of formats to a 2-channel binaural format that is VR-friendly.\n\nThe sample rate of the output is determined by the audio source, which must be either 44100 or 48000.\n\nSee also: [[Audio Render CHOP]], [[OpenVR]], [[Oculus Rift]]"
    },
    "audiodeviceinCHOP": {
        "label": "audiodeviceinCHOP",
        "members": [
            {
                "text": "Toggle : Turns the audio input on or off.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select between default DirectSound/CoreAudio, ASIO, or native device supported drivers.",
                "type": "MenuPar",
                "name": "driver",
                "items": []
            },
            {
                "text": "StrMenu : A menu of available audio devices to receive input from. Selecting ''default'' sets the audio device to that which is selected in Windows Control Panel&gt;Sounds and Audio Devices&gt;Audio&gt;Sound Recording.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Toggle : The CHOP will error if the specified device is not found.",
                "type": "TogglePar",
                "name": "errormissing",
                "items": []
            },
            {
                "text": "StrMenu : When Driver is set to ASIO on Windows or CoreAudio on macOS, this parameter lets you pick which input channels to use.",
                "type": "StrMenuPar",
                "name": "inputs",
                "items": []
            },
            {
                "text": "Menu : When Driver is set to DirectSound, this set mono, stereo, or multi-channel. Also determines how many channels are created 1(mono) or 2(stereo left and stereo right), or when set to multi-channel set the number of channels active on the Input 1 and Input 2 parameter pages.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "Float : Audio input sample rate expressed in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Float : The size of the input buffer, will effect latency.  The larger the buffer the more latency is introduced.",
                "type": "FloatPar",
                "name": "bufferlength",
                "items": []
            },
            {
                "text": "Int : When using Driver Blackmagic or AJA, use this parameter to set the number of channels.",
                "type": "IntPar",
                "name": "numchan",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "frontleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "frontright",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "frontcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "lowfrequency",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "backleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "backright",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "frontleftcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "frontrightcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "backcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "sideleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "sideright",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "topcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "topfrontleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "topfrontcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "topfrontright",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "topbackleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "topbackcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this input if available (or simply adds another input channel).",
                "type": "TogglePar",
                "name": "topbackright",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Device In CHOP receives audio from any of the attached audio input devices using DirectSound/CoreAudio or ASIO.",
        "opClass": "audiodeviceinCHOP_Class",
        "opFilter": "False",
        "long": "The Audio Device In CHOP receives audio from any of the attached audio input devices using DirectSound/CoreAudio or ASIO. It always outputs time sliced audio data. \n    \nIf you want to capture the data in memory, use a [[Trail CHOP]] or [[Record CHOP]].\tIf you want to record to a file, use [[Audio File Out CHOP]] or [[Movie File Out TOP]].\t\n    \nThe Audio Device In CHOP can receive analog control voltages ('''CVs''') as long as your audio device's analog to digital converters can handle constant non-zero voltages.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiodevin",
        "opLabel": "Audio Device In",
        "opCategories": ""
    },
    "audiodeviceoutCHOP": {
        "label": "audiodeviceoutCHOP",
        "members": [
            {
                "text": "Toggle : Turns the audio output on or off.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select between default DirectSound/CoreAudio or ASIO drivers.",
                "type": "MenuPar",
                "name": "driver",
                "items": []
            },
            {
                "text": "StrMenu : A menu of available audio devices to output to. Selecting ''default'' sets the audio device to that which is selected in Windows Control Panel&gt;Sounds and Audio Devices&gt;Audio&gt;Sound Playback.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Toggle : The CHOP will error if the specified device is not found.",
                "type": "TogglePar",
                "name": "errormissing",
                "items": []
            },
            {
                "text": "StrMenu : When Driver is set to ASIO on Windows or CoreAudio on macOS, this parameter lets you pick which output channels to use.",
                "type": "StrMenuPar",
                "name": "outputs",
                "items": []
            },
            {
                "text": "Float : The length of the audio buffer in seconds. Audio output is delayed by this amount. For example, if the Buffer Length is 0.25 then the sound will occur 250ms = 0.25 seconds later than this CHOP received it (to keep the buffer full). If you hear crackling or popping in the audio output, try increasing this value.",
                "type": "FloatPar",
                "name": "bufferlength",
                "items": []
            },
            {
                "text": "Float : 0 = mute, 1 = full volume.",
                "type": "FloatPar",
                "name": "volume",
                "items": []
            },
            {
                "text": "Float : 0 = left, 0.5 = centered, 1 = right.",
                "type": "FloatPar",
                "name": "pan",
                "items": []
            },
            {
                "text": "Toggle : Clamps the output between -1 and 1 to avoid clipping and overdriving of the audio system.",
                "type": "TogglePar",
                "name": "clampoutput",
                "items": []
            },
            {
                "text": "Toggle : Forces the CHOP to cook every frame. This should be checked on at all times when outputing audio. It can be turned off when the CHOP is not in use.",
                "type": "TogglePar",
                "name": "cookalways",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "frontleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "frontright",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "frontcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "lowfrequency",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "backleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "backright",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "frontleftcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "frontrightcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "backcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "sideleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "sideright",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "topcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "topfrontleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "topfrontcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "topfrontright",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "topbackleft",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "topbackcenter",
                "items": []
            },
            {
                "text": "Toggle : Enable this output if available.",
                "type": "TogglePar",
                "name": "topbackright",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Device Out CHOP sends audio to any of the attached audio output devices using DirectSound/CoreAudio or ASIO.",
        "opClass": "audiodeviceoutCHOP_Class",
        "opFilter": "True",
        "long": "The Audio Device Out CHOP sends audio to any of the attached audio output devices using DirectSound/CoreAudio or ASIO. \t\t\t\nThe second input on the Audio Device Out CHOP can be used for volume control.\t\t\t\n\t\t\t\n'''Tip''': If you get audio popping or audio dropouts, it may be caused by your actual frame rate of your main <code>timeline</code> - some frames may take too long to compute/render. See [[Time Slicing]]. There are four possible remedies:\t\t\t\n* The global CHOP [[Time Slice|Maximum Time Slice Size]] may be shorter than your worst-case time steps. Its default is .2 seconds set in Edit -> Preferences -> CHOPs -> Maximum Time Slice Size). If any frame takes longer than the Maximum Time Slice Size time to draw, audio will pop.\t\t\t\n* Then the audio buffer size can be increased (the Buffer Length parameter defaults to .15 seconds) up to the Maximum Time Slice Size.\t\t\t\n* Optimize your networks so under no condition your frame time exceeds the audio buffer size or the maximum time slice size. You can monitor this precisely with the [[Perform CHOP]].\t\t\t\n* Put audio in a separate TouchDesigner process.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiodevout",
        "opLabel": "Audio Device Out",
        "opCategories": ""
    },
    "audiodynamicsCHOP": {
        "label": "audiodynamicsCHOP",
        "members": [
            {
                "text": "Float : This parameter controls the volume of the channel before it reaches the compressor.  If the signal to be compressed is not in a useful dynamic range, this parameter can be used to repair it.",
                "type": "FloatPar",
                "name": "inputgain",
                "items": []
            },
            {
                "text": "Toggle : Turns the compressor on or off.",
                "type": "TogglePar",
                "name": "enablecompressor",
                "items": []
            },
            {
                "text": "Menu : Determines which compression method to use.",
                "type": "MenuPar",
                "name": "compressiontype",
                "items": []
            },
            {
                "text": "Menu : As various channels come into the CHOP, they can either be compressed by an equal amount, or individually.  If they are compressed equally, all of the channels will be evaluated for the highest peak value, and this value will be used to determine the compression amount.\t\nIf they are compressed separately, each channel will be evaluated and compressed by different amounts.",
                "type": "MenuPar",
                "name": "chanlinkingcomp",
                "items": []
            },
            {
                "text": "Float : This parameter sets the threshold value which a signal must cross before compression is applied. It uses a decibel scale, where '0 decibels' would be considered the loudest possible signal*, and '-60 decibels' would be nearly inaudible. This is assuming that input signals are normalized to a \"-1 to +1\" range.",
                "type": "FloatPar",
                "name": "thresholdcompressor",
                "items": []
            },
            {
                "text": "Float : The ratio is the amount of compression that will be applied to the signal, with respect to how far the signal has gone past the threshold value. A ratio of '0' will apply no compression. A value of '1' will cause a signals amplitude to be held down to the threshold value. With values over '1', the signal will become quieter as it passes the threshold.",
                "type": "FloatPar",
                "name": "ratiocompressor",
                "items": []
            },
            {
                "text": "Float : The knee defines how the CHOP will transition into compression as signals approach or cross the threshold. With a knee of '0' (a hard knee), think of the compressor as applying a flat compression response, where:\t\ncompression_gain(db) = amount_that_signal_has_crossed_threshold(dB) * compression_ratio\t\t\t\nThis type of compression is not always desirable, as it can have a strong effect upon the dynamics of a sound. Increasing the knee parameter will cause there to be a smoothed transition into the compression.\t\t\t\nSee the Knee diagram below.\t\t\t\n\t\t\t\n[[image:AudioKnee.png|300px]]",
                "type": "FloatPar",
                "name": "kneecompressor",
                "items": []
            },
            {
                "text": "Float : The attack will control how quickly the compressor responds when a signal crosses the threshold.  Increasing the attack parameter will cause the compressor to apply compression at a slower and smoother rate. Increasing the parameter too much, will cause compression to be applied too slowly.",
                "type": "FloatPar",
                "name": "attackcompressor",
                "items": []
            },
            {
                "text": "Float : The release will control how quickly the compressor responds when a signal drops to a lower level, or goes below the threshold altogether. Just like the attack, higher value will slow down the response, but too high of a value will be too slow.",
                "type": "FloatPar",
                "name": "releasecompressor",
                "items": []
            },
            {
                "text": "Float : After applying compression, the signal can be reduced with Gain to a lower volume level. To make up the lost volume, this parameter can be increased.",
                "type": "FloatPar",
                "name": "gaincompressor",
                "items": []
            },
            {
                "text": "Toggle : Turns the limiter on or off.",
                "type": "TogglePar",
                "name": "enablelimiter",
                "items": []
            },
            {
                "text": "Menu : Same as compressor.",
                "type": "MenuPar",
                "name": "chanlinkinglim",
                "items": []
            },
            {
                "text": "Float : This is the threshold value which a signal must cross before limiting is applied. Usually, this value should be left at '0' decibels. Just like the compressor, a value of '0' decibels is considered to be the loudest possible signal.  \t\nFrom the perspective of digital audio, a signal level which varies between \"+1 <-> -1\" is at a volume level of \"0\" decibels, because it is not possible for a digital system to respresent any values larger than \"+1 <-> -1\".  Instead, they will simply be clipped as they proceed to the output device. The limiter allows you to stop your audio from being clipped if you exceed this range, and applies a much smoother form of fast compression, which is barely audible.\t\t\t\nLowering the threshold value will cause the output to be clamped to a lower level.",
                "type": "FloatPar",
                "name": "thresholdlimiter",
                "items": []
            },
            {
                "text": "Float : Although the attack of a limiter is always quick, the release can still be set by the user. This will determine how long the limiter takes to transition out of a limiting situation. Increasing the release will help smooth out the effect of the limiter. Too high of a value may cause the limiter to release too slowly.  For example, after an excessively loud tone burst, the limiter's gain may have been pushed up to an extreme value. This extreme value will take a long time to be fully released.\t\n\t\t\t\nEach channel can be different by putting expressions with the channel index, <code>me.channelIndex</code> in parameters like the frequency channel.",
                "type": "FloatPar",
                "name": "releaselimiter",
                "items": []
            },
            {
                "text": "Float : Similar to the compressor, this parameter controls how the CHOP will transition into limiting, when a signal becomes louder. A larger knee will mean a smoother transition. See the Knee diagram above.\t\nIf set to '0', no limiting will be applied until a signal goes over the threshold value. When increasing the knee parameter, some limiting will be applied before a signal goes beyond the threshold value, in an attempt to smooth out the effects of limiting overall.",
                "type": "FloatPar",
                "name": "kneelimiter",
                "items": []
            },
            {
                "text": "Float : As this parameter is reduced from 1 (Wet) toward 0 (Dry), it removes the effect of the filter.",
                "type": "FloatPar",
                "name": "drywet",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Dynamics CHOP is designed to control the dynamic range of an audio signal.",
        "opClass": "audiodynamicsCHOP_Class",
        "opFilter": "False",
        "long": "The Audio Dynamics CHOP is designed to control the dynamic range of an audio signal. Dynamic range refers to how loud and quiet the audio is over some period of time. The Operator contains two types of dynamic control: compression and limiting.\t\t\nIt is recommended that you [[link]] this CHOP to an [[Info CHOP]], so that you can have some visual feedback:  The amount of compression or limiting which is being applied will be displayed in the Info CHOP.\t\t\t\n\t\t\t\n'''Compressor'''\t\t\t\nThe goal of a compressor is to reduce the amplitude of a signal when it crosses a certain threshold, while introducing little to no harmonic distortion.  The desired threshold is set by the user, and the amount of compression to be applied is determined by the compression ratio.  The attack and release parameters determine how quickly the compression will be applied and released, as incoming signal goes above and below the threshold.\t\t\t\n\t\t\t\n'''Limiter'''\t\t\t\nThe purpose of a limiter is to ensure a signal is within a certain dynamic range, while introducing as little harmonic distortion as possible.  Unlike the compressor, the goal is not to apply a smooth or musical form of dynamic control, but instead to keep the signal within a 'safe' range that is compatible with any CHOPS that are downstream (for example, an Audio Device Out).  This means that the Limiter has a much more abrupt (instant) attack value, which cannot be adjusted by the user.\t\t\t\n\t\t\t\nInput 2: '''Side Chain Channels''' - Other audio channels coming in can be used to determine the gains that are applied to the audio channels of the first input.\t\t\t\n\t\t\t\n'''NOTE''': This is a useful article for procedurally [http://gameaudionoise.blogspot.co.uk/p/all-in-mix-importance-of-real-time.html mixing audio for games].\t\t\t\n\t\t\t\nSee [[Audio Filter CHOP]], [[Audio Para EQ CHOP]], [[Audio Band EQ CHOP]], [[Audio Spectrum CHOP]]\t\t\t\nSee also: [[Envelope CHOP]].",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiodyna",
        "opLabel": "Audio Dynamics",
        "opCategories": ""
    },
    "audiofileinCHOP": {
        "label": "audiofileinCHOP",
        "members": [
            {
                "text": "File : Path of source.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Pulse : Instantly reload the file from disk.",
                "type": "PulsePar",
                "name": "reloadpulse",
                "items": []
            },
            {
                "text": "Toggle : Audio will playback when this is set to 1 and stop when set to 0.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Menu : Specifies the method used to playback the audio, there are 3 options.",
                "type": "MenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "Float : This is a speed multiplier which only works when Play Mode is ''Sequential''. A value of 1 is the default playback speed. A value of 2 is double speed, 0.5 is half speed and so on. This node can not play audio backwards so negative values will not work well.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Toggle : Jumps to Cue Point when set to 1. Only available when Play Mode is Sequential.",
                "type": "TogglePar",
                "name": "cue",
                "items": []
            },
            {
                "text": "Pulse : Instantly jumps to the Cue Point.",
                "type": "PulsePar",
                "name": "cuepulse",
                "items": []
            },
            {
                "text": "Float : Set any index in the song as a point to jump to.",
                "type": "FloatPar",
                "name": "cuepoint",
                "items": []
            },
            {
                "text": "Menu : Units used when setting the Cue Point parameter.",
                "type": "MenuPar",
                "name": "cuepointunit",
                "items": []
            },
            {
                "text": "Float : This parameter explicitly sets the song position when Play Mode is set to Specify Index. The units menu on the right lets you specify the index in the following units: Index, Frames, or Seconds.",
                "type": "FloatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Menu : Units used for the Index parameter.",
                "type": "MenuPar",
                "name": "indexunit",
                "items": []
            },
            {
                "text": "Menu : Repeats the audio stream when the end is reached.",
                "type": "MenuPar",
                "name": "repeat",
                "items": []
            },
            {
                "text": "Toggle : Enables the Trim parameters below.",
                "type": "TogglePar",
                "name": "trim",
                "items": []
            },
            {
                "text": "Float : Sets an '''In''' point from the beginning of the audio, allowing you to trim the starting position of the audio stream. The units menu on the right let you specify this position by index, frames, or seconds.",
                "type": "FloatPar",
                "name": "trimstart",
                "items": []
            },
            {
                "text": "Menu : Units used for the Trim Start parameter.",
                "type": "MenuPar",
                "name": "trimstartunit",
                "items": []
            },
            {
                "text": "Float : Sets an '''Out''' point from the end of the audio, allowing you to trim the ending position of the audio stream. The units menu on the right let you specify this position by index, frames, or seconds.",
                "type": "FloatPar",
                "name": "trimend",
                "items": []
            },
            {
                "text": "Menu : Units used for the Trim End parameter.",
                "type": "MenuPar",
                "name": "trimendunit",
                "items": []
            },
            {
                "text": "Float : The amount of audio to buffer to maintain smooth playback.",
                "type": "FloatPar",
                "name": "prereadlength",
                "items": []
            },
            {
                "text": "Menu : Units used for the Pre-Read Length parameter.",
                "type": "MenuPar",
                "name": "prereadlengthunit",
                "items": []
            },
            {
                "text": "Float : The time (in milliseconds) TouchDesigner will wait for the audio file to open. If the Open Timeout time is reached, the Audio File In CHOP will stop waiting, and play silence. If the file still isn't opened the next time the CHOP cooks, it'll wait again, and do the same. It'll keep doing this until the file is opened, or the open fails.",
                "type": "FloatPar",
                "name": "opentimeout",
                "items": []
            },
            {
                "text": "Toggle : Output mono channel only even if file has multiple channels.",
                "type": "TogglePar",
                "name": "mono",
                "items": []
            },
            {
                "text": "Float : Set the level the file is read in at. A setting of 1 is full signal while 0 is muted.",
                "type": "FloatPar",
                "name": "volume",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio File In CHOP reads audio from files on disk or at <code>http://</code> addresses.",
        "opClass": "audiofileinCHOP_Class",
        "opFilter": "False",
        "long": "The Audio File In CHOP reads audio from files on disk or at <code>http://</code> addresses. File types <code>.mp3</code>, <code>.aif</code>, <code>.aiff</code>, <code>.au</code>, and <code>.wav</code> files are supported. It always outputs time sliced audio data. If you want to record the data, use a [[Record CHOP]] or [[Movie File Out TOP]].\t\t\n\t\t\t\nSee [[Audio Movie CHOP]] for reading from movie files. See [[OSC In CHOP]] for receiving audio streams via OSC.\t\t\t\n\t\t\t\nFor large files the Audio File In CHOP streams the file from disk so loading the entire file into memory is not needed.\t\t\t\n\t\t\t\n* It streams files from disk and from <code>http:</code> locations (latter copies to local disk first) - It only keeps a few seconds in memory at a time.\t\t\t\n* The supported audio files are <code>.mp3 .aif .aiff .wav</code> and other [[File Types|audio formats]].\t\t\t\n* It also plays audio-only from any movie files that TouchDesigner supports, like <code>.mov, .mpg .mp4</code>. See also the [[Audio Movie CHOP]] for playing audio from movie files in sync with their video.\t\t\t\n* Audio files can be dragged/dropped onto TouchDesigner, double-clicked (if preferred), and RMB Open With... TouchDesigner.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiofilein",
        "opLabel": "Audio File In",
        "opCategories": ""
    },
    "audiofileoutCHOP": {
        "label": "audiofileoutCHOP",
        "members": [
            {
                "text": "Menu : Select the file type (container) of the output file.",
                "type": "MenuPar",
                "name": "filetype",
                "items": []
            },
            {
                "text": "Toggle : When enabled, me.fileSuffix will be a unique suffix when used in the file parameter.",
                "type": "TogglePar",
                "name": "uniquesuff",
                "items": []
            },
            {
                "text": "Int : When unique suffix is disabled, me.fileSuffix will simply contain the value of N, instead of being unique",
                "type": "IntPar",
                "name": "n",
                "items": []
            },
            {
                "text": "File : Sets the path and filename of the audio file that is saved out. The file extension must match the file type parameter.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Menu : Select the compression codec for the WAV file type.",
                "type": "MenuPar",
                "name": "codec",
                "items": []
            },
            {
                "text": "Menu : Selects the bit rate for the MP3 file type.",
                "type": "MenuPar",
                "name": "bitrate",
                "items": []
            },
            {
                "text": "Toggle : When toggled on, it will open the audio file and begin recording. When toggled off, it will close the file and release the read/write lock.",
                "type": "TogglePar",
                "name": "record",
                "items": []
            },
            {
                "text": "Toggle : Pauses the recording of the audio to the audio file.",
                "type": "TogglePar",
                "name": "pause",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "audiofileoutCHOP",
        "opLabel": "Audio File Out",
        "opClass": "audiofileoutCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Audio File Out CHOP saves an audio stream out to a file using a variety of different codecs.",
        "long": "The Audio File Out CHOP saves an audio stream out to a file using a variety of different codecs.\n    \nCurrently supports '''.wav''', '''.mp3''', '''.aiff''', and '''.ogg''' container formats.\n    \nSee also: [[Movie File Out TOP]].",
        "opCategories": ""
    },
    "audiofilterCHOP": {
        "label": "audiofilterCHOP",
        "members": [
            {
                "text": "Menu : The filter type:",
                "type": "MenuPar",
                "name": "filter",
                "items": []
            },
            {
                "text": "Menu : The filter cutoff frequency can be expressed in Hz (menu set to Frequency) or power-of-10 (menu set to Logarithmic). It enables one of the next 2 Filter Cutoff parameters.",
                "type": "MenuPar",
                "name": "units",
                "items": []
            },
            {
                "text": "Float : The filter cutoff frequency expressed in power-of-10, where value 0 translates to 1 Hz (10**0), value 1 is 10 Hz (10**1), value 2 is 100 Hz (10**2), value 3 is 1000 Hz, value 4 is 10,000 Hz, value 4.5 is 31,623 Hz. The parameter in this form gives more meaningful range in relation to human hearing, as increasing the parameter by 1 raises the frequency by about 3 octaves.",
                "type": "FloatPar",
                "name": "cutofflog",
                "items": []
            },
            {
                "text": "Float : The filter cutoff frequency expressed in Hz (cycles per second). This parameter set to 1000 has exactly the same effect as the above parameter set to 3.",
                "type": "FloatPar",
                "name": "cutofffrequency",
                "items": []
            },
            {
                "text": "Float : Increasing the resonance will boost the loudness of the passed frequencies near the cutoff frequency.",
                "type": "FloatPar",
                "name": "resonance",
                "items": []
            },
            {
                "text": "Float : Rolloff determines how much the levels decrease near the cutoff frequency. This parameter will make it decrease by 12 [http://en.wikipedia.org/wiki/Decibel decibels] (dB) per octave, to, more extremely, 24 decibels per octave. 12 and 24 decibels correspond to levels of about 1/4 and 1/16.",
                "type": "FloatPar",
                "name": "rolloff",
                "items": []
            },
            {
                "text": "Float : As this parameter is reduced from 1 (Wet) toward 0 (Dry), it removes the effect of the filter.",
                "type": "FloatPar",
                "name": "drywet",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Filter CHOP removes low frequencies, high frequencies, both low and high, or removes a mid-frequency range.",
        "opClass": "audiofilterCHOP_Class",
        "opFilter": "True",
        "long": "The Audio Filter CHOP removes low frequencies, high frequencies, both low and high, or removes a mid-frequency range. \t\t\n\t\t\t\nA Low pass filter removes the higher frequencies of a sound, while a high pass filter reduces the bass of the sound. A band pass filter is used to extract a frequency range (i.e. extracting a person's voice from background noise) and a band reject filter is used to cut out a frequency range.\t\t\t\n\t\t\t\nIf a certain frequency lies outside the pass band, sounds at that frequency will be reduced in magnitude. The farther outside the pass band the frequency is, the more it will be reduced.\t\t\t\n\t\t\t\nThe Cutoff frequency is also known as the \"half-power\" frequency. A wave at the cutoff frequency will be reduced to half power.\t\t\t\n\t\t\t\nThe Rolloff of a filter determines how quickly the drop occurs at its Cutoff frequencies. A low rolloff will produce a gradual filter falloff (more of the sounds outside the frequency range are heard), and a high rolloff will produce a sharp filter falloff.\t\t\t\n\t\t\t\nRefer to [http://en.wikipedia.org/wiki/Audio_filter audio filter] for more insight.\t\t\t\n\t\t\t\nYou can see the effects of the Audio Filter CHOP by passing it white noise from an Oscillator CHOP and sending the result to an Audio Spectrum CHOP. The Audio Filter CHOP is implemented with a 4-pole filter internally.\t\t\t\n\t\t\t\nMoving the Dry / Wet parameter to Dry will bring back the incoming signal un-affected.\t\t\t\n\t\t\t\nInput 2: See [[Audio_Filter_CHOP#Cutoff_Modulation_Channels_Input| Cutoff Modulation Channels]]\t\t\t\n\t\t\t\nSee [[Audio Para EQ CHOP]], [[Audio Band EQ CHOP]], [[Audio Spectrum CHOP]], [[Audio Dynamics CHOP]]",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiofilter",
        "opLabel": "Audio Filter",
        "opCategories": ""
    },
    "audiomovieCHOP": {
        "label": "audiomovieCHOP",
        "members": [
            {
                "text": "Toggle : Audio playback is enabled when this is set to On. No audio output when Off.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "TOP : Put the path of a Movie File In TOP in this parameter. The file named in the Movie File In TOP will be the source for the audio.",
                "type": "TOPPar",
                "name": "moviefileintop",
                "items": []
            },
            {
                "text": "Float : Use to read-ahead the audio into cache. You can specify in samples, frames and in seconds using the Units menu.",
                "type": "FloatPar",
                "name": "prereadlength",
                "items": []
            },
            {
                "text": "Menu : Specify which units to use for the Pre-Read Length parameter.",
                "type": "MenuPar",
                "name": "prereadlengthunit",
                "items": []
            },
            {
                "text": "Float : The amount of time TouchDesigner will wait for the audio samples to be read from the movie file. On file opening, if this timeout period is reached and the read-ahead has not finished, the audio will be output as zeros until all the pre-read samples have been read from the file.",
                "type": "FloatPar",
                "name": "opentimeout",
                "items": []
            },
            {
                "text": "Float : Offsets the audio playback of the movie. This can be used to get better sync between the audio and images in the movie when there is audio latency in the system (For example, audio latency from the [[Audio Device Out CHOP]] queue). A negative value plays audio that amount of time sooner, to counteract delay introduced by buffering such as in [[Audio Device Out CHOP]].",
                "type": "FloatPar",
                "name": "syncoffset",
                "items": []
            },
            {
                "text": "Menu : Specify which units to use for the Audio Sync Offset parameter.",
                "type": "MenuPar",
                "name": "syncoffsetunit",
                "items": []
            },
            {
                "text": "Toggle : Turn this parameter On to output an additional channel which reports the current position in the movie ie. 0 = start, 1 = end.",
                "type": "TogglePar",
                "name": "index",
                "items": []
            },
            {
                "text": "Int : When the movie has multiple audio tracks available this parameter can select between them.",
                "type": "IntPar",
                "name": "audiotrack",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Movie CHOP plays the audio of a movie file that is played back with a [[Movie File In TOP]].",
        "opClass": "audiomovieCHOP_Class",
        "opFilter": "False",
        "long": "The Audio Movie CHOP plays the audio of a movie file that is played back with a [[Movie File In TOP]]. Use the Movie File In TOP parameter to specify which Movie File In TOP to get the audio signal from.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiomovie",
        "opLabel": "Audio Movie",
        "opCategories": ""
    },
    "audiondiCHOP": {
        "label": "audiondiCHOP",
        "members": [
            {
                "text": "toggle : When 'On' the audio will playback, when 'Off' the channels will not output an audio signal.",
                "type": "togglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "topref : Specify which [[NDI In TOP]]'s NDI stream to get the audio from.",
                "type": "toprefPar",
                "name": "ndiintop",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "audiondiCHOP",
        "opLabel": "Audio NDI",
        "opClass": "audiondiCHOP_Class",
        "opFilter": "False",
        "short": "Gets audio from an [[NDI]] stream.",
        "long": "Retrieves the audio from a [[NDI In TOP]]'s NDI stream. The audio signal can then be modified or output via CHOPs.  See [[NDI]].",
        "opLicense": "",
        "opCategories": ""
    },
    "audiooscillatorCHOP": {
        "label": "audiooscillatorCHOP",
        "members": [
            {
                "text": "Menu : The shape of the waveform to repeat, unless overridden by the Playback Source:",
                "type": "MenuPar",
                "name": "wavetype",
                "items": []
            },
            {
                "text": "Float : The cycles per second when the Pitch Control is zero.",
                "type": "FloatPar",
                "name": "frequency",
                "items": []
            },
            {
                "text": "Float : Amount that the Pitch Control needs to increase by to raise the pitch by one octave. The default of 1 means that Pitch Control of 1 raises the pitch by 1 octave. Units per Octave of .08333 means that a Pitch Control of 3 raises the pitch by a factor of 3 x .08333 (three semitones). This is suitable for using MIDI note numbers as pitch control.",
                "type": "FloatPar",
                "name": "octave",
                "items": []
            },
            {
                "text": "Float : Values output from the CHOP can have an offset added to them.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Float : Values output from the CHOP can be scaled.",
                "type": "FloatPar",
                "name": "amp",
                "items": []
            },
            {
                "text": "Float : Shape control for Triangle, Gaussian and Square waves. For triangle waves, it moves the peak. For square waves, it alters the width of the peak. Zero means no bias.",
                "type": "FloatPar",
                "name": "bias",
                "items": []
            },
            {
                "text": "Float : A value of .5 is a phase shift of 180 degrees, or one half cycle.",
                "type": "FloatPar",
                "name": "phase",
                "items": []
            },
            {
                "text": "Toggle : If the Pitch Control channel input to the Audio Oscillator CHOP is rising and is running at the Touch default of 60 frames per second, then the pitch will hold for 1/60 second before stepping up for another 1/60 second. This is an audible step. With this option On, the pitch rises for every audio sample, giving perfectly smooth glissando at extra compute cost.",
                "type": "TogglePar",
                "name": "smooth",
                "items": []
            },
            {
                "text": "Menu : This menu determines how the Reset input triggers a reset of the channel(s).",
                "type": "MenuPar",
                "name": "resetcondition",
                "items": []
            },
            {
                "text": "Toggle : This button resets the channel(s) to 0 when On.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly resets the channel(s) to 0.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "Float : Set the sample rate of the CHOP in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Oscillator CHOP generates sounds in three ways.",
        "opClass": "audiooscillatorCHOP_Class",
        "opFilter": "False",
        "long": "The Audio Oscillator CHOP generates sounds in three ways. It repeats common waveforms (sine, triangle), it generates white noise (a random number for each sample), or it repeats a prepared incoming audio clip of any duration. It outputs typically 44100 samples per second. In contrast, the [[LFO CHOP]] by default generates waves at lower frequencies and lower sample rates (60 samples/second), however both Audio Oscillator and LFO are interchangeable by changing their frequencies and sample rates.\t\t\n\t\t\t\nWhen it is synthesizing tones from the basic waveforms, the Audio Oscillator CHOP steps through the waveform at a rate that depends on the Pitch Control input. By default, a Pitch Control of 0 gives a middle A at 440 Hz; a 1 gives 880 Hz; a -1 gives 220 Hz. Steps of 1 in Pitch Control are 1 octave apart. Steps of 1/12 (.08333) are 1 semitone apart.\t\n\nThe Audio Oscillator is roughly modelled after the [https://www.google.com/search?q=ARP+2600+Oscillator+design&oq=ARP+2600+Oscillator+design APR 2600 voltage-controlled oscillator] (VCO).\n\t\t\t\nUp to three input CHOPs can be connected to the Audio Oscillator CHOP.\t\t\t\n\t\t\t\n'''Pitch Control''' - The first (optional) input affects the pitch. Output channels are generated for each Pitch Control channel. When pitch control is 0, it outputs a wave at the base frequency (default 440 Hz at 44,100 samples per second). It is \"logarithmic\": By default, increasing the pitch control by 1 increases the pitch by 1 octave, by 2 it increases by 2 octaves (4 times the frequency).\t\t\t\n\t\t\t\n'''Reset Pulse''' - The second (optional) input contains pulses that restart the oscillator from the beginning of the wave or the Playback Source. 0 in the input means \"play the oscillator\". 1 means \"stop the oscillator and cue it at the start of the waveform or Playback Source\".\t\t\t\n\t\t\t\n'''Playback Source''' - The third (optional) input is a replacement of the waveform Type. It is a sound clip to play at a rate modified by the Pitch Control, and can contain any number of channels. These channels are generated for each Pitch Control channel. The waveform Type and the Base Frequency parameters are disabled.\t\t\t\n\t\t\t\nIf you plug any sound clip into the Audio Oscillator CHOP's Playback Source, and Pitch Control is a constant value of 0 of any duration, it will just repeat the Playback Source. If you feed a [[Wave CHOP]] as its Pitch Control, it will raise and lower the speed/pitch of the input.\t\t\t\n\t\t\t\nThe Audio Oscillator CHOP can serve as a general motion time-warper and repeater. If you put motion channels into the third input, you can control the time warp by feeding different Pitch Control curves. 0 pitch is normal speed, 1 is double speed.\t\t\t\n\t\t\t\nUnlike the Wave CHOP, this is an iterating CHOP, that is, it steps through the waveform while the pitch changes. To see this effect, feed an LFO CHOP into the Audio Oscillator. Unlike the LFO CHOP, the Audio Oscillator CHOP is designed for audio frequencies.\t\t\t\n\t\t\t\nSee also: [[LFO CHOP]], [[Wave CHOP]].",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audioosci",
        "opLabel": "Audio Oscillator",
        "opCategories": ""
    },
    "audioparaeqCHOP": {
        "label": "audioparaeqCHOP",
        "members": [
            {
                "text": "Menu : How frequency is expressed:",
                "type": "MenuPar",
                "name": "units",
                "items": []
            },
            {
                "text": "Toggle : When off, it passes the sound through the first equalizer unchanged.",
                "type": "TogglePar",
                "name": "enableeq1",
                "items": []
            },
            {
                "text": "Float : When boost is greater than 0, it will make louder the audio around the center frequency. When boost is less than 0, it will make the audio quieter around the center frequency. Boost is in decibels (dB) where 0 dB has no effect.",
                "type": "FloatPar",
                "name": "boost1",
                "items": []
            },
            {
                "text": "Float : The frequency is expressed in power-of-10, where value 0 translates to 1 Hz (10**0), value 1 is 10 Hz (10**1), value 2 is 100 Hz (10**2), value 3 is 1000 Hz, value 4 is 10,000 Hz, value 4.5 is 31,623 Hz. The parameter in this form gives more meaningful range in relation to human hearing, as increasing the parameter by 1 raises the frequency by about 3 octaves.",
                "type": "FloatPar",
                "name": "frequencylog1",
                "items": []
            },
            {
                "text": "Float : The filter frequency is expressed in Hz (cycles per second). This parameter set to 1000 has exactly the same effect as the above parameter set to 3.",
                "type": "FloatPar",
                "name": "frequencyhz1",
                "items": []
            },
            {
                "text": "Float : Bandwidth determines how much the levels decrease near the center frequency, expressed in octaves.",
                "type": "FloatPar",
                "name": "bandwidth1",
                "items": []
            },
            {
                "text": "Toggle : When off, it passes the sound through the second equalizer unchanged.",
                "type": "TogglePar",
                "name": "enableeq2",
                "items": []
            },
            {
                "text": "Float : When boost is greater than 0, it will make louder the audio around the center frequency. When boost is less than 0, it will make the audio quieter around the center frequency. Boost is in decibels (dB) where 0 dB has no effect.",
                "type": "FloatPar",
                "name": "boost2",
                "items": []
            },
            {
                "text": "Float : The frequency is expressed in power-of-10, where value 0 translates to 1 Hz (10**0), value 1 is 10 Hz (10**1), value 2 is 100 Hz (10**2), value 3 is 1000 Hz, value 4 is 10,000 Hz, value 4.5 is 31,623 Hz. The parameter in this form gives more meaningful range in relation to human hearing, as increasing the parameter by 1 raises the frequency by about 3 octaves.",
                "type": "FloatPar",
                "name": "frequencylog2",
                "items": []
            },
            {
                "text": "Float : The filter frequency is expressed in Hz (cycles per second). This parameter set to 1000 has exactly the same effect as the above parameter set to 3.",
                "type": "FloatPar",
                "name": "frequencyhz2",
                "items": []
            },
            {
                "text": "Float : Bandwidth determines how much the levels decrease near the center frequency, expressed in octaves.",
                "type": "FloatPar",
                "name": "bandwidth2",
                "items": []
            },
            {
                "text": "Toggle : When off, it passes the sound through the third equalizer unchanged.",
                "type": "TogglePar",
                "name": "enableeq3",
                "items": []
            },
            {
                "text": "Float : When boost is greater than 0, it will make louder the audio around the center frequency. When boost is less than 0, it will make the audio quieter around the center frequency. Boost is in decibels (dB) where 0 dB has no effect.",
                "type": "FloatPar",
                "name": "boost3",
                "items": []
            },
            {
                "text": "Float : The frequency is expressed in power-of-10, where value 0 translates to 1 Hz (10**0), value 1 is 10 Hz (10**1), value 2 is 100 Hz (10**2), value 3 is 1000 Hz, value 4 is 10,000 Hz, value 4.5 is 31,623 Hz. The parameter in this form gives more meaningful range in relation to human hearing, as increasing the parameter by 1 raises the frequency by about 3 octaves.",
                "type": "FloatPar",
                "name": "frequencylog3",
                "items": []
            },
            {
                "text": "Float : The filter frequency is expressed in Hz (cycles per second). This parameter set to 1000 has exactly the same effect as the above parameter set to 3.",
                "type": "FloatPar",
                "name": "frequencyhz3",
                "items": []
            },
            {
                "text": "Float : Bandwidth determines how much the levels decrease near the center frequency, expressed in octaves.",
                "type": "FloatPar",
                "name": "bandwidth3",
                "items": []
            },
            {
                "text": "Float : As this parameter is reduced from 1 (Wet) toward 0 (Dry), it removes the effect of the filter.",
                "type": "FloatPar",
                "name": "drywet",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Para EQ CHOP (parametric [http://en.wikipedia.org/wiki/Equalization_(audio) equalizer]) applies up to 3 parametric filters to the incoming sound.",
        "opClass": "audioparaeqCHOP_Class",
        "opFilter": "True",
        "long": "The Audio Para EQ CHOP (parametric [http://en.wikipedia.org/wiki/Equalization_(audio) equalizer]) applies up to 3 parametric filters to the incoming sound. The three filters are in series, where internally, the second filter takes its input from the output of the first filter, and so on.\t\t\n\t\t\t\nIt is called parametric because each filter has 3 controls - center frequency, bandwidth and boost, which in the old days, was more than usual analog filters.\t\t\t\n\t\t\t\nEach filter has a center frequency (the Frequency parameter) where the filter will have the most effect, and a bandwidth which is roughly expressed in octaves, and is typically 3 or 4. The Boost parameter, when it is greater than 0, will make louder the audio around the center frequency. When boost is less than 0, it will make the audio quieter around the center frequency. Boost is in decibels (dB) where 0 dB has no effect.\t\t\t\n\t\t\t\nYou can best hear the effects of the Audio Para EQ CHOP by passing it rich-spectrum music. The Audio Para EQ CHOP is implemented with three 4-pole filters internally.\t\t\t\n\t\t\t\nInput 2-4: See [[Audio_Para_EQ_CHOP#Frequency_Modulation_Channels_Input|Frequency Modulation Channels]], and the Scope parameter.\t\t\t\n\t\t\t\nThe Audio Para EQ CHOP is implemented as three 4-pole filters in series.\t\t\t\n\t\t\t\nSee [[Audio Filter CHOP]], [[Audio Band EQ CHOP]], [[Audio Spectrum CHOP]], [[Audio Dynamics CHOP]]",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiopara",
        "opLabel": "Audio Para EQ",
        "opCategories": ""
    },
    "audioplayCHOP": {
        "label": "audioplayCHOP",
        "members": [
            {
                "text": "StrMenu : A menu of available audio devices to output to. Selecting ''default'' sets the audio device to that which is selected in Windows Control Panel&gt;Sound&gt;Playback.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "StrMenu : ",
                "type": "StrMenuPar",
                "name": "outputs",
                "items": []
            },
            {
                "text": "File : <code>.aif</code>, <code>.mp3</code>, <code>.mid</code>, <code>.wav</code> or <code>.m4a</code> audio file. The file can be mono or stereo.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "DAT : Links to a [[Table DAT]] which can be used as list of audio files to choose from. When using the <span class=\"tipTextCHOP\">DAT List</span>, the first input (Input 0: Triggers) on the CHOP can contain mulitiple channels to fire the files in the list individually. Using the <code>audioplay</code> command the index can be specified directly.",
                "type": "DATPar",
                "name": "datlist",
                "items": []
            },
            {
                "text": "Float : 0 = mute, 1 = full volume. Using the second input (Input 1: Volume) or the python <code>.play(volume=''val'')</code> method, will override the value of this parameter.",
                "type": "FloatPar",
                "name": "volume",
                "items": []
            },
            {
                "text": "Menu : Determines how the audio is triggered when using the first input to trigger.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Pulse : Triggers the audio to play.",
                "type": "PulsePar",
                "name": "trigger",
                "items": []
            },
            {
                "text": "Toggle : Forces CHOP to cook every frame.",
                "type": "TogglePar",
                "name": "cookalways",
                "items": []
            },
            {
                "text": "Toggle : Sets output to just 2 channels, front left and front right. \t\n\t\t\t\nOutputs - The outputs on this page and the following <span class=\"tipTextCHOP\">Output 2</span> page are for routing to an audio device's different speaker outputs. Not all devices will support all outputs. For each speaker output, you can route any of the file's channels to play through it. For example, you can easily output the front left channel of the file to the all the front left speaker outputs, or you could output the front left channel to both front and rear speaker outputs. The value of each output parameter determines which channel from the file it plays, see below.\t\t\t\n\t\t\t\n'''File's channel mapping for outputs'''\n<!--TDitemStart-->* -1 - no audio plays through this output<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* 0 - File's front left channel will play<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* 1 - File's front right channel will play<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* 2 - File's rear left channel will play<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* 3 - File's rear right channel will play<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* 4 - File's center channel will play<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* 5 - File's sub or low frequency channel will play<!--TDitemEnd-->\t\t\t\n\t\t\t\nThe following speaker outputs are found on this parameter page.",
                "type": "TogglePar",
                "name": "stereo",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "frontleft",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "frontright",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "frontcenter",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "lowfrequency",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "backleft",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "backright",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "frontleftcenter",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "frontrightcenter",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "backcenter",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "sideleft",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "sideright",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "topcenter",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "topfrontleft",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "topfrontcenter",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "topfrontright",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "topbackleft",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "topbackcenter",
                "items": []
            },
            {
                "text": "Int : Play audio on this output based on mapping table above.",
                "type": "IntPar",
                "name": "topbackright",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Play CHOP plays back a sound file through any attached audio output device using DirectSound.",
        "opClass": "audioplayCHOP_Class",
        "opFilter": "False",
        "long": "The Audio Play CHOP plays back a sound file through any attached audio output device using DirectSound. It supports <code>.aif</code>, <code>.mp3</code>, <code>.mid</code>, <code>.wav</code> and <code>.m4a</code> files up to 48.000 kHz, which can have mono, stereo or even up to 5.1 channels in them. The audio channels can then be routed to any speaker location that DirectSound uses. See Outputs section below.\t\t\n\t\t\t\n'''NOTE''': With the Audio Play CHOP, audio samples do not enter or pass through TouchDesigner, so you will not see them in CHOPs, and you cannot process them in CHOPs. The Audio Play CHOP starts an external process that opens the file and sends it directly to the the audio outputs of your computer. If you want to process the audio within TouchDesigner or output them into a [[Movie File Out TOP]] or [[Audio Device Out CHOP]], use the [[Audio File In CHOP]].\t\t\t\n\t\t\t\nThe Audio Play CHOP contains a channel called ''state''.  This channel is 1 whenever any file is being played, 0 otherwise.\t\t\t\n\t\t\t\nThe first input (Input 0:Triggers) is used to trigger the audio file to play. The second input (Input 1: Volume) can be used to control volume, if no input is connected the <span class=\"tipTextCHOP\">Volume</span> parameter will be used. The third input (Input 2: Pan) is for panning, no input assumes it is centered. When using the <span class=\"tipTextCHOP\">DAT List</span> parameter, the inputs can contain mulitiple channels to manipulate each file individually. Multiple Audio Play CHOPs can output to different devices simutaneously.\t\t\t\n\t\t\t\nIt can also be triggered by the <span class=\"tipTextCHOP\">Trigger</span> parameter below, but in this case if multiple files are specified via the DAT List, then all files will be played at the same time when triggered.\t\t\t\n\t\t\t\nSound files can also be triggered through the <code>play()</code> method [[audioplayCHOP_Class]]. Some advanced options are only available through the [[audioplayCHOP_Class]].\t\t\t\n\t\t\t\nThe file can be read in from disk or from the web. Use <code>http://</code> when specifying a URL.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audioplay",
        "opLabel": "Audio Play",
        "opCategories": ""
    },
    "audiorenderCHOP": {
        "label": "audiorenderCHOP",
        "members": [
            {
                "text": "Toggle : Turns the Audio Render on or off.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Object : A COMP that represents the listener. Must be a COMP that contains transform data, such as a Geometry or Camera COMP.",
                "type": "ObjectPar",
                "name": "listenerobject",
                "items": []
            },
            {
                "text": "Object : A COMP that represents the source of the sound. Must be a COMP that contains transform data, such as a Geometry or Camera COMP.",
                "type": "ObjectPar",
                "name": "sourceobject",
                "items": []
            },
            {
                "text": "Menu : The output format of the audio: Binaural, Stereo, Quadraphonic Surround, 5.1 Surround, 7.1 Surround, Custom Setup, or Ambisonics (AmbiX). Ambisonics is a format for encoding three-dimensional 360 degree audio. The Ambisonics format used in the Audio Render CHOP is the 3rd order SN3D format consisting of 16 encoded channels (WXYZ, RSTUV, KLMNOPQ) that define the sphere of sound. Custom Setup requires use of the Mapping Table.",
                "type": "MenuPar",
                "name": "outputformat",
                "items": []
            },
            {
                "text": "Toggle : Attenuate the sound based on relative distance.",
                "type": "TogglePar",
                "name": "attenuation",
                "items": []
            },
            {
                "text": "DAT : A DAT Table that specifies the various speakers in the setup and their position. The Table must have 3 columns named <code>x</code>, <code>y</code>, <code>z</code>. Each row specifies an individual speaker, and the 3 columns specify its position. Used with the Custom Setup Output Format. The mapping table will create one channel per row.",
                "type": "DATPar",
                "name": "mappingtable",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "audiorender",
        "opLabel": "Audio Render",
        "opLicense": "Non-Commercial",
        "opClass": "audiorenderCHOP_Class",
        "opFilter": "True",
        "short": "The Audio Render CHOP uses the Steam Audio SDK to spatially render audio based on the full transforms of a listener and an audio source.",
        "long": "The Audio Render CHOP uses the Steam Audio SDK to spatially render audio based on the full transforms (translation, rotation, scale) of a listener and an audio source. The Audio Render CHOP takes a mono sound audio source as input, and spatially outputs the sound in the format specified from the Output Format parameter. The number of channels outputted by the Audio Render CHOP depends on the Output Format. \n\nYou specify a 3D component for the transform of the listener, plus a 3D component for the transform of a source.\n\nThe sample rate of the output is determined by the audio source, which must be either 44100 or 48000.\n\nLook at the Audio Render CHOP example in Help -> Operator Snippets.\n\nSee also [[Oculus Audio CHOP]].",
        "opCategories": ""
    },
    "audiospectrumCHOP": {
        "label": "audiospectrumCHOP",
        "members": [
            {
                "text": "Menu : Select which mode to use, modes described below.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Menu : Converting to frequency needs a power-of-2 number of samples, like 512, 1024, 2048. (FFT means Fast [http://en.wikipedia.org/wiki/Joseph_Fourier Fourier] Transform.) The more samples, the more accurate the spectrum but the more it doesn't represent the most recent sound. Whatever the size, the CHOP uses the most recent samples. Knowing that audio at 44100 samples per second with a timeline frame rate of 60 frames per second gives 735 samples per frame, if the CHOP cooks 1 frame later and the FFT size is 1024, then it will re-use 1024-735 = 289 samples, which is good as there's a little overlap. However if it cooks 2 frames later, it will miss using 446 frames since it will have advanced 735*2=1470 samples and it will only use 1024 of them.",
                "type": "MenuPar",
                "name": "fftsize",
                "items": []
            },
            {
                "text": "Float : Logarithmic (=1) is more tangible for human hearing. Each octave is represented with the same number of samples, so low frequencies are more readable. Frequency (=0) shows one sample for a fixed number of Hz, which is what the raw FFT gives, but most of the upper samples are uninteresting. Your ears hear ranges of octaves better.  '''IMPORTANT NOTE''': If Mode is set to Visualization and this parameter is set to 0, the output data is interpreted more simply: '''1 sample per Hz'''. Set the CHOP viewer Units to Samples (via RMB on CHOP graph) and the level you see at sample 5000 is the level at 5 KHz.",
                "type": "FloatPar",
                "name": "frequencylog",
                "items": []
            },
            {
                "text": "Float : When 0, the levels are not changed. When greater than 1, the levels are boosted, mostly at the high frequencies. High Frequency Boost can be over-driven past 1.",
                "type": "FloatPar",
                "name": "highfreqboost",
                "items": []
            },
            {
                "text": "Menu : The method how output length will be determined.",
                "type": "MenuPar",
                "name": "outputmenu",
                "items": []
            },
            {
                "text": "Int : Number of Samples desired in output. The fewer the samples, the less the frequency resolution.",
                "type": "IntPar",
                "name": "outlength",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Spectrum CHOP calculates and displays the frequency spectrum of the input channels.",
        "opClass": "audiospectrumCHOP_Class",
        "opFilter": "True",
        "long": "The Audio Spectrum CHOP calculates and displays the frequency spectrum of the input channels. \t\t\n\t\t\t\nIn the default Visualization Mode the CHOP is set to display the spectrum in a more understandable way by emphasizing the higher frequency levels and the lower frequency ranges.\t\t\t\n\t\t\t\nIn another Mode, the Time to Magnitude and Phase mode, the audio can be converted to the frequency spectrum domain, manipulated and then converted back to get a filtered audio signal. When converting a signal to its spectrum, two channels are created from the one containing the audio signal. One channel contains the magnitude of the frequency components, and the other contains the phase. The channels are named, for example <code>chan1_m</code> and <code>chan1_p</code> where <code>_m</code> and <code>_p</code> are the suffixes for the magnitude and phase channels.\t\t\t\n\t\t\t\n'''Tip''':  You can reduce cook time if you decrease the FFT Size from its default 8192 samples. The fastest form of this CHOP is by setting the Output Length parameter to \"Output Length Manually\". For example set the output buffer size to 2048 samples and the FFT Size to 2048. Each time it cooks, the CHOP is looking at the latest 2028 samples (at 44.1 KHz that amounts to the 50 msec, or 3 frames), which is plenty. Note the default form of the CHOP gives you 22,000 samples: 1 Hz to 22,050 Hz in steps of 1 Hz (when set to Frequency vs Logarithmic scaling), designed for clear interpretation: sample 1000 is the level of audio at 1000 Hz.\t\n\n'''Tip''':  To find the exact frequency of a wave entering the Audio Spectrum CHOP, look at the Info pop-up for that node (MMB on the node). It says:  Set \"Frequency <-> Logarithmic Scaling\" to 0, then multiply any sample to xxxx to get the Frequency at that sample.  xxxx depends on the sample rates etc and isn't a constant.\n\t\t\t\nSee [[Audio Filter CHOP]], [[Audio Para EQ CHOP]], [[Audio Band EQ CHOP]], [[Audio Oscillator CHOP]] set to White Noise.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiospect",
        "opLabel": "Audio Spectrum",
        "opCategories": ""
    },
    "audiostreaminCHOP": {
        "label": "audiostreaminCHOP",
        "members": [
            {
                "text": "Menu : Select the source type: either from a server URL, or a WebRTC peer.",
                "type": "MenuPar",
                "name": "srctype",
                "items": []
            },
            {
                "text": "Str : The URL address of the stream. E.g rtsp://localhost:554/tdaudio",
                "type": "StrPar",
                "name": "url",
                "items": []
            },
            {
                "text": "TOP : Point to a [[Video Stream In TOP]] whose stream has audio embedded to extract the audio channels.",
                "type": "TOPPar",
                "name": "videostreamintop",
                "items": []
            },
            {
                "text": "Float : Turns the audio streaming on (1) or off (0).",
                "type": "FloatPar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : The time (in milliseconds) TouchDesigner will wait attempting to open the audio stream.",
                "type": "FloatPar",
                "name": "opentimeout",
                "items": []
            },
            {
                "text": "Float : Offsets the audio playback of the movie. This can be used to get better sync between the audio and images in the stream when there is audio latency in the system (For example, audio latency from the [[Audio Device Out CHOP]] queue). A negative value plays audio that amount of time sooner, to counteract delay introduced by buffering such as in [[Audio Device Out CHOP]].",
                "type": "FloatPar",
                "name": "syncoffset",
                "items": []
            },
            {
                "text": "Menu : Specify which units to use for the Audio Sync Offset parameter.",
                "type": "MenuPar",
                "name": "syncoffsetunit",
                "items": []
            },
            {
                "text": "Float : 0 = mute, 1 = full volume.",
                "type": "FloatPar",
                "name": "volume",
                "items": []
            },
            {
                "text": "DAT : Set the [[WebRTC DAT]] (ie. peer) to get the audio stream from. Setting this will automatically populate the WebRTC Connection parameter menu with available connections.",
                "type": "DATPar",
                "name": "webrtc",
                "items": []
            },
            {
                "text": "StrMenu : Select the [[WebRTC]] peer-to-peer connection. Selecting this will automatically population the WebRTC Track parameter menu with available audio input tracks.",
                "type": "StrMenuPar",
                "name": "webrtcconnection",
                "items": []
            },
            {
                "text": "StrMenu : Select the audio input track that's a part of the WebRTC peer-to-peer connection.",
                "type": "StrMenuPar",
                "name": "webrtctrack",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Stream In CHOP can stream audio into TouchDesigner from any [http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol rtsp] server.",
        "opClass": "audiostreaminCHOP_Class",
        "opFilter": "False",
        "long": "The Audio Stream In CHOP can stream audio into TouchDesigner from any [http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol rtsp] server, or from a [[WebRTC]] peer.  See [[Video Stream In TOP]].",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiostrin",
        "opLabel": "Audio Stream In",
        "opCategories": ""
    },
    "audiostreamoutCHOP": {
        "label": "audiostreamoutCHOP",
        "members": [
            {
                "text": "Toggle : Toggle's the rtsp server on or off.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the stream out mode: either [[RTSP]] or [[WebRTC]].",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Int : Port number used to transmit the audio stream. This number is needed in the URL supplied to the client receiving the stream. See example in Summary at top.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Str : Name assigned to the stream. This stream name is needed in the URL supplied to the client receiving the stream. See example in Summary at top.",
                "type": "StrPar",
                "name": "streamname",
                "items": []
            },
            {
                "text": "DAT : Set the [[WebRTC DAT]] (ie. peer) to send the audio stream over. Setting this will automatically populate the WebRTC Connection parameter menu with available connections.",
                "type": "DATPar",
                "name": "webrtc",
                "items": []
            },
            {
                "text": "StrMenu : Select the [[WebRTC]] peer-to-peer connection. Selecting this will automatically population the WebRTC Track parameter menu with available audio output tracks.",
                "type": "StrMenuPar",
                "name": "webrtcconnection",
                "items": []
            },
            {
                "text": "StrMenu : Select the audio output track that's a part of the WebRTC peer-to-peer connection. The audio stream will be sent over this track.",
                "type": "StrMenuPar",
                "name": "webrtctrack",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Stream Out CHOP can stream audio out to any [http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol rtsp] client such as VideoLAN's VLC media player and Apple's Quicktime, or to a [[WebRTC]] peer.",
        "opClass": "audiostreamoutCHOP_Class",
        "opFilter": "True",
        "long": "The Audio Stream Out CHOP can stream audio out to any [http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol rtsp] client such as VideoLAN's VLC media player and Apple's Quicktime, or to a [[WebRTC]] peer.\n\t\t\nTo access the stream in one of these players, open a \"Network Stream\" or \"URL\" under the File menu.\t\t\n\t\t\n\t\t\nBelow is an example of a URL used to access the stream in a rtsp client.\t\t\n\t\t\n* IP Address = IP address of computer running TouchDesigner with the Audio Stream Out CHOP.\t\t\n* Port = number set in the Port parameter.\t\t\n* Stream Name = name given to stream in the Stream Name parameter.\t\t\nThe URL required is rtsp://<''IP address''>:<''Port''>/<''Stream Name''>",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiostrout",
        "opLabel": "Audio Stream Out",
        "opCategories": ""
    },
    "audiovstCHOP": {
        "label": "audiovstCHOP",
        "members": [
            {
                "text": "File : The path to the VST3 plugin. Default install location for VST3 plugins is <code>C:/Program Files/Common Files/VST3</code> on Windows and <code>/Library/Audio/Plug-Ins/VST3</code> on macOS.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Pulse : Reloads the VST3 plugin.",
                "type": "PulsePar",
                "name": "reloadpulse",
                "items": []
            },
            {
                "text": "Toggle : The plugin state (including preset value and other UI elements) is saved into the toe file and is restored on TouchDesigner start, if enabled. The toggle exists to provide a work-around to plugins that do not behave well (eg. crash) when their plugin state is set; the toggle should be disabled in those cases.",
                "type": "TogglePar",
                "name": "loadpluginstate",
                "items": []
            },
            {
                "text": "Float : Sets the sample rate of the VST3 plugin.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the plugin window will always be on top of other windows.",
                "type": "TogglePar",
                "name": "alwaysontop",
                "items": []
            },
            {
                "text": "Pulse : When pulsed, will open the plugin GUI in a separate window. Changing a parameter in the plugin GUI while the learn toggle is enabled will create the parameter on the Audio VST CHOP side.",
                "type": "PulsePar",
                "name": "displaygui",
                "items": []
            },
            {
                "text": "Toggle : When enabled, parameters that are interacted with in the VST Plugin window will be created as parameters on the Plugin page, ie. they will be learned.",
                "type": "TogglePar",
                "name": "learnparms",
                "items": []
            },
            {
                "text": "Toggle : When enabled, every Plugin parameter will be created on the Plugin page.",
                "type": "TogglePar",
                "name": "regularparms",
                "items": []
            },
            {
                "text": "Toggle : When enabled, all read-only Plugin parameters will be created on the Plugin page. If Regular Parameters is also toggled on then this toggle will have no effect.",
                "type": "TogglePar",
                "name": "readonlyparms",
                "items": []
            },
            {
                "text": "Pulse : When pulsed, all learned parameters will be cleared. If neither Regular or Read-only parameters are toggled on then the parameters will be destroyed.",
                "type": "PulsePar",
                "name": "clearlearnedparms",
                "items": []
            },
            {
                "text": "DAT : Reference to the DAT containing Audio VST CHOP supported callbacks.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "File : The path to the VST3 plugin. Default install location for VST3 plugins is <code>C:/Program Files/Common Files/VST3</code> on Windows and <code>/Library/Audio/Plug-Ins/VST3</code> on macOS.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Pulse : Reloads the VST3 plugin.",
                "type": "PulsePar",
                "name": "reloadpulse",
                "items": []
            },
            {
                "text": "Toggle : The plugin state (including preset value and other UI elements) is saved into the toe file and is restored on TouchDesigner start, if enabled. The toggle exists to provide a work-around to plugins that do not behave well (eg. crash) when their plugin state is set; the toggle should be disabled in those cases.",
                "type": "TogglePar",
                "name": "loadpluginstate",
                "items": []
            },
            {
                "text": "Float : Sets the sample rate of the VST3 plugin.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the plugin window will always be on top of other windows.",
                "type": "TogglePar",
                "name": "alwaysontop",
                "items": []
            },
            {
                "text": "Pulse : When pulsed, will open the plugin GUI in a separate window. Changing a parameter in the plugin GUI while the learn toggle is enabled will create the parameter on the Audio VST CHOP side.",
                "type": "PulsePar",
                "name": "displaygui",
                "items": []
            },
            {
                "text": "Toggle : When enabled, parameters that are interacted with in the VST Plugin window will be created as parameters on the Plugin page, ie. they will be learned.",
                "type": "TogglePar",
                "name": "learnparms",
                "items": []
            },
            {
                "text": "Toggle : When enabled, every Plugin parameter will be created on the Plugin page.",
                "type": "TogglePar",
                "name": "regularparms",
                "items": []
            },
            {
                "text": "Toggle : When enabled, all read-only Plugin parameters will be created on the Plugin page. If Regular Parameters is also toggled on then this toggle will have no effect.",
                "type": "TogglePar",
                "name": "readonlyparms",
                "items": []
            },
            {
                "text": "Pulse : When pulsed, all learned parameters will be cleared. If neither Regular or Read-only parameters are toggled on then the parameters will be destroyed.",
                "type": "PulsePar",
                "name": "clearlearnedparms",
                "items": []
            },
            {
                "text": "DAT : Reference to the DAT containing Audio VST CHOP supported callbacks.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Toggle : Enables custom bus layout. If disabled the bus layout will be the plugin's default.",
                "type": "TogglePar",
                "name": "custombuslayout",
                "items": []
            },
            {
                "text": "StrMenu : Select the output bus layout (ie. number of channels) of the output bus. This will directly affect how many channels the Audio VST CHOP has.",
                "type": "StrMenuPar",
                "name": "outputbuslayout",
                "items": []
            },
            {
                "text": "StrMenu : Select the main input bus layout (ie. number of channels). The main input bus is always the CHOP's first input, and this selection determines how many channels it accepts from it.",
                "type": "StrMenuPar",
                "name": "maininputlayout",
                "items": []
            },
            {
                "text": "Toggle : Enable the auxiliary bus.",
                "type": "TogglePar",
                "name": "enableauxinput0",
                "items": []
            },
            {
                "text": "StrMenu : Select the auxiliary bus layout (ie. number of channels) for the auxiliary input. An auxiliary input is every input after the main input. Not every plugin will support auxiliary buses, and the parameter will be disabled if not supported. If no more sequential auxiliary buses can be added (ie. the +/- disappears in the parameter sequence) then that means the auxiliary bus maximum has been reached.",
                "type": "StrMenuPar",
                "name": "auxinputlayout0",
                "items": []
            },
            {
                "text": "Toggle : Enable the custom playhead. When disabled, the plugin will always sequentially step forward in time. Not all plugins support a custom playhead.",
                "type": "TogglePar",
                "name": "customplayhead",
                "items": []
            },
            {
                "text": "Str : Specifies the playhead time of the plugin. A reference to either a CHOP with channels 'hour', 'second', 'minute', 'frame', a DAT with a timecode string in its first cell, or a [[Timecode Class]] object.",
                "type": "StrPar",
                "name": "timecodeop",
                "items": []
            },
            {
                "text": "Float : The tempo of the playhead. Not all plugins support changing of the tempo via the playhead.",
                "type": "FloatPar",
                "name": "tempo",
                "items": []
            },
            {
                "text": "Int : The time signature of the playhead. Not all plugins support changing of the time signature via the playhead.",
                "type": "IntPar",
                "name": "signature",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "audiovstCHOP",
        "opLabel": "Audio VST",
        "opClass": "audiovstCHOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "Loads VST3 Plugins.",
        "long": "The Audio VST CHOP loads VST3 Plugin files that generate (instruments) or process (filter) audio. See the [[VST]] overview.\n    \nThe plugin's parameters can be exposed and driven bi-directionally via a corresponding TouchDesigner parameter or the plugin's GUI control.  In order to get the full benefit of the bidirectional nature of the plugin parameters it is recommended to use [[Binding]] or a [[Bind CHOP]] when driving the parameter in TouchDesigner, rather than an expression or CHOP reference.\n\nPython calls let you [[AudiovstCHOP_Class|send MIDI messages]] to the plugin. And if the plugin generates MIDI, you can get and process the messages in the [[Docking|docked]] callbacks DAT.\n\nDepending on the plugin, the Audio VST CHOP takes up to 4 multi-channel inputs.\n    \nSee the discussion on which VST plugins work well with TouchDesigner - [https://derivative.ca/community-post/vst-plugin-testing/65712 VST Plugin Testing]. Also for a selection of free VSTs along with a useful set of affordable upgraded versions go here: https://hy-plugins.com.\n\n2 Free HY-Plugins are included with TouchDesigner and can be found using the Help > Browse Samples menu. This will open a file browser to the TouchDesigner application Samples folder which contains a VST3 folder holding one synthesizer and filter plugin for both Windows and MacOS. The Windows VST3 plugin files can be distinguished by their included \"64 Bit\" string.\n\nInstalled VST plugins are found in <code>C:Program Files/Common Files/VST</code> on Windows, and be <code>/Library/Audio/Plug-Ins/VST3</code> on macOS.\n\n'''Tip''': You can get detailed info about the VST plugin by attaching an [[Info DAT]] to the CHOP.\n\n[[VST]] is a trademark of Steinberg Media Technologies GmbH, registered in Europe and other countries."
    },
    "audiowebrenderCHOP": {
        "label": "audiowebrenderCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Audio Web Render CHOP plays the audio of a web page in a [[Web Render TOP]].",
        "opClass": "audiowebrenderCHOP_Class",
        "opFilter": "False",
        "long": "The Audio Web Render CHOP plays the audio of a web page in a [[Web Render TOP]].\tIn the Web Render TOP you need to have the Audio Options menus set to Route to Audio Web Render CHOPs, as well as the Active parameter on.",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "opType": "audiowebrender",
        "opLabel": "Audio Web Render",
        "opCategories": ""
    },
    "beatCHOP": {
        "label": "beatCHOP",
        "members": [
            {
                "text": "OP : This node is used to specify the time settings referenced by the Beat CHOP. The time is defined by the Time COMP found at <code>timepath(\"''reference_node''\")</code>",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Toggle : Turn on this checkbox to use the [[Time Slice]] used by the Reference Node.",
                "type": "TogglePar",
                "name": "reftimeslice",
                "items": []
            },
            {
                "text": "Menu : Specifies the method used to playback the output.",
                "type": "MenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "Float : Number of beats it takes to generate one cycle of ramp.",
                "type": "FloatPar",
                "name": "period",
                "items": []
            },
            {
                "text": "Pulse : Use this drop down menu to select from some commonly used Period lengths.",
                "type": "PulsePar",
                "name": "setperiod",
                "items": []
            },
            {
                "text": "Int : The number of channels to create.",
                "type": "IntPar",
                "name": "multiples",
                "items": []
            },
            {
                "text": "Float : Delays all channels by this amount. 0 = no change, .5 means 50% of one period later.",
                "type": "FloatPar",
                "name": "shiftoffset",
                "items": []
            },
            {
                "text": "Float : When set to 1, and Multiples is 5, each ramp channel is 1/5 cycle later than the previous channel. When set to .1, the delay is 1/50 cycle. This is a way to stagger the channels.",
                "type": "FloatPar",
                "name": "shiftstep",
                "items": []
            },
            {
                "text": "Float : The amount that each ramp is randomly time-shifted relative to a perfect ramp.",
                "type": "FloatPar",
                "name": "randoffset",
                "items": []
            },
            {
                "text": "Float : Changing this generates a different set of random offsets.",
                "type": "FloatPar",
                "name": "randseed",
                "items": []
            },
            {
                "text": "Menu : This menu determines how the Reset input triggers a reset of the channel(s).",
                "type": "MenuPar",
                "name": "resetcondition",
                "items": []
            },
            {
                "text": "Float : Specifies which Bar the Beat CHOP will jump to when the Reset Condition is met. Beat values are derived from the fractional part of this value.",
                "type": "FloatPar",
                "name": "resetbarvalue",
                "items": []
            },
            {
                "text": "Toggle : When using the '''While On''' Reset Condition, Wait After Reset will hold the channels at zero until the next bar is started, after which the output will continue. When Wait After Reset is off, the channels will restart output as soon as the reset condition is done.",
                "type": "TogglePar",
                "name": "resetwait",
                "items": []
            },
            {
                "text": "Toggle : This button resets the ramps to zero when On. The ramp is also zero when the Beat CHOP's input is above 0.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly resets the ramps to zero.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "Toggle : Any Beat CHOP can now be made a \"global beat source\" by turning Update Global. A reference Beat CHOP is created at /local/master_beat (if it doesn't already exist) and all Beat CHOPs can synchronize to this by turning on Update Global. This means you require exactly one master Beat CHOP per toe. You can turn off its 'Update Global' flag when desired.  $MASTER_BEAT is set to whatever Beat CHOP has this option turned on.",
                "type": "TogglePar",
                "name": "updateglobal",
                "items": []
            },
            {
                "text": "Toggle : Outputs a 0-1 ramp each bar.",
                "type": "TogglePar",
                "name": "ramp",
                "items": []
            },
            {
                "text": "Toggle : Outputs a pulse each bar.",
                "type": "TogglePar",
                "name": "pulse",
                "items": []
            },
            {
                "text": "Toggle : Outputs a sine wave each bar.",
                "type": "TogglePar",
                "name": "sine",
                "items": []
            },
            {
                "text": "Toggle : Increases the count each bar.",
                "type": "TogglePar",
                "name": "count",
                "items": []
            },
            {
                "text": "Toggle : A ramp that counts up until the bar is reset.",
                "type": "TogglePar",
                "name": "countramp",
                "items": []
            },
            {
                "text": "Toggle : Output the current bar.",
                "type": "TogglePar",
                "name": "bar",
                "items": []
            },
            {
                "text": "Toggle : Output the current beat.",
                "type": "TogglePar",
                "name": "beat",
                "items": []
            },
            {
                "text": "Toggle : Output the current sixteenths.",
                "type": "TogglePar",
                "name": "sixteenths",
                "items": []
            },
            {
                "text": "Toggle : Outputs a 0-1 ramp each bar.",
                "type": "TogglePar",
                "name": "rampbar",
                "items": []
            },
            {
                "text": "Toggle : Outputs a 0-1 ramp each beat.",
                "type": "TogglePar",
                "name": "rampbeat",
                "items": []
            },
            {
                "text": "Toggle : Outputs the current BPM.",
                "type": "TogglePar",
                "name": "bpm",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Beat CHOP generates a variety of ramps, pulses and counters that are timed to the beats per minute and the sync as produced by the [[Beat Dialog]].\t\t\n\t\t\t\n* You can generate a ramp every 1/4 1/2 1 2 4 8 32 beats.\t\t\t\n* You can generate ramps of any other length, like 12 beats per bar (ramp) and fractional beats like 3.33 beats per ramp. \t\t\t\n* You can generate a set of channels, where each channel is delayed relative to the prior channel. This is useful, for example, for moving eight objects delayed by one beat each. \t\t\t\n* There also is a counter of how many ramps it has generated.\t\t\t\n* The Count+Ramp type generates a continuously-rising ramp equal to the number of cycles since the start.\t\n* If Play Mode is set to Local Sequential, it doesn't look at start/end of the timeline (i.e. doesn't reset when the timeline loops), so is more appropriate for long improvised playing.\n\t\t\t\nThe [[Beat Dialog]] is used to manually tap the beat to set the beats-per-minute (BPM). The Beat CHOP converts the BPM into a repeating ramp or pulse that keeps time with the music after you stop tapping.\t\t\n\nYou can set the global beats-per-minute with the python command:  <code>op('/local/time').tempo = 140</code>\n\t\t\t\nThe phase can be controlled with the Beat CHOP's Reset parameters. \n\nThe Beat CHOP's timing is defined by the [[Component Time]] of the Reference Node.  If the Reference Node parameter is left blank, then the time defined at the Beat CHOP's location is used. The default is in <code>/local/time</code>.\t\n\t\t\t\nSee also: [[Timeline CHOP]], [[Time COMP]].",
        "opLabel": "Beat",
        "opClass": "beatCHOP_Class",
        "opType": "beat",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Beat CHOP generates a variety of ramps, pulses and counters that are timed to the beats per minute and the sync produced by the [[Beat Dialog]] or the <code>beat</code> Command.",
        "opCategories": ""
    },
    "bindCHOP": {
        "label": "bindCHOP",
        "members": [
            {
                "text": "Menu : Match channels between inputs by name or index.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Toggle : When on a channel's value will not update until the changing input value crosses the current value.",
                "type": "TogglePar",
                "name": "pickup",
                "items": []
            },
            {
                "text": "DAT : When channel values change the callbacks DAT can be used to query where the change was initiated and then take further actions via python script.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "bindCHOP",
        "opLabel": "Bind",
        "opClass": "bindCHOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "Allows for binding of CHOP channels and parameters.",
        "long": "Allows for [[binding]] of CHOP channels and parameters. \n    \nWhen a parameter is bound to a channel in the Bind CHOP (via the [[Parameter_Mode|parameter modes]] Export or Bind), any change in the channel will update the parameter value, and vice versa any change to the parameter will update the channel value. \n    \nAdditionally, the Bind CHOP is a multi-input CHOP and will match input channels by Channel Number or Channel Name. It monitors the matched channels and updates the Bind CHOP's output channel to match whichever input changed most recently. When bound to a parameter (via Export mode or Bind mode) changes to any matched input or the bound parameter will update the channel's value.\n\nA 'Callbacks DAT' is available for querying where the change was initiated and then taking further actions via python script.\n\nThis workflow is useful for binding multiple inputs to a parameter. For example, one input channel might be coming from a [[MIDI]] input device, and another channel coming from an [[OSC]] input device, and you want them both to control a given parameter. The Bind CHOP's output channel which is bound to the parameter will update to stay in sync with the most recent change from either of the inputs or the parameter. See video demonstration below.\n\n{{#widget:YouTube|id=N5yIlpIfu-E|width=781|height=217}}\n\n===== Tutorial =====\nBasic Bind CHOP setup: https://youtu.be/bLi-xrCUt-c",
        "opCategories": ""
    },
    "blacktraxCHOP": {
        "label": "blacktraxCHOP",
        "members": [
            {
                "text": "Toggle : While on, the CHOP receives information sent to the network port. While Off, no updating occurs.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Int : The port that will accept packets.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Menu : The network protocol to use. Refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : When using Multicast, this is the address that will listen for packets.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : Sets the sample rate of this CHOP.",
                "type": "IntPar",
                "name": "samplerate",
                "items": []
            },
            {
                "text": "Menu : Specifies the format for the CHOP channels (ie. how many beacons to add). \"From Mapping Table\" adds one beacon to the CHOP for every row in the mapping table. \"From Max Beacons\" adds the number specified in the \"Max Beacons\" parameter.",
                "type": "MenuPar",
                "name": "outputformat",
                "items": []
            },
            {
                "text": "Int : Specifies how many beacons to add to the CHOP. Used with the \"From Max Beacons\" output format.",
                "type": "IntPar",
                "name": "maxbeacons",
                "items": []
            },
            {
                "text": "Toggle : When enabled, adds beacon translation and rotation channels.",
                "type": "TogglePar",
                "name": "centroid",
                "items": []
            },
            {
                "text": "Toggle : When enabled, adds beacon velocity channels.",
                "type": "TogglePar",
                "name": "velocity",
                "items": []
            },
            {
                "text": "Toggle : When enabled, adds beacon acceleration channels.",
                "type": "TogglePar",
                "name": "acceleration",
                "items": []
            },
            {
                "text": "Toggle : When enabled, adds position channels for each LED in the beacon.",
                "type": "TogglePar",
                "name": "leds",
                "items": []
            },
            {
                "text": "Toggle : Clears any stored beacons and removes any stale data while On.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly clears any stored beacons and removes any stale data.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "DAT : A DAT table that maps beacon IDs to CHOP channels (beacon0, beacon1, etc.). The first row will map to beacon0, second row to beacon1, etc. Beacon ID is a unique non-negative integer and is specified within BlackTrax applications.\n\nBelow is an example of a mapping table that is tracking 3 beacons with IDs 10, 11, and 12. In this example 10 is mapped to beacon0, 11 is mapped to beacon1, and 12 is mapped to beacon2.\n\n[[image:beacon_setup_example.jpg]]",
                "type": "DATPar",
                "name": "mappingtable",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "short": "The BlackTrax CHOP will provide motion tracking data from http://blacktrax.cast-soft.com.",
        "long": "The BlackTrax CHOP will provide motion tracking data from [http://blacktrax.cast-soft.com BlackTrax Motion Tracking Systems] is a vision-based real-time tracking system developed by [http://cast-soft.com/ CAST Software] that specializes in large-scale performances. BlackTrax Beacons (\"BTBeacons\") are attached to performers or rigid objects, and the BlackTrax system accurately tracks the Beacon's position, rotation, velocity, and acceleration.\n\nThe BlackTrax CHOP will accept tracking data from [http://blacktrax.cast-soft.com/ BlackTrax Motion Tracking Systems].  See [[BlackTrax]].\n\nThe BlackTrax CHOP works in conjunction with the BlackTrax system. BlackTrax tracks up to 85 BlackTrax Beacons and sends \ndata regarding their position, rotation, velocity, and acceleration to TouchDesigner inside [https://rttrp.github.io/RTTrP-Wiki/RTTrPM.html RTTrPM Packets]. Each Beacon can have up to 3 LEDs attached, which can also be independently tracked in TouchDesigner. Each Beacon will have an ID that is specified in BlackTrax software and that Beacon ID must be mapped correctly to CHOP channels in TouchDesigner using the Mapping Table. Alternatively if the IDs are incremental then the \"From Max Beacons\" option in \"Output Format\" can be used.\n\n=== Server Settings ===\t\t\t\nThe server software should be set to send data in the WYSIWYG coordinate system (which should be the default). Rotations should be sent in Euler angles, not Quaternions. TouchDesigner should support both endian settings, but it's best to leave those as their default values.\t\n\nSee also [[BlackTrax]], [[PosiStageNet CHOP]]",
        "opLabel": "BlackTrax",
        "opClass": "blacktraxCHOP_Class",
        "opType": "blacktrax",
        "opLicense": "Pro",
        "opFamily": "CHOP",
        "opCategories": ""
    },
    "blendCHOP": {
        "label": "blendCHOP",
        "members": [
            {
                "text": "Menu : The blend method:",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Toggle : When using the Differencing method, the weight channel for the base input has no effect, so the channel is omitted if this option is On.",
                "type": "TogglePar",
                "name": "firstweight",
                "items": []
            },
            {
                "text": "Toggle : Replace denormalized (very small) numerical values with 0. These values can otherwise cause performance issues.",
                "type": "TogglePar",
                "name": "underflow",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Blend CHOP combines two or more CHOPs in input 2, 3 and so on, by using a set of blending channels in input 1. The blending channels cause different strengths of the CHOPs to contribute to the output of the CHOP. It works like the [[Blend SOP]].\t\t\n\t\t\t\nThe first channel of input 2 is blended with the first channel of input 3 and input 4 and so on.\t\t\t\n\t\t\t\nInput 1 acts as the control input, which contains the blend weight channels for the rest of the inputs. In it there is one channel for each of the blended CHOPs coming in on input 2, 3 and so on.\t\t\t\n\t\t\t\nThe first channel in input 1 is input 2's blend weight, the second channel in input 1 is the input 3's blend weight, and so on. There should be as many blend channels in input 1 as there are inputs, excluding input 1.\t(However when using Differencing and Omit First Weight Channel is on, the first channel if inout 1 ias assumed to be the weight of input 3, as input 2 is the \"base\" and doesn't need a weight.)\t\t\n\t\t\t\nThe interval of the output of the CHOP is the interval of input 1 (the blend channels).\t\t\t\n\t\t\t\nIf input 2 onwards are just poses, it's acceptable, as the CHOP blends between poses by using extend conditions. \t\t\t\n\t\t\t\n'''Note:''' This CHOP is optimized and doesn't cook inputs that have zero weight.",
        "opLabel": "Blend",
        "opClass": "blendCHOP_Class",
        "opType": "blend",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Blend CHOP combines two or more CHOPs in input 2, 3 and so on, by using a set of blending channels in input 1.",
        "opCategories": ""
    },
    "blobtrackCHOP": {
        "label": "blobtrackCHOP",
        "members": [
            {
                "text": "Toggle : While on, the CHOP receives information from the input. While off, no processing occurs. Existing blobs will remain.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Int : Controls how searching for blobs is done across all the points.",
                "type": "IntPar",
                "name": "searchmode",
                "items": []
            },
            {
                "text": "Int : The maximum number of blobs that can be tracked.",
                "type": "IntPar",
                "name": "maxblobs",
                "items": []
            },
            {
                "text": "Float : Two measured points from the input are considered to be part of the same blob if they are this distance or closer to each other.",
                "type": "FloatPar",
                "name": "maxpointdistance",
                "items": []
            },
            {
                "text": "Float : This controls the maximum distance a blob can move between successive frames and still be considered the same 'blob'.",
                "type": "FloatPar",
                "name": "maxblobmovement",
                "items": []
            },
            {
                "text": "Menu : Limits the area in which blobs are tracked. Points outside the area of interest are ignored.",
                "type": "MenuPar",
                "name": "areaofinterest",
                "items": []
            },
            {
                "text": "XY : The center of the area of interest.",
                "type": "XYPar",
                "name": "centerx",
                "items": []
            },
            {
                "text": "XY : The center of the area of interest.",
                "type": "XYPar",
                "name": "centery",
                "items": []
            },
            {
                "text": "WH : The size of the area of interest.",
                "type": "WHPar",
                "name": "size",
                "items": []
            },
            {
                "text": "Float : Rotate the area of interest.",
                "type": "FloatPar",
                "name": "rotate",
                "items": []
            },
            {
                "text": "Toggle : When this is on, blobs detected within the Area of Interest can move outside of that area and still be tracked. When this is off blobs that move outside the area of interest will stop being tracked.",
                "type": "TogglePar",
                "name": "allowmovementoutside",
                "items": []
            },
            {
                "text": "Toggle : Include the centroid of detected blobs as part of the output channels.",
                "type": "TogglePar",
                "name": "outputcentroid",
                "items": []
            },
            {
                "text": "Toggle : Include the velocity of detected blobs as part of the output channels.",
                "type": "TogglePar",
                "name": "outputvelocity",
                "items": []
            },
            {
                "text": "Int : Minimum number of points that must be near each other to form a blob. Use to help filter out false positives.",
                "type": "IntPar",
                "name": "minblobpoints",
                "items": []
            },
            {
                "text": "Float : Amount of time a blob must be detected to be considered trustworthy. Use to help filter out false positives. A blob will only be output if it's been detected for at least time amount of time.",
                "type": "FloatPar",
                "name": "blobinittime",
                "items": []
            },
            {
                "text": "Float : The amount of time before a blob that has been lost is removed from the output.",
                "type": "FloatPar",
                "name": "lostblobtimeout",
                "items": []
            },
            {
                "text": "Menu : With prediction enabled, blobs from the last frame have their new position predicted before being matched to the current frame.",
                "type": "MenuPar",
                "name": "predicttype",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "blobtrackCHOP",
        "opLabel": "Blob Track",
        "opClass": "blobtrackCHOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The Blob Track CHOP allows tracking blobs in 2D point data",
        "long": "The Blob Track CHOP allows tracking blobs in 2D point data.\n\nInput data should be have two channels named ''tx'' and ''ty'' describing the 2D points in cartesian coordinates. See the [[OP Snippets]] examples.\n\nGood sources for input scans are the [[Hokuyo CHOP]] (in Cartesian coordinate mode) and the [[Leuze ROD4 CHOP]]. These devices naturally output a radial scan from the device as the center point, where each point represents (angle, distance). Outputting each scan point in Cartesian coordinate mode gives an (x,y) for each point which is the format required for the Blob Track CHOP.  \n\nBut any set of (x,y) points in the two channels will be analyzed.  The tracker looks for consecutive points close to each other, and handles the case where one blob passes behind another blob giving the hidden blob a linear motion for a specifiable amount of time while it occluded before it removes the blob from the set of blobs being output.\n\nSee also [[Blob Track TOP]]",
        "opCategories": ""
    },
    "bodytrackCHOP": {
        "label": "bodytrackCHOP",
        "members": [
            {
                "text": "Toggle : Enables the body tracking features.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Folder : The location of the AI model files used for body detection. By default these files are located in the Config/Models folder.",
                "type": "FolderPar",
                "name": "modelfolder",
                "items": []
            },
            {
                "text": "Menu : The GPU to run the body tracking models on. An Nvidia RTX or newer card is required.",
                "type": "MenuPar",
                "name": "gpu",
                "items": []
            },
            {
                "text": "TOP : A path to the TOP operator that provides the image to perform body tracking on.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Toggle : Enable high performance while sacrificing quality. This is only available when Keypoints are on.",
                "type": "TogglePar",
                "name": "highperformance",
                "items": []
            },
            {
                "text": "Toggle : Output channels that describe a bounding box around the detected body. The channels give the u and v positions of the center of the body as well as the width and height of the box. The positions are relative to the bottom-left corner of the input image.",
                "type": "TogglePar",
                "name": "bbox",
                "items": []
            },
            {
                "text": "Toggle : Outputs a channel that describes the level of certainty that the AI model has detected a body in the input image. Higher numbers indicate greater confidence.",
                "type": "TogglePar",
                "name": "bboxconfidence",
                "items": []
            },
            {
                "text": "Toggle : Outputs either the UV or XYZ positions of the body's keypoints, depending on whether Body 3D is enabled.",
                "type": "TogglePar",
                "name": "keypoints",
                "items": []
            },
            {
                "text": "Toggle : Outputs a channel that describes the level of certainty that the AI model has detected for each keypoint on a body. Higher numbers indicate greater confidence.",
                "type": "TogglePar",
                "name": "keypointsconfidence",
                "items": []
            },
            {
                "text": "Toggle : Output rx, ry, and rz values for each keypoint on the body. (0,0,0) indicates that the body is oriented directly towards the camera. Values can range from +/- 180 degrees.",
                "type": "TogglePar",
                "name": "rotations",
                "items": []
            },
            {
                "text": "Toggle : If keypoints are enabled, output XYZ positions instead of UV positions for each keypoint.",
                "type": "TogglePar",
                "name": "body3d",
                "items": []
            },
            {
                "text": "Float : If Body 3D is enabled, fov is the Field of View of the camera which produced the image given to the Body Track.",
                "type": "FloatPar",
                "name": "fov",
                "items": []
            },
            {
                "text": "Toggle : Rescales the u and v positions so that they have the correct aspect ratio of the input image. This is useful when using the u, v positions as 3D coordinates rather than as image positions.",
                "type": "TogglePar",
                "name": "aspectcorrectuv",
                "items": []
            },
            {
                "text": "Toggle : Flips the u-coordinate of the UVs so that 1.0 becomes 0. and 0. becomes 1.",
                "type": "TogglePar",
                "name": "flipskelu",
                "items": []
            },
            {
                "text": "Toggle : Track multiple people within the input image. Each person will have a persistent ID which is accessible with the Bounding Boxes toggle.",
                "type": "TogglePar",
                "name": "peopletracking",
                "items": []
            },
            {
                "text": "Toggle : The maximum number of people for the Maxine SDK to track. After the new maximum target tracked limit is met, any new targets will be discarded. This parameter does not affect the number of output channels from the CHOP. There is no maximum to this parameter.",
                "type": "TogglePar",
                "name": "maxbodies",
                "items": []
            },
            {
                "text": "Int : Once a previously tracked body is no longer detected, an internal integer will be reset and incremented by one for each frame. The shadow tracking age is the threshold of this integer after which the body is discarded and no longer tracked. This property is measured in the number of frames, and the default is 90.",
                "type": "IntPar",
                "name": "shadowtrackingage",
                "items": []
            },
            {
                "text": "Int : This option is the length of the tracker's probationary period. After a body reaches this age, it is considered to be valid and is appointed an ID. This will help with false positives, where false bodies are detected only for a few frames. This is measured by the number of frames, and the default is 10.",
                "type": "IntPar",
                "name": "probationage",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "bodytrackCHOP",
        "opLabel": "Body Track",
        "opClass": "bodytrackCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "os": "Microsoft Windows",
        "hardware": "This operator uses the [https://docs.nvidia.com/deeplearning/maxine/ar-sdk-programming-guide/index.html Augmented Reality (AR) SDK] of the Nvidia Maxine system and requires a 20, 30, or 40 series Nvidia RTX GPU.",
        "short": "The Body Track CHOP can track bounding boxes and 34 key points of one or more human bodies, with optional joint angles, in 2D or 3D.",
        "long": "The Body Track CHOP can track bounding boxes and 34 key points of one or more human bodies, with optional joint angles, in 2D or 3D. \n    \nThe input image is taken from a provided TOP and can be of any resolution or format, and either a still image or video.\n\nThe coordinates of the detected features are given in u, v positions relative to the bottom-left corner of the input image. By default, the values range from 0 to 1, but the 'Aspect Correct' parameter can be enabled to scale the values so that they can be used as 3D coordinates while maintaining the aspect ratio of the original image."
    },
    "bulletsolverCHOP": {
        "label": "bulletsolverCHOP",
        "members": [
            {
                "text": "objref : A reference to either a [[Bullet Solver COMP]] or [[Actor COMP]]. If a Bullet Solver COMP is referenced then the CHOP will output the simulation results for all of its actors. If an Actor COMP is referenced then the CHOP will output the simulation results for only that actor.",
                "type": "objrefPar",
                "name": "comp",
                "items": []
            },
            {
                "text": "dropmenu : The space in which to output the transformation values. That is, the transform values (translation/rotation) will be outputted relative to the selected space.",
                "type": "dropmenuPar",
                "name": "xformspace",
                "items": []
            },
            {
                "text": "toggle : Adds colliding, colliding_actor_id, colliding_body_id, and total_collisions channels to the CHOP. In order to track these values for a body, \"Perform Contact Test\" must be enabled on the Bullet Solver COMP.",
                "type": "togglePar",
                "name": "collisioninfo",
                "items": []
            },
            {
                "text": "toggle : Adds translation channels to the CHOP.",
                "type": "togglePar",
                "name": "trans",
                "items": []
            },
            {
                "text": "toggle : Adds rotation channels to the CHOP.",
                "type": "togglePar",
                "name": "rot",
                "items": []
            },
            {
                "text": "toggle : Adds scale channels to the CHOP.",
                "type": "togglePar",
                "name": "scale",
                "items": []
            },
            {
                "text": "toggle : Adds linear velocity channels to the CHOP.",
                "type": "togglePar",
                "name": "linvel",
                "items": []
            },
            {
                "text": "toggle : Adds angular velocity channels to the CHOP.",
                "type": "togglePar",
                "name": "angvel",
                "items": []
            },
            {
                "text": "float : The sample rate of the CHOP.",
                "type": "floatPar",
                "name": "rate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "bulletsolverCHOP",
        "opLabel": "Bullet Solver",
        "opClass": "bulletsolverCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Bullet Solver CHOP is used in conjunction with a [[Bullet Dynamics]] system. It outputs the solved results from a Bullet simulation and can include the results for the entire system ([[Bullet Solver COMP]]) or an individual actor ([[Actor COMP]]) within a system.",
        "long": "The Bullet Solver CHOP is used in conjunction with a [[Bullet Dynamics]] system. It outputs the solved results from a Bullet simulation and can include the results for the entire system ([[Bullet Solver COMP]]) or an individual actor ([[Actor COMP]]) within a system. \n    \nThe Bullet Solver CHOP can also be used with the \"Feedback CHOP\" parameter on the Bullet Solver COMP or Actor COMP. Bullet Solver simulation results can be grabbed using the Bullet Solver CHOP, modified, then fed back into the [[Bullet Solver COMP]] it came from. The values at the beginning of the next step of the simulation will be whatever values are in the CHOP that is fed back. This allows any CHOP data to be injected into the simulation at the beginning of the next frame (time step).\n\nFor example: making an actor in the simulation jump to the mouse cursor when clicked. \n    \n'''Output Channels:''' \n* '''actor_id:''' the OP id of the Actor COMP \n* '''body_id:''' the id of the body within the Actor COMP. Actor COMPs can have multiple bodies if they are static or if instancing (see: Actor COMP). Body id's increment from 0 to N-1, where N is the total number of bodies in an Actor COMP. \n* '''active:''' whether the body is active in the simulation\n* '''colliding:''' whether the body is currently colliding with another body\n* '''colliding_actor_id''' the ID of the Actor COMP that contains the body we are colliding with\n* '''colliding_body_id''' the ID of the body we are colliding with; together with colliding_actor_id will map back to a specific body in the simulation\n* '''total_collisions:''' the total number of collisions this body has had\n* '''t[xyz]:''' the translation of the body in the given transform space \n* '''r[xyz]:''' the rotation of the body in the given transform space \n* '''s[xyz]:''' the scale of the body in the given transform space \n* '''vel_t[xyz]:''' linear velocity of the body \n* '''vel_r[xyz]:''' angular velocity of the body \n    \nSee also: [[Bullet Dynamics]], [[Bullet Solver COMP]], [[Actor COMP]], [[Force COMP]], [[Impulse Force COMP]], [[Constraint COMP]].",
        "opCategories": ""
    },
    "clipblenderCHOP": {
        "label": "clipblenderCHOP",
        "members": [
            {
                "text": "CHOP : Operator path to a valid [[Clip CHOP]].",
                "type": "CHOPPar",
                "name": "default",
                "items": []
            },
            {
                "text": "DAT : Operator path to a valid [[Table DAT]].",
                "type": "DATPar",
                "name": "datlist",
                "items": []
            },
            {
                "text": "XYZ : This parameter works in conjunction with the root transform channels as defined on the Channels page of the clpblender CHOP as well as the [[Clip CHOP]] parameter called Position Type. When Position Type is set to \"Blend To Target\" it will blend the root transform channels for the current clip to the new position defined in this parameter.",
                "type": "XYZPar",
                "name": "targetx",
                "items": []
            },
            {
                "text": "XYZ : This parameter works in conjunction with the root transform channels as defined on the Channels page of the clpblender CHOP as well as the [[Clip CHOP]] parameter called Position Type. When Position Type is set to \"Blend To Target\" it will blend the root transform channels for the current clip to the new position defined in this parameter.",
                "type": "XYZPar",
                "name": "targety",
                "items": []
            },
            {
                "text": "XYZ : This parameter works in conjunction with the root transform channels as defined on the Channels page of the clpblender CHOP as well as the [[Clip CHOP]] parameter called Position Type. When Position Type is set to \"Blend To Target\" it will blend the root transform channels for the current clip to the new position defined in this parameter.",
                "type": "XYZPar",
                "name": "targetz",
                "items": []
            },
            {
                "text": "Float : Provides a scale value to slow down or speed up the playback of the animation sequence.",
                "type": "FloatPar",
                "name": "playspeed",
                "items": []
            },
            {
                "text": "Toggle : Unknown",
                "type": "TogglePar",
                "name": "stepforward",
                "items": []
            },
            {
                "text": "Toggle : Unknown",
                "type": "TogglePar",
                "name": "stepbackward",
                "items": []
            },
            {
                "text": "Str : Broken",
                "type": "StrPar",
                "name": "aend",
                "items": []
            },
            {
                "text": "Int : Delays the output of animation data by the specified number of samples.",
                "type": "IntPar",
                "name": "delay",
                "items": []
            },
            {
                "text": "Toggle : When On, resets the clipblender and holds it ready to play the clip defined by the Default Clip CHOP parameter.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly reset the cliblender and start playing the clip defined by the Default Clip CHOP parameter.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "Str : A channel of the name defined in this parameter will return the time remaining in the current clip.",
                "type": "StrPar",
                "name": "timeremaining",
                "items": []
            },
            {
                "text": "Str : A channel of the name defined in this parameter will return the time elapsed in the current clip.",
                "type": "StrPar",
                "name": "timechannel",
                "items": []
            },
            {
                "text": "StrMenu : The translate X channel of the animation hierarchy that defines the [[Clipblender Motion Root]].",
                "type": "StrMenuPar",
                "name": "xtrans",
                "items": []
            },
            {
                "text": "StrMenu : The translate Y channel of the animation hierarchy that defines the [[Clipblender Motion Root]].",
                "type": "StrMenuPar",
                "name": "ytrans",
                "items": []
            },
            {
                "text": "StrMenu : The translate Z channel of the animation hierarchy that defines the [[Clipblender Motion Root]].",
                "type": "StrMenuPar",
                "name": "ztrans",
                "items": []
            },
            {
                "text": "StrMenu : The rotate X channel of the animation hierarchy that defines the [[Clipblender Motion Root]].",
                "type": "StrMenuPar",
                "name": "xrot",
                "items": []
            },
            {
                "text": "StrMenu : The rotate Y channel of the animation hierarchy that defines the [[Clipblender Motion Root]].",
                "type": "StrMenuPar",
                "name": "yrot",
                "items": []
            },
            {
                "text": "StrMenu : The rotate Z channel of the animation hierarchy that defines the [[Clipblender Motion Root]].",
                "type": "StrMenuPar",
                "name": "zrot",
                "items": []
            },
            {
                "text": "Str : Specifies the name of the queue enable channel that may be added to all animation clips that will be loaded into this clipblender. A \"Queue Enable\" channel may be added to the animation clip to define when this clip is safe and unsafe for blending into other clips. If the animation is not safe for blending, the channel would be set to 1, which means the clipblender should \"Queue\" the next clip in the sequence instead of playing it.  When the channel is 0, the any animation request will be executed immediately.",
                "type": "StrPar",
                "name": "qenable",
                "items": []
            },
            {
                "text": "Toggle : Unknown",
                "type": "TogglePar",
                "name": "qtrigger",
                "items": []
            },
            {
                "text": "Toggle : Unknown",
                "type": "TogglePar",
                "name": "prerotate",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "doxform",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "printstate",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "logjumps",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "jumpminx",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "jumpminy",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "jumpminz",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "jumpmaxx",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "jumpmaxy",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "jumpmaxz",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "jumpxyx",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "jumpxyy",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "jumpxyz",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "fixjump",
                "items": []
            },
            {
                "text": "Pulse : ",
                "type": "PulsePar",
                "name": "logpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Pro",
        "opLabel": "Clip Blender",
        "short": "The Clip Blender CHOP can be used as an animation system that blends between different animation clips, preserving rotation, changing target positions etc.",
        "opFilter": "False",
        "long": "The Clip Blender CHOP is a an engine for blending, sequencing and scripting animation clips. It loads animation channel data that is formatted using Clip CHOPs. It reads clip CHOP paths from a specified DAT list which can be dynamically scripted. The Clip Blender plays clips from the list DAT; each time it reads a clip, it pop's the item off the list, and when the next clip plays through it will continue playing and popping clips off the list until it is empty. Once the list is empty the last animation in the sequence is looped. \n    \nAnimation clips will typically come from an FBX or USD asset but can also be read using the Houdini bclip format or raw chan format. Animation clips found in FBX assets must be extracted from the asset hierarchy and then loaded speerately into a [[Clip CHOP]]. All [[Clip CHOP]]'s loaded into the same clipblender must have the same number of channels, all channel names must match and the all clips must be the same sample rate.  If any of these 3 important requirements are not met, there will likely be animation glitches.\n\t\t\t\nUse the [[Info CHOP]] and [[Info DAT]] to extract information about its current state. See also the [[Clip CHOP]] and [[Clip DAT]].",
        "opClass": "clipblenderCHOP_Class",
        "opType": "clipblender",
        "opCategories": ""
    },
    "clipCHOP": {
        "label": "clipCHOP",
        "members": [
            {
                "text": "DAT : ",
                "type": "DATPar",
                "name": "rdat",
                "items": []
            },
            {
                "text": "DAT : ",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Pulse : ",
                "type": "PulsePar",
                "name": "reload",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "transtion",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "blendtime",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "blendtimeunit",
                "items": []
            },
            {
                "text": "Str : ",
                "type": "StrPar",
                "name": "next",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "nblendtime",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "nblendtimeunit",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "loopactive",
                "items": []
            },
            {
                "text": "Str : ",
                "type": "StrPar",
                "name": "looprelease",
                "items": []
            },
            {
                "text": "Str : ",
                "type": "StrPar",
                "name": "indexchannel",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "abspos",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rottype",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "pauseend",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "See [[Clip Blender CHOP]].",
        "opLabel": "Clip",
        "opClass": "clipCHOP_Class",
        "opType": "clip",
        "opLicense": "Pro",
        "opFamily": "CHOP",
        "short": "See [[Clip Blender CHOP]].",
        "opCategories": ""
    },
    "clockCHOP": {
        "label": "clockCHOP",
        "members": [
            {
                "text": "Menu : Fractions or Units affects the channel data that is output from the Clock CHOP. Fraction gives convenient 0-1 ramps and Units give integers, like 0-23 for the hours of a day. For example, use Fractions and the day, hour and minute channels to drive a wall clock.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Menu : 12 hour or 24 hour - Causes the hour channel to cycle through 12 or 24 hours. Also affects the AM/PM channel.",
                "type": "MenuPar",
                "name": "hourformat",
                "items": []
            },
            {
                "text": "Float : After the Clock CHOP reads the current time, it adds Hour Adjust to pretend the current time is different than the actual current time.",
                "type": "FloatPar",
                "name": "houradjust",
                "items": []
            },
            {
                "text": "Menu : The date/time that corresponds to year 0, day 1, hour 0, minute 0. It can be relative to Jan 1, 2000 or to the time that the TouchDesigner process started.",
                "type": "MenuPar",
                "name": "startref",
                "items": []
            },
            {
                "text": "Str : If Output is Units, it is the current millisecond, starting at 0 at the start of a second, going up to 999 at the end of a second. If Output is Fraction, it is the current fraction of a millisecond.",
                "type": "StrPar",
                "name": "msec",
                "items": []
            },
            {
                "text": "Str : If Output is Units, it is the current second, starting at 0 for on-the-hour, going up to 59. If Output is Fraction, it is the current fraction of a second (45 seconds past the minute gives .75).",
                "type": "StrPar",
                "name": "sec",
                "items": []
            },
            {
                "text": "Str : If Output is Units, it is the current minute, starting at 0 for on-the-hour, going up to 59. If Output is Fraction, it is the current fraction of a minute (45 seconds past the minute gives .75).",
                "type": "StrPar",
                "name": "min",
                "items": []
            },
            {
                "text": "Str : If Output is Units, it is the current hour, starting at 0 for midnight and affected by AM/PM. If Output is Fraction, it is the current fraction of an hour (15 minutes past the hour gives .25), taking into account the current minute and second.",
                "type": "StrPar",
                "name": "hour",
                "items": []
            },
            {
                "text": "Str : 0 if before noon, 1 if after noon.",
                "type": "StrPar",
                "name": "ampm",
                "items": []
            },
            {
                "text": "Str : If Output is Units, it is the actual day of the week, starting with 0 for Monday and 6 for Sunday.",
                "type": "StrPar",
                "name": "wday",
                "items": []
            },
            {
                "text": "Str : If Output is Units, it is the actual day of the month, so on March 20, it is 20. If Output is Fraction, it is fraction of a day of the current moment, so at 6:30 PM, it is .77, taking into account the hour, minute and second.",
                "type": "StrPar",
                "name": "day",
                "items": []
            },
            {
                "text": "Str : If Output is Units, it is the Day of year, starting with 0 for January 1. If it is Fraction, it is the same as Day of Month.",
                "type": "StrPar",
                "name": "yday",
                "items": []
            },
            {
                "text": "Str : Week of the year, starting with 0 for the first week and 51 for the last week of the year.",
                "type": "StrPar",
                "name": "week",
                "items": []
            },
            {
                "text": "Str : Month of the year, starting with 1 for January and 12 for December.",
                "type": "StrPar",
                "name": "month",
                "items": []
            },
            {
                "text": "Str : If Output is Units, it is the integer year number relative to the Start Reference, starting at 0, so year 2009 is 9 by default. If Output is Fraction, it is the current fraction of a year, taking into account today's month, day, hour, minute and second.",
                "type": "StrPar",
                "name": "year",
                "items": []
            },
            {
                "text": "Float : Enter a latitude (hours/min north/south) of your location. (defaults to Toronto, Canada). Fractional hours are permitted. For example:  43.6532 hours and 0 minutes, is identical to 43 hours and 39 minutes. The parameter latitude1 is hours, latitude2 is minutes.",
                "type": "FloatPar",
                "name": "latitude",
                "items": []
            },
            {
                "text": "Menu : Set if the Latitude value above is in the north or south hemisphere.",
                "type": "MenuPar",
                "name": "northsouth",
                "items": []
            },
            {
                "text": "Float : Enter a longitude (hours/min east/west) of your location. Fractional hours are permitted. The parameter longitude1 is hours, longitude2 is minutes.",
                "type": "FloatPar",
                "name": "longitude",
                "items": []
            },
            {
                "text": "Menu : Set if the Longitude value above is in the east or west hemisphere.",
                "type": "MenuPar",
                "name": "eastwest",
                "items": []
            },
            {
                "text": "Str : Outputs the moon phase (0 to 1. .5 is a full moon, 0 and 1 are at the time of the new moon).",
                "type": "StrPar",
                "name": "moonphase",
                "items": []
            },
            {
                "text": "Str : (0 to 1, where sunrise=0, sunset = 1, and it reverses down to 0 in time for the sunrise.",
                "type": "StrPar",
                "name": "sunphase",
                "items": []
            },
            {
                "text": "Str : Outputs the sunrise time (0 to 1, midnight=0, twenty-four hours later = 1).",
                "type": "StrPar",
                "name": "sunrise",
                "items": []
            },
            {
                "text": "Str : Outputs the sunset time (0 to 1, midnight=0, twent.y-four hours later = 1).",
                "type": "StrPar",
                "name": "sunset",
                "items": []
            },
            {
                "text": "Str : (-180 to 180, degrees north/south that the sun is off the equator).",
                "type": "StrPar",
                "name": "declination",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Clock CHOP generates channels that reflect the time of year, month, week, day, hour, minute, second and millisecond. It also has a moon cycle channel. It provides the date as separate channels and in different units. It presents the time in two ways:\t\t\n\t\t\t\n* It generates '''0-1 ramps''' that reflect the time of year, month, week, day, hour, minute, second and millisecond.\t\t\t\n* It generates '''integers that reflects the day-of month''' etc. In this form the year channel is 4 for 2004, etc.\t\t\t\n\t\t\t\nThere are sunrise/sunset features, and you can override the day-of-year by inputting 1-6 channels into the CHOP.",
        "opLabel": "Clock",
        "opClass": "clockCHOP_Class",
        "opType": "clock",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Clock CHOP generates channels that reflect the time of year, month, week, day, hour, minute, second and millisecond.",
        "opCategories": ""
    },
    "compositeCHOP": {
        "label": "compositeCHOP",
        "members": [
            {
                "text": "Float : Determines how much of the base to blend into the output at points where the layer has an effect.",
                "type": "FloatPar",
                "name": "base",
                "items": []
            },
            {
                "text": "Menu : Matches channels in the base input with ones in the layer input by either index or name.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Toggle : Allows rotations with the quaternion attribute set to use spherical interpolation to produce smooth rotation blending (set in the Attribute CHOP).",
                "type": "TogglePar",
                "name": "quatrot",
                "items": []
            },
            {
                "text": "Toggle : It better-handles the blending from one set of angles to another, taking into account 0 degrees is 360 degrees.",
                "type": "TogglePar",
                "name": "shortrot",
                "items": []
            },
            {
                "text": "Str : Pattern (like *rx *ry *rz) that identifies which channels are rotations that should be handled specially as per the above option.",
                "type": "StrPar",
                "name": "rotscope",
                "items": []
            },
            {
                "text": "Float : Blend 0 degrees to this angle, generally 360.",
                "type": "FloatPar",
                "name": "cyclelen",
                "items": []
            },
            {
                "text": "Float : '''Note:''' If the third input is supplied, the Effect page will be overridden by the third input's first channel, which should contain the effect values over the range of the layer.",
                "type": "FloatPar",
                "name": "effect",
                "items": []
            },
            {
                "text": "Menu : Sets the meaning of the next four parameters - either Absolute values, Relative to the Start/End of the channel, or Relative to the Current Frame. The layer and base are never shifted.",
                "type": "MenuPar",
                "name": "relative",
                "items": []
            },
            {
                "text": "Float : The beginning of the composite interval. Effect is zero at the start.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : Where the composite operation reaches maximum effect.<br /> This value is held until the release point.",
                "type": "FloatPar",
                "name": "peak",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "peakunit",
                "items": []
            },
            {
                "text": "Float : The point at which the effect begins to fall back towards zero.",
                "type": "FloatPar",
                "name": "release",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "releaseunit",
                "items": []
            },
            {
                "text": "Float : The end of the composite operation's effect. The effect reduces to zero again.",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Menu : How to interpolate from one CHOP to another. It is the shape of the segment between the Start and Peak indices.",
                "type": "MenuPar",
                "name": "risefunc",
                "items": []
            },
            {
                "text": "Menu : How to interpolate from one CHOP to another. It is the shape of the segment between the Release and End.",
                "type": "MenuPar",
                "name": "fallfunc",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Composite CHOP layers (blends) the channels of one CHOP on the channels of another CHOP. The first input is the base input and the second is the layer input. It is designed for blending static multi-frame motion channels. Blending time-sliced channels or single-frame channels should be done with the [[Blend CHOP]].\t\t\n\t\t\t\nOver the interval of the layer, the layer channels are blended with the base channels. The contribution of the layer is eased-in and eased-out according to the Start, Peak, Release and End parameters. The base is unaffected outside the interval of the layer.\t\t\t\n\t\t\t\nThe Effect parameter determines the amount of contribution of the layer.\t\t\t\n\t\t\t\nIf Base Hold is 0, the layer input will completely replace the base input when the effect is 1. If the Base Hold is 1, the layer will be added to the base.\t\t\t\n\t\t\t\nThe interval of the output starts at the minimum of the base and layer. The interval of the output ends at the maximum of the base and layer. The base's extend conditions are used if the layer lies outside the base.\t\t\t\n\t\t\t\n'''Note:''' If the third input is supplied, the Effect page will be overridden by the third input's first channel, which should contain the effect values over the range of the layer.",
        "opLabel": "Composite",
        "opClass": "compositeCHOP_Class",
        "opType": "comp",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Composite CHOP layers (blends) the channels of one CHOP on the channels of another CHOP.",
        "opCategories": ""
    },
    "constantCHOP": {
        "label": "constantCHOP",
        "members": [
            {
                "text": "Str : The name of the channel.",
                "type": "StrPar",
                "name": "name0",
                "items": []
            },
            {
                "text": "Float : The value of the channel.",
                "type": "FloatPar",
                "name": "value0",
                "items": []
            },
            {
                "text": "Pulse : The optional first CHOP input on Constant is used when the Snapshot Input button is pressed. At this time, the channel names and values at the CHOP input at the current frame are used to initialize the channel names and values of the constant sliders.\t\n\t\t\t\nTo snap channels from other OPs, connect a Parameter CHOP to the Constant CHOP and hit <code>Snapshot Input</code>.\t\t\t\n\t\t\t\nYou can simulate the pressing of the Snapshot Input button from a script. To simulate the clicking of a CHOP dialog box button from a script use the [[Par Class]] pulse() Method:\n\t\t\t\nExample:\n<syntaxhighlight lang=\"python\">op('constant1').par.snap.pulse()</syntaxhighlight>",
                "type": "PulsePar",
                "name": "snap",
                "items": []
            },
            {
                "text": "Int : The First Channel parameter is used to select a smaller set of the incoming channels. This is useful if the number of incoming channels is greater than the 40 channels the Constant CHOP can hold, and you must break it into several CHOPs.",
                "type": "IntPar",
                "name": "first",
                "items": []
            },
            {
                "text": "Toggle : This is used with the second input as described above, when you want to add a displacement to channels by using external devices or sources.\t\n: When Active Needs Current is On, the second CHOP input (the Active input) has an effect only if the Constant CHOP is the current CHOP.\t\t\t\n: When Active Needs Current is Off, the Constant CHOP is affected any time the Active input is on (greater than 0).\t\t\t\n: This is used by the Channel Editor when editing keyframes using CHOPs. An input device like a button in the Keyboard In CHOP or a MIDI keyboard can be fed to the Active input of many Constant CHOPs. Only the current CHOP will be affected if this option is On.",
                "type": "TogglePar",
                "name": "current",
                "items": []
            },
            {
                "text": "Toggle : Turn this Off to make constant channels that are longer than one Sample.",
                "type": "TogglePar",
                "name": "single",
                "items": []
            },
            {
                "text": "Float : Start and end of the interval, expressed in Units (seconds, frames or samples). The parameters are expressed in the <code>Units</code> found on the Common page. To set the CHOP to be 100 samples long, Set <code>Units</code> to Samples, <code>Single Frame</code> Off and <code>Start</code> / <code>End</code> to 0 and 99.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : Start and end of the interval, expressed in Units (seconds, frames or samples). The parameters are expressed in the <code>Units</code> found on the Common page. To set the CHOP to be 100 samples long, Set <code>Units</code> to Samples, <code>Single Frame</code> Off and <code>Start</code> / <code>End</code> to 0 and 99.",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Constant CHOP creates new constant-value channels. Each channel can be named and assigned a different value. To create a channel, simply enter a channel name in a name parameter on the Constant page, then adjust the below value.\t\t\n\t\t\t\nThe CHOP interval (length of time) is one sample long by default (one sample at index 0 = frame 1). An interval range can be optionally set in the Channel page.\n\nYou can use [[Pattern Expansion]] like <code>geo[1-4][xyz]</code> to generate multiple channels in one line.\n\t\t\t\nA simple Constant CHOP with no inputs is the most common use of the CHOP. However, the channels names and values can be set up by connecting any CHOP to its input and clicking the Snapshot Input button (Snap page). This allows you to get some channels from another CHOP and adjust them with sliders in the Constant CHOP.\t\t\t\n\t\t\t\nThe second input can be used to add offsets to the constant values. When the second input (Active) is greater than zero, any change to the first input will be added to the output of the CHOP. This is useful for adjusting Constant CHOP values from external input devices like a MIDI slider box. For example you can connect the mouse or a MIDI slider box to a [[Mouse In CHOP]] or [[MIDI In CHOP]], and you can raise/lower the Constant CHOP values by holding the Active input On, while moving the mouse or sliders.",
        "opLabel": "Constant",
        "opClass": "constantCHOP_Class",
        "opType": "constant",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Constant CHOP creates new constant-value channels.",
        "opCategories": ""
    },
    "copyCHOP": {
        "label": "copyCHOP",
        "members": [
            {
                "text": "Menu : Select which copy method to use from the menu options below.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Menu : Select which output method to use from the menu options below.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Float : The threshold value for triggering copies.",
                "type": "FloatPar",
                "name": "threshold",
                "items": []
            },
            {
                "text": "Menu : See Remainder parameter below..",
                "type": "MenuPar",
                "name": "remainder",
                "items": []
            },
            {
                "text": "Toggle : If enabled, non-scoped channels are copied to the output, otherwise they are deleted.",
                "type": "TogglePar",
                "name": "keep",
                "items": []
            },
            {
                "text": "Toggle : Recook the second input for each triggered copy.",
                "type": "TogglePar",
                "name": "stamp",
                "items": []
            },
            {
                "text": "Str : The parameters are re-calculated for each copy. Set the parameter name here and the value below. You can use CHOP Members and Methods. The parameters you set here are available to any CHOP in the network attached to the second input through the function:\t\n<syntaxhighlight lang=python>fetchStamp(key, default)</syntaxhighlight>\nWhere <code>default</code> is any initial value for the parameter, and is usually set to 0.",
                "type": "StrPar",
                "name": "param1",
                "items": []
            },
            {
                "text": "Float : Set the parameter's value to be copied.",
                "type": "FloatPar",
                "name": "val1",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Copy CHOP produces multiple copies of the second input along the timeline of the first input. The first input provides the trigger signals or the convolve levels.\t\t\n\t\t\t\nThe Copy CHOP can be used to produce a motion every time a trigger occurs. It can be used to trigger motion, such as eyelid blinks. The copies it produces can be identical, or the copies can be re-cooked each time a copy is added to the timeline. It is useful for triggering a sound multiple times, where the sounds may overlap in time.\t\t\t\n\t\t\t\nEach copy that is added to the output can be completely different than any other copy. By passing variables through the Variables page, the second (Copy) input can be any CHOP chain that uses the variables and recooks to create each copy.",
        "opLabel": "Copy",
        "opClass": "copyCHOP_Class",
        "opType": "copy",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Copy CHOP produces multiple copies of the second input along the timeline of the first input.",
        "opCategories": ""
    },
    "countCHOP": {
        "label": "countCHOP",
        "members": [
            {
                "text": "Toggle : If on, the trigger threshold is also used as the release threshold.",
                "type": "TogglePar",
                "name": "threshold",
                "items": []
            },
            {
                "text": "Float : The channel level that must be exceeded in order to trigger a count.",
                "type": "FloatPar",
                "name": "threshup",
                "items": []
            },
            {
                "text": "Float : A release count is triggered when the channel level drops below this threshold.",
                "type": "FloatPar",
                "name": "threshdown",
                "items": []
            },
            {
                "text": "Float : The amount of time after a trigger point that a new trigger may occur.",
                "type": "FloatPar",
                "name": "retrigger",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "retriggerunit",
                "items": []
            },
            {
                "text": "Menu : Determines whether a trigger occurs on an increasing slope or decreasing slope when passing the trigger threshold. A release will occur on the opposite slope.",
                "type": "MenuPar",
                "name": "triggeron",
                "items": []
            },
            {
                "text": "Menu : Select limit options such as loop and/or clamp from the menu. The value will remain in the range from Min to Max.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Float : The minimum allowed count number.",
                "type": "FloatPar",
                "name": "limitmin",
                "items": []
            },
            {
                "text": "Float : The maximum allowed count number.",
                "type": "FloatPar",
                "name": "limitmax",
                "items": []
            },
            {
                "text": "Menu : The operation to perform when a trigger event (off to on) occurs.",
                "type": "MenuPar",
                "name": "offtoon",
                "items": []
            },
            {
                "text": "Menu : The operation to perform while the input remains triggered (on).",
                "type": "MenuPar",
                "name": "on",
                "items": []
            },
            {
                "text": "Menu : The operation to perform when a release event (on to off) occurs.",
                "type": "MenuPar",
                "name": "ontooff",
                "items": []
            },
            {
                "text": "Menu : The operation to perform while the input is not triggered (off).\t\n\t\t\t\n'''Note''': The scripts are run relative to the parent node of this CHOP, as if the script is in the node above this CHOP.",
                "type": "MenuPar",
                "name": "off",
                "items": []
            },
            {
                "text": "Menu : This menu determines how the Reset input triggers a reset of the channel(s).",
                "type": "MenuPar",
                "name": "resetcondition",
                "items": []
            },
            {
                "text": "Float : The channel(s) is set to this value when reset.",
                "type": "FloatPar",
                "name": "resetvalue",
                "items": []
            },
            {
                "text": "Toggle : When On resets the channel(s) to the Reset Value. The Count CHOP will only begin counting again when Reset is Off.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly resets the channel(s) to the Reset Value.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Count CHOP counts the number of times a channel crosses a trigger or release threshold. It operates in either static or realtime (\"Cook to Current Frame\") mode.\t\t\n\t\t\t\nThe trigger value by default is 0, so the count occurs when the input goes from below (or equal to) 0 to a value that is greater than zero.\t\t\t\n\t\t\t\nCrossing the trigger threshold (increasing past the trigger level) creates a trigger event. Similarly, crossing the release threshold (decreasing past the release level) creates a release event. Operations may also be performed while the input remain above or below the trigger or release levels. On each event, the count may be increased or decreased by 1 or the time, or reset to zero. The time per sample varies with the sample rate (i.e. for 100 samples/second, the time for each sample would be 1/100th of a second).\t\t\t\n\t\t\t\nThe optional second input is a reset input. The first channel is interpreted as a channel containing reset pulses. Whenever this channel is non-zero, the count for all channels is reset.\t\t\t\n\t\t\t\nThe third input is labeled \"Increment Value\". It allows you to specify a value other than the default +-1 to count. If you want to count by Fives, then put a channel with a value of 5 in this input. It will increment by 5 each count, or by 5 per second depending on the On / Off menus on the second page.",
        "opLabel": "Count",
        "opClass": "countCHOP_Class",
        "opType": "count",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Count CHOP counts the number of times a channel crosses a trigger or release threshold.",
        "opCategories": ""
    },
    "cplusplusCHOP": {
        "label": "cplusplusCHOP",
        "members": [
            {
                "text": "File : The path to the plugin you want to load.",
                "type": "FilePar",
                "name": "plugin",
                "items": []
            },
            {
                "text": "Toggle : When this parameter is On, it will delete the instance of the class created by the plugin, and create a new one.",
                "type": "TogglePar",
                "name": "reinit",
                "items": []
            },
            {
                "text": "Pulse : Instantly reinitialize the class.",
                "type": "PulsePar",
                "name": "reinitpulse",
                "items": []
            },
            {
                "text": "Toggle : When this parameter goes above 1, it will delete the instance of the class created by the plugin and unload the plugin. If multiple CHOPs have loaded the same plugin, they will all need to unload it to release the file.",
                "type": "TogglePar",
                "name": "unloadplugin",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The CPlusPlus CHOP allows you to make custom CHOP operators by writing your own plugin using C++.\t\n\nSee [[Write a CPlusPlus Plugin]] and the other articles in the [[:Category:C++ | C++ Category]] for more detailed information on how to make plugins for use with this node and how to access example projects.",
        "opLabel": "CPlusPlus",
        "opClass": "cplusplusCHOP_Class",
        "opType": "cplusplus",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The CPlusPlus CHOP allows you to make custom CHOP operators by writing your own plugin using C++.",
        "opCategories": ""
    },
    "crossCHOP": {
        "label": "crossCHOP",
        "members": [
            {
                "text": "Float : This parameter controls the blending of the inputs. A value of 0 will select the first input, 1 will select the second input, 2 will select the third and so on. Using inbetween values will blend the 2 closest inputs. For example; 1.5 will add 50% of input2 and 50% of input3 to the result; 0.75 will add 25% of input1 and 75% of input2 to the result.",
                "type": "FloatPar",
                "name": "cross",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Cross CHOP is a multi input OP that blends between 2 inputs at a time. This is similar to a [[Switch CHOP]] however the Cross CHOP allows for interpolation between the inputs.",
        "opLabel": "Cross",
        "opClass": "crossCHOP_Class",
        "opType": "cross",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Cross CHOP is a multi input OP that blends between 2 inputs at a time.",
        "opCategories": ""
    },
    "cycleCHOP": {
        "label": "cycleCHOP",
        "members": [
            {
                "text": "Float : The number of cycles to loop before the input CHOP. This parameter can be fractional.",
                "type": "FloatPar",
                "name": "before",
                "items": []
            },
            {
                "text": "Float : The number of cycles to loop after the input CHOP. This parameter can be fractional.",
                "type": "FloatPar",
                "name": "after",
                "items": []
            },
            {
                "text": "Toggle : If enabled, consecutive cycles are mirror images (reversed) of each another. The first cycle is never mirrored.",
                "type": "TogglePar",
                "name": "mirror",
                "items": []
            },
            {
                "text": "Toggle : If on, the end of the CHOP is blended into the start of the CHOP to produce a smooth loop. If Cycles Before and Cycles After are 0, Region is non-zero, and Extend Conditions are \"Cycle\", it loops smoothly forever.",
                "type": "TogglePar",
                "name": "extremes",
                "items": []
            },
            {
                "text": "Menu : How to blend between cycles:",
                "type": "MenuPar",
                "name": "blendmethod",
                "items": []
            },
            {
                "text": "Menu : The shape of the blending function:",
                "type": "MenuPar",
                "name": "blendfunc",
                "items": []
            },
            {
                "text": "Float : The size of the blend region, in either seconds, samples or frames (set with Units in the Common page).",
                "type": "FloatPar",
                "name": "blendregion",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "blendregionunit",
                "items": []
            },
            {
                "text": "Float : The bias of the blend. A -1 biases the blend toward the beginning of the blend region, 0 is no bias and +1 biases towards the end of the blend region.",
                "type": "FloatPar",
                "name": "blendbias",
                "items": []
            },
            {
                "text": "Float : If set to 1, the next cycle will be shifted up or down in value, so that it begins where the last cycle ended. Suitable for the root object of walk cycles.",
                "type": "FloatPar",
                "name": "step",
                "items": []
            },
            {
                "text": "Str : The names of those channels that will be affected by the Step parameter.",
                "type": "StrPar",
                "name": "stepscope",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Cycle CHOP creates cycles. It can repeat the channels any number of times before and after the original. It can also make a single cycle have a smooth transition from its end to its beginning, so it loops smoothly.\t\t\n\t\t\t\nSince channels may not naturally loop well, the Cycle CHOP provides three different methods of blending between the cycles.",
        "opLabel": "Cycle",
        "opClass": "cycleCHOP_Class",
        "opType": "cycle",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Cycle CHOP creates cycles. It can repeat the channels any number of times before and after the original.",
        "opCategories": ""
    },
    "dattoCHOP": {
        "label": "dattoCHOP",
        "members": [
            {
                "text": "DAT : The DAT to be used to retrieve values. This DAT should be in ''table'' format. For table format, use either a [[Table DAT]] or a [[Convert DAT]] set to '''To Table'''.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "Menu : This parameter allows you to pick different ways of specifying the rows selected.",
                "type": "MenuPar",
                "name": "extractrows",
                "items": []
            },
            {
                "text": "Str : Specify the row name to start the selection range from.",
                "type": "StrPar",
                "name": "rownamestart",
                "items": []
            },
            {
                "text": "Int : Specify the row index to start the selection range from.",
                "type": "IntPar",
                "name": "rowindexstart",
                "items": []
            },
            {
                "text": "Str : Specify the row name to end the selection range.",
                "type": "StrPar",
                "name": "rownameend",
                "items": []
            },
            {
                "text": "Int : Specify the row index to end the selection range.",
                "type": "IntPar",
                "name": "rowindexend",
                "items": []
            },
            {
                "text": "Str : Specify actual row names that you want to select. You can use pattern matching, for example row[1-4] will select all the rows names row1 thru row4.",
                "type": "StrPar",
                "name": "rownames",
                "items": []
            },
            {
                "text": "Str : Specify an expression that will be evaluated. If the expression evaluates to true, the row will be selected.\nExpand the parameter and you will see that it is in [[Parameter Mode|expression mode]].\n\n[[File:SelectDAT_rowselectexpr.png]]\n\nBy default, the [[Python]] expression is re.match('.*',me.inputCell.val) != None. '.*' means match any character multiple times, so this expression matches all values. If you want to match the parent's operator name followed by any numeric number you can use parent().name+'[0-9]*', where '[0-9]*' matches any numerical string. '.*'+parent().name+'.*' will match any cell that contains the operator's parent name. You can check [https://docs.python.org/3.3/library/re.html Regular Expression Operations] for additional information on how to use the Python Regular Expression module.",
                "type": "StrPar",
                "name": "rowexpr",
                "items": []
            },
            {
                "text": "Int : When selecting rows by values, this parameter selects which column to use when matching cell values to Selected Row Values to determine which rows are selected.",
                "type": "IntPar",
                "name": "fromcol",
                "items": []
            },
            {
                "text": "Menu : This parameter allows you to pick different ways of specifying the columns selected.",
                "type": "MenuPar",
                "name": "extractcols",
                "items": []
            },
            {
                "text": "Str : Specify the column name to start the selection range from.",
                "type": "StrPar",
                "name": "colnamestart",
                "items": []
            },
            {
                "text": "Int : Specify the column index to start the selection range from.",
                "type": "IntPar",
                "name": "colindexstart",
                "items": []
            },
            {
                "text": "Str : Specify the column name to end the selection range.",
                "type": "StrPar",
                "name": "colnameend",
                "items": []
            },
            {
                "text": "Int : Specify the column index to end the selection range.",
                "type": "IntPar",
                "name": "colindexend",
                "items": []
            },
            {
                "text": "Str : Specify actual column names that you want to select. You can use pattern matching, for example colvalue[1-4] will select all the columns named colvalue1 thru colvalue4.",
                "type": "StrPar",
                "name": "colnames",
                "items": []
            },
            {
                "text": "Str : Specify an expression that will be evaluated. If the expression evaluates to true, the column will be selected. See Row Select Condition for more details.",
                "type": "StrPar",
                "name": "colexpr",
                "items": []
            },
            {
                "text": "Int : When extracting columns by Specified Names, this parameter selects which row to use when matching cell values to Selected Col Values to determine which columns are selected.",
                "type": "IntPar",
                "name": "fromrow",
                "items": []
            },
            {
                "text": "Menu : Specify the form of the channels output.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Menu : Specifies whether the first row is ignored, names, or values.",
                "type": "MenuPar",
                "name": "firstrow",
                "items": []
            },
            {
                "text": "Menu : Specifies whether the first columnn is ignored, names, or values.",
                "type": "MenuPar",
                "name": "firstcolumn",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opClass": "dattoCHOP_Class",
        "opFamily": "CHOP",
        "long": "The DAT to CHOP will create a set of CHOP channels with values derived from a [[DAT]].",
        "short": "The DAT to CHOP will create a set of CHOP channels with values derived from a [[DAT]].",
        "opFilter": "False",
        "opType": "datto",
        "opLabel": "DAT to",
        "opCategories": ""
    },
    "delayCHOP": {
        "label": "delayCHOP",
        "members": [
            {
                "text": "Float : Delay in seconds, or in units determined by its [[Units]] menu. To get a delay per channel, use <code>me.chanIndex</code>. From a table where each row has a delay amount, use <code>op('delaysTable')[me.chanIndex,0]</code>.",
                "type": "FloatPar",
                "name": "delay",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "delayunit",
                "items": []
            },
            {
                "text": "Float : Useful for optimizing performance when the Delay parameter above is changing dynamically. Set Max Delay to a value higher than the expected range of the Delay parameter.",
                "type": "FloatPar",
                "name": "maxdelay",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "maxdelayunit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Delay CHOP delays the input. Multiple channels can be fed in to delay each separately. Each channel can have a separate delay time using <code>me.chanIndex</code>. \t\n\t\t\nEchoes can be created by chains of Delay CHOPs with Math CHOPs between, or by using the [[Feedback CHOP]].",
        "opLabel": "Delay",
        "opClass": "delayCHOP_Class",
        "opType": "delay",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Delay CHOP delays the input. Multiple channels can be fed in to delay each separately and each channels can have a separate delay time.",
        "opCategories": ""
    },
    "deleteCHOP": {
        "label": "deleteCHOP",
        "members": [
            {
                "text": "Toggle : Toggle to enable channel deleting.",
                "type": "TogglePar",
                "name": "delchannels",
                "items": []
            },
            {
                "text": "Menu : Determines whether the scoped channels should be deleted or retained:",
                "type": "MenuPar",
                "name": "discard",
                "items": []
            },
            {
                "text": "Menu : How to select channels - <span class=\"tipTextCHOP\">By Name</span>, or By <span class=\"tipTextCHOP\">Numeric</span> index.",
                "type": "MenuPar",
                "name": "select",
                "items": []
            },
            {
                "text": "StrMenu : Enter a scope pattern here to specify the names of channels to delete or extract. You do this by specifying a scope pattern, as detailed in [[Pattern Matching]].\t\n\t\t\t\n: The default scope pattern <code>t*</code> will scope the translation channels: <code>tx</code>, <code>ty</code>, and <code>tz</code> , or any other channel whose name starts with <code>t</code>.",
                "type": "StrMenuPar",
                "name": "delscope",
                "items": []
            },
            {
                "text": "Str : The indices of the channels to delete or extract. - See possible number patterns below.",
                "type": "StrPar",
                "name": "selnumbers",
                "items": []
            },
            {
                "text": "Menu : Chooses the type of value range selection:",
                "type": "MenuPar",
                "name": "chanvalue",
                "items": []
            },
            {
                "text": "Float : The lower and upper values of the range used for Range Selection.",
                "type": "FloatPar",
                "name": "selrange",
                "items": []
            },
            {
                "text": "Toggle : Select channels which have the same value for all samples. These kinds of channel name patterns are used to select existing channels in an input CHOP, see [[Pattern Matching]] for details.\t\n\t\t\t\nAlso these kinds of channel number patterns can be used to select existing channels in an input CHOP:\t\t\t\n\t\t\t\n<!--TDitemStart-->* <code> 0 1 4</code> - Matches the first, second and fifth channel.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code> [0-4]</code> - Matches the first five channels.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>[3-9:2]</code> - Matches channels at indices 3,5, 7 and 9.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "selconst",
                "items": []
            },
            {
                "text": "Toggle : Toggle to enable sample deleting.",
                "type": "TogglePar",
                "name": "delsamples",
                "items": []
            },
            {
                "text": "Menu : How to select channels used to compare against criteria - By <span class=\"tipTextCHOP\">Name</span>, by <span class=\"tipTextCHOP\">Numeric</span> index, by using the <span class=\"tipTextCHOP\">First Channel</span>, or by using the <span class=\"tipTextCHOP\">Last Channel</span>.",
                "type": "MenuPar",
                "name": "compchans",
                "items": []
            },
            {
                "text": "StrMenu : Enter a scope pattern here to specify the names of channels to be used as compare channels. You do this by specifying a scope pattern, as detailed in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "compnames",
                "items": []
            },
            {
                "text": "Str : The indices of the channels to be used as compare channels, the default being '''0''', the first channel. - See possible number patterns above.",
                "type": "StrPar",
                "name": "compnums",
                "items": []
            },
            {
                "text": "Menu : If there is more that one compare channel, this determines how to treat the values in the compare channels before checking against the criteria:",
                "type": "MenuPar",
                "name": "compmulti",
                "items": []
            },
            {
                "text": "Menu : Choose the criteria for the samples to be compare against:",
                "type": "MenuPar",
                "name": "condition",
                "items": []
            },
            {
                "text": "Float : Set a value for Value 1.",
                "type": "FloatPar",
                "name": "value1",
                "items": []
            },
            {
                "text": "Toggle : Toggle the inclusivity of Value 1.",
                "type": "TogglePar",
                "name": "inclvalue1",
                "items": []
            },
            {
                "text": "Float : Set a value for Value 2.",
                "type": "FloatPar",
                "name": "value2",
                "items": []
            },
            {
                "text": "Toggle : Toggle the inclusivity of Value 2.",
                "type": "TogglePar",
                "name": "inclvalue2",
                "items": []
            },
            {
                "text": "Toggle : Determines whether the compare channels should be deleted or retained.",
                "type": "TogglePar",
                "name": "deletecomp",
                "items": []
            },
            {
                "text": "Toggle : Leaves one sample even when all samples are deleted.",
                "type": "TogglePar",
                "name": "onesample",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Delete CHOP removes entire channels and/or individual samples of its input. \t\t\n\t\t\t\nFor deleting channels, on the Channels page, you can specify which channels to delete by channel name or a channel number range. A second method deletes channels using a value range to select channels whose values are all within a range. The third method deletes constant-valued channels. An option selects whether to delete or retain the matched channels.\t\t\t\n\t\t\t\nFor deleting individual samples (i.e. no channels are deleted), on the Samples page you can delete, for example, only the samples whose value is below 0, which will shorten the length of the CHOP. \t\t\t\n\t\t\t\nIn CHOPs with two or more channels, one or more \"compare\" channels are used to determine which samples are to be deleted. By default it uses the first channel to compare against. Deleting a sample at a certain index deletes a value for all the channels. If there are 4 channels, <code>red</code>, <code>green</code>, <code>blue</code>, <code>alpha</code> and you specify <code>alpha</code> as the \"compare\" channel, you can delete all the samples with an <code>alpha</code> of <code>0</code>. If a CHOP is 3 channels with an X,Y,Z position, you can delete all samples where the XYZ length is below a threshold.\t\t\t\n\t\t\t\nThis is useful, for example, for thinning your data before sending a CHOP to a Geometry component for instancing. \t\t\t\n\t\t\t\nWhen all the samples are deleted, the CHOP will keep one sample for all channels and will have a <code>length</code> of one sample. When this happens, if you have an Info CHOP attached to the Delete CHOP, it's \t\t\t\n\t\t\t\nSee also [[Splice CHOP]], [[Select CHOP]], [[Trim CHOP]]",
        "opLabel": "Delete",
        "opClass": "deleteCHOP_Class",
        "opType": "delete",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Delete CHOP removes entire channels and/or individual samples of its input.",
        "opCategories": ""
    },
    "dmxinCHOP": {
        "label": "dmxinCHOP",
        "members": [
            {
                "text": "Toggle : Connects to the device while On.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the type of interface to connect to the device with.",
                "type": "MenuPar",
                "name": "interface",
                "items": []
            },
            {
                "text": "Menu : Set the version of the KiNET protocol to use.",
                "type": "MenuPar",
                "name": "kinetversion",
                "items": []
            },
            {
                "text": "StrMenu : Select a DMX device from the menu.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "StrMenu : When the <span class=\"tipTextCHOP\">Interface</span> parameter is set Generic Serial this parameter lets you select which Serial (COM) port to use.",
                "type": "StrMenuPar",
                "name": "serialport",
                "items": []
            },
            {
                "text": "Menu : Select between receiving Packet Per Sample (Timesliced), Packet Per Channel (Latest) or Packet Per Channel (All). When selecting Packet Per Channel (Latest), any messages outside the last cook are being discarded while the option Packet Per Channel (All) will append channels that would get otherwise skipped by dropped frames.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "Int : When the <span class=\"tipTextCHOP\">Interface</span> parameter is set to Art-Net, this sets the net address. A net is a groups of 16 consecutive subnets or 256 consecutive universes. The range for this parameter is 0-127. This is '''not''' a network IP address.",
                "type": "IntPar",
                "name": "net",
                "items": []
            },
            {
                "text": "Int : When the <span class=\"tipTextCHOP\">Interface</span> parameter is set to Art-Net, this sets the subnet address. A subnet is a group of 16 consecutive universes. The range for this parameter is 0-15. This is '''not''' a network subnet mask.",
                "type": "IntPar",
                "name": "subnet",
                "items": []
            },
            {
                "text": "Int : When the <span class=\"tipTextCHOP\">Interface</span> parameter is set to Art-Net, this sets the universe address. A single DMX512 frame of 512 channels is referred to as a universe. The range for this parameter is 0-15.",
                "type": "IntPar",
                "name": "universe",
                "items": []
            },
            {
                "text": "DAT : Available when using Packet Per Channel Format for Art-Net or sACN. Use the docked Table DAT to specify which net, subnet, universe channels are being received from.\t\n\t\t\t\n'''Note:''' For sACN the first available universe has the index 1 as universe 0 is reserved by the system for future use.",
                "type": "DATPar",
                "name": "filterdat",
                "items": []
            },
            {
                "text": "Str : Specify the channel prefix for the net part of the address.",
                "type": "StrPar",
                "name": "netname",
                "items": []
            },
            {
                "text": "Str : Specify the channel prefix for the subnet part of the address.",
                "type": "StrPar",
                "name": "subnetname",
                "items": []
            },
            {
                "text": "Str : Specify the channel prefix for the universe part of the address.",
                "type": "StrPar",
                "name": "universename",
                "items": []
            },
            {
                "text": "Str : Specify the channel prefix for the KiNET port part of the address.",
                "type": "StrPar",
                "name": "kinetportname",
                "items": []
            },
            {
                "text": "Str : A list of accepted start codes when using sACN. If the DMX In CHOP receives an sACN packet with a start code not in the list then it will discard it.",
                "type": "StrPar",
                "name": "startcodes",
                "items": []
            },
            {
                "text": "Toggle : Enable multicast for sACN. Multicast automatically builds the IP based on Net, Subnet, and Universe of the device. This allows for the DMX In CHOP to automatically receive from a sender without knowledge of it's address.",
                "type": "TogglePar",
                "name": "multicast",
                "items": []
            },
            {
                "text": "Int : When using interface Art-Net or sACN, this will set the size of the incoming packets queue.  This can be used to smooth data, though latency will be higher.  In the case of Packet Per Channel (All), this parameter controls the maximum number of packets created per cook.",
                "type": "IntPar",
                "name": "queuesize",
                "items": []
            },
            {
                "text": "Int : Resample the incoming data to this rate.",
                "type": "IntPar",
                "name": "rate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The DMX In CHOP receives channels from DMX, [[Art-Net]], [[sACN]] or KiNET devices. Channel values for DMX are 0-255. Note that input rate is limited to the DMX maximum refresh rate of 44Hz.\t\t\n\t\t\t\nA Filter Table can be provided in a DAT where addresses can be specified by adding rows for each channel and specifying '''net''', '''subnet''' and '''universe'''. Optionally, packets can be filtered using the '''srcaddress''' and '''destaddress''' columns; only packets that have a matching source IP address and destination IP address will be accepted. The cell values for these columns should be a single IP address (ie. regex not supported); if left blank then all packets will be accepted. \n\nThe '''srcaddress''' column is useful for when there is DMX noise on the network that needs to be filtered out; the IP of the desired controller can be specified in the '''srcaddress''' cell. The '''id''' column should be used in conjunction with '''srcaddress''' and '''destaddress''' to provide a unique channel suffix.\n\n[https://www.wireshark.org/ Wireshark] is a useful tool for debugging network issues. In the Art-Net case, packets can easily be filtered using '''artnet''', '''dmx''', or '''dmx_chan'''.\n\t\t\t\n'''ENTTEC NOTE:''' - Use ENTTEC's [http://www.enttec.com/us/products/controls/dmx-over-ethernet/nmu/ NMU (Node Management Utility)] to configure and inspect the ENTTEC devices found on your network. \t\t\t\n\t\t\t\nSee also: [[Art-Net]], [[DMX Out CHOP]], [[DMX]]",
        "opLabel": "DMX In",
        "opClass": "dmxinCHOP_Class",
        "opType": "dmxin",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The DMX In CHOP receives channels from DMX, [[Art-Net]]  or [[sACN]] devices.",
        "opCategories": ""
    },
    "dmxoutCHOP": {
        "label": "dmxoutCHOP",
        "members": [
            {
                "text": "Toggle : Connects to the device while On.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the type of interface to connect to the device with.",
                "type": "MenuPar",
                "name": "interface",
                "items": []
            },
            {
                "text": "Menu : Set the version of the KiNET protocol to use.",
                "type": "MenuPar",
                "name": "kinetversion",
                "items": []
            },
            {
                "text": "Menu : Select between sending Packet Per Sample or Packet Per Channel.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "DAT : Available when using Packet Per Channel Format for Art-Net or sACN. Use the docked Table DAT to route channels to the appropriate universes. Addresses can be specified by adding rows for each channel and specifying net, subnet and universe. The net, subnet and universe columns are optional. If for example the <code>net</code> column is missing from the Routing Table, the <code>Net</code> parameter is used instead.\t\n\t\t\t\nWhen removing the Routing Table from the parameter, the specified address will be used for the first channel while all other channels are assigned to consecutive addresses.\t\t\t\n\t\t\t\n'''Note:''' For sACN the first available universe has the index 1 as universe 0 is reserved by the system for future use.",
                "type": "DATPar",
                "name": "routingtable",
                "items": []
            },
            {
                "text": "Toggle : When enabled will send out ArtSync packets. ArtSync packets are used to synchronize multiple universes together.",
                "type": "TogglePar",
                "name": "sendartsync",
                "items": []
            },
            {
                "text": "StrMenu : Select a DMX device from the menu.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "StrMenu : When the Interface parameter is set to Generic Serial this parameter lets you select which Serial (COM) port to use.",
                "type": "StrMenuPar",
                "name": "serialport",
                "items": []
            },
            {
                "text": "Int : How often data is sent to the device (per second).\n        \n        '''WARNING: DMX512 devices have a maximum refresh rate of 44Hz. It is recommended that Rate <= 44 for reliable performance.'''",
                "type": "IntPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Int : When the Interface parameter is set to Art-Net, this sets the net address. A net is a groups of 16 consecutive subnets or 256 consecutive universes. The range for this parameter is 0-127. This is '''not''' a network IP address.",
                "type": "IntPar",
                "name": "net",
                "items": []
            },
            {
                "text": "Int : When the Interface parameter is set to Art-Net, this sets the subnet address. A subnet is a group of 16 consecutive universes. The range for this parameter is 0-15. This is '''not''' a network subnet mask.",
                "type": "IntPar",
                "name": "subnet",
                "items": []
            },
            {
                "text": "Int : When the Interface parameter is set to Art-Net, this sets the universe address. A single DMX512 frame of 512 channels is referred to as a universe. The range for this parameter is 0-15.",
                "type": "IntPar",
                "name": "universe",
                "items": []
            },
            {
                "text": "Str : The unique ID of the sender.",
                "type": "StrPar",
                "name": "cid",
                "items": []
            },
            {
                "text": "Str : User assigned name of source (for informative purposes).",
                "type": "StrPar",
                "name": "source",
                "items": []
            },
            {
                "text": "Int : The priority of the data being sent, if there are multiple sources.",
                "type": "IntPar",
                "name": "priority",
                "items": []
            },
            {
                "text": "Toggle : When enabled, can specify a custom port for the KiNET v2 interface. When disabled, the port will be the broadcast port: 255.",
                "type": "TogglePar",
                "name": "customkinetport",
                "items": []
            },
            {
                "text": "Int : Specifies the port for KiNET v2 interface.",
                "type": "IntPar",
                "name": "kinetport",
                "items": []
            },
            {
                "text": "Toggle : Enable multicast for sACN. Multicast automatically builds the IP based on Net, Subnet, and Universe of the device. This allows for sending to multiple devices at once by specifying multiple universes.",
                "type": "TogglePar",
                "name": "multicast",
                "items": []
            },
            {
                "text": "Str : Specify the IP address to use when Interface is set to Art-Net. This address corresponds to the receiving device address.  When the address is set to its default 255.255.255.255, the messages are instead broadcast to all devices on the  network. The Art-Net Net, Subnet and Universe of the receiving devices must still match those specified in the DMX Out CHOP in all cases.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "StrMenu : When the sending machine is equipped with multiple network adapters, this parameter can be used to choose which adapter to send the data from by specifying its IP address here.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Int : In rare cases it can be necessary to supply a custom port from which the data should be sent. The default of <code>-1</code> means the O/S assigned port is being used.",
                "type": "IntPar",
                "name": "localport",
                "items": []
            },
            {
                "text": "Toggle : Enable the Network Port parameter to specify the port of the receiving hardware.",
                "type": "TogglePar",
                "name": "customport",
                "items": []
            },
            {
                "text": "Int : Let's you specify the port of the receiving hardware. By default and the spec of ArtNet this is set to 6454 and should only be changed in rare cases.",
                "type": "IntPar",
                "name": "netport",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The DMX Out CHOP sends channels to [[DMX]], [[Art-Net]], [[sACN]], KiNET, or FTDI devices. Channel values for DMX are 0-255.  \t\t\n\t\t\t\nThe first channel you send into the DMX Out will correspond to the first DMX address (DMX channel) As you add channels to the DMX Out, you will access the next DMX channels in order. For example, if you input 12 channels into the DMX out, you will be controlling DMX channels 1 thru 12.\t\t\t\n\t\t\t\nThe DMX in TouchDesigner was developed on the [http://www.enttec.com ENTTEC] device, namely their [http://www.enttec.com/?main_menu=Products&pn=70304 DMX USB Pro] and DMX over Ethernet devices, but it should work for many devices and software that support DMX/Art-Net/sACN/KiNET.\t\t\t\n\t\t\t\nA Routing Table can be provided in a DAT where addresses can be specified by adding rows for each channel and specifying net, subnet and universe. \t\t\t\n\t\t\t\n'''ENTTEC NOTE:''' - Use ENTTEC's [http://www.enttec.com/us/products/controls/dmx-over-ethernet/nmu/ NMU (Node Management Utility)] to configure and inspect the ENTTEC devices found on your network. \t\t\t\n\t\t\t\n'''macOS NOTE:''' - ENTTEC USB Pro may not connect automatically, to enable it enter the following command in the Terminal:\t\t\t\n\t\t\t\n<code>sudo kextunload -b com.apple.driver.AppleUSBFTDI</code>\n\n'''Tip''': See the [[OP Snippets]] for setup and usage examples.\n\n'''Tip''': Use [https://www.wireshark.org/ WireShark] to watch your DMX network traffic.\n\t\t\t\n\t\t\t\nSee also: [[Art-Net]], [[sACN]], [[DMX In CHOP]], [[DMX]]",
        "opLabel": "DMX Out",
        "opClass": "dmxoutCHOP_Class",
        "opType": "dmxout",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The DMX Out CHOP sends channels to DMX, Art-Net, or [[sACN]] devices.",
        "opCategories": ""
    },
    "envelopeCHOP": {
        "label": "envelopeCHOP",
        "members": [
            {
                "text": "Menu : The two methods of calculating the envelope:",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "bounds",
                "items": []
            },
            {
                "text": "Float : The width of the window to use in the envelope calculation. Adjust this width to capture as many features of the input as needed. It is expressed in Units.",
                "type": "FloatPar",
                "name": "width",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "widthunit",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Toggle : Keeps the total power in the signal constant when adjusting the Envelope Width.",
                "type": "TogglePar",
                "name": "norm",
                "items": []
            },
            {
                "text": "Toggle : When On, the envelope can be resampled to the Sample Rate specified in the parameter below.",
                "type": "TogglePar",
                "name": "resample",
                "items": []
            },
            {
                "text": "Float : Set the sample rate to resample the envelope to when the Resample Envelope parameter above is On.",
                "type": "FloatPar",
                "name": "samplerate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Envelope CHOP outputs the maximum amplitude in the vicinity of each sample of the input. It takes the absolute value of the input, and uses a sliding window of a number of samples to find the maximum amplitude near each sample.\t\t\n\t\t\t\n'''Tip:''' The loudness levels of an audio track can be kept roughly constant by computing an envelope of the audio with a wide window, and then passing the original audio and the envelope to a [[Math CHOP]] and selecting '''Combine CHOPs - Divide'''. This will make the amplitude approximately 1.",
        "opLabel": "Envelope",
        "opClass": "envelopeCHOP_Class",
        "opType": "envelope",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Envelope CHOP outputs the maximum amplitude in the vicinity of each sample of the input.",
        "opCategories": ""
    },
    "etherdreamCHOP": {
        "label": "etherdreamCHOP",
        "members": [
            {
                "text": "Toggle : If turned off, the EtherDream CHOP will stop sending data to the EtherDream and will immediately clear its point buffer. Consider it equivalent to powering off the EtherDream.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : Set this parameter to the network address that both the EtherDream and the user's computer are connected to. It should have the following format: <code>xxx.xxx.xx.xxx</code>\n\t\t\nTo determine the required network address and to identify if the EtherDream is properly connected to the network, install and run the [http://ether-dream.com/downloads.html EtherDream Diagnostic Tool].",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : By default, the EtherDream uses TCP Port <code>7765</code>. Firewall settings may need to be adjusted to allow for the EtherDream CHOP to properly communicate with the EtherDream.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Float : Determines the queue size of the EtherDream point buffer and the corresponding time required to drain it. It is often useful to reduce this value when sending fewer points.",
                "type": "FloatPar",
                "name": "queuetime",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "queueunits",
                "items": []
            },
            {
                "text": "Float : Allows the input x values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "xscale",
                "items": []
            },
            {
                "text": "Float : Allows the input y values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "yscale",
                "items": []
            },
            {
                "text": "Float : Allows the input r values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "redscale",
                "items": []
            },
            {
                "text": "Float : Allows the input g values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "greenscale",
                "items": []
            },
            {
                "text": "Float : Allows the input b values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "bluescale",
                "items": []
            },
            {
                "text": "Toggle : If turned off, the EtherDream CHOP will stop sending data to the EtherDream and will immediately clear its point buffer. Consider it equivalent to powering off the EtherDream.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : Set this parameter to the network address that both the EtherDream and the user's computer are connected to. It should have the following format: <code>xxx.xxx.xx.xxx</code>\n\t\t\nTo determine the required network address and to identify if the EtherDream is properly connected to the network, install and run the [http://ether-dream.com/downloads.html EtherDream Diagnostic Tool].",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : By default, the EtherDream uses TCP Port <code>7765</code>. Firewall settings may need to be adjusted to allow for the EtherDream CHOP to properly communicate with the EtherDream.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Float : Determines the queue size of the EtherDream point buffer and the corresponding time required to drain it. It is often useful to reduce this value when sending fewer points.",
                "type": "FloatPar",
                "name": "queuetime",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "queueunits",
                "items": []
            },
            {
                "text": "Float : Allows the input x values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "xscale",
                "items": []
            },
            {
                "text": "Float : Allows the input y values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "yscale",
                "items": []
            },
            {
                "text": "Float : Allows the input r values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "redscale",
                "items": []
            },
            {
                "text": "Float : Allows the input g values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "greenscale",
                "items": []
            },
            {
                "text": "Float : Allows the input b values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "bluescale",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "EtherDream is a laser controller. The EtherDream CHOP takes as input up to five channels interpreted as X and Y (horizontal and vertical) position values in the first 2 channels, and red, green and blue color values in the next 3 channels. It outputs the data to an [http://ether-dream.com/ EtherDream] device via a network connection. The EtherDream device is connected to a laser using an ILDA cable. The user can then control the image that the laser should output using the EtherDream CHOP. Applications of the EtherDream CHOP include displaying computer-generated shape animations or other special effects of a light show.\t\n\t\t\nThe EtherDream CHOP needs the IP address of the EtherDream device, which you can get from the output of an [[EtherDream DAT]].\t\t\n\t\t\nBlanking (all-off) occurs when the incoming RGB CHOP channels are all zero, or the Red Scale, Green Scale, and Blue Scale parameters are all zero.\t\t\n\t\t\nIt is sometimes helpful to have additional information with respect to the general state of the hardware, whether any warnings are generated by the connected devices, how well the EtherDream is receiving points, the point output rate, and the point buffer capacity. Such details can be seen by connecting the EtherDream CHOP to an [[Info CHOP]], and may be useful for troubleshooting display images.\t\t\n\t\t\nThe <code>maxrate</code> column of the EtherDream DAT indicates the maximum number of samples per second that can be sent to the EtherDream device, though in practice, most lasers are reflected into position by a set of mechanical reflectors, with their own mechanical characteristics.  As a result, attempting to quickly scan a square over a large area too quickly, for example, may result in a very curved corners as the physical components lag behind their target positions.\t\t\n\t\t\nLarge changes in RGB values from sample-to-sample will likely be visibly correct as lasers generally can switch on-off quickly.\t\t\n\t\t\nThe range of X and Y is typically -1 to +1, and the range of RGB is typically 0 to 1.\t\t\n\t\t\nIf <code>maxrate</code> is 100,000, and given that the CHOP takes time-sliced data, it is appropriate to send a time-sliced CHOP with a sample rate of up to 100,000 samples per second to the EtherDream CHOP.\t\t\n\t\t\nSee also: [[EtherDream DAT]], [[Laser CHOP]], and the [[Pattern CHOP]], [[Helios DAC CHOP]].",
        "opLabel": "EtherDream",
        "opClass": "etherdreamCHOP_Class",
        "opType": "etherdream",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "EtherDream is a laser controller.",
        "opCategories": ""
    },
    "eventCHOP": {
        "label": "eventCHOP",
        "members": [
            {
                "text": "Str : The sequence # of the event, starting from 0 and incrementing by 1 for each event.",
                "type": "StrPar",
                "name": "id",
                "items": []
            },
            {
                "text": "Str : The channel index of the incoming CHOP that caused the event.",
                "type": "StrPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Str : While the input is greater than 0 this channel goes to 1, ie when the input channel goes \"On\".",
                "type": "StrPar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The value of the input channel when the input went on (at the birth of the event). It is often the note velocity value. If you pass the Midi In CHOP into the Event CHOP, and set the Midi In option to output the velocity, velocity will end up in this channel and preserved until the event ends.",
                "type": "StrPar",
                "name": "input",
                "items": []
            },
            {
                "text": "Str : Time in seconds from the start of the event.",
                "type": "StrPar",
                "name": "time",
                "items": []
            },
            {
                "text": "Str : The value according to the Attack, Decay, Sustain, Release. It uses the parameters on the ADSR page, regulating the speed and values, with extended parameters: Attack Time, Attack Level, Decay Time, Sustain Time, Sustain Min, Sustain Max, Release Time, Release Level.",
                "type": "StrPar",
                "name": "adsr",
                "items": []
            },
            {
                "text": "Str : This is good for playing back movies. You divide your movie into 4 parts that correspond to the (0=attack, 1=decay, 2=sustain, 3=release) phases. The state channel outputs fractional values, so you can watch it climb through all the transitions, including multiple sustain-sections. e.g., 0...1...2...2...2...2...3...4. If your movie is 8 seconds long, take the state channel and multiply by 2, passing it as the time-index of the movie.\t\nGoes from 0 to 1 during the attack phase, 1 to 2 as it repeats in the sustain phase, and 2 to 3 in the release phase. It is suitable for indexing movies.",
                "type": "StrPar",
                "name": "state",
                "items": []
            },
            {
                "text": "Menu : Determines the reset behavior of using the 2nd Input Reset Trigger. This parameter is only active if there is an input connected to the CHOP's 2nd input.",
                "type": "MenuPar",
                "name": "resetcondition",
                "items": []
            },
            {
                "text": "Toggle : When set to 'On' it resets the CHOP clearing all events.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Immediately resets the CHOP and clears all events in the frame it was clicked.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "DAT : The path to a DAT containing onCreate() and onDestroy() callbacks for each event.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Float : Affects <code>adsr</code> and <code>state</code> channel. Time to rise to max attack level.",
                "type": "FloatPar",
                "name": "attacktime",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "attacktunit",
                "items": []
            },
            {
                "text": "Float : Affects <code>adsr</code> channel. Peak attack level.",
                "type": "FloatPar",
                "name": "attacklevel",
                "items": []
            },
            {
                "text": "Float : Affects <code>adsr</code> channel and <code>state</code> channel. Time after peak to sustain level.",
                "type": "FloatPar",
                "name": "decaytime",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "decaytunit",
                "items": []
            },
            {
                "text": "Float : Affects <code>adsr</code> channel.",
                "type": "FloatPar",
                "name": "sustaintime",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "sustaintunit",
                "items": []
            },
            {
                "text": "Float : Affects <code>adsr</code> channel. Level at start of sustain time.",
                "type": "FloatPar",
                "name": "sustainmin",
                "items": []
            },
            {
                "text": "Float : Affects <code>adsr</code> channel. Level at end of sustain time.",
                "type": "FloatPar",
                "name": "sustainmax",
                "items": []
            },
            {
                "text": "Float : Affects <code>adsr</code> and <code>state</code> channels.",
                "type": "FloatPar",
                "name": "releasetime",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "releasetunit",
                "items": []
            },
            {
                "text": "Float : Affects <code>adsr</code> channel. Level at end of life cycle.",
                "type": "FloatPar",
                "name": "releaselevel",
                "items": []
            },
            {
                "text": "Float : Affects the speed of the event, letting you stretch out or shorten the life of an event.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "globalspeed",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Event CHOP manages the birth and life of overlapping events triggered by devices like a MIDI keyboard. It can be seen as a simple particle system designed for MIDI keyboards.\t\t\n\t\t\t\nThe Event CHOP generates one sample for each off-to-on event in the input channels, which would often come from a [[MIDI In CHOP]], [[MIDI In Map CHOP]], [[Keyboard In CHOP]], or python events sent to the Event CHOP. The sample exists for the duration of the event's attack+decay+sustain+release time.\t\t\t\n\t\t\t\n'''NOTE''': See the examples in Help->[[OP Snippets]]\t\t\t\n\t\t\t\nThe Event CHOP can used to follow a polyphonic music keyboard with MIDI velocity, and can generate generating one object, polygon or geometry instance for each event. It assures the object, polygon or instance exists until the event ends after an attack-decay-sustain-release phase. The Event CHOP is often fed through other OPs to the Instance parameters of a Geometry component.\t\t\t\n\t\t\t\nThe Event CHOP outputs up to 8 channels, with one sample generated per off-to-on event that is active. The sample is active until the attack-decay-sustain-release is over, at which moment the sample disappears (like particle death).\t\t\t\n\t\t\t\nWatch the channel graph of the Event CHOP to understand what it is doing. It can be sent to a [[Limit SOP]] or a [[CHOP to SOP|Channel SOP]] to place geometry for each event. You can send event information to the SOP via the Event CHOP channels that get transformed into geometry channels like <code>tx</code>, <code>ty</code>, <code>scale</code>, texture v (giving movie time offsets), alpha, r, g and b colors.\t\t\t\n\t\t\t\nOn a MIDI keyboard, you can trigger many events simultaneously, and, like particles, you may want to launch objects that remain in existence the next time you press the same key.\t\t\t\n\t\t\t\nThe Event CHOP is designed to handle this. It creates one sample every time you press any key, and that sample lives for any length of time. This CHOP is lightweight - the minimum number of channels and samples are created, even with 88-key MIDI keyboards and lots of pounding on the keyboard.\t\t\t\n\t\t\t\nThere are channels that represent age, note number and MIDI velocity when you pressed the key, as well as a flag telling if the key has since been released.\t\t\t\n\t\t\t\nEach event has a unique ID, held in the <code>id</code> channel that can be used to generate random XY displacements of each note, for example.\t\t\t\n\t\t\t\nA movie index is set by the <code>state</code> channel which rises from 0 to 1 and loops between 1 to 2 continuously until the note goes into its release state at which time it goes from 2 to 3. So for a bird cycle, you use the 0 to 1 state for the jump phase, 1 to 2 for the flappin in flight phase, and 2 to 3 for the landing phase.\t\t\t\n\t\t\t\nThe Event CHOP's 1st input is for event triggers.\t\t\t\n\t\t\t\nThe 2nd input resets the triggers.\t\t\t\n\t\t\t\nThe 3rd input is optional and allows for sampling values for each event.\t\t\t\n\t\t\t\nSee also: [[Timer CHOP]], [[Count CHOP]], [[Speed CHOP]], [[Trigger CHOP]]",
        "opLabel": "Event",
        "opClass": "eventCHOP_Class",
        "opType": "event",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Event CHOP manages the birth and life of overlapping events triggered by devices like a MIDI keyboard.",
        "opCategories": ""
    },
    "expressionCHOP": {
        "label": "expressionCHOP",
        "members": [
            {
                "text": "Int : The number of channels that use the current expression before the next expression is selected.",
                "type": "IntPar",
                "name": "chanperexpr",
                "items": []
            },
            {
                "text": "Toggle : Turn On this parameter to limit the number of channels the Expression CHOP will output.",
                "type": "TogglePar",
                "name": "limitexpr",
                "items": []
            },
            {
                "text": "Int : When the above parameter is On, set the maximum number of channels to output.",
                "type": "IntPar",
                "name": "limitnum",
                "items": []
            },
            {
                "text": "Float : Enter your expressions here. The input values are <code>me.inputVal</code> in the expressions. <code>me.inputs[1]['chan1']</code> gets from the channel <code>chan1</code> of the second input.",
                "type": "FloatPar",
                "name": "expr0",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Expression CHOP allows you to modify input channels by using math expressions. Each input channel is modified by exactly one expression, and the expressions are looped for multiple channels.\t\n\t\t\nThe output is the same length and set of channels as the first input, but its sample values are changed according to the expressions.\t\t\n\t\t\nAn expression is applied to each keyframe value or raw sample. If there are more channels coming from input 0 than expressions, the expressions are recycled. A Channels per Expression parameter controls how many channels to apply the first expression to before going on to the second expression.\n\t\t\nThe corresponding input values are <code>me.inputVal</code> in the expressions. <code>me.inputs[1][0]</code> gets from the first channel of the second input.\t\t\n\t\t\nSee also [[Evaluate DAT]] for easy evaluation of any expression.",
        "opLabel": "Expression",
        "opClass": "expressionCHOP_Class",
        "opType": "express",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Expression CHOP allows you to modify input channels by using math expressions.",
        "opCategories": ""
    },
    "extendCHOP": {
        "label": "extendCHOP",
        "members": [
            {
                "text": "Menu : The extend condition before the CHOP interval. They are:",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : Extend condition after the interval. Same options as Extend Left.",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Extend CHOP only sets the \"extend conditions\" of a CHOP, which determines what values you get when sampling the CHOP before or after its interval.\t\t\n\t\t\t\nThe Extend CHOP has separate menus to control both the pre-interval and the post-interval. For example, before the interval, you may want to hold a constant value, and after the interval you may want to cycle or repeat the curves in the interval.\t\t\t\n\t\t\t\nTo shorten or lengthen the interval (the start or end of the CHOP), use the [[Trim CHOP]].\t\t\t\n\t\t\t\nYou can see the state of Extend Conditions in the pop-up info of any CHOP (use middle-mouse click on the CHOP).",
        "opLabel": "Extend",
        "opClass": "extendCHOP_Class",
        "opType": "extend",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Extend CHOP only sets the \"extend conditions\" of a CHOP, which determines what values you get when sampling the CHOP before or after its interval.",
        "opCategories": ""
    },
    "facetrackCHOP": {
        "label": "facetrackCHOP",
        "members": [
            {
                "text": "Toggle : Enables the face tracking features.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Folder : The location of the AI model files used for face detection. By default these files are located in the Config/Models folder.",
                "type": "FolderPar",
                "name": "modelfolder",
                "items": []
            },
            {
                "text": "File : The 3D morphable mesh file in Nvidia 'nvf' format to use in mesh fitting. See above for instructions on how to create a compatible file. When available, the fitted mesh can be accessed with a [[Face Track SOP]].",
                "type": "FilePar",
                "name": "meshfile",
                "items": []
            },
            {
                "text": "Menu : The GPU to run the face tracking models on. An Nvidia RTX or newer card is required.",
                "type": "MenuPar",
                "name": "gpu",
                "items": []
            },
            {
                "text": "TOP : A path to the TOP operator that will provides the image to perform face tracking on.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Toggle : Output channels that describe a bounding box around the detected face. The channels give the u and v positions of the center of the face as well as the width and height of the box. The positions are relative to the bottom-left corner of the input image.",
                "type": "TogglePar",
                "name": "bbox",
                "items": []
            },
            {
                "text": "Toggle : Outputs a channel that describes the level of certainty that the AI model has detected a face in the input image. Higher numbers indicate greater confidence.",
                "type": "TogglePar",
                "name": "bboxconfidence",
                "items": []
            },
            {
                "text": "Toggle : Output rx, ry, and rz values that indicate how the face is oriented in the image. (0,0,0) indicates that the face is oriented directly towards the camera. Values can range from +/- 180 degrees as the subject turns away from the camera.",
                "type": "TogglePar",
                "name": "rotations",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "landmarks",
                "items": []
            },
            {
                "text": "Toggle : Adds a confidence value for each landmark feature. Higher values indicate the feature is more likely to be accurate.",
                "type": "TogglePar",
                "name": "landmarkconfidence",
                "items": []
            },
            {
                "text": "Toggle : Enable to output translate, rotate and scale channels for the fitted face mesh. This feature requires a valid 3D morphable face mesh file (see notes above). The values from these channels can be used to transform the mesh produced by an attached [[Face Track SOP]] so that it aligns with the input image. By default the fitted mesh is pre-transformed to align with the image, but if 'Pre-Transform' is disabled in the SOP, these values can be used instead for more control and speed.",
                "type": "TogglePar",
                "name": "meshtransform",
                "items": []
            },
            {
                "text": "Toggle : Rescales the the u and v positions so that they have the correct aspect ratio of the input image. This is useful when using the u, v positions as 3D coordinates rather than as image positions.",
                "type": "TogglePar",
                "name": "aspectcorrectuv",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "facetrackCHOP",
        "opLabel": "Face Track",
        "opClass": "facetrackCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This operator uses the Augmented Reality (AR) SDK of the Nvidia Maxine system and requires a 20 or 30 series Nvidia RTX card to operate. 40 series cards are not currently supported.",
        "short": "The Face Track CHOP can detect faces and facial landmarks in a given image stream.",
        "long": "The Face Track CHOP can detect faces and facial landmark points in an image, as well as the direction the face is looking relative to the camera. Using a compatible 3D Morphable Face Model (3DMM) and the [[Face Track SOP]], it can also be used to fit and animate a 3D mesh to the detected face.\n    \nThe input image is taken from a provided TOP and can be of any resolution or format, and either a still image or video. If multiple faces are present in an image, the CHOP will attempt to track the largest one detected.\n\nThe coordinates of the detected features are given in u, v positions relative to the bottom-left corner of the input image. By default, the values range from 0 to 1, but the 'Aspect Correct' parameter can be enabled to scale the values so that they can be used as 3D coordinates while maintaining the aspect ratio of the original image.\n\nTo align a 3D rendering of the points with the original input image, set the 'Projection' of your [[Camera COMP]] to 'Orthographic', the 'Ortho Origin' parameter to 'Bottom-Left', and the 'Ortho Width' to 1, while also enabling 'Aspect Correct' on the Face Track CHOP.\n\nTo use the mesh fitting features you will need a compatible face mesh file in the Nvidia 'nvf' format. This file is not included with TouchDesigner, but can be generated using files available online. \n\nTo create the file:\n\n1. Download the Surrey Face Model files from the [https://github.com/patrikhuber/eos/tree/master/share eos project on GitHub]:\n* ''sfm_shape_3448.bin''\n* ''expression_blendshapes_3448.bin''\n* ''sfm_3448_edge_topology.json''\n* ''sfm_model_contours.json''\n* ''ibug_to_sfm.txt''\n\n2. Download the mesh conversion tool ''ConvertSurreyFaceModel.exe'' from the [https://github.com/NVIDIA/BROADCAST-AR-SDK/tree/master/tools Nvidia AR SDK page on GitHub]\n\n3. Run the conversion tool to generate the nvf file. The 'path' is only necessary if the model files are in a different folder than the conversion tool.\n<syntaxhighlight lang=python>\nConvertSurreyFaceModel.exe \n--shape=<i>path/</i>sfm_shape_3448.bin\n--blend_shape=<i>path/</i>expression_blendshapes_3448.bin\n--topology=<i>path/</i>sfm_3448_edge_topology.json\n--contours=<i>path/</i>sfm_model_contours.json\n--ibug=<i>path/</i>ibug_to_sfm.txt\n--out=<i>output-path/</i>face_model0.nvf</syntaxhighlight>",
        "opCategories": ""
    },
    "fanCHOP": {
        "label": "fanCHOP",
        "members": [
            {
                "text": "Menu : Selects either Fan In or Fan Out.",
                "type": "MenuPar",
                "name": "fanop",
                "items": []
            },
            {
                "text": "Str : The names for the output channels that this CHOP creates. This also controls how many output channels are created (one for each name) in Fan Out mode. In Fan In mode, only one channel is created, and its name is the base name (minus the number suffix) of the first input channel.",
                "type": "StrPar",
                "name": "channame",
                "items": []
            },
            {
                "text": "Menu : Determines how to handle input values that are outside the index range (0 to N-1).",
                "type": "MenuPar",
                "name": "range",
                "items": []
            },
            {
                "text": "Menu : For a Fan In operation, when all input channels are off, set the output to -1 or 0.",
                "type": "MenuPar",
                "name": "alloff",
                "items": []
            },
            {
                "text": "Toggle : On by default. Channels are quatized to the nearest integer. For example, if the input channel's value is 5.6 and 6 channels are created, channel 5 is 1, while the rest are 0.",
                "type": "TogglePar",
                "name": "quantize",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Fan CHOP converts one channel out to many channels, or converts many channels down to one.\t\t\n\t\t\t\nIts first operation, '''Fan Out''', takes one channel and generates 2 or more channels. It sets to 1 one of the output channels while all others are 0, based on the input channel's value. The first output channel is index value 0, the second, 1, and so on. If the input value is above N-1 or below 0, the value can be clamped, cycled or ignored.\t\t\t\n\t\t\t\nFor example, if the value of the input channel at a certain frame is 4, and if the CHOP outputs 8 channels, the fifth channel will have a value of 1, and all other channels will have a zero value at that frame.\t\t\t\n\t\t\t\nThe input is assumed to have 1 channel which contains integer values; fractions are truncated and extra channels are ignored. The output channels are binary (0 or 1) channels.\t\t\t\n\t\t\t\nThe second operation, '''Fan In''', does the opposite: it takes a bunch of binary inputs and produces one channel containing the index of the \"On\" channel. If more than one input channel is \"On\", the first \"On\" input channel is selected.",
        "opLabel": "Fan",
        "opClass": "fanCHOP_Class",
        "opType": "fan",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Fan CHOP converts one channel out to many channels, or converts many channels down to one.",
        "opCategories": ""
    },
    "feedbackCHOP": {
        "label": "feedbackCHOP",
        "members": [
            {
                "text": "Menu : Choose what to output from this menu.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Toggle : Time differential during feedback. If on, it adds a 'dt' channel whose value is the elapsed time since the last cook.",
                "type": "TogglePar",
                "name": "delta",
                "items": []
            },
            {
                "text": "Toggle : Activates feedback when set to 0. Disables feedback when set to 1. When disabled, the Feedback CHOP passes thru the data connected to its input.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Resets the feedback in a single frame when clicked.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Feedback CHOP stores channels from the current frame to be used in a later frame, without forcing recooking back one frame. It allows you to get the state of a CHOP as it was one frame or time slice ago.\t\t\n\t\t\t\nFor example, if you need the position or speed of an object from a frame ago in order to compute its position, displacement or speed at the current frame, you would select a CHOP containing those values, and it will output it a frame or time slice later.\t\t\t\n\t\t\t\nCHOPs like the [[Lag CHOP]] and [[Filter CHOP]] look back in time (iterate) internal to the CHOP, but sometimes the output of a chain of CHOPs is needed as the input of the same chain one frame later.\t\t\t\n\t\t\t\nIt allows connecting CHOPs in circular loops without '''Infinite Recursion''' errors. It simply copies its input without cooking it first.",
        "opLabel": "Feedback",
        "opClass": "feedbackCHOP_Class",
        "opType": "feedback",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Feedback CHOP stores channels from the current frame to be used in a later frame, without forcing recooking back one frame.",
        "opCategories": ""
    },
    "fileinCHOP": {
        "label": "fileinCHOP",
        "members": [
            {
                "text": "File : The name of the file to load. Use http:// when specifying a URL.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Menu : Use this menu to control the names of the loaded channels.",
                "type": "MenuPar",
                "name": "nameoption",
                "items": []
            },
            {
                "text": "Str : Used to name the channels when the Name Options parameter is set to Use New Names.",
                "type": "StrPar",
                "name": "name",
                "items": []
            },
            {
                "text": "Menu : Use this menu to adjust the sample rate of the loaded channels.",
                "type": "MenuPar",
                "name": "rateoption",
                "items": []
            },
            {
                "text": "Float : Samples per second, as utilized by the Rate Options parameter.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            },
            {
                "text": "StrMenu : The channel pattern to rename. See [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "renamefrom",
                "items": []
            },
            {
                "text": "StrMenu : The replacement pattern for the names. The default parameters do not rename the channels. See [[Pattern Replacement]].",
                "type": "StrMenuPar",
                "name": "renameto",
                "items": []
            },
            {
                "text": "Str : Scopes channels to apply the Override Value to.",
                "type": "StrPar",
                "name": "overridpattern",
                "items": []
            },
            {
                "text": "Float : The value given to channels scope by the Value Override Pattern parameter above.",
                "type": "FloatPar",
                "name": "overridevalue",
                "items": []
            },
            {
                "text": "Toggle : Reload the file when this parameter is set to On.",
                "type": "TogglePar",
                "name": "refresh",
                "items": []
            },
            {
                "text": "Pulse : Instantly reload the file from disk.",
                "type": "PulsePar",
                "name": "refreshpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The File In CHOP reads in channel and audio files for use by CHOPs. The file can be read in from disk or from the web. Use <code>http://</code> when specifying a URL.\t\t\n\t\t\t\n===<div class=\"subSectionLineCHOP\">Valid Formats</div>===\t\t\t\n\t\t\t\nFor a complete listing of all valid formats for CHOPs, see the [[File Types]] section. The types of files that can be read into CHOPs include:\t\t\t\n\t\t\t\n* <code>'''.chan'''</code> - Raw ASCII channel files; a row of numbers per frame. The channels are named automatically.\t\t\t\n* <code>'''.clip .bclip'''</code> - TouchDesigner native CHOP clip files.\t\t\t\n* <code>'''.aiff'''</code> - Audio files.\t\t\t\n* <code>'''.wav'''</code> - Audio files.\t\t\t\n\t\t\t\n===<div class=\"subSectionLineCHOP\"> Outputting Channel Files </div>===\t\t\t\n\t\t\t\nThe same files can be output from the [[Mouse Click|RMB]] menu on the CHOP by selecting '''Save Data Channels'''.\t\t\t\n\t\t\t\n===<div class=\"subSectionLineCHOP\"> Other Input Devices </div>===\t\t\t\n\t\t\t\nFor MIDI files (<code>.mid</code> or <code>.midi</code>), see the [[MIDI In CHOP]].",
        "opLabel": "File In",
        "opClass": "fileinCHOP_Class",
        "opType": "filein",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The File In CHOP reads in channel and audio files for use by CHOPs.",
        "opCategories": ""
    },
    "fileoutCHOP": {
        "label": "fileoutCHOP",
        "members": [
            {
                "text": "Toggle : When this parameter is set to 1, the file will be written to at the interval specified above.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "File : Sets the path and filename of the file that is saved out.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Int : Sets the number of frames between each write of data into the file.",
                "type": "IntPar",
                "name": "interval",
                "items": []
            },
            {
                "text": "Pulse : Click this button to write out a single frame.",
                "type": "PulsePar",
                "name": "write",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The File Out CHOP writes CHOP channel data out to .chan files. The data can be written out every frame or at intervals (set by the Interval parameter) into a log file. \t\n\t\t\n* <code>'''.chan'''</code> format - Raw ASCII channel files; a row of numbers per frame. The channels are named automatically.",
        "opLabel": "File Out",
        "opClass": "fileoutCHOP_Class",
        "opType": "fileout",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The File Out CHOP writes CHOP channel data out to .chan files.",
        "opCategories": ""
    },
    "filterCHOP": {
        "label": "filterCHOP",
        "members": [
            {
                "text": "Menu : There are seven types of filters:",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Float : The extent to which the filter affects the channel (0 - not at all, 1 - maximum effect).",
                "type": "FloatPar",
                "name": "effect",
                "items": []
            },
            {
                "text": "Float : The amount of surrounding samples used in the calculation of the current sample. It is expressed in the Units.",
                "type": "FloatPar",
                "name": "width",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "widthunit",
                "items": []
            },
            {
                "text": "Float : For the De-spike filter type, this is the amount that a sample can differ from its neighbours without being considered a spike.",
                "type": "FloatPar",
                "name": "spike",
                "items": []
            },
            {
                "text": "Float : When using a Ramp Preserve filter, if the input value deviates from the current output ramp value by this much, then the ramp will reset to the new input value. Otherwise the Ramp Preserve will continue climbing at the specified 'Ramp Rate'.",
                "type": "FloatPar",
                "name": "ramptolerance",
                "items": []
            },
            {
                "text": "Float : When using a Ramp Preserve filter, this is the rate that the CHOP's output channel will increase. Only if the input channel value deviates from the desired output value by 'Ramp Tolerance' amount will the CHOP instead output the input channel value.",
                "type": "FloatPar",
                "name": "ramprate",
                "items": []
            },
            {
                "text": "Int : The number of times the filter is applied to the channel.",
                "type": "IntPar",
                "name": "passes",
                "items": []
            },
            {
                "text": "Toggle : Applies the filter to each sample of the channel instead of across the whole channel. Useful for working with multi-sample channels.",
                "type": "TogglePar",
                "name": "filterpersample",
                "items": []
            },
            {
                "text": "Float : Decrease it if slow speed jitter is a problem.",
                "type": "FloatPar",
                "name": "cutoff",
                "items": []
            },
            {
                "text": "Float : Increase if high speed lag is a problem.",
                "type": "FloatPar",
                "name": "speedcoeff",
                "items": []
            },
            {
                "text": "Float : Avoids high derivative bursts caused by jitter.",
                "type": "FloatPar",
                "name": "slopecutoff",
                "items": []
            },
            {
                "text": "Toggle : When On resets (bypasses) the filter effect.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly resets the filter effect.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Filter CHOP smooths or sharpens the input channels. It filters by combining each sample and a range of its neighbor samples to set the new value of that sample. Each filter type uses its own weighting factors for the neighboring samples. The <span class=\"tipTextCHOP\">Filter Width</span> determines the number of neighbors to use.\t\t\n    \nThe default Gaussian filter nicely smooths out data, typically with a Filter Width around .3 seconds. The Box Filter is interesting when your inputs are step changes to new values: the values linearly interpolate to the new value. \n\nIt is useful to follow the Filter CHOP with a [[Trail CHOP]] and connect the filtered and pre-filtered signal to its inputs.\n\nIf you want to pass one or more channels in, each with multi-samples, and you want to filter each sample as if each sample was its own filter, turn on the Filter per Sample parameter. \n\t\t\t\nFor a similar, more-abrupt effect, see the [[Lag CHOP]].\t\t\t\n\t\t\t\nThe Filter CHOP can filter both motion and sound, but other CHOPs are more appropriate for filtering sound (see the [[Audio Filter CHOP]], [[Band EQ CHOP]], and [[Parametric EQ CHOP]]).",
        "opLabel": "Filter",
        "opClass": "filterCHOP_Class",
        "opType": "filter",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Filter CHOP smooths or sharpens the input channels.",
        "opCategories": ""
    },
    "freedCHOP": {
        "label": "freedCHOP",
        "members": [
            {
                "text": "Toggle : While On, the CHOP receives FreeD information sent to the network port. While Off, no updating occurs.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : The network protocol to use. Refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : When using Multicast, this is the address that FreeD will listen for packets on.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port which FreeD will accept packets on.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to receive on, useful when the system has mulitple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "freedCHOP",
        "opLabel": "FreeD",
        "opClass": "freedCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The FreeD CHOP reads incoming camera tracking data sent over a network using the FreeD protocol and outputs CHOP channels that can be used to control a virtual 3D camera.",
        "long": "The FreeD CHOP reads incoming camera tracking data sent over a network using the FreeD protocol and outputs CHOP channels that can be used to control a virtual 3D camera. FreeD is not exclusive to any particular tracking system, but is frequenty used as an interchange protocol since it is supported by a wide range of hardware and software. However, as an older standard, it is lower precision and does not contain len distortion data like [[Stype In CHOP|Stype]] or [[Ncam CHOP|Ncam]], so it is recommended to use the hardware specific protocol when possible. Examples of hardware and software that support FreeD are [https://www.vizrt.com/products/viz-virtual-studio Viz Virtual Studio] and [https://na.panasonic.com/us/ar-vr-virtual-set-production-with-panasonic-robotic-ptz-camera Panasonic PTZ cameras.] \n\nThe channels exported by the FreeD CHOP are:\n:''camera_id'' - a number from 0 - 255 that can be used to store an id number for the camera\n:''tx, ty, tz'' - camera position, can be connected to the [[Camera COMP]] Translate parameters\n:''rx, ry, rz'' - camera rotation, can be connected to the [[Camera COMP]] Rotate parameters\n:''focus'' - a 24-bit positive integer (0-16 million) in arbitrary units that relates to the focus ring on a camera lens. Applications can interpret this value according to the hardware in use.\n:''zoom'' - a 24-bit positive integer (0-16 million) in arbitrary units that relates to the zoom ring on a camera lens. Applications can interpret this value according to the hardware in use.\n:''user'' - a 16-bit positive integer (0 - 65k) that can be used by the camera system to send custom user-defined data\n\n'''Note:''' The FreeD CHOP only processes the 'D1' camera position and orientation message that is part of the FreeD protocol. All other message types will be ignored.\n\nFor more information or to diagnose connection problems, an [[Info CHOP]] can be connected to see if any packets have been dropped or skipped.",
        "opCategories": ""
    },
    "freedoutCHOP": {
        "label": "freedoutCHOP",
        "members": [
            {
                "text": "Toggle : Turn this parameter off to stop sending out data packets.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Selects the network protocol to use. Refer to the Network Protocols article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : The network address of the computer to send the Stype data to. The address can be a domain name, an IP address (e.g. 100.123.45.78), or \"localhost\" to target the packets at another program on the same machine.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port to send the data packets to.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to send from. This is useful when the system has multiple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "freedoutCHOP",
        "opLabel": "FreeD Out",
        "opClass": "freedoutCHOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "",
        "long": "The FreeD Out CHOP sends camera tracking information, including position and orientation, to an external device or program over the network using the popular device-indepedent FreeD protocol. This can be used to emulate a physical camera or to send data to another program/device that can process FreeD tracking data. Data packets are sent out once per frame based on the current data in the CHOP channels. If one of the expected channels is not found in the input, then a default value will be sent. FreeD data can be received from other devices using the corresponding [[FreeD In CHOP]].\n  \nThe channels used by the FreeD Out CHOP are:\n:''camera_id'' - a number from 0 - 255 that can be used to store an id number for the camera\n:''tx, ty, tz'' - camera position, can be connected to the [[Camera COMP]] Translate parameters. Values can range from +/- 131.07m.\n:''rx, ry, rz'' - camera rotation, can be connected to the [[Camera COMP]] Rotate parameters. Values can range from +/- 256 degrees.\n:''focus'' - a 24-bit positive integer (0-16 million) in arbitrary units that relates to the focus ring on a camera lens. Applications can interpret this value according to the hardware in use.\n:''zoom'' - a 24-bit positive integer (0-16 million) in arbitrary units that relates to the zoom ring on a camera lens. Applications can interpret this value according to the hardware in use.\n:''user'' - a 16-bit positive integer (0 - 65k) that can be used by the camera system to send custom user-defined data\n\n'''Note:''' The FreeD Out CHOP sends the 'D1' camera position and orientation message that is part of the FreeD protocol."
    },
    "functionCHOP": {
        "label": "functionCHOP",
        "members": [
            {
                "text": "Menu : Which math function to apply to the channels. All of the functions are unary functions except for the binary functions 'arctan (Input1/Input2)' and 'Input1 ^ Input2'. In the cases of power functions, a negative base is inverted first to avoid imaginary numbers, and the result is negated.",
                "type": "MenuPar",
                "name": "func",
                "items": []
            },
            {
                "text": "Float : The value of the base for 'Log base N' and 'Base ^ Input1'. parameter name <code>/baseval</code>",
                "type": "FloatPar",
                "name": "baseval",
                "items": []
            },
            {
                "text": "Float : The value of the exponent for <code>'Input1 ^ Exponent'</code>. channel name <code>/expval</code>",
                "type": "FloatPar",
                "name": "expval",
                "items": []
            },
            {
                "text": "Menu : For trigonometric functions, the angles can be measured in Degrees, Radians, or Cycles (0 to 1).",
                "type": "MenuPar",
                "name": "angunit",
                "items": []
            },
            {
                "text": "Menu : How to pair channels together from the two inputs for the binary functions, by name or by channel index.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Menu : How to correct samples with math errors:",
                "type": "MenuPar",
                "name": "error",
                "items": []
            },
            {
                "text": "Float : Value to use when an infinity error occurs. Caused by sinh(), cosh() and tan().",
                "type": "FloatPar",
                "name": "pinfval",
                "items": []
            },
            {
                "text": "Float : Value to use when a negative infinity error occurs. Caused by sinh() and tan().",
                "type": "FloatPar",
                "name": "ninfval",
                "items": []
            },
            {
                "text": "Float : Value to use when a domain error occurs. Caused by asin(), acos(), log10(), logN(), ln() and sqrt().",
                "type": "FloatPar",
                "name": "domval",
                "items": []
            },
            {
                "text": "Float : Value to use when a divide by zero error occurs. Caused by pow(x,y).",
                "type": "FloatPar",
                "name": "divval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Function CHOP provides more complicated math functions than found in the [[Math CHOP]] : trigonometic functions, logarithmic functions and exponential functions, and also audio decibels (dB)-power-amplitude conversions.\t\t\n\t\t\t\nMost of the functions require only one parameter, and they are applied as a unary operator to each input channel. Some functions take two parameters, and these require the use of the second input. The first parameter, X, is always a value from a channel in the first input. The second parameter, Y, is a value from a corresponding channel in the second input. Channels from each input are paired by name or index.\t\t\t\n\t\t\t\nSince many of these functions can produce math errors, an error handling tab is provided for error handling and recovery. \t\t\t\nErrors can be handled by replacing the bad sample with a pre-defined value or by using the value of the previous sample. Alternatively, cooking can be aborted upon error for debugging networks.\t\n\nFunction types in decibels: as you would employ for audio or other signal strengths. -10dB means 1/10 the power, -20dB means 1/100 the power. It turns out that each 3dB means almost exactly double the power, so +12dB is 2*2*2*2 = 16 times the power. Power is proportional to the square of the amplitude. So -20dB means 1/10 the amplitude, and 6dB is double the amplitude.",
        "opLabel": "Function",
        "opClass": "functionCHOP_Class",
        "opType": "function",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Function CHOP provides more complicated math functions than found in the [[Math CHOP]] : trigonometic functions, logarithmic functions and exponential functions, and also audio decibels (dB)-power-amplitude conversions.",
        "opCategories": ""
    },
    "gestureCHOP": {
        "label": "gestureCHOP",
        "members": [
            {
                "text": "Menu : Controls the gesture playback.",
                "type": "MenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "Toggle : When on the captured gesture will be extended or trimmed to be a multiple of the Beats Per Cycle.",
                "type": "TogglePar",
                "name": "fitmethod",
                "items": []
            },
            {
                "text": "Int : Specifies the number of beats to cycle the recorded animation around. If the recorded animation is longer than a multiple of the Beats Per Cycle, it will loop at that multiplied length.",
                "type": "IntPar",
                "name": "numbeats",
                "items": []
            },
            {
                "text": "Toggle : If on, the cycled animation will adjust up or down each iteration to avoid jumps when looping to the beginning.  For example, it would turn a simple 0-1 ramp gesture into a continuously increasing line.",
                "type": "TogglePar",
                "name": "step",
                "items": []
            },
            {
                "text": "Toggle : When On and you re-record a gesture, the step will be zeroed.",
                "type": "TogglePar",
                "name": "stepreset",
                "items": []
            },
            {
                "text": "Float : How much of the recorded segment to use as a blend region. The blend region is used to blend the beginning of the segment to the end so that a seemless loop is produced.",
                "type": "FloatPar",
                "name": "blend",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "blendunit",
                "items": []
            },
            {
                "text": "Toggle : If on, recorded samples are interpolated when scaling occurs, otherwise the nearest sample is selected.",
                "type": "TogglePar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Float : Scales the rate of playback for the segment.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "speedunit",
                "items": []
            },
            {
                "text": "Menu : This menu determines how the Reset input (the third input) triggers a reset of the channel(s).",
                "type": "MenuPar",
                "name": "resetcondition",
                "items": []
            },
            {
                "text": "Toggle : Resets the gesture while On when in '''Sequential''' <span class=\"tipTextCHOP\">Play Mode</span>.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Resets the gesture.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Gesture CHOP records a short segment of the first input and loops this segment in time with options as specified in the Gesture Page. The second input defines the \"listen\" input.  The third input is used to reset the gesture.\t\t\n\t\t\t\n'''Tip''': The <code>gestureCapture</code> component in the palette is much more powerful and flexible to capture and record channels, and has full UI.\t\t\t\n\t\t\t\nIn the Gesture CHOP, when the first channel of the listen input goes above zero, the Gesture CHOP begins recording the first input's channels. While listen is on, the input channels are output exactly as is. When the listen is turned off, the recorded segment of the channels is processed (trimmed and blended). While listen is off, the recorded segment is looped continuously.\t\t\t\n\t\t\t\nThe Gesture CHOP determines the number of beats that the listen was on for; this defines the period of the loop. If the beat frequency changes, the period will change with it.\t\t\t\n\t\t\t\nIf \"Fit to Nearest Cycle\" is Off, the beats are ignored and the gesture length is exactly the time it took to record - the recorded segment will be looped back with a period equal to the recorded length. When On, the captured gesture will be extended or trimmed to be a multiple of the beats per cycle.",
        "opLabel": "Gesture",
        "opClass": "gestureCHOP_Class",
        "opType": "gesture",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Gesture CHOP records a short segment of the first input and loops this segment in time with options as specified in the Gesture Page.",
        "opCategories": ""
    },
    "handleCHOP": {
        "label": "handleCHOP",
        "members": [
            {
                "text": "Object : Creates <code>rx</code>/<code>ry</code>/<code>rz</code> channels for each bone listed.",
                "type": "ObjectPar",
                "name": "source",
                "items": []
            },
            {
                "text": "Object : If you have entered bones which form a branch or should act as a unit, enter them here. An example may be two bones splitting at the shoulders. You want them to rotate, but only as a unit.",
                "type": "ObjectPar",
                "name": "fixed",
                "items": []
            },
            {
                "text": "Int : Increasing this parameters gives a more accurate solution at the cost of cooking time. Preroll (only when precalculating a range of frames, SingleFrame turned off): This will cook the solution a given number of frames before the requested frame range. Max Angle Change: This will limit the delta angle degrees the bones can move in any given frame. Use this to tame erratic behavior.",
                "type": "IntPar",
                "name": "iterations",
                "items": []
            },
            {
                "text": "Float : Specifies a frame in which the bones are reset to their default rest angles.",
                "type": "FloatPar",
                "name": "init",
                "items": []
            },
            {
                "text": "Int : Specifies the number of iterations to solve at the initialization frame.",
                "type": "IntPar",
                "name": "preroll",
                "items": []
            },
            {
                "text": "Float : Specifies the maximum change in degrees the solver is allowed to move each bone per frame. Use this parameter if the solution is too drastic.",
                "type": "FloatPar",
                "name": "delta",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Handle CHOP is the \"engine\" which drives Inverse Kinematic solutions using the [[Handle COMP]]. The role of the Handle CHOP is to generate rotation values for the bones which will bring their attached handles as close to their respective targets as possible.\t\n\t\t\nThe use of this method is best described with an example:\t\t\n\t\t\n# Increase the frame range to 10000. Create a [[Null COMP]] called 'target' and animate a few random positions for it to travel to.\t\t\n# Create a three bone IK chain with No Kinematics. Append a [[Handle COMP]] to the last bone.\t\t\n# In the Handle COMP set the Target menu to Target. This is the Null COMP you just created.\t\t\n# The system is now specified. To actually start the IK enter a CHOP pane.\t\t\n# Place a Handle CHOP. In the Source field type in the names of the bones that were earlier created.\t\t\n# Click the Export button on the Handle CHOP and click Play. You should now see the two-bone system chasing the animated null.\t\t\n\t\t\n'''Tip:''' In the [[Geometry_Viewer|geometry viewer]], you can use the '''Select''' state to select the bones you created. Then in the Handle CHOP click the '''Grab Source Form Selection''' button. The names are entered automatically for you. You don't have to worry about being too picky when selecting objects this way, since non-bone objects are ignored.\t\t\n\t\t\nYou can place any number of bones with any number of (possibly zero) Handles attached to the system. The following parameter description will now give a more detailed explanation of the functionality:",
        "opLabel": "Handle",
        "opClass": "handleCHOP_Class",
        "opType": "handle",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "he Handle CHOP is the \"engine\" which drives Inverse Kinematic solutions using the [[Handle COMP]].",
        "opCategories": ""
    },
    "heliosdacCHOP": {
        "label": "heliosdacCHOP",
        "members": [
            {
                "text": "Toggle : If turned off, the Helios DAC CHOP will stop sending data to the Helios DAC and will immediately clear its point buffer. Consider it equivalent to powering off the Helios DAC.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : Select the Helios DAC you want to control from this menu.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Float : Determines the queue size of the Helios DAC CHOP point buffer and the corresponding time required to drain it. It is often useful to reduce this value when sending fewer points.",
                "type": "FloatPar",
                "name": "queuetime",
                "items": []
            },
            {
                "text": "Float : Allows the input x values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "xscale",
                "items": []
            },
            {
                "text": "Float : Allows the input y values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "yscale",
                "items": []
            },
            {
                "text": "Float : Allows the input r values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "redscale",
                "items": []
            },
            {
                "text": "Float : Allows the input g values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "greenscale",
                "items": []
            },
            {
                "text": "Float : Allows the input b values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "bluescale",
                "items": []
            },
            {
                "text": "Float : Allows the input intensity values (i) to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "intensityscale",
                "items": []
            },
            {
                "text": "Toggle : If turned off, the Helios DAC CHOP will stop sending data to the Helios DAC and will immediately clear its point buffer. Consider it equivalent to powering off the Helios DAC.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : Select the Helios DAC you want to control from this menu.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Float : Determines the queue size of the Helios DAC CHOP point buffer and the corresponding time required to drain it. It is often useful to reduce this value when sending fewer points.",
                "type": "FloatPar",
                "name": "queuetime",
                "items": []
            },
            {
                "text": "Float : Allows the input x values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "xscale",
                "items": []
            },
            {
                "text": "Float : Allows the input y values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "yscale",
                "items": []
            },
            {
                "text": "Float : Allows the input r values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "redscale",
                "items": []
            },
            {
                "text": "Float : Allows the input g values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "greenscale",
                "items": []
            },
            {
                "text": "Float : Allows the input b values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "bluescale",
                "items": []
            },
            {
                "text": "Float : Allows the input intensity values (i) to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "intensityscale",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "Helios DAC is a laser controller. The Helios DAC CHOP takes as input up to five channels interpreted as X and Y (horizontal and vertical) position values in the first 2 channels, and red, green and blue color values in the next 3 channels. It outputs the data to a [http://pages.bitlasers.com/helios/ Helios DAC]. The Helios DAC device is connected to a laser using an ILDA cable. The user can then control the image that the laser should output using the Helios DAC CHOP. Applications of the Helios DAC CHOP include displaying computer-generated shape animations or other special effects of a light show.\t\n\t\t\nBlanking (all-off) occurs when the incoming RGB CHOP channels are all zero, or the Red Scale, Green Scale, and Blue Scale parameters are all zero.\t\t\n\t\t\nLarge changes in RGB values from sample-to-sample will likely be visibly correct as lasers generally can switch on-off quickly.\t\t\n\t\t\nThe range of X and Y is typically -1 to +1, and the range of RGB is typically 0 to 1.\n\n'''Note:''' The Helios DAC CHOP listens for any device changes on the system and will perform a Helios device re-scan when triggered. However, the re-scan can only be triggered if all Helios connections are closed, meaning all Helios DAC CHOPs are either deactivated or bypassed. To perform a Helios device re-scan with only a single Helios DAC CHOP, simply deactivate and reactivate the CHOP.\n\t\t\nSee also: [[EtherDream CHOP]], [[EtherDream DAT]], [[Laser CHOP]], and the [[Pattern CHOP]].",
        "opLabel": "Helios DAC",
        "opClass": "heliosdacCHOP_Class",
        "opType": "heliosdac",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "Helios DAC is a laser controller.",
        "opCategories": ""
    },
    "hogCHOP": {
        "label": "hogCHOP",
        "members": [
            {
                "text": "Toggle : Turns the Hog CHOP on and off.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : Forces the CHOP to cook every frame.",
                "type": "TogglePar",
                "name": "cookalways",
                "items": []
            },
            {
                "text": "Float : Minimum amount of time CHOP wastes.",
                "type": "FloatPar",
                "name": "delay",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "delayunit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Hog CHOP eats up CPU cycles (ie it's a CPU hog - oink!). This can be used to simulate performance on slower machines, or to artifically slow down a synth's frame rate.",
        "opLabel": "Hog",
        "opClass": "hogCHOP_Class",
        "opType": "hog",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Hog CHOP eats up CPU cycles (ie it's a CPU hog - oink!).",
        "opCategories": ""
    },
    "hokuyoCHOP": {
        "label": "hokuyoCHOP",
        "members": [
            {
                "text": "Toggle : This enables the connection to the Hokuyo sensor.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the device interface.",
                "type": "MenuPar",
                "name": "interface",
                "items": []
            },
            {
                "text": "StrMenu : Selects the COM port that the serial connection will use.  Default port names 1 through 8 are available in the popup menu, though any name can be manually entered in this field.",
                "type": "StrMenuPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Str : The network address of the laser scanner to connect to. The default address of a UST-10LX device is 192.168.0.10.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Toggle : This check box enables the high sensitivity mode on the sensor. High Sensitivity mode increases the detection ability of the laser scanner, but with a higher chance of measurement error. Only available on serial devices.",
                "type": "TogglePar",
                "name": "highsensitivity",
                "items": []
            },
            {
                "text": "Int : Modifies the motor speed of the laser scanner. This should be used when running multiple laser scanners in the same environment. Different motor speeds across multiple laser scanners will avoid light interference between them. Only available on serial devices.",
                "type": "IntPar",
                "name": "motorspeed",
                "items": []
            },
            {
                "text": "Int : Specifies the first data point of the laser scan. Start step must be a number between first and last measurement point, and must be less than or equal to the end step parameter. Refer to the above table to get device specific first/last measurement points. This parameter defaults to 0, the start step of the UST-10LX and other ethernet lasers. For the URG-04LX-UG01 and other similar devices the start step must be 44 or greater.",
                "type": "IntPar",
                "name": "startstep",
                "items": []
            },
            {
                "text": "Int : Specifies the last data point of the laser scan. End step must be a number between first and last measurement point, and must be greater than or equal to the start step parameter. Refer to the above table to get device specific first/last measurement points. This parameter defaults to 1080, the end step of the UST-10LX and other ethernet lasers. For the URG-04LX-UG01 and other similar devices the end step must be 725 or fewer.",
                "type": "IntPar",
                "name": "endstep",
                "items": []
            },
            {
                "text": "Menu : Outputs the scan data in either Polar or Cartesian coordinates.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "hokuyo",
        "opLabel": "Hokuyo",
        "opLicense": "Non-Commercial",
        "opClass": "hokuyoCHOP_Class",
        "opFilter": "False",
        "short": "The Hokuyo CHOP is used for communication with Hokuyo laser scanners (serial or ethernet interface): [http://www.hokuyo-aut.jp/search/ Hokuyo Products]",
        "long": "The Hokuyo CHOP is used for communication with Hokuyo laser scanners (serial or ethernet interface): [http://www.hokuyo-aut.jp/search/ Hokuyo Products]\n\nThe Hokuyo CHOP will work with all serial or ethernet Hokuyo laser scanners, though the only laser scanners tested in-house are the URG-04LX-UG01 (Serial) and the UST-10LX (Ethernet).\n\nIt can be used with the [[Blob Track CHOP]] to detect objects in its field. See the Snippet for Blob Track.\n\nAll of a computer's available serial ports can be found in the Device Manager under the Windows operating system. Their names begin with 'COM'. Example: COM1, COM2, COM3, etc.\n\nThe Hokuyo CHOP outputs the measurement data from the laser scan in meters, either in Polar or Cartesian Coordinates. The laser scan is done counter clockwise over N degrees (defined by the device, eg. URG-04LX-UG01 is 240 degrees, UST-10LX is 270 degrees) and returns the distance to the first object hit by the laser at that point. \n\nThe Hokuyo laser scanners have an angular resolution that specifies the number of data points returned from a full scan. For the URG-04LX-UG01 there is a data point every ~0.3515 degrees, so over a 240 degree scan there is a total of 682 data points. For the UST-10LX there is a data point every 0.25 degrees, so over a 270 degree scan there is a total of 1080 data points. The Hokuyo laser scanners also have a start and end step that define a total detection range. \n\nThe UST-10LX has the same measurement parameters as the UTM-30LX in the chart below. The UST-20LX ethernet model will also work like the UST-10LX.\n\nFor a visualization of the scan and a table of device specific numbers, see the image below:\n\n[[image:scan_info.jpg]]\n\nIf the Hokuyo device is an ethernet model like the UTM-30LX-EW, make sure Window Firewall is not blocking it. Each install of TD will need to be allowed through the firewall separately. This commonly catches people out with networking OPs, as sometimes the Windows \u201callow TD to network\u201d dialog doesn\u2019t open on first connection attempt. A quick disabling of the firewall will let you test this theory.\n\nSee also [[Serial DAT]], [[serialDAT_Class]], [[Arduino]]",
        "opCategories": ""
    },
    "holdCHOP": {
        "label": "holdCHOP",
        "members": [
            {
                "text": "Menu : Defines when to sample the input channels. The parameters are as follows.",
                "type": "MenuPar",
                "name": "sample",
                "items": []
            },
            {
                "text": "Toggle : When On continue to sample the input, when Off hold the values.",
                "type": "TogglePar",
                "name": "hold",
                "items": []
            },
            {
                "text": "Pulse : Sample the input and hold those values when pulsed.",
                "type": "PulsePar",
                "name": "holdpulse",
                "items": []
            },
            {
                "text": "Toggle : Useful for working with multi-sample channels, this applies the hold to each sample of the channel instead of only the last sample in the channel.",
                "type": "TogglePar",
                "name": "holdsamples",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Hold CHOP waits for a 0 to 1 step on its second input, at which time it reads the current values from the first input (one value per channel). It holds the values constant until it receives another 0 to 1 step. The second input controls the sampling. When the second input changes from 0 to 1, the first input is sampled. This value is held in the output until the second input changes from 0 to 1 again. Hold does not sample while the second input is 1, nor on the falling edge (1 to 0).\t\t\n\t\t\t\nA common application for this CHOP is to grab the current value of a channel when an event occurs, so that value can be used until the event occurs again.",
        "opLabel": "Hold",
        "opClass": "holdCHOP_Class",
        "opType": "hold",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Hold CHOP waits for a 0 to 1 step on its second input, at which time it reads the current values from the first input (one value per channel).",
        "opCategories": ""
    },
    "inCHOP": {
        "label": "inCHOP",
        "members": [
            {
                "text": "Str : The label for this input on the COMP that will show up in a popup if the mouse is held over it.",
                "type": "StrPar",
                "name": "label",
                "items": []
            },
            {
                "text": "Int : If On, and the number of incoming channels does not match this value, an error is generated.",
                "type": "IntPar",
                "name": "numchannels",
                "items": []
            },
            {
                "text": "Str : When used with <span class=\"tipTextCHOP\">Num Channels</span> the input is scanned for channels matching these names. All other channels are ignored and not passed through. This is a way of filtering out unnecessary channels without requiring a [[Select CHOP]] or [[Delete CHOP]].  When used without <span class=\"tipTextCHOP\">Num Channels</span> the input channels are simply renamed according to this pattern.",
                "type": "StrPar",
                "name": "channames",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The In CHOP gets channels that are connected to one of the inputs of the component. For each In CHOP inside a component, there is one input connector added to the In CHOP's parent component.",
        "opLabel": "In",
        "opClass": "inCHOP_Class",
        "opType": "in",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The In CHOP gets channels that are connected to one of the inputs of the component.",
        "opCategories": ""
    },
    "infoCHOP": {
        "label": "infoCHOP",
        "members": [
            {
                "text": "OP : The path of the node that the Info CHOP is getting information from. You can drag and drop any node onto this path, or type the path directly into the field.",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "StrMenu : The names of the attributes to keep. Name patterns may be used as detailed in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "iscope",
                "items": []
            },
            {
                "text": "Menu : Select channel with values inside or outside the range specified in <span class=\"tipTextCHOP\">Range</span>.",
                "type": "MenuPar",
                "name": "values",
                "items": []
            },
            {
                "text": "Float : Set the bounds for selecting channels by value.",
                "type": "FloatPar",
                "name": "range",
                "items": []
            },
            {
                "text": "Toggle : When Passive is Off the Info CHOP will cook the <span class=\"tipTextCHOP\">Operator</span> it is pointing to before querying its values. When Passive is On it will not force a cook. A side effect: If the Info CHOP and the target are both cooking that frame, the Info may cook before the target, so it\u2019s data will be a frame late.",
                "type": "TogglePar",
                "name": "passive",
                "items": []
            },
            {
                "text": "Toggle : When the Info CHOP is monitoring a [[Component]], this toggle will enable a channel called <code>children_cpu_cook_time</code> which is the total cooktime of all the component's children. This is off by default, enabling it for a large network may impact performance as all cooktimes need to be summed.",
                "type": "TogglePar",
                "name": "childcooktime",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Info CHOP gives you extra information about a node. All nodes contain extra inside information, and different types of nodes (TOPs, CHOPs, etc) contain different subsets of information. This additional information can be accessed via an Info CHOP.\t\t\n\t\t\t\nThe Info CHOP's extra attributes for specific OPs are also expressed as python members of those operators. The the operators python class for more information.",
        "opLabel": "Info",
        "opClass": "infoCHOP_Class",
        "opType": "info",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Info CHOP gives you extra information about a node.",
        "opCategories": ""
    },
    "interpolateCHOP": {
        "label": "interpolateCHOP",
        "members": [
            {
                "text": "Menu : The shape of the interpolation curve:",
                "type": "MenuPar",
                "name": "blendfunc",
                "items": []
            },
            {
                "text": "Menu : If an input is not a single frame, and if there are overlaps in the input CHOPs, an option is used to resolve the conflict.",
                "type": "MenuPar",
                "name": "overlap",
                "items": []
            },
            {
                "text": "Menu : Specify how to match the channels of each input.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Interpolate CHOP treats its multiple-inputs as keyframes and interpolates between them. The inputs are usually single-frame CHOP channels like those produced by a [[Constant CHOP]]. The Interpolate CHOP first sorts the input CHOPs in time (without shifting them) and interpolates between them to fill the gaps.\t\t\n\t\t\t\nThe number of channels in the output is the same as the number of channels in the first input.\t\t\t\n\t\t\t\nIf a channel is missing in an input, and Match By is set to Channel Name, it is treated as if there is no keyframe at that frame for that channel, and the interpolation occurs between CHOPs before and after that frame.",
        "opLabel": "Interpolate",
        "opClass": "interpolateCHOP_Class",
        "opType": "interp",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Interpolate CHOP treats its multiple-inputs as keyframes and interpolates between them.",
        "opCategories": ""
    },
    "inversecurveCHOP": {
        "label": "inversecurveCHOP",
        "members": [
            {
                "text": "Object : The set of objects describing the curve.",
                "type": "ObjectPar",
                "name": "guide",
                "items": []
            },
            {
                "text": "Object : The first bone in the chain to place.",
                "type": "ObjectPar",
                "name": "bonestart",
                "items": []
            },
            {
                "text": "Object : The last bone in the chain to place.",
                "type": "ObjectPar",
                "name": "boneend",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "span",
                "items": []
            },
            {
                "text": "Menu : The type of guide curve to create with the guide components.",
                "type": "MenuPar",
                "name": "interpolation",
                "items": []
            },
            {
                "text": "Int : The curve order when using NURBs or Bezier interpolation.",
                "type": "IntPar",
                "name": "order",
                "items": []
            },
            {
                "text": "XYZ : Control bone twist with this parameter.",
                "type": "XYZPar",
                "name": "upvectorx",
                "items": []
            },
            {
                "text": "XYZ : Control bone twist with this parameter.",
                "type": "XYZPar",
                "name": "upvectory",
                "items": []
            },
            {
                "text": "XYZ : Control bone twist with this parameter.",
                "type": "XYZPar",
                "name": "upvectorz",
                "items": []
            },
            {
                "text": "Toggle : Export the calculated transform values directly onto the bone chain parameters.",
                "type": "TogglePar",
                "name": "mapexports",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Inverse Curve CHOP calculates an inverse kinematics simulation for [[Bone COMP |bone objects]] using a curve object.\t\t\n\t\t\t\nThe Inverse Curve CHOP will stretch and position a set of bones to follow a curve defined by another set of [[object]]s (guide).\t\t\t\n\t\t\t\nSpecify the first and last bone in the chain with Bone Start / Bone End.\t\t\t\n\t\t\t\nSpecify the Guide by listing them in order, space separated, in the Guide Components field. This parameter also accepts patterns and wildcards. Example: <code>null[1-5] null17 null4</code>. You can also specify bones in this group as well.\t\t\t\n\t\t\t\nThe CHOP will then create a set of rotate and bone-length channels for each bone. Additionally, the CHOP will also output 3 translate channels for the first bone in the chain. It will also setup the export links automatically, so you just have to turn on the export flag for this CHOP.\t\t\t\n\t\t\t\nThe way the CHOP solves this system is by creating a guide curve between the supplied Guide objects. Use the Interpolation and Order parameters to define what type of curve it will use. By default, the control vertices of the curve will be the centroids of the object. The curve is also given orientation, by adopting the orientation of each guide object. The bones line up their X axes with this orientation.\t\t\t\n\t\t\t\nYou can view this curve by using the [[Inverse Curve SOP]]. Just supply it with the name of the Inverse Curve CHOP and it will extract the geometry for viewing/debugging purposes. It actually will contain 3 curves (the original guide, and the guide displaced in +X and +Y). These curves can be skinned with a [[Skin SOP]] for better feedback, etc.\t\t\t\n\t\t\t\nThe span parameters can be used to trim out the beginning and end of the guide curve if so needed.\u00a0For example Span 0.3 0.7 will lay the bones along the middle 40% of the curve.\t\t\t\n\t\t\t\nIn the rare case that the user has setup a curve with all the X axes\u00a0(twists) pointing along the same direction of the curve, then the Up Vector parameter is used to break the tie, so to speak. However, this curve setup is likely degenerate to start with and should be avoided by twisting all the objects 90 degrees.",
        "opLabel": "Inverse Curve",
        "opClass": "inversecurveCHOP_Class",
        "opType": "inversecurve",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Inverse Curve CHOP calculates an inverse kinematics simulation for [[Bone COMP |bone objects]] using a curve object.",
        "opCategories": ""
    },
    "inversekinCHOP": {
        "label": "inversekinCHOP",
        "members": [
            {
                "text": "Menu : This parameter defines the method used to determine the motion of the Bone object when it, its ancestor, or its children are moved.",
                "type": "MenuPar",
                "name": "solvertype",
                "items": []
            },
            {
                "text": "Object : The starting bone of the chain; where the chain starts.",
                "type": "ObjectPar",
                "name": "boneroot",
                "items": []
            },
            {
                "text": "Object : If you specify a bone as the last bone in chain, then you will be defining a bone chain that has the current bone as the first in the chain and the bone chosen from the menu as the final bone in the chain. This chain includes all bones in between those just chosen.",
                "type": "ObjectPar",
                "name": "boneend",
                "items": []
            },
            {
                "text": "Object : This specifies which object will serve as the chain's end affector.",
                "type": "ObjectPar",
                "name": "endaffector",
                "items": []
            },
            {
                "text": "Object : If you specify a twist affector, the entire bone chain will twist along the axis from the chain's root to its end-affector so that the first bone is pointing as much as it can at the twist affector. The twist value can be specified as well, and is applied on top of the twist generated for the twist affector.",
                "type": "ObjectPar",
                "name": "twistaffector",
                "items": []
            },
            {
                "text": "Float : Amount of twist allowed by the kinematics solution.",
                "type": "FloatPar",
                "name": "iktwist",
                "items": []
            },
            {
                "text": "Float : Amount of damping (slows down at the extremes of angular allowability).",
                "type": "FloatPar",
                "name": "ikdampen",
                "items": []
            },
            {
                "text": "SOP : Curve object to follow.",
                "type": "SOPPar",
                "name": "curve",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Inverse Kin CHOP calculates an inverse kinematics simulation for [[Bone COMP|Bone objects]].",
        "opLabel": "Inverse Kin",
        "opClass": "inversekinCHOP_Class",
        "opType": "inversekin",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Inverse Kin CHOP calculates an inverse kinematics simulation for [[Bone COMP|Bone objects]].",
        "opCategories": ""
    },
    "joinCHOP": {
        "label": "joinCHOP",
        "members": [
            {
                "text": "Menu : The blend method to produce a seamless sequence:",
                "type": "MenuPar",
                "name": "blendmethod",
                "items": []
            },
            {
                "text": "Menu : The blend interpolation shape to use. See Shape in the [[Cycle CHOP]].",
                "type": "MenuPar",
                "name": "blendfunc",
                "items": []
            },
            {
                "text": "Toggle : When this is checked on, the first input can be a multi-channel input which specifies blend regions for the remaining inputs into the Join CHOP. Channel 1 of input0 is used to blend between input1 &amp; input2, channel 2 between input2 &amp; input3, and so on. If not enough channels are specified, the last channel is repeated.",
                "type": "TogglePar",
                "name": "blendbyinput",
                "items": []
            },
            {
                "text": "Float : The size of the blend region.",
                "type": "FloatPar",
                "name": "blendregion",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "blendregionunit",
                "items": []
            },
            {
                "text": "Float : Which segment to favour when blending: the previous (-1), the next (+1) or neither (0).",
                "type": "FloatPar",
                "name": "blendbias",
                "items": []
            },
            {
                "text": "Menu : Match channels between inputs by index or by name.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Float : If set to 1, the next segment will be shifted up or down so that it begins where the last segment ended.",
                "type": "FloatPar",
                "name": "step",
                "items": []
            },
            {
                "text": "Str : The names of channels that use Step.",
                "type": "StrPar",
                "name": "stepscope",
                "items": []
            },
            {
                "text": "Str : The names of the channels that should be blended. Other channels will not be blended.",
                "type": "StrPar",
                "name": "blendscope",
                "items": []
            },
            {
                "text": "Str : The names of channels that will be translation-blended. Each string field contains a list of its component channels, such as *tx, *ty and *tz.",
                "type": "StrPar",
                "name": "transscopex",
                "items": []
            },
            {
                "text": "Str : The names of channels that will be translation-blended. Each string field contains a list of its component channels, such as *tx, *ty and *tz.",
                "type": "StrPar",
                "name": "transscopey",
                "items": []
            },
            {
                "text": "Str : The names of channels that will be translation-blended. Each string field contains a list of its component channels, such as *tx, *ty and *tz.",
                "type": "StrPar",
                "name": "transscopez",
                "items": []
            },
            {
                "text": "Toggle : Use quaternion blending on rotation channels.",
                "type": "TogglePar",
                "name": "quatrot",
                "items": []
            },
            {
                "text": "Toggle : If enabled, compensates.",
                "type": "TogglePar",
                "name": "shortrot",
                "items": []
            },
            {
                "text": "Str : Enabled when Shortest Path Rotation Blending is turned on.",
                "type": "StrPar",
                "name": "rotscope",
                "items": []
            },
            {
                "text": "Float : Enabled when Shortest Path Rotation Blending is turned on.",
                "type": "FloatPar",
                "name": "cyclelen",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Join CHOP takes all its inputs and appends one CHOP after another. It is expected they all have the same channels.\t\t\n\t\t\t\nThe end section of the first CHOP is overlapped with the start section of the second CHOP, and so on for the rest of the input CHOPs. The second input is shifted to line up with the end of the first.\t\t\t\n\t\t\t\nBlending allows you to splice channels together by slowly phasing out one CHOP while phasing into the next, or by inserting interpolation curves between the channels of the adjacent CHOPs.\t\t\t\n\t\t\t\nQuaternion Blend blends rotation triplets (rx ry rz) together using the shortest rotation arc. Rotation triplets are identified by \"quaternion\" attributes, which are set in the [[Attribute CHOP]].\t\t\t\n\t\t\t\nTranslation Blending blends translation channels together by slowly changing from the final velocity of the previous channel to the initial velocity of the next. The next channel may be shifted up or down. If this is undesirable, use cubic blending instead (in the Shape menu). Translation Blending is done on channel triplets that represent translations or positions (*tx *ty *tz).",
        "opLabel": "Join",
        "opClass": "joinCHOP_Class",
        "opType": "join",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Join CHOP takes all its inputs and appends one CHOP after another.",
        "opCategories": ""
    },
    "joystickCHOP": {
        "label": "joystickCHOP",
        "members": [
            {
                "text": "Toggle : While on, the CHOP receives information from joysticks and gamepads. While Off, no updating occurs.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : This menu will list up to 4 game controllers currently attached to the computer presented to the operating system as Player 1 through Player 4. The selected game controller is the one the CHOP reads data from. If set to 'Default', the CHOP will adopt the first game controller it finds.",
                "type": "StrMenuPar",
                "name": "source",
                "items": []
            },
            {
                "text": "Menu : Select between and axis range of 0 to 1 or -1 to 1.",
                "type": "MenuPar",
                "name": "axisrange",
                "items": []
            },
            {
                "text": "Str : The name of the channel that records the X-axis position of the game controller.",
                "type": "StrPar",
                "name": "xaxis",
                "items": []
            },
            {
                "text": "Str : The name of the channel that records the Y-axis position of the game controller.",
                "type": "StrPar",
                "name": "yaxis",
                "items": []
            },
            {
                "text": "Toggle : Inverts the Y axis.",
                "type": "TogglePar",
                "name": "yaxisinvert",
                "items": []
            },
            {
                "text": "Str : The name of the channel that records the Z-axis position of the game controller.",
                "type": "StrPar",
                "name": "zaxis",
                "items": []
            },
            {
                "text": "Str : The names of the channels that record the X-rotation axis position of the game controller.",
                "type": "StrPar",
                "name": "xrot",
                "items": []
            },
            {
                "text": "Str : The names of the channels that record the Y-rotation axis position of the game controller.",
                "type": "StrPar",
                "name": "yrot",
                "items": []
            },
            {
                "text": "Toggle : Invert the rotation direction around the Y axis.",
                "type": "TogglePar",
                "name": "yrotinvert",
                "items": []
            },
            {
                "text": "Str : The names of the channels that record the Z-rotation axis position of the game controller.",
                "type": "StrPar",
                "name": "zrot",
                "items": []
            },
            {
                "text": "Str : The name of the channel that records the position of the first slider on the game controller.",
                "type": "StrPar",
                "name": "slider0",
                "items": []
            },
            {
                "text": "Str : The name of the channel that records the position of the second slider on the game controller.",
                "type": "StrPar",
                "name": "slider1",
                "items": []
            },
            {
                "text": "Str : The names of the channels for the buttons on the game controller. This CHOP can handle up to 32 buttons.",
                "type": "StrPar",
                "name": "buttonarray",
                "items": []
            },
            {
                "text": "Str : The names of the channels for the POV Hats. This CHOP can handle up to 4 POV Hats. The channels a POV hat is split up into are ''POVHatName''_X and ''POVHatName''_Y.",
                "type": "StrPar",
                "name": "povarrray",
                "items": []
            },
            {
                "text": "Str : ",
                "type": "StrPar",
                "name": "povstatearray",
                "items": []
            },
            {
                "text": "Str : Creates a channel that reports the state of connection of the controller.",
                "type": "StrPar",
                "name": "connected",
                "items": []
            },
            {
                "text": "Float : This value defines how much of the area in the center of the joystick is considered 'dead zone'. When a joystick axis is in this dead zone it is considered to be centered. This value applies to all normal axes and rotation axes. This value is a percentage that defaults to 7%.",
                "type": "FloatPar",
                "name": "axisdeadzone",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Joystick CHOP outputs values for all 6 possible axes on any game controller (joysticks, game controllers, driving wheels, etc.), as well as up to 32 button, 2 sliders and 4 POV Hats.\t\t\n\t\t\t\nIt handles game controllers connected to the gameport or USB ports, including the [http://www.3dconnexion.com/ 3D Connexion] mouse. You can have several devices attached, and any number of Joystick CHOPs in a project per device.\t\t\t\n\t\t\t\nBefore you use the game controller on your computer, calibrate them using Start -&gt; Settings -&gt; Control Panel -&gt; Gaming Options -&gt; Properties.\t\t\t\n\t\t\t\nThe main two outputs, the X-axis and Y-axis are output through channels called xaxis and yaxis. The other four axes are output through channels with similar names.\t\t\t\n\t\t\t\nThe range of the values for each channel is 0 to 1. For any axis, a value 0.5 is considered \"centered\". A value of 0 is given if the axis doesn't exist.\t\t\t\n\t\t\t\nFor any button, a value of 0 means the button is up or doesn't exist. A value of 1 means the button is pressed.\t\t\t\n\t\t\t\nPOV Hats behave like an X and Y axis. A POV axis only has 3 values though, 0, 0.5 and 1.",
        "opLicense": "Non-Commercial",
        "opClass": "joystickCHOP_Class",
        "opLabel": "Joystick",
        "opFamily": "CHOP",
        "opType": "joystick",
        "short": "The Joystick CHOP outputs values for all 6 possible axes on any game controller (joysticks, game controllers, driving wheels, etc.), as well as up to 32 button, 2 sliders and 4 POV Hats.",
        "opCategories": ""
    },
    "keyboardinCHOP": {
        "label": "keyboardinCHOP",
        "members": [
            {
                "text": "Menu : While '''On''', the keyboard inputs will be monitored and the CHOP will cook every frame. When set to '''Off''' it will not cook and the current keyboard values will not be output. '''While Playing''' will capture keyboard events only when the [[Timeline]] is playing forward.",
                "type": "MenuPar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : Enter the keys to monitor create a channel for. Can be selected from the dropdown menu on the right. Valid keys are the numbers 0-9, letters A-Z, and keypad 0-9.",
                "type": "StrMenuPar",
                "name": "keys",
                "items": []
            },
            {
                "text": "Menu : If it is set to Ctrl, the keys will only go On if you are also pressing the Ctrl key. This works similarly for Alt and Shift modifiers. If it set to Ignore, it doesn't matter if the Ctrl/Alt/Shift key is down or not.",
                "type": "MenuPar",
                "name": "modifiers",
                "items": []
            },
            {
                "text": "Menu : Channel names are generated automatically using one of these criteria.",
                "type": "MenuPar",
                "name": "channelnames",
                "items": []
            },
            {
                "text": "PanelCOMP : When a path to a [[Panel Component|Panel COMP]](s) is specified, only keyboard events that take place when that panel(s) has focus will reported by the Keyboard In CHOP.",
                "type": "PanelCOMPPar",
                "name": "panels",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Keyboard In CHOP receives ASCII input from the keyboard, and outputs channels for the number of keys specified. It creates a single-frame channel representing the current state of each key.\t\t\n\t\t\t\nThe channels for keys are created by specifying the first key, the number of keys to follow, and the order with which they are selected. Key channel names are either determined by the name of the key, or the channel number.\t\t\t\n\t\t\t\n'''NOTE:''' The Keyboard In CHOP does not handle rapid repeats of characters and does not output channels or all keys. A better way is as follows: Create a [[Panel Execute DAT]], and set the 'Panel' parameter to the panel in which keyboard keys need to be monitored.\t\t\t\nSet the Panel Value to: <code>key</code>.\t\t\t\nIn this DAT, if you enter <code>print(panelValue)</code> in the onValueChange() callback, you will see a line printed for every keystroke.",
        "opLicense": "Non-Commercial",
        "opClass": "keyboardinCHOP_Class",
        "opLabel": "Keyboard In",
        "opFamily": "CHOP",
        "opType": "keyboardin",
        "short": "The Keyboard In CHOP receives ASCII input from the keyboard, and outputs channels for the number of keys specified.",
        "opCategories": ""
    },
    "keyframeCHOP": {
        "label": "keyframeCHOP",
        "members": [
            {
                "text": "COMP : The path to the Animation Component holding the channel and key data.",
                "type": "COMPPar",
                "name": "animation",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The default value for extend conditions.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Keyframe CHOP uses channel and keys data in an [[Animation COMP]] and creates channels of samples at a selectable sample rate (frames per second).\t\t\n\t\t\t\nSee also: [[Animation COMP]] and [[Animation Editor]]\t\t\t\n\t\t\t\nThe Keyframe CHOP lets you access the keyframed channel data inside an Animation component. The Animation CHOP allows the channels to be played back with the global frame or seconds index. It can be synced to the internal global beat clock, a specified index, or based on a timing or lookup channel sent into the input. It outputs all channels - either as a single sample or an entire start/end range.\t\t\t\n\t\t\t\nTo create/edit/delete keyframed channels, create an [[Animation COMP]] and open the [[Animation Editor]] by right-clicking on the component and selecting Edit Keyframes... from the pop-up menu. Inside the Animation component a Keyframe CHOP will be outputting the channels created in the editor.\t\t\t\n\t\t\t\nAdding an input to the Keyframe CHOP now acts as a lookup index. In addition it outputs a proper [[Time Slice]] if its input is a Time Slice.\t\t\t\n\t\t\t\nThe lookup cycles through all the input channels, though only 1 is necessary.",
        "opLicense": "Non-Commercial",
        "opClass": "keyframeCHOP_Class",
        "opLabel": "Keyframe",
        "opFamily": "CHOP",
        "opType": "keyframe",
        "short": "The Keyframe CHOP uses channel and keys data in an [[Animation COMP]] and creates channels of samples at a selectable sample rate (frames per second).",
        "opCategories": ""
    },
    "kinectazureCHOP": {
        "label": "kinectazureCHOP",
        "members": [
            {
                "text": "Toggle : Enable to disable the capturing of body tracking data. The primary [[Kinect Azure TOP]] must also be active to receive data.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "TOP : The name of the [[Kinect Azure TOP]] that is connected to the camera.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Int : The number of player skeletons that should be tracked by the device. If the camera does not find enough skeletons, then the extra channels will be set to zero.",
                "type": "IntPar",
                "name": "maxplayers",
                "items": []
            },
            {
                "text": "Toggle : Include rotation data for all bone in the skeleton. Rotation is measured in degrees around the XYZ axes relative to the bone's parent.",
                "type": "TogglePar",
                "name": "relbonerotations",
                "items": []
            },
            {
                "text": "Toggle : Include absolute rotation data for all bone in the skeleton. Rotation is measured in degrees around the XYZ axes relative to the world.",
                "type": "TogglePar",
                "name": "absbonerotations",
                "items": []
            },
            {
                "text": "Toggle : Include channels for the length of each bone. A bone's length is the distance between a joint and its parent joint. See the [https://docs.microsoft.com/en-us/azure/kinect-dk/system-requirements Kinect Azure SDK] for a diagram of the joint heirarchy.",
                "type": "TogglePar",
                "name": "bonelengths",
                "items": []
            },
            {
                "text": "Toggle : Include channels for the bone's absolute world position in meters.",
                "type": "TogglePar",
                "name": "worldspace",
                "items": []
            },
            {
                "text": "Toggle : Include channels for the skeleton positions in UV coordinates of the Color Image.",
                "type": "TogglePar",
                "name": "colorspace",
                "items": []
            },
            {
                "text": "Toggle : Include channels for the skeleton positions in UV coordinates of the Depth Image.",
                "type": "TogglePar",
                "name": "depthspace",
                "items": []
            },
            {
                "text": "Toggle : Scale the image space positions to that they match the aspect ratio of the corresponding camera.",
                "type": "TogglePar",
                "name": "aspectcorrectuv",
                "items": []
            },
            {
                "text": "Toggle : Flip the v coordinate of the image space positions so that 0,0 would be in the top-left corner. This was the default behaviour prior to version 2020.44130.",
                "type": "TogglePar",
                "name": "flipimagev",
                "items": []
            },
            {
                "text": "Toggle : Mirror's the U coordintate of Color Image Positions and Depth Image Positions above which is useful when those images have been flipped in U (x axis flip like a mirror).",
                "type": "TogglePar",
                "name": "flipskelu",
                "items": []
            },
            {
                "text": "Toggle : The confidence that the sensor has that a joint's position and rotation is correct. It can be one of the following values:\n    \n* 0 - The joint is out of range (too far from the camera)\n* 1 - The joint cannot be seen by the sensor and is predicted based on the neighbouring joints\n* 2 - Medium confidence. The sensor is reasonably confident of the joint's position/rotation. This is currently the highest level of confidence the sensor will produce.\n* 3 - High confidence. Reserved for future use.",
                "type": "TogglePar",
                "name": "confidence",
                "items": []
            },
            {
                "text": "Toggle : Include temperature, acceleration and rotation data from the camera's IMU sensor.",
                "type": "TogglePar",
                "name": "imuchans",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "kinectazureCHOP",
        "opLabel": "Kinect Azure",
        "opClass": "kinectazureCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows 10 April 2018 or newer",
        "hardware": "An NVIDIA GEFORCE GTX 1070 or better graphics card is required to obtain body tracking data from the camera; however, a slower CPU-only mode can also be enabled using the parameters. [https://docs.microsoft.com/en-us/azure/kinect-dk/system-requirements Kinect Azure System Requirements]",
        "short": "The Kinect Azure CHOP can be used to obtain body tracking information, including joint positions and rotations, and IMU sensor data from a Microsoft Kinect Azure camera.",
        "long": "The Kinect Azure CHOP can be used to obtain body tracking information, including joint positions and rotations, and IMU sensor data from a Microsoft Kinect Azure camera.\n\nThis CHOP requires a [[Kinect Azure TOP]] to connect to the camera and to configure the camera's settings. Not all configuration settings support body tracking e.g. Passive IR depth mode.\n\nUse the Max Players parameter to determine how many players you would like the camera to track. The TOP will automatically assign any bodies that are discovered by the device to the available player spaces. Due to the system used to detect player skeletons from the depth camera image, body tracking data can lag multiple frames behind the image data. To more closely synchronize body and image data, use the 'Sync Body Tracking To Image' option on the primary [[Kinect Azure TOP]] that is controlling the device (synchronization will increase lag in the image capture).\n\nFor a diagram of the joints tracked and their hierarchy, visit [https://docs.microsoft.com/en-us/azure/kinect-dk/body-joints Microsoft's Kinect Azure SDK].\n\nAcceleration and rotation data from the camera's IMU sensor can be obtained by enabling the 'IMU Channels' parameter.\n\nSee also [[Kinect Azure TOP]], [[Kinect Azure Select TOP]].",
        "opCategories": ""
    },
    "kinectCHOP": {
        "label": "kinectCHOP",
        "members": [
            {
                "text": "Toggle : When 'On' data is captured from the Kinect sensor.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Choose between Kinect v1 or Kinect v2 sensors.",
                "type": "MenuPar",
                "name": "hwversion",
                "items": []
            },
            {
                "text": "StrMenu : Selects which Kinect sensor to use. Only available when using Kinect v1.",
                "type": "StrMenuPar",
                "name": "sensor",
                "items": []
            },
            {
                "text": "Menu : Selects options for skeletal tracking.",
                "type": "MenuPar",
                "name": "skeleton",
                "items": []
            },
            {
                "text": "Int : Limits how many players to track.",
                "type": "IntPar",
                "name": "maxplayers",
                "items": []
            },
            {
                "text": "Toggle : Enables interactions, which returns interaction data such as \"grip\" and \"press\".  The additional channels output are prefixed with  <code>p[1-2]/hand_l_*</code> and <code>p[1-2]/hand_r_*</code>.<\t\n<!--TDitemStart-->* For the x and y values of the interaction hand, 0.0 corresponds to left edge of interaction region and 1.0 corresponds to right edge of interaction region, but values could be outside of this range.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* For the z value of the interaction hand, 0.0 means that hand is close to shoulder and 1.0 represents a fully extended arm, but values could be outside of this range.<!--TDitemEnd-->\t\t\t\n'''NOTE:''' Interaction mode requires a depth resolution of 640x480. As such, a [[Kinect TOP]] displaying a depth image for the same sensor will output an image with a resolution of 640x480 and the Near Depth Mode setting will be set in the Kinect CHOP.\t\t\t\n\t\t\t\nFor guidelines in creating applications with Kinect Interaction, download the [http://download.microsoft.com/download/B/0/7/B070724E-52B4-4B1A-BD1B-05CC28D07899/Human_Interface_Guidelines_v1.7.0.pdf Kinect for Windows Human Interface Guidelines].",
                "type": "TogglePar",
                "name": "interactions",
                "items": []
            },
            {
                "text": "Toggle : Returns rx, ry, and rz relative rotation channels for each bone. The rotation is relative to the previous joint.",
                "type": "TogglePar",
                "name": "relbonerotations",
                "items": []
            },
            {
                "text": "Toggle : Returns rx, ry, and rz absolute rotation channels for each bone.",
                "type": "TogglePar",
                "name": "absbonerotations",
                "items": []
            },
            {
                "text": "Toggle : Returns the length for each bone.",
                "type": "TogglePar",
                "name": "bonelengths",
                "items": []
            },
            {
                "text": "Toggle : Return the rx, ry, and rz values in a form that includes no discontinuities (or wrap arounds), so that they can be safely blended, filtered, lagged etc. For example, a rotation value running from 0 to 360 continuously, unrolled would start at 0 and increase in value indefinitely.",
                "type": "TogglePar",
                "name": "unrollbones",
                "items": []
            },
            {
                "text": "Toggle : Returns the tracked positions in world space coordinates. For each tracked point, a <code>tx</code>, <code>ty</code>, <code>tz</code> triplet of channels will be output.",
                "type": "TogglePar",
                "name": "worldspace",
                "items": []
            },
            {
                "text": "Toggle : Returns the tracked positions in image space coordinates relative to the color camera. For each tracked point, a <code>u</code>, <code>v</code>, <code>tz</code> triplet of channels will be output. Note this is only available on Kinectv2.",
                "type": "TogglePar",
                "name": "colorspace",
                "items": []
            },
            {
                "text": "Toggle : Returns the tracked positions in image space coordinates relative to the depth camera. For each tracked point, a <code>depthu</code>, <code>depthv</code>, <code>tz</code> triplet of channels will be output. Works on both Kinectv1 and Kinectv2.",
                "type": "TogglePar",
                "name": "depthspace",
                "items": []
            },
            {
                "text": "Toggle : Returns face tracking channels for detected faces.",
                "type": "TogglePar",
                "name": "facetracking",
                "items": []
            },
            {
                "text": "Toggle : A number of additional status channels are reported when this is turned on. A group of channels will report if a joint is currently being tracked, and another group of channels reports if part of the player is clipped outside the bounds of the Kinect sensor. The additional channels output are suffixed with <code>tracked</code> or <code>clipped</code>.",
                "type": "TogglePar",
                "name": "statuschans",
                "items": []
            },
            {
                "text": "Toggle : Enables near mode for skeleton tracking, which allows the depth camera to see objects as close as 40cm to the camera (instead of the default 80cm).",
                "type": "TogglePar",
                "name": "neardepthmode",
                "items": []
            },
            {
                "text": "Toggle : Flips the u-axis for skeleton channels, helpful when using a mirror image from the camera.",
                "type": "TogglePar",
                "name": "flipskelu",
                "items": []
            },
            {
                "text": "Toggle : Flips the u-axis for face channels, helpful when using a mirror image from the camera.",
                "type": "TogglePar",
                "name": "flipfaceu",
                "items": []
            },
            {
                "text": "Toggle : Activates Kinect's smoothing algorithm for joint tracking and enables the smoothing parameters below.",
                "type": "TogglePar",
                "name": "jointsmoothing",
                "items": []
            },
            {
                "text": "Float : Increasing the smoothing parameter value leads to more highly-smoothed skeleton position values being returned. It is the nature of smoothing that, as the smoothing value is increased, responsiveness to the raw data decreases. Thus, increased smoothing leads to increased latency in the returned skeleton values. Values must be in the range 0 through 1.0. Passing 0 causes the raw data to be returned.",
                "type": "FloatPar",
                "name": "smoothing",
                "items": []
            },
            {
                "text": "Float : Lower values are slower to correct towards the raw data and appear smoother, while higher values will correct toward the raw data more quickly. Values must be in the range 0 through 1.0.",
                "type": "FloatPar",
                "name": "correction",
                "items": []
            },
            {
                "text": "Float : The number of frames to predict into the future. Values must be greater than or equal to zero. Values greater than 0.5 will likely lead to overshooting when moving quickly. This effect can be damped by using small values of Max Deviation Radius.",
                "type": "FloatPar",
                "name": "prediction",
                "items": []
            },
            {
                "text": "Float : The radius in meters for jitter reduction. Any jitter beyond this radius is clamped to the radius.",
                "type": "FloatPar",
                "name": "jitterrad",
                "items": []
            },
            {
                "text": "Float : The maximum radius in meters that filtered positions are allowed to deviate from raw data. Filtered values that would be more than this radius from the raw data are clamped at this distance, in the direction of the filtered value.",
                "type": "FloatPar",
                "name": "maxdevrad",
                "items": []
            },
            {
                "text": "Float : Activates Kinect's smoothing algorithm for rotations. As with joint smoothing above, higher levels of smoothing will introduce more latency.",
                "type": "FloatPar",
                "name": "rotationsmoothing",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Kinect CHOP reads positional and skeletal tracking data from the Kinect and Kinect2 sensors.  Up to 6 people's full skeletons can be tracked (2 on the original Kinect), and the center position of an addition 4 people in the camera view is tracked as well.  Multiple Kinect devices can be used by using multiple Kinect CHOPs and changing the Camera parameter.\t\t\n\t\t\t\nIt also supports face tracking.\n\t\t\t\nTo use a Kinect 2 device you need to install the Kinect 2 SDK or runtime from [http://www.microsoft.com/en-us/kinectforwindows/ here].  \t\t\t\n\t\t\t\nTo use the original Kinect 1 you will need to install the [http://www.microsoft.com/en-ca/download/details.aspx?id=40277 Kinect Runtime 1.8] for builds greater than 12000, or [http://www.microsoft.com/en-us/download/details.aspx?id=36997 Kinect Runtime 1.7] for builds below 12000.\t\t\t\nMultiple Kinects: The Kinect 2 SDK does not allow for multiple kinects to be used on one system at a time. There is no way to connect to different devices through the SDK. The Kinect 1 can do this, but not the 2.\n\t\t\t\nSee also [[Kinect TOP]], [[Kinect]] and [[Kinect1]].",
        "opLicense": "Non-Commercial",
        "opClass": "kinectCHOP_Class",
        "opLabel": "Kinect",
        "opFamily": "CHOP",
        "opType": "kinect",
        "os": "Microsoft Windows",
        "hardware": "This CHOP only supports the '''Kinect for Windows''' hardware and the '''Kinect 2''', ''not'' Kinect for Xbox hardware.",
        "short": "The Kinect CHOP reads positional and skeletal tracking data from the Kinect and Linect2 sensors.",
        "opCategories": ""
    },
    "lagCHOP": {
        "label": "lagCHOP",
        "members": [
            {
                "text": "Menu : The method by which lag is applied to the channels.",
                "type": "MenuPar",
                "name": "lagmethod",
                "items": []
            },
            {
                "text": "Float : Applies a lag to a channel. The first value is for lagging up, and the second is for lagging down. It is approximately the time that the output follows 90% of a change to the input.",
                "type": "FloatPar",
                "name": "lag",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "lagunit",
                "items": []
            },
            {
                "text": "Float : Applies overshoot to a channel. The first value is for overshoot while moving up, and the second is for overshoot while moving down.",
                "type": "FloatPar",
                "name": "overshoot",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "overshootunit",
                "items": []
            },
            {
                "text": "Toggle : Clamps the slope (or velocity) to lie between the values listed in Max Slope below. Slope is expressed as value/Units.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Float : The first value limits the slope when it is rising, and the second value limits the slope when it is decreasing.",
                "type": "FloatPar",
                "name": "slope",
                "items": []
            },
            {
                "text": "Toggle : Clamps the acceleration to lie between the values listed in Max Acceleration below. Acceleration is expressed as value/(Units*2) .",
                "type": "TogglePar",
                "name": "aclamp",
                "items": []
            },
            {
                "text": "Float : The first value limits the acceleration when it is rising, and the second value limits the acceleration when it is decreasing.",
                "type": "FloatPar",
                "name": "accel",
                "items": []
            },
            {
                "text": "Toggle : Applies the lag to each sample of the channel instead of across the whole channel. Useful for working with multi-sample channels.",
                "type": "TogglePar",
                "name": "lagsamples",
                "items": []
            },
            {
                "text": "Toggle : When On resets (bypasses) the lag effect.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly resets the lag effect.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Lag CHOP adds lag and overshoot to channels. It can also limit the velocity and acceleration of channels. Lag slows down rapid changes in the input channels. Overshoot amplifies the changes in the input channels.\t\t\n\t\t\t\nTwo values exist for each parameter. For example, in the Lag effect, when the input channel value is rising, the first lag parameter is used, and when the channel value is decreasing, the second lag parameter is used. This can give a quick rise, and a slow fall. But lag up and down are often kept at the same value.\t\t\t\n\t\t\t\nFor a similar, less-abrupt effect, see the [[Filter CHOP]].",
        "opLicense": "Non-Commercial",
        "opClass": "lagCHOP_Class",
        "opLabel": "Lag",
        "opFamily": "CHOP",
        "opType": "lag",
        "short": "The Lag CHOP adds lag and overshoot to channels.",
        "opCategories": ""
    },
    "laserCHOP": {
        "label": "laserCHOP",
        "members": [
            {
                "text": "Toggle : When disabled, the CHOP will zero out all channels.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the source operator type for the laser image.",
                "type": "MenuPar",
                "name": "source",
                "items": []
            },
            {
                "text": "SOP : Path to the SOP.",
                "type": "SOPPar",
                "name": "sop",
                "items": []
            },
            {
                "text": "CHOP : Path to the CHOP. The input CHOP must have '''x''', '''y''' channels for the point positions. In addition, it also supports '''z''', '''r''', '''g''', '''b''', and '''id''' channels. The '''id''' channel is used for grouping points together as a single shape. By default when no '''id''' channel is present, each point is separate and unconnected. Additional and arbitrarily named colour channels may be added for laser projectors that accept more than just r, g, b.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Float : Specify the Sample Rate the input source will be sampled at. This can be lower than the output sample rate. If lower than the output sample rate then the output will be resampled (same as if put through a Resample CHOP).",
                "type": "FloatPar",
                "name": "inputrate",
                "items": []
            },
            {
                "text": "Float : The sample rate of the CHOP, and the sample rate at which it will output to the laser. With the default 48000 samples per second and a 60fps frame rate, the Laser CHOP can output 800 position and color values per frame.",
                "type": "FloatPar",
                "name": "outputrate",
                "items": []
            },
            {
                "text": "Toggle : Lets you swap the x and y axis of the output.",
                "type": "TogglePar",
                "name": "swap",
                "items": []
            },
            {
                "text": "Float : Control the horizontal scale of the output.",
                "type": "FloatPar",
                "name": "xscale",
                "items": []
            },
            {
                "text": "Float : Control the vertical scale of the output.",
                "type": "FloatPar",
                "name": "yscale",
                "items": []
            },
            {
                "text": "Float : Control the rotation of the output.",
                "type": "FloatPar",
                "name": "rotate",
                "items": []
            },
            {
                "text": "Menu : Control how the Laser CHOP pulls data from its source.\n    \nIn most cases you will want to keep this at the default setting \"When All Points Drawn\". \n\nThere is a specific usage case that requires the \"Every Frame\" update method. Background is that the Laser CHOP might have to draw the input values over multiple frames. For example given a source with 200 sampling values. After applying all blanking and step sizes at a certain sample rate, the Laser might need more than one frame to draw the full image. The effect will be visible by the Laser image flickering. With the default setting, the Laser will grab a new set of samples from its input once it has completed drawing all previous values. With the \"Every Frame\" update method, the Laser will grab the updated values for the remaining samples after each frame.",
                "type": "MenuPar",
                "name": "updatemethod",
                "items": []
            },
            {
                "text": "Toggle : When enabled, will insert a sample with all colors set to -1 at the beginning of the laser frame.",
                "type": "TogglePar",
                "name": "startpulse",
                "items": []
            },
            {
                "text": "Toggle : Output the points in the same order as the vertices of each polygon, instead of the order in which the points are defined in the geometry.",
                "type": "TogglePar",
                "name": "vertexorder",
                "items": []
            },
            {
                "text": "Float : The distance each x,y can change while outputing color.",
                "type": "FloatPar",
                "name": "stepsize",
                "items": []
            },
            {
                "text": "Float : The distance each x,y can change while not outputing color (blanking).",
                "type": "FloatPar",
                "name": "bstepsize",
                "items": []
            },
            {
                "text": "Float : The minimum value of the vertex hold of a point. The value of the vertex hold of a point is calculated linearly in the range from the minimum to maximum vertex hold, based on the steepness of the angle at the point. This angle is calculated with the following three points: the previous point, the point itself, and the next point. Example: when the angle at the point is 180 degrees then the vertex hold of the point will be the minimum value.",
                "type": "FloatPar",
                "name": "minverthold",
                "items": []
            },
            {
                "text": "Float : The maximum value of the vertex hold of a point. See Minimum Vertex Hold for more details. When the angle at the point is 0 degrees, then the vertex hold will be the maximum value. If the maximum value is lower than the minimum then the maximum will be clamped upward.",
                "type": "FloatPar",
                "name": "maxverthold",
                "items": []
            },
            {
                "text": "OBJ : Specify the path to a Camera COMP used to draw a SOP from the cameras view.",
                "type": "OBJPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "Float : Set the intensity of the Red Channel.",
                "type": "FloatPar",
                "name": "redscale",
                "items": []
            },
            {
                "text": "Float : Set the intensity of the Green Channel.",
                "type": "FloatPar",
                "name": "greenscale",
                "items": []
            },
            {
                "text": "Float : Set the intensity of the Blue Channel.",
                "type": "FloatPar",
                "name": "bluescale",
                "items": []
            },
            {
                "text": "Float : Set the time in ms the Laser should wait at a position before turning the color output off.",
                "type": "FloatPar",
                "name": "preblankon",
                "items": []
            },
            {
                "text": "Float : Set the time in ms the Laser should wait at a position after turning the color output off.",
                "type": "FloatPar",
                "name": "postblankon",
                "items": []
            },
            {
                "text": "Float : Set the time in ms the Laser should wait at a position before turning the color output on.",
                "type": "FloatPar",
                "name": "preblankoff",
                "items": []
            },
            {
                "text": "Float : Set the time in ms the Laser should wait at a position after turning the color output on.",
                "type": "FloatPar",
                "name": "postblankoff",
                "items": []
            },
            {
                "text": "Float : Set the time in ms the Laser should wait at the first point of a new data frame before continuing on.",
                "type": "FloatPar",
                "name": "starthold",
                "items": []
            },
            {
                "text": "Float : Set the delay in ms of the color channels in the output.",
                "type": "FloatPar",
                "name": "colordelay",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "laserCHOP",
        "opLabel": "Laser",
        "opClass": "laserCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Laser CHOP produces channels that can drive a laser projector. It uses the points and lines of a SOP or CHOP and outputs the channels at a specified sample rate.",
        "long": "The Laser CHOP produces channels that can drive a laser projector. It uses the points and lines of a SOP or CHOP and outputs the channels at a specified sample rate, typically 10,000 to 96,000 samples per second. The Laser CHOP gives optimal control over the movement of the reflectors of the laser projector as well as enhanced color control. In particular, it gives better control of lines being straight, end-points being not cut off or over-drawn, and eliminating tails, all adjustable using a set of parameters. \n    \nThe resulting channels can be sent to the [[EtherDream CHOP]] or [[Helios DAC CHOP]] in case of controlling a Laser via the [https://en.wikipedia.org/wiki/International_Laser_Display_Association ILDA Protocol], or the [[Audio Device Out CHOP]] in case of using one of LaserAnimation Sollinger's [https://en.wikipedia.org/wiki/Audio_Video_Bridging AVB] capable devices, where the audio is output via the [[Audio Device Out CHOP]] to a low-latency AVB-ready audio device like those from MOTU, RME, LaserAnimation Sollinger or Apple macOS. \n\n[https://laseranimation.com/en/products/avb-devices LaserAnimation Sollinger's AVB2ILDA devices] give you access to features for the professional sector including 24bit resolution on the x/y signal and all color channels. Additionally the AVB2ILDA device includes software for electronic masking, making it possible to limit the laser output for certain areas (for example to protect scanning areas such as auditoriums or sectors with optical equipment). Also packaged is a color correction tool that includes individual control of the color delay for 3 colors as well as a Digital Geometric Correction to allow for projection on for example uneven surfaces.    (The Laser CHOP replaces the Scan CHOP.)\n    \nThe CHOP was developed with the help of [https://laseranimation.com/en/ LaserAnimation Sollinger] who guided us in speccing and implementing the necessary parameters, especially in regards of the blanking timing settings.\n\n'''Tip''': See the [[OP Snippets]] for setup and usage examples.\n\n'''LASERS ARE DANGEROUS - DAMAGE TO YOUR OR THE AUDIENCE'S EYE SIGHT IS A VERY REAL RISK'''\n* If you plan to use lasers\n# Understand all the laws and regulations for laser operation in your area.\n# Become a certified Laser Safety Officer (this is required by law in some areas). Courses are available from ILDA directly: [https://www.ilda.com/LSOcourse.htm ILDA Laser Safety Courses]\n* Make sure an emergency stop button is close to you at all times.\n* Do not let anyone enter the laser projection area unless all precautions have been taken to limit the output.\n* Make sure there are no reflective surfaces in the projection area that might cause the beam to reflect unintendedly.",
        "opCategories": ""
    },
    "laserdeviceCHOP": {
        "label": "laserdeviceCHOP",
        "members": [
            {
                "text": "Toggle : When enabled, the CHOP will connect to the specified device and send points to it.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Specify the type of laser device.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "StrMenu : Menu to select the named devices in the case of Helios and ShowNET.",
                "type": "StrMenuPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Pulse : Scan for Helios devices. '''Note:''' there should not be any active Helios device connections when this scan is performed, otherwise they will be closed by the scanning process.",
                "type": "PulsePar",
                "name": "scan",
                "items": []
            },
            {
                "text": "Str : The network address of the EtherDream device to send the packets to. EtherDream IP can be found be polling devices on the network using the [[EtherDream DAT]].",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port to send the EtherDream packets to.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to send from. This is useful when the system has multiple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Float : Determines the queue size of the Helios/EtherDream point buffer and the corresponding time required to drain it. It is often useful to reduce this value when sending fewer points.",
                "type": "FloatPar",
                "name": "queuetime",
                "items": []
            },
            {
                "text": "Menu : The units of queue time.",
                "type": "MenuPar",
                "name": "queueunits",
                "items": []
            },
            {
                "text": "Float : Allows the input x values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "xscale",
                "items": []
            },
            {
                "text": "Float : Allows the input y values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "yscale",
                "items": []
            },
            {
                "text": "Float : Allows the input r values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "redscale",
                "items": []
            },
            {
                "text": "Float : Allows the input g values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "greenscale",
                "items": []
            },
            {
                "text": "Float : Allows the input b values to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "bluescale",
                "items": []
            },
            {
                "text": "Float : Allows the input intensity values (i) to be scaled by the specified factor.",
                "type": "FloatPar",
                "name": "intensityscale",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "laserdeviceCHOP",
        "opLabel": "Laser Device",
        "opClass": "laserdeviceCHOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "",
        "long": "The Laser Device CHOP can send laser points to supported laser devices: EtherDream, Helios, and ShowNET. The devices can be connected to a laser using an ILDA cable, except in the case of ShowNET when an onboard DAC is used. Applications of the Laser Device CHOP include displaying computer-generated shape animations or other special effects of a light show. The Laser Device CHOP replaces the deprecated [[EtherDream CHOP]] and [[Helios DAC CHOP]].\n    \n'''Input/Output Channels:''' \n* '''x:''' the point's X position, between -1 and 1.\n* '''y:''' the point's Y position, between -1 and 1.\n* '''r:''' the point's red color component, between 0 and 1.\n* '''g:''' the point's green color component, between 0 and 1.\n* '''b:''' the point's blue color component, between 0 and 1.\n* '''i:''' the point's color intensity, between 0 and 1.\n* '''user1:''' Optional user field 1. Supported by EtherDream and ShowNET.\n* '''user2:''' Optional user field 2. Supported by EtherDream and ShowNET.\n* '''user3:''' Optional user field 3. Supported by EtherDream.\n* '''user4:''' Optional user field 4. Supported by EtherDream.\n    \nLarge changes in RGB values from sample-to-sample will likely be visibly correct as lasers generally can switch on-off quickly.\n\nBlanking (all-off) occurs when the incoming RGB CHOP channels are all zero, or the Red Scale, Green Scale, and Blue Scale parameters are all zero.\n\nSee also: [[Laser CHOP]], [[EtherDream DAT]], [[Pattern CHOP]]"
    },
    "leapmotionCHOP": {
        "label": "leapmotionCHOP",
        "members": [
            {
                "text": "Toggle : When 'On' data is captured from the Leap Motion sensor.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select between Leap Motion V2 or V4/V5 SDKs for tracking. V5 offers the fastest and most stable tracking, V2 offers some legacy features like gestures.",
                "type": "MenuPar",
                "name": "api",
                "items": []
            },
            {
                "text": "Folder : This parameter should point to the location of the library file (.dll on Windows) that corresponds to the selected API version. The dll file can be found in the driver kit downloaded from the Ultra Leap website inside the 'LeapSDK/lib/x64' folder. For V2, the file will be called 'Leap.dll' and for V4, it is called 'LeapC.dll'.\n\nFor Gemini V5, first install the tracking software, then set this parameter to C:\\Program Files\\Ultraleap\\LeapSDK\\lib\\x64 where it will find the LeapC.dll file.",
                "type": "FolderPar",
                "name": "libfolder",
                "items": []
            },
            {
                "text": "Menu : Switches the device to '''H'''ead '''M'''ounted '''D'''isplay mode.",
                "type": "MenuPar",
                "name": "hmd",
                "items": []
            },
            {
                "text": "Toggle : If set, the following channels will be included:\t\n<!--TDitemStart-->* <code>connected</code> - 1 if the Leap Motion sensor is connected, 0 otherwise.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>sequence_id</code> - Unique id corresponding to the current frame.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "debugchannels",
                "items": []
            },
            {
                "text": "Toggle : If set, the following channels will be included:\t\n<!--TDitemStart-->* <code>hands</code> - Number of hands detected by the sensor.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>fingers</code> - Number of fingers detected by the sensor.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>tools</code> - Number of tools detected by the sensor.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>gestures</code> - Number of gestures detected by the sensor.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>[hand / finger / tool / circle / swipe / keytap / screeptap]:tracking</code> - 1 if the data for the hand, finger, tool or gesture is actively being tracked, 0 otherwise.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "statuschannels",
                "items": []
            },
            {
                "text": "Toggle : This names the hand channels as either right (r) or left (l) hands.",
                "type": "TogglePar",
                "name": "namedhands",
                "items": []
            },
            {
                "text": "Int : Number of hands. The following channels will be included for each detected hand:\t\n<!--TDitemStart-->* <code>hand*:t[xyz]</code> - Coordinates of the hand relative to the sensor.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>hand*:r[xyz]</code> - Rotation of the detected hand.<!--TDitemEnd-->",
                "type": "IntPar",
                "name": "hands",
                "items": []
            },
            {
                "text": "Int : When using 'Named Hands', specify how many left hands will be tracked.",
                "type": "IntPar",
                "name": "lefthands",
                "items": []
            },
            {
                "text": "Int : When using 'Named Hands', specify how many right hands will be tracked.",
                "type": "IntPar",
                "name": "righthands",
                "items": []
            },
            {
                "text": "Toggle : If set, the following channels will be included for each hand, in addition to any others:\t\n<!--TDitemStart-->* <code>hand*:v[xyz]</code> - Velocity of the detected hand.",
                "type": "TogglePar",
                "name": "handvelocity",
                "items": []
            },
            {
                "text": "Toggle : This is only available when using API = Version 2 Tracking. It adds the following channels to tracking hands: \n<!--TDitemStart-->* <code>hand*/sphere:t[xyz]</code> - Position of the detected hand sphere.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>hand*/sphere:radius</code> - Radius size of the detected hand sphere.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "handsphere",
                "items": []
            },
            {
                "text": "Toggle : Pinch is defined as the distance between the thumb and first finger.\n<!--TDitemStart-->* <code>hand*:pinch</code> - How much pinch is detected between the thumb and first finger.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "pinchstrength",
                "items": []
            },
            {
                "text": "Toggle : Grab is defined as how close a hand is to being a fist.\t\n<!--TDitemStart-->* <code>hand*:grab</code> - How much grab is detected, strength is 0 for a flat hand and 1 for a fist.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "grabstrength",
                "items": []
            },
            {
                "text": "Toggle : Instead of simply using a finger index number for each finger tracked, when On this names the finger channels as thumb, index, middle, ring, and pinky.",
                "type": "TogglePar",
                "name": "namedfingers",
                "items": []
            },
            {
                "text": "Int : When not using 'Named Fingers', specify how many fingers to track per hand.",
                "type": "IntPar",
                "name": "fingersperhand",
                "items": []
            },
            {
                "text": "Toggle : Track the rotation for all fingers.\t\n<!--TDitemStart-->* <code>hand*/finger*:r[xyz]</code> - The rotation of the finger.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "fingerrotation",
                "items": []
            },
            {
                "text": "Toggle : If set, the following channels will be included for each finger, in addition to any others:\t\n<!--TDitemStart-->* <code>hand*/finger*:length</code> - Length of the detected finger.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>hand*/finger*:width</code> - Width of the detected finger.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "fingersize",
                "items": []
            },
            {
                "text": "Toggle : Track how straight the fingers are, a finger is considered extended when it is straight as if pointing.\n<!--TDitemStart-->* <code>hand*/finger*:extended</code> - How straight the finger is.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "fingerextended",
                "items": []
            },
            {
                "text": "Toggle : Tracks the position of every joint of every finger.\n<!--TDitemStart-->* <code>hand*/finger*/joint_mcp:t[xyz]</code> - The mcp joint position of the finger.<!--TDitemEnd-->\n<!--TDitemStart-->* <code>hand*/finger*/joint_pip:t[xyz]</code> - The pip joint position of the finger.<!--TDitemEnd-->\n<!--TDitemStart-->* <code>hand*/finger*/joint_dip:t[xyz]</code> - The dip joint position of the finger.<!--TDitemEnd-->\n<!--TDitemStart-->* <code>hand*/finger*/joint_tip:t[xyz]</code> - The finger tip position.<!--TDitemEnd-->",
                "type": "TogglePar",
                "name": "fingerjoints",
                "items": []
            },
            {
                "text": "Int : Number of tools. The following channels will be included for each detected tool:\t\n<!--TDitemStart-->* <code>tool*:t[xyz]</code> - Coordinates of the tool relative to the sensor.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>tool*:length</code> - Length of the detected tool.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>tool*:width</code> - Width of the detected tool.<!--TDitemEnd-->",
                "type": "IntPar",
                "name": "tools",
                "items": []
            },
            {
                "text": "Int : Number of circle gestures. The following channels will be included for each detected [http://developer.leapmotion.com/documentation/Languages/C++/Guides/Leap_Overview.html#circle Circle Gesture]:\t\n<!--TDitemStart-->* <code>circle*:handindex</code> - Index of the hand associated with the gesture. See Notes.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>circle*:t[xyz]</code> - Coordinates of the center of the Circle Gesture relative to the sensor.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>circle*:radius</code> - Radius of the circle in the gesture.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>circle*:progress</code> - Number of cycles done in the gesture.<!--TDitemEnd-->",
                "type": "IntPar",
                "name": "circlegestures",
                "items": []
            },
            {
                "text": "Int : Number of swipe gestures. The following channels will be included for each detected [http://developer.leapmotion.com/documentation/Languages/C++/Guides/Leap_Overview.html#swipe Swipe Gesture]:\t\n<!--TDitemStart-->* <code>swipe*:handindex</code> - Index of the hand associated with the gesture. See Notes.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>swipe*:fingerindex</code> - Index of the finger associated with the gesture. See Notes.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>swipe*:t[xyz]</code> - Coordinates of the Swipe Gesture relative to the sensor.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>swipe*:start[xyz]</code> - Coordinates of the start of the Swipe Gesture relative to the sensor.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>swipe*:speed</code> - Speed of the swipe.<!--TDitemEnd-->",
                "type": "IntPar",
                "name": "swipegestures",
                "items": []
            },
            {
                "text": "Int : Number of key tap gestures. The following channels will be included for each detected [http://developer.leapmotion.com/documentation/Languages/C++/Guides/Leap_Overview.html#key-taps Key Tap Gesture]:\t\n<!--TDitemStart-->* <code>keytap*:handindex</code> - Index of the hand associated with the gesture. See Notes.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>keytap*:fingerindex</code> - Index of the finger associated with the gesture. See Notes.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>keytap*:t[xyz]</code> - Coordinates of the Key Tap Gesture relative to the sensor.<!--TDitemEnd-->",
                "type": "IntPar",
                "name": "keytapgestures",
                "items": []
            },
            {
                "text": "Int : Number of screen tap gestures, which is recognized as a quick forward tapping movement by a tool or finger. The following channels will be included for each detected screen tap gesture:\n<!--TDitemStart-->* <code>screentap*:handindex</code> - Index of the hand associated with the gesture. See Notes.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>screentap*:fingerindex</code> - Index of the finger associated with the gesture. See Notes.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* <code>screentap*:t[xyz]</code> - Coordinates of the Screen Tap Gesture relative to the sensor.<!--TDitemEnd-->",
                "type": "IntPar",
                "name": "screentapgestures",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Leap Motion CHOP reads hand, finger, tool and gesture data from the [[Leap Motion]] controller. It outputs hand, finger and tool positions, rotations and 'tracking' channels that indicate if these values are currently being detected and updated. Currently only 1 Leap Motion device can be connected at a time.\t\t\n\t\t\t\nTo connect with the device you will need to install the Leap Motion software which is available here:\t\nhttps://developer.leapmotion.com/releases\n* API Version 5 Gemini - Download Gemini v5.6.1\n* API Version 4 Orion - Download Orion Beta v4.1.0\n* API Version 2 Tracking - Download Orion Beta v3.2.1\n\nYou will also need to set the Library Folder parameter to the location of the Leap SDK on your machine. See the parameter details below for more information.\n\n'''Tip:''' If using Gemini V5, the Leap Motion will only work in one orientation. By default the hands enter from the bottom of the camera view, though this can be changed in setting to invert the direction. This is an important distinction between Gemini V5 and the older V2/V4 APIs which could work in either orientation.\n\n'''Note:''' TouchDesigner does not include a license to use the Leap Motion hardware or software. Make sure to check with the [https://www.ultraleap.com/ UltraLeap website] regarding any applicable licenses that you may need for your project.\n\nSee also [[Leap Motion]], [[Leap Motion TOP]]",
        "opLicense": "Non-Commercial",
        "opClass": "leapmotionCHOP_Class",
        "opLabel": "Leap Motion",
        "opFamily": "CHOP",
        "opType": "leapmotion",
        "short": "The Leap Motion CHOP reads hand, finger, tool and gesture data from the [[Leap Motion]] controller.",
        "opCategories": ""
    },
    "leuzerod4CHOP": {
        "label": "leuzerod4CHOP",
        "members": [
            {
                "text": "Toggle : While on, the CHOP receives information from the scanner. While off, the network connection is disconnected and no updating occurs.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The IP address of the ROD4 scanner.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The network port of the scanner.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Menu : Selects which protocol to use. This must match the protocol the scanner was set to use in the RODplussoft setup utility for the device. You may still get some sort of data if the wrong protocol is selected, but the data will be random and incorrect.",
                "type": "MenuPar",
                "name": "rod4porotocol",
                "items": []
            },
            {
                "text": "Menu : Available when using ROD4plus ASCII-Remote protocol, specifies whether to use Polar or Cartesian input coordinates. This must match the coordinate the scanner was set to use in the RODplussoft setup utility for the device.",
                "type": "MenuPar",
                "name": "inputcoordinate",
                "items": []
            },
            {
                "text": "Menu : Select Raw Data or Blob Tracking mode for output channels. The parameters below are only available in Blob Tracking mode.",
                "type": "MenuPar",
                "name": "outputmode",
                "items": []
            },
            {
                "text": "Int : The maximum number of blobs that can be tracked.",
                "type": "IntPar",
                "name": "maxblobs",
                "items": []
            },
            {
                "text": "Float : Two measured points from the scanner are considered to be part of the same blob if they are this distance or closer to each other. Distance is specified in meters.",
                "type": "FloatPar",
                "name": "maxpointdistance",
                "items": []
            },
            {
                "text": "Float : Specified in meters. This controls the maximum distance a blob can move between successive frames and still be considered the same 'blob'.",
                "type": "FloatPar",
                "name": "maxblobmovement",
                "items": []
            },
            {
                "text": "Menu : Limits the area in which blobs are tracked.",
                "type": "MenuPar",
                "name": "areaofinterest",
                "items": []
            },
            {
                "text": "Float : Maximum distance in which blobs are tracked when Area of Interest parameter is set to Distance Based.",
                "type": "FloatPar",
                "name": "maxdistance",
                "items": []
            },
            {
                "text": "Float : Specifies the lower left corner of the bounding box used when Area of Interest parameter is set to Bounding Box.",
                "type": "FloatPar",
                "name": "lowerleft",
                "items": []
            },
            {
                "text": "Float : Specifies the upper right corner of the bounding box used when Area of Interest parameter is set to Bounding Box.",
                "type": "FloatPar",
                "name": "upperright",
                "items": []
            },
            {
                "text": "Toggle : When this is on, blobs detected within the Area of Interest can move outside of that area and still be tracked. When this is off blobs that move outside the area of interest will stop being tracked.",
                "type": "TogglePar",
                "name": "allowmovementoutside",
                "items": []
            },
            {
                "text": "TOP : Specify a TOP to use as a mask for the bounding box when Area of Interest parameter is set to Bounding Box. Any pixel with a non-zero value will be treated as part of the area of interest, any pixel that is (0,0,0) will be treated as not in the area of interest. Regardless of resolution/aspect ratio of the TOP, the TOP will be stretched to fix the bounding box specified. This TOP should '''not''' be cooking every frame as that will make the ROD4 CHOP very slow.",
                "type": "TOPPar",
                "name": "boundingboxmask",
                "items": []
            },
            {
                "text": "Float : Rotates all incoming coordinates where the tx and ty values are rotated around a perpendicular z-axis.",
                "type": "FloatPar",
                "name": "rotate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Leuze ROD4 CHOP connects to the [https://www.leuze.com/en-int/products/switching-sensors/area-scanners?p=1 Leuze ROD4] laser scanner via TCP/IP. Blob Tracking mode allows for turning the measured distances into blobs for use as an interaction surface. It should work with any of the ROD4 scanners currently available.\t\t\n\t\t\t\nThe 'object detection' mode available on some of the models is not currently supported.\t\t\n\nThe Leuze can be used with the [[Blob Track CHOP]] to detect objects in its field. See the OP Snippet for Blob Track.",
        "opLicense": "Commercial",
        "opClass": "leuzerod4CHOP_Class",
        "opLabel": "Leuze ROD4",
        "opFamily": "CHOP",
        "opType": "rod",
        "short": "The Leuze ROD4 CHOP connects to the [https://www.leuze.com/en-int/products/switching-sensors/area-scanners?p=1 Leuze ROD4] laser scanner via TCP/IP.",
        "opCategories": ""
    },
    "lfoCHOP": {
        "label": "lfoCHOP",
        "members": [
            {
                "text": "Menu : The shape of the waveform to repeat, unless overridden by the Source Wave:",
                "type": "MenuPar",
                "name": "wavetype",
                "items": []
            },
            {
                "text": "Toggle : The LFO oscillates when 1, and stops when 0. Think of it like play and pause.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : The cycles per second of the oscillation. When the Octave Control input is connected, it alters the frequency exponentially.",
                "type": "FloatPar",
                "name": "frequency",
                "items": []
            },
            {
                "text": "Float : Values output from the CHOP can have an offset added to them.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Float : Values output from the CHOP can be scaled.",
                "type": "FloatPar",
                "name": "amp",
                "items": []
            },
            {
                "text": "Float : Shape control for Triangle, Gaussian and Square waves. For triangle waves, it moves the peak. For square waves, it alters the width of the peak. Zero means no bias.",
                "type": "FloatPar",
                "name": "bias",
                "items": []
            },
            {
                "text": "Float : A value of .5 is a phase shift of 180 degrees, or one half cycle.",
                "type": "FloatPar",
                "name": "phase",
                "items": []
            },
            {
                "text": "Menu : This menu determines how the Reset input triggers resetting the channel(s).",
                "type": "MenuPar",
                "name": "resetcondition",
                "items": []
            },
            {
                "text": "Toggle : This toggle resets the channel(s) to 0 while On.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : This button instantly resets the channel(s) to 0.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "Str : A list of the names of the channels. You can put patterns like <code>chan[1-10]</code> to generate 10 channels. See [[Pattern Expansion]].\t\n\t\t\t\nEach channel can be different by putting the channel index variable, <code>$C</code> in parameters like the frequency channel.",
                "type": "StrPar",
                "name": "channelname",
                "items": []
            },
            {
                "text": "Float : The sample rate of the CHOP. The default sample rate is 60 samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opClass": "lfoCHOP_Class",
        "opFamily": "CHOP",
        "long": "The LFO CHOP (low frequency oscillator) generates waves in real-time in two ways. It synthesizes curves using a choice of common waveforms like Sine or Pulse, or it repeats a prepared incoming curve.\t\t\n\t\t\t\nIt steps through the waveform at a rate that depends on the Frequency parameter and the Octave Control input. To watch its behavior, attach a Trail CHOP to its output and alter the Frequency parameter.\t\t\t\n\t\t\nUp to three input CHOPs can be connected to the LFO CHOP:\t\t\t\n\t\t\t\n'''Octave Control''' - Without this first (optional) input, the frequency is simply the Frequency parameter. If this input is connected, every unit doubles the frequency: When Octave Control is 1, the frequency is double, when it is 2 it is 4x, when it is -1 the frequency is half the Frequency parameter and when it is 0, there is no change in the frequency.\t\t\t\n\t\t\t\n'''Reset''' - The seond (optional) input contains on-off (<=0 or >0) that restarts the channels of the oscillator from the beginning of the wave. The reset depends on the setting of the Reset Condition menu. By default, when the Reset input goes from off to on, it resets the wave and starts the waveform immediately. If Reset Condition is set to \"While On\", the reset value will be held until the Reset input goes off. Reset means \"stop the oscillator and cue it at the start of the waveform\".\t\t\t\n\t\t\t\n'''Source Wave''' - The third (optional) input is a replacement of the waveform Type. It is a multi-sample CHOP curve and can contain any number of channels, limited to the channels defined on the Channel page. The waveform Type parameter is disabled.\t\t\t\n\t\t\t\nThe LFO CHOP can serve as a general motion time-warper and repeater. If you alter the Frequency, you can control the time warp.\t\t\t\n\t\t\t\nUnlike the [[Wave CHOP]], this is a time-sliced CHOP, that is, it generates its waveform as it goes, and speeds/slows how it steps through the waveform Type while the Frequency changes.  Unlike the [[Audio Oscillator CHOP]], the LFO CHOP is designed for non-audio frequencies. \t\t\t\n\t\t\t\nSee also: [[Audio Oscillator CHOP]], [[Wave CHOP]], [[Pulse CHOP]].",
        "short": "The LFO CHOP (low frequency oscillator) generates waves in real-time in two ways.",
        "opFilter": "False",
        "opType": "lfo",
        "opLabel": "LFO",
        "opCategories": ""
    },
    "limitCHOP": {
        "label": "limitCHOP",
        "members": [
            {
                "text": "Menu : Select limit options such as loop, clamp, or zigzag from the menu. The value will remain in the range from Min to less than Max.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Float : The minimum value the output channel can have.",
                "type": "FloatPar",
                "name": "min",
                "items": []
            },
            {
                "text": "Float : The maximum value the output channel can have.",
                "type": "FloatPar",
                "name": "max",
                "items": []
            },
            {
                "text": "Toggle : Takes the absolute value of the channel, making all negative values positive.",
                "type": "TogglePar",
                "name": "positive",
                "items": []
            },
            {
                "text": "Toggle : Scale and offset the channel so that it lies between -1 and +1. The Normalize function does not work with [[Time Slicing]] on.",
                "type": "TogglePar",
                "name": "norm",
                "items": []
            },
            {
                "text": "Toggle : This will cause extremely tiny numbers to be rounded to 0.",
                "type": "TogglePar",
                "name": "underflow",
                "items": []
            },
            {
                "text": "Menu : Selects the quantization method to use:",
                "type": "MenuPar",
                "name": "quantvalue",
                "items": []
            },
            {
                "text": "Float : The increment between quantized values.",
                "type": "FloatPar",
                "name": "vstep",
                "items": []
            },
            {
                "text": "Float : The offset for quantized values, to allow steps to not lie at zero, the default.",
                "type": "FloatPar",
                "name": "voffset",
                "items": []
            },
            {
                "text": "Menu : Selects whether to quantize the index relative to the sample 0, or the start index of the CHOP.",
                "type": "MenuPar",
                "name": "quantindex",
                "items": []
            },
            {
                "text": "Float : The increment between quantized indices, in seconds, frames or samples.",
                "type": "FloatPar",
                "name": "istep",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "istepunit",
                "items": []
            },
            {
                "text": "Float : The offset for quantized indices.",
                "type": "FloatPar",
                "name": "ioffset",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "ioffsetunit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Limit CHOP can limit the values of the input channels to be between a minimum and maximum, and can quantize the input channels in time and/or value such that the value steps over time.\t\t\n\t\t\t\nLimiting a channel causes all its values to lie within a range. Several different methods are for limiting are listed under the Type parameter description.\t\t\t\n\t\t\t\nQuantizing a channel value snaps its values to the closest allowable value (the \"quantized values\"). Quantizing methods are: Floor, Ceiling, and Round.\t\t\t\n\t\t\t\nQuantizing a channel index is like quantizing in time, and acts as a sample and hold mechanism. The channel is sampled at a quantized index, and held at that value until the next quantized index at which time the value takes on the input value at that point.",
        "opLicense": "Non-Commercial",
        "opClass": "limitCHOP_Class",
        "opLabel": "Limit",
        "opFamily": "CHOP",
        "opType": "limit",
        "short": "The Limit CHOP can limit the values of the input channels to be between a minimum and maximum, and can quantize the input channels in time and/or value such that the value steps over time.",
        "opCategories": ""
    },
    "logicCHOP": {
        "label": "logicCHOP",
        "members": [
            {
                "text": "Menu : This menu determines the method to convert inputs to binary:",
                "type": "MenuPar",
                "name": "convert",
                "items": []
            },
            {
                "text": "Menu : Once converted by the Convert Input stage, Channel Pre OP defines a unary operation on each input sample:",
                "type": "MenuPar",
                "name": "preop",
                "items": []
            },
            {
                "text": "Menu : Takes the first input and combines its channels, then the second input and combines its channels, and so on.",
                "type": "MenuPar",
                "name": "chanop",
                "items": []
            },
            {
                "text": "Menu : Combine CHOPs combines the first channels of each CHOP, the second channels of each CHOP, etc.. Channels between inputs can be combined by number or name. Combining (Logic) Operations are:",
                "type": "MenuPar",
                "name": "chopop",
                "items": []
            },
            {
                "text": "Menu : Channels are matched between inputs by Channel Name or Channel Number.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Menu : Inputs that don't start at the same frame can be aligned. Se the section, Align Options.",
                "type": "MenuPar",
                "name": "align",
                "items": []
            },
            {
                "text": "Float : Set lower and upper bounds for when Convert Input is set to '''Off When Outside Bounds'''.",
                "type": "FloatPar",
                "name": "bound",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Logic CHOP first converts channels of all its input CHOPs into binary (0 = off, 1 = on) channels and then combines the channels using a variety of logic operations.\t\t\n\t\t\t\n'''NOTE:''' The Logic CHOP is superceded by more convenient operators like the [[CHOP Execute DAT]] or the [[Text DAT]] which will run their scripts when CHOP channels change.\t\t\t\n\t\t\t\nThe Logic CHOP performs logic operations on the samples in CHOP channels. The channels of a CHOP can be combined into one channel, and several CHOPs can be combined into one CHOP.\t\t\t\n\t\t\t\nWith one input CHOP, you can invert the values of each sample. You can also do logic operations on the samples of one channel by the samples in the other channels, reducing N channels down to one. You can combine by applying an \"or\", \"and\", etc..\t\t\t\n\t\t\t\nWith two or more CHOP inputs, you can combine the channels in one CHOP with the channels in all the other CHOPs, reducing N CHOPs to 1.\t\t\t\n\t\t\t\nTo do math operations (add, multiply, ...) between channels or CHOPs, use the [[Math CHOP]].",
        "opLicense": "Non-Commercial",
        "opClass": "logicCHOP_Class",
        "opLabel": "Logic",
        "opFamily": "CHOP",
        "opType": "logic",
        "short": "The Logic CHOP first converts channels of all its input CHOPs into binary (0 = off, 1 = on) channels and then combines the channels using a variety of logic operations.",
        "opCategories": ""
    },
    "lookupCHOP": {
        "label": "lookupCHOP",
        "members": [
            {
                "text": "Float : The Index Range maps the index channel's values to the lookup table's start and end and defaults to 0 and 1. The first parameter represents the start of the lookup table. When the index channel has this value, it will index the start of the lookup table. The second parameter represents the end of the lookup table and behaves in the same way.",
                "type": "FloatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Menu : Adapts the range of the Lookup Table (2nd input) for cyclic or non-cyclic input indices. When using a cyclic input index (1st input), the lookup value for index 0.0 and 1.0 result in the same value. To avoid this, set Cyclic Range to Yes and the lookup will cycle smoothly.",
                "type": "MenuPar",
                "name": "cyclic",
                "items": []
            },
            {
                "text": "Menu : Determines how index channels are mapped to lookup Channel tables.",
                "type": "MenuPar",
                "name": "chanmatch",
                "items": []
            },
            {
                "text": "Menu : Determines how index channels are matched with a lookup channel in 'One Lookup Table Channel' mode.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Toggle : When on, the input can be interpolated between samples. When off, the nearest sample is used.",
                "type": "TogglePar",
                "name": "interp",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Lookup CHOP outputs values from a lookup table. The first input (the Index Channel) is an index into the second input (the Lookup Table). Lookup outputs interpolated values from the lookup table.\t\t\n\t\t\t\nBoth the Index and Lookup Tables can contain any number of channels.\t\t\t\n\t\t\t\nAn Index sample with value 0 maps to the beginning (first sample) of the lookup table, and an index sample with value of 1 maps to the end (last sample) of the lookup table.\t\t\t\n\t\t\t\nThe output CHOP is the same length as the Index input. It is the same number of channels as the Lookup Table input, and has the same channel names as the Lookup Table input. The output is filled with the data extracted from the lookup tables. Indexes that fall between two lookup table samples are interpolated. The lookup table can be sampled outside its range. \n\nNOTE: The Extend Conditions of the lookup table are used in this case where the index is less than 0 or greater than 1.\t\t\t\n\t\t\t\nThe sample rate of the output is the sample rate of the Index input.\t\t\t\n\t\t\t\nThe Lookup CHOP can be used to fetch values from a color lookup table, where a single index produces red, green and blue channels. It can also be used for rolloff or decay tables, where it specifies how much a parameter drops with distance.",
        "opLicense": "Non-Commercial",
        "opClass": "lookupCHOP_Class",
        "opLabel": "Lookup",
        "opFamily": "CHOP",
        "opType": "lookup",
        "short": "The Lookup CHOP outputs values from a lookup table.",
        "opCategories": ""
    },
    "ltcinCHOP": {
        "label": "ltcinCHOP",
        "members": [
            {
                "text": "Float : This specifies the number of complete frame messages per second the signal encodes. It is usually between 24 and 30.",
                "type": "FloatPar",
                "name": "inputrate",
                "items": []
            },
            {
                "text": "Toggle : When enabled, adds frame, second, minute, and hour channels will be added to the output.",
                "type": "TogglePar",
                "name": "discrete",
                "items": []
            },
            {
                "text": "Toggle : When enabled, adds a channel to the output that reports total elapsed LTC frames at the current time. This value will change if up-sampling to the timeline FPS.",
                "type": "TogglePar",
                "name": "totalframes",
                "items": []
            },
            {
                "text": "Toggle : When enabled, adds a channel to the output that reports total elapsed seconds.",
                "type": "TogglePar",
                "name": "totalsec",
                "items": []
            },
            {
                "text": "Toggle : Resamples up to the project's FPS.",
                "type": "TogglePar",
                "name": "upsample",
                "items": []
            },
            {
                "text": "Toggle : This enables channels for custom user fields which may be encoded in the audio signal.",
                "type": "TogglePar",
                "name": "userfields",
                "items": []
            },
            {
                "text": "Toggle : This enables the following debug channels.\n* quantized - Outputs the raw signal quantized to on and off levels.\n* bits - Outputs the above quantized signal into decoded bits. (Note:  Bits are decoded from specific edge sequences, not the raw levels themselves).\n* ones_count - Outputs the total number of consecutive decoded one bits.  (Note, 12 consecutive ones denotes an end of message).\n* decode_count -  Outputs the total number of successful decoded frame messages.",
                "type": "TogglePar",
                "name": "debugchans",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The LTC In CHOP reads SMPTE timecode data encoded into an audio signal. Read the overview [http://en.wikipedia.org/wiki/Linear_timecode Linear Timecode].\t\n\t\t\nFirst bring the audio signal into CHOPs using an [[Audio Device In CHOP]]. This can then be input into the LTC In CHOP.\t\t\n\t\t\nSee also: [[LTC Out CHOP]]",
        "opLicense": "Non-Commercial",
        "opClass": "ltcinCHOP_Class",
        "opLabel": "LTC In",
        "opFamily": "CHOP",
        "opType": "ltcin",
        "short": "The LTC In CHOP reads SMPTE timecode data encoded into an audio signal.",
        "opCategories": ""
    },
    "ltcoutCHOP": {
        "label": "ltcoutCHOP",
        "members": [
            {
                "text": "Toggle : Specifies whether the count should increment or hold steady.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Int : The initial frame to count from.",
                "type": "IntPar",
                "name": "frame",
                "items": []
            },
            {
                "text": "Int : The initial second to count from.",
                "type": "IntPar",
                "name": "second",
                "items": []
            },
            {
                "text": "Int : The initial minute to count from.",
                "type": "IntPar",
                "name": "minute",
                "items": []
            },
            {
                "text": "Int : The initial hour to count from.",
                "type": "IntPar",
                "name": "hour",
                "items": []
            },
            {
                "text": "Float : The number of complete frame messages per second the signal encodes. It is usually between 24 and 30.",
                "type": "FloatPar",
                "name": "framerate",
                "items": []
            },
            {
                "text": "Float : This audio sampling rate of the output signal.",
                "type": "FloatPar",
                "name": "audiorate",
                "items": []
            },
            {
                "text": "Toggle : Drop frame numbering converts 30 fps time code to the 29.97 fps NTSC standard. Frame numbers 0 and 1 are skipped during the first second of every minute, except multiples of 10 minutes.",
                "type": "TogglePar",
                "name": "dropframe",
                "items": []
            },
            {
                "text": "Toggle : While set to on, the output is held at the specified initial values above.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : When pulsed, the output is held at the specified initial values above.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 1.",
                "type": "IntPar",
                "name": "user1",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 2.",
                "type": "IntPar",
                "name": "user2",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 3.",
                "type": "IntPar",
                "name": "user3",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 4.",
                "type": "IntPar",
                "name": "user4",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 5.",
                "type": "IntPar",
                "name": "user5",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 6.",
                "type": "IntPar",
                "name": "user6",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 7.",
                "type": "IntPar",
                "name": "user7",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 8.",
                "type": "IntPar",
                "name": "user8",
                "items": []
            },
            {
                "text": "Menu : Specifies the method used to output LTC, there are 2 options.",
                "type": "MenuPar",
                "name": "playmode",
                "items": []
            },
            {
                "text": "Toggle : Specifies whether the count should increment or hold steady.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Toggle : While set to on, the output is held at the specified initial values below.",
                "type": "TogglePar",
                "name": "cue",
                "items": []
            },
            {
                "text": "Pulse : When pulsed, the output is set to the initial values below.",
                "type": "PulsePar",
                "name": "cuepulse",
                "items": []
            },
            {
                "text": "Int : The initial frame to count from.",
                "type": "IntPar",
                "name": "frame",
                "items": []
            },
            {
                "text": "Int : The initial second to count from.",
                "type": "IntPar",
                "name": "second",
                "items": []
            },
            {
                "text": "Int : The initial minute to count from.",
                "type": "IntPar",
                "name": "minute",
                "items": []
            },
            {
                "text": "Int : The initial hour to count from.",
                "type": "IntPar",
                "name": "hour",
                "items": []
            },
            {
                "text": "Float : The number of complete frame messages per second the signal encodes. It is usually between 24 and 30.",
                "type": "FloatPar",
                "name": "framerate",
                "items": []
            },
            {
                "text": "Toggle : Drop frame numbering converts 30 fps time code to the 29.97 fps NTSC standard. Frame numbers 0 and 1 are skipped during the first second of every minute, except multiples of 10 minutes.",
                "type": "TogglePar",
                "name": "dropframe",
                "items": []
            },
            {
                "text": "Str : Set the LTC output value with a reference to a timecode. Should be a reference to either a CHOP with channels 'hour', 'second', 'minute', 'frame', a DAT with a timecode string in its first cell, or a [[Timecode Class]] object.",
                "type": "StrPar",
                "name": "timecodeop",
                "items": []
            },
            {
                "text": "Float : This audio sampling rate of the output signal.",
                "type": "FloatPar",
                "name": "audiorate",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 1.",
                "type": "IntPar",
                "name": "user1",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 2.",
                "type": "IntPar",
                "name": "user2",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 3.",
                "type": "IntPar",
                "name": "user3",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 4.",
                "type": "IntPar",
                "name": "user4",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 5.",
                "type": "IntPar",
                "name": "user5",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 6.",
                "type": "IntPar",
                "name": "user6",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 7.",
                "type": "IntPar",
                "name": "user7",
                "items": []
            },
            {
                "text": "Int : Send this value in the bits reserved for User Data 8.",
                "type": "IntPar",
                "name": "user8",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The LTC Out CHOP outputs \"linear timecode\" which is a SMPTE timecode data encoded into an audio signal. See also [http://en.wikipedia.org/wiki/Linear_timecode Linear Timecode].\t\n\t\t\nUse an [[Info CHOP]] to determine which values are currently being output.\t\t\n\t\t\nThe output of this CHOP can be sent to an [[Audio Device Out CHOP]].\t\t\n\t\t\nSee also: [[LTC In CHOP]]",
        "opLicense": "Non-Commercial",
        "opClass": "ltcoutCHOP_Class",
        "opLabel": "LTC Out",
        "opFamily": "CHOP",
        "opType": "ltcout",
        "short": "The LTC Out CHOP outputs \"linear timecode\" which is a SMPTE timecode data encoded into an audio signal. See also [http://en.wikipedia.org/wiki/Linear_timecode Linear Timecode].",
        "opCategories": ""
    },
    "mathCHOP": {
        "label": "mathCHOP",
        "members": [
            {
                "text": "Menu : Unary operations can be performed on individual channels. A menu of unary operations (as described above) that are performed on each channel as it comes in to the Math CHOP include:",
                "type": "MenuPar",
                "name": "preop",
                "items": []
            },
            {
                "text": "Menu : A choice of operations is performed between the channels of an input CHOP, for each input. The Nth sample of one channel is combined with the Nth sample of other channels:",
                "type": "MenuPar",
                "name": "chanop",
                "items": []
            },
            {
                "text": "Menu : A menu of operations that is performed between the input CHOPs, combining several CHOPs into one.",
                "type": "MenuPar",
                "name": "chopop",
                "items": []
            },
            {
                "text": "Menu : A menu (same as Channel Pre OP) is performed as the finale stage upon the channels resulting from the above operations.",
                "type": "MenuPar",
                "name": "postop",
                "items": []
            },
            {
                "text": "Menu : Match channels between inputs by name or index.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Menu : This menu handles cases where multiple input CHOPs have different start or end times. All channels output from a CHOP share the same start/end interval, so the inputs must be treated with the Align Options:",
                "type": "MenuPar",
                "name": "align",
                "items": []
            },
            {
                "text": "Toggle : Use this option when the input is a higher frequency than the timeline (example: audio).  It will avoid any pops or crackles in the output when adjusting the multiply, add or  range parameters.",
                "type": "TogglePar",
                "name": "interppars",
                "items": []
            },
            {
                "text": "Menu : The resulting values can be converted to integer.",
                "type": "MenuPar",
                "name": "integer",
                "items": []
            },
            {
                "text": "Float : First, add the value to each sample of each channel.",
                "type": "FloatPar",
                "name": "preoff",
                "items": []
            },
            {
                "text": "Float : Then multiply by this value.",
                "type": "FloatPar",
                "name": "gain",
                "items": []
            },
            {
                "text": "Float : Then add this value.",
                "type": "FloatPar",
                "name": "postoff",
                "items": []
            },
            {
                "text": "Float : Another way to multiply/add. Converts from one low-high range to another range.",
                "type": "FloatPar",
                "name": "fromrange",
                "items": []
            },
            {
                "text": "Float : Another way to multiply/add. Converts from one low-high range to another range.",
                "type": "FloatPar",
                "name": "torange",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Math CHOP performs arithmetic operations on channels. The channels of a CHOP can be combined into one channel, and several CHOPs can be combined into one CHOP.\t\t\n\t\t\t\nThe OP page lets you pre-operate on each sample, like making all samples positive or taking the square  of each sample.\t\t\t\n\t\t\t\nUsing '''Combine Channels''', for an input CHOP with multi-channels, you can multiply the samples of one channel by the samples in the other channels, reducing N channels down to one. You can combine them by multiplying, adding, finding the maximum, etc..  \t\t\t\n\t\t\t\nUsing '''Combine CHOPs''', where there are two or more CHOP inputs, you can multiply (or add, etc.) the channels in one CHOP with the channels in all the other CHOPs, reducing N CHOPs to 1. (otherwise channels of multi-inputs are just merged)\t\t\t\n\t\t\t\nYou can then post-operate on the resulting samples - negate, square root, etc.\t\t\t\n\t\t\t\nThen using the Mult-Add page it can offset and scale the values of each sample.\t\t\t\n\t\t\t\nMore conveniently you can use the Range page to do linear scaling as well by setting an output low-high range for a certain input low-high range.\t\t\t\n\t\t\t\nFinally, you can round the resulting values off to an integer.\n\n'''Tip''': You can affect only certain channels of your input by using the Scope parameter on the Common page.\n\t\t\t\n'''Note''': To do logic operations (and, or, ...) between channels or CHOPs, use the [[Logic CHOP]].\n\n'''Tip: Customizing each channel:''': You can use the local member <code>chanIndex</code> in a parameter like Post-Add, for example, <code>me.chanIndex*2</code> to give a different post-add value for each channel. <code>chanIndex</code> is available in numerous CHOPs like the [[Pattern CHOP]]. (expressions are non-optimized)",
        "opLicense": "Non-Commercial",
        "opClass": "mathCHOP_Class",
        "opLabel": "Math",
        "opFamily": "CHOP",
        "opType": "math",
        "short": "The Math CHOP performs arithmetic operations on channels. The channels of a CHOP can be combined into one channel, and several CHOPs can be combined into one CHOP.",
        "opCategories": ""
    },
    "mergeCHOP": {
        "label": "mergeCHOP",
        "members": [
            {
                "text": "Menu : This menu handles cases where multiple input CHOPs have different start or end times. All channels output from a CHOP share the same start/end interval, so the inputs must be treated with the Align Options:",
                "type": "MenuPar",
                "name": "align",
                "items": []
            },
            {
                "text": "Menu : When channels of the input CHOPs have the same name, this menu determines what to do.",
                "type": "MenuPar",
                "name": "duplicate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Merge CHOP takes multiple inputs and merges them into the output. All the channels of the input appear in the output. The channel order is the channels of the first input followed by the channels of the second input, and so on.\t\t\n\t\t\t\nChannel names may conflict, but a channel is renamed according to the Duplicate Names menu. The CHOP appends or increments the digits of the channel name until an unused name is found.\t\t\t\n\t\t\t\nWhen the Time Slice flag on the Common parameter page is on, the Merge CHOP will merge only the current [[Time Slice]] of a channel, not the entire length of all the channels.",
        "opLicense": "Non-Commercial",
        "opClass": "mergeCHOP_Class",
        "opLabel": "Merge",
        "opFamily": "CHOP",
        "opType": "merge",
        "short": "The Merge CHOP takes multiple inputs and merges them into the output.",
        "opCategories": ""
    },
    "midiinCHOP": {
        "label": "midiinCHOP",
        "members": [
            {
                "text": "Toggle : Enable or disable the MIDI In CHOP.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Get MIDI input from a device or a file.",
                "type": "MenuPar",
                "name": "source",
                "items": []
            },
            {
                "text": "DAT : Path to the MIDI device [[Table DAT]]",
                "type": "DATPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Str : Specify the id of which device to use.",
                "type": "StrPar",
                "name": "id",
                "items": []
            },
            {
                "text": "File : If MIDI file is selected as the MIDI source use this field to specify the name of the MIDI file to read. The file can be read in from disk or from the web. Use http:// when specifying a URL.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : If enabled, the entire MIDI file is read. Otherwise, the Start and End parameters on the Channel page determine the segment of the file to read.",
                "type": "TogglePar",
                "name": "entire",
                "items": []
            },
            {
                "text": "Toggle : Deletes all channels when set to On, new channels will not be added until Reset Channels is turned Off.",
                "type": "TogglePar",
                "name": "resetchannels",
                "items": []
            },
            {
                "text": "Pulse : Instantly resets all channels to 0.",
                "type": "PulsePar",
                "name": "resetchannelspulse",
                "items": []
            },
            {
                "text": "Toggle : When this is on channels are automatically created when MIDI signal is detected from the selected MIDI device.",
                "type": "TogglePar",
                "name": "simplified",
                "items": []
            },
            {
                "text": "Toggle : When on, quick value transitions (pulses) are spaced out over consecutive output samples. Use this option when pulse frequencies approach or exceed the timeline rate, otherwise they risk overlapping each other and being lost.",
                "type": "TogglePar",
                "name": "preservepulses",
                "items": []
            },
            {
                "text": "Toggle : Make the index 1 based instead of the default 0 based.",
                "type": "TogglePar",
                "name": "onebased",
                "items": []
            },
            {
                "text": "Str : The CHOP may read from any number of MIDI channels, numbered 1-16. Ranges and multiple entries are supported (i.e. \"1 4 6\", \"1-7 12\", \"1-5:2\").\t\n\t\t\t\n: If Channel Prefix is left blank, then the input streams from multiple MIDI channels will be combined into one set of CHOP channels (i.e., a \"note 64 on\" event on channel 12 followed by a \"note 64 off\" event on channel 8 appears in the note 64 CHOP channel as a single note).",
                "type": "StrPar",
                "name": "channel",
                "items": []
            },
            {
                "text": "Str : When recording from multiple MIDI channels, putting a string like \"ch\" in this parameter causes the MIDI channel to be split into separate CHOP channels per MIDI channel. Otherwise the MIDI channels are all merged into one set of CHOP channels.",
                "type": "StrPar",
                "name": "prefix",
                "items": []
            },
            {
                "text": "Menu : Determine what to record.",
                "type": "MenuPar",
                "name": "recordtype",
                "items": []
            },
            {
                "text": "Toggle : This parameter is used as a button to start and stop recording into the CHOP channels.",
                "type": "TogglePar",
                "name": "record",
                "items": []
            },
            {
                "text": "Str : Put an \"n\" in here to generate channels for note events. It is the base name of the CHOP channel used to record notes. If blank, notes are ignored. If the Note Output parameter is set to Separate Channels, then CHOP channels will be created for each note in the Note Scope, of the form: notename",
                "type": "StrPar",
                "name": "notename",
                "items": []
            },
            {
                "text": "Str : The scope of notes to record. Multiple ranges and notes can be recorded (i.e., \"50-60\", \"64 65 66 70-80\").",
                "type": "StrPar",
                "name": "notescope",
                "items": []
            },
            {
                "text": "Menu : Describes how multiple notes are handled. (As one channel, or individual).",
                "type": "MenuPar",
                "name": "notemeth",
                "items": []
            },
            {
                "text": "Menu : Describes how multiple velocity events are recorded. (Separate channels or combined in one channel as separate samples).",
                "type": "MenuPar",
                "name": "velocity",
                "items": []
            },
            {
                "text": "Str : When Velocity is set to Separate Channels, this parameter is the base name of the Velocity CHOP channel (try \"v\"). If blank, no velocity channels will be recorded.",
                "type": "StrPar",
                "name": "velname",
                "items": []
            },
            {
                "text": "Str : The base name of the polyphonic Aftertouch CHOP channels. One aftertouch channel is created for each note in the Note Scope. If blank, no aftertouch channels will be created.",
                "type": "StrPar",
                "name": "aftername",
                "items": []
            },
            {
                "text": "Str : The name of the Channel Pressure channel. If multiple channels are being recorded, all channel pressure changes of interest will be recording on this CHOP channel. If blank, this channel will not be created.",
                "type": "StrPar",
                "name": "pressname",
                "items": []
            },
            {
                "text": "Menu : Note values can be normalized for convenience:",
                "type": "MenuPar",
                "name": "notenorm",
                "items": []
            },
            {
                "text": "Str : The name of the Pitch Wheel CHOP channel. Pitch wheel values range from -1 to +1. If blank, this channel will not be created. Put \"p\" in here to generate a channel.",
                "type": "StrPar",
                "name": "pitchname",
                "items": []
            },
            {
                "text": "Str : The base name of the Control Change CHOP channels. The channel names are appended with the controller index (0-127). If blank, control changes will not be recorded. It typically contains \"c\".",
                "type": "StrPar",
                "name": "controlname",
                "items": []
            },
            {
                "text": "Menu : There are 128 different controllers available. By choosing By Index Only, you can specify any number of controllers in the Control Index parameter. Otherwise, you can select a controller from the list from this menu. Some controllers have multiple instances, such as Sound Controllers 1-10. Selecting a controller with multiple instances allows you to use the Control Index parameter to select which instances you want. Any invalid control indices will be ignored.",
                "type": "MenuPar",
                "name": "controltype",
                "items": []
            },
            {
                "text": "Str : Used to select controllers by number, or multiple controllers by ranges. When in By Index Only Controller Type mode, you can select up to the full 128 controllers or sub-ranges thereof (i.e. \"1-10\", \"2 34 70\", \"1-32 70-80:2\").",
                "type": "StrPar",
                "name": "controlind",
                "items": []
            },
            {
                "text": "Menu : Some controllers can be paired together to form 14 bit controllers, rather than the normal 7 bit controllers (controller indices 0-31, 98 and 100). Selecting 14 bit Controllers interprets a pair as one 14 bit controller. Otherwise, they are interpreted as separate 7 bit Controllers.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "Menu : Controller values can be normalized for convenience:",
                "type": "MenuPar",
                "name": "norm",
                "items": []
            },
            {
                "text": "Toggle : When on, values do not jump between min and max, but are modified to be continuous ramps. Use with knob controllers for examples.",
                "type": "TogglePar",
                "name": "unwrap",
                "items": []
            },
            {
                "text": "Str : The name of the Program Change CHOP channel. All program change messages will be recorded onto this channel. If blank, this channel will not be created.",
                "type": "StrPar",
                "name": "progname",
                "items": []
            },
            {
                "text": "Str : Record timer pulse messages.",
                "type": "StrPar",
                "name": "pulsename",
                "items": []
            },
            {
                "text": "Str : Record timer ramp messages.",
                "type": "StrPar",
                "name": "rampname",
                "items": []
            },
            {
                "text": "Str : Record timer period messages.",
                "type": "StrPar",
                "name": "timerperiod",
                "items": []
            },
            {
                "text": "Str : Record timer start messages.",
                "type": "StrPar",
                "name": "timerstart",
                "items": []
            },
            {
                "text": "Int : Specify the expected ticks per beat. This will influence the timer and bar output values.",
                "type": "IntPar",
                "name": "ticks",
                "items": []
            },
            {
                "text": "Str : Output the current bar position.",
                "type": "StrPar",
                "name": "barname",
                "items": []
            },
            {
                "text": "Str : Output the current bar period events.",
                "type": "StrPar",
                "name": "barperiod",
                "items": []
            },
            {
                "text": "Str : Output when a bar starts.",
                "type": "StrPar",
                "name": "barstart",
                "items": []
            },
            {
                "text": "Str : Capture bar messages. Place a V in the message to specify which value the channel should have.",
                "type": "StrPar",
                "name": "barmsg",
                "items": []
            },
            {
                "text": "Str : Capture song position messages.",
                "type": "StrPar",
                "name": "songpos",
                "items": []
            },
            {
                "text": "Str : Name of a specific exclusive message to be captured.",
                "type": "StrPar",
                "name": "exname1",
                "items": []
            },
            {
                "text": "Str : Contents of the exclusive message. Place a V in the message to specify which value the channel should have.",
                "type": "StrPar",
                "name": "exmsg1",
                "items": []
            },
            {
                "text": "Float : Defines where recording begins. In \"Tie to Time Line\" mode, any events received before the start time will be ignored. In \"Time Line Independent\" mode, recording will start at this point and continue on (not looping back). If reading from a MIDI File, Start/End will determine the start of the segment to read. \n\nStart and end of the interval, expressed in Units (seconds, frames or samples). The parameters are expressed in the <code>Units</code> found on the Common page. To set the CHOP to be 100 samples long, Set <code>Units</code> to Samples, <code>Single Frame</code> Off and <code>Start</code> / <code>End</code> to 0 and 99.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : Defines the end of the segment to read for MIDI Files.",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Float : Defines the sample rate of this CHOP, in samples per second. If the sample rate is too low, a rapidly changing input may be misrepresented.\t\n\t\t\t\n'''Note''': If the sample rate is too low, you may miss MIDI events. A note event may set a sample value to 1, and then the next note event less than 1/30 second later can set it to 0 on the same sample in the CHOP channel. So the event will be missed. Make the sample rate higher, like 600, to catch these events, or make sure that your on-off events coming in are a minimum time separation, as can be achieved through Opcode's MAX.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The MIDI In CHOP reads Note events, Controller events, Program Change events, System Exclusive messages and Timing events from both MIDI devices and files. See also [[MIDI In Map CHOP]].\t\t\n\t\t\t\nThe MIDI In CHOP receives [[MIDI]] events from MIDI devices connected to the serial port, reads MIDI events internal to the workstation (i.e. the built-in software synth), and interprets musical scores in MIDI files. Supported MIDI events are:\t\t\t\n\t\t\t\n: Note On, Note Off\t\t\t\n: Polyphonic Aftertouch\t\t\t\n: Channel Pressure\t\t\t\n: Program Change\t\t\t\n: Control Change (MIDI controller devices)\t\t\t\n: Pitch Wheel\t\t\t\n: Timer Events including beat pulses\t\t\t\n: Bar Messages\t\t\t\n: Start, Stop, Continue\t\t\t\n: Song Position Pointer\t\t\t\n: System Exclusive Messages\t\t\t\n\t\t\t\nMIDI events arriving on separate MIDI channels may be recorded on separate CHOP channels. Also, any number of MIDI CHOPs can read from the same or different sources. TouchDesigner can be configured such that MIDI Start, Stop, or Continue events can control the [[Timeline]] and [[Beat Dialog]].\t\t\t\n\t\t\t\nThe 'Simplified Output' option creates a channel for every type of MIDI event received, so number of channels expands while the devices is being used. No need to specify name, channel and index patterns.\t\t\t\n\t\t\t\n'''Note''': The values of the MIDI inputs are saved into the TouchDesigner .toe file, and are restored when the file is reloaded. The physical controllers may be in a different position when the .toe is restarted, causing the values to jump when the controllers are moved. This is unavoidable. \t\t\t\n\t\t\t\nSee also the [[MIDI In DAT]], [[MIDI Event DAT]], [[MIDI In Map CHOP]], [[MIDI Out CHOP]].",
        "opLicense": "Non-Commercial",
        "opClass": "midiinCHOP_Class",
        "opLabel": "MIDI In",
        "opFamily": "CHOP",
        "opType": "midiin",
        "short": "The MIDI In CHOP reads Note events, Controller events, Program Change events, System Exclusive messages and Timing events from both MIDI devices and files.",
        "opCategories": ""
    },
    "midiinmapCHOP": {
        "label": "midiinmapCHOP",
        "members": [
            {
                "text": "DAT : Path to the MIDI device [[Table DAT]].",
                "type": "DATPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Str : Specify the id of which device to use.",
                "type": "StrPar",
                "name": "id",
                "items": []
            },
            {
                "text": "Str : The slider controllers to import from the MIDI Mapper. For example to import the first 16 sliders, slider 20 and sliders 32 to 40, type:\t\n  s[1-16] s20 s[32-40]",
                "type": "StrPar",
                "name": "sliders",
                "items": []
            },
            {
                "text": "Str : The buttons to import from the MIDI Mapper. For example to import the first 16 buttons, button 20 and buttons 32 to 40, type: \t\n  b[1-16] b20 b[32-40]",
                "type": "StrPar",
                "name": "buttons",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "bvelocity",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "squeue",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "See first the [[MIDI In DAT]]. The MIDI In Map CHOP reads in specified channels from the [[MIDI Device Mapper Dialog]] which prepares slider channels starting from s1, s2, etc. and button channels starting with b1, b2 and so on. The MIDI In Map CHOP selects from these channels.\t\t\n\t\t\t\n'''NOTE''': (Apr 12 09) This page needs to be updated with the info in the release notes.\n\t\t\t\nAnother CHOP, the [[MIDI In CHOP]] retrieves [[MIDI]] data more directly but it is less portable as it addresses the MIDI channel numbers, note numbers and controller numbers in the CHOP, so in order to change the MIDI mapping, you need to change the settings in TouchDesigner, whereas with the MIDI In Map CHOP, users need only set the mapping in the Dialogs -&gt; MIDI Device Mapper.\t\t\t\n\t\t\t\nSee also the [[MIDI In DAT]], [[MIDI Event DAT]], [[MIDI In CHOP]], [[MIDI Out CHOP]], <code>midi</code> command, [[MIDI Device Mapper Dialog]].",
        "opLicense": "Non-Commercial",
        "opClass": "midiinmapCHOP_Class",
        "opLabel": "MIDI In Map",
        "opFamily": "CHOP",
        "opType": "midiinmap",
        "short": "See first the [[MIDI In DAT]]. The MIDI In Map CHOP reads in specified channels from the [[MIDI Device Mapper Dialog|MIDI Device Mapper]] which prepares slider channels starting from s1, s2, etc.",
        "opCategories": ""
    },
    "midioutCHOP": {
        "label": "midioutCHOP",
        "members": [
            {
                "text": "Toggle : Enable or disable the MIDI Out CHOP.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Where the MIDI events are sent to. MIDI Mapper is the default destination.",
                "type": "MenuPar",
                "name": "destination",
                "items": []
            },
            {
                "text": "DAT : Path to the MIDI device [[Table DAT]].",
                "type": "DATPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Str : Specify the id of which device to use.",
                "type": "StrPar",
                "name": "id",
                "items": []
            },
            {
                "text": "Toggle : Make the index 1 based instead of the default 0 based.",
                "type": "TogglePar",
                "name": "onebased",
                "items": []
            },
            {
                "text": "File : The filename of the output MIDI file.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Pulse : Writes all the data to a MIDI file.",
                "type": "PulsePar",
                "name": "writefile",
                "items": []
            },
            {
                "text": "Str : The prefix string that all input channels must have in order to extract the channel number from their name (i.e. \"ch1note44\", with a channel prefix of \"ch\").",
                "type": "StrPar",
                "name": "prefix",
                "items": []
            },
            {
                "text": "Toggle : Forces a cook of the CHOP every frame. It should be On because the MIDI Out CHOP will otherwise only cook if the CHOP leads to a graphics display viewer. You want it to cooks whether you are displaying anything or not.",
                "type": "TogglePar",
                "name": "cookalways",
                "items": []
            },
            {
                "text": "Menu : A MIDI 'All Note Off' event can be sent upon the start and/or end of the output.",
                "type": "MenuPar",
                "name": "autonoteoff",
                "items": []
            },
            {
                "text": "Pulse : Sends an All Notes Off message to all MIDI channels.",
                "type": "PulsePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Sends an All Notes Off message to all MIDI channels.",
                "type": "PulsePar",
                "name": "volumeoff",
                "items": []
            },
            {
                "text": "Pulse : Sends an All Notes On message to all MIDI channels.",
                "type": "PulsePar",
                "name": "volumeon",
                "items": []
            },
            {
                "text": "Toggle : Sends the appropriate events when the framebar starts or stops.\t\n\t\t\t\n<nowiki>---- not implemented: ----</nowiki>",
                "type": "TogglePar",
                "name": "startstop",
                "items": []
            },
            {
                "text": "Str : The base name of the note channels. If input channels have a number after the name, it is assumed to be the note number. If not, the channel value is assumed to contain the note number.",
                "type": "StrPar",
                "name": "notename",
                "items": []
            },
            {
                "text": "Str : The name of the aftertouch channel.",
                "type": "StrPar",
                "name": "aftername",
                "items": []
            },
            {
                "text": "Str : The name of the channel pressure channel.",
                "type": "StrPar",
                "name": "pressname",
                "items": []
            },
            {
                "text": "Menu : Values in the range 0-1 are mapped to MIDI value 0-127.",
                "type": "MenuPar",
                "name": "notenorm",
                "items": []
            },
            {
                "text": "Str : The name of the pitch wheel channel.",
                "type": "StrPar",
                "name": "pitchname",
                "items": []
            },
            {
                "text": "Str : The base name of the controller channels.",
                "type": "StrPar",
                "name": "controlname",
                "items": []
            },
            {
                "text": "Menu : Sends 7 or 14 bit controller events.",
                "type": "MenuPar",
                "name": "controlformat",
                "items": []
            },
            {
                "text": "Menu : Maps channel values from different ranges to 0-127.",
                "type": "MenuPar",
                "name": "controlnorm",
                "items": []
            },
            {
                "text": "Str : The name of the program change channel.",
                "type": "StrPar",
                "name": "progname",
                "items": []
            },
            {
                "text": "StrMenu : Clock ticks frequency is determined by the period of the ramp. The ramp must be 0 to 1. An incoming channel name for a 0 to 1 ramp over each 4-beat bar.",
                "type": "StrMenuPar",
                "name": "barname",
                "items": []
            },
            {
                "text": "Int : Default is 96 = 4 beats * 24 ticks per beat.",
                "type": "IntPar",
                "name": "barticks",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The MIDI Out CHOP sends [[MIDI]] events to any available MIDI devices when its input channels change. More flexibly, the Python [[midioutCHOP Class]] can be used to send any type of MIDI event to a MIDI device via an existing MIDI Out CHOP. In [[Tscript]], the <code>midi</code> command can output MIDI events.\t\t\n\t\t\t\nThe MIDI devices can be other software programs (such as midisynth) or devices attached to the serial ports. Channels are used to control the sending of the MIDI events. The channels are evaluated over the last time slice (from the last [[Timeline]] position to the current).\t\t\t\n\t\t\t\nThe MIDI Out CHOP sends MIDI events based on any changes to its input channels. The channels have to be named appropriately, like <code>ch3c14</code> and <code>ch7n60</code>.\t\t\t\n\t\t\t\nAn event is sent every time a channel changes its value during this slice. All timing is preserved, as long as the [[Timeline]] is running in realtime (the \"Realtime\" flag is in the top menu bar). \t\t\t\n\t\t\t\nNaming the CHOP channels: Channels are mapped to events by their name. Events like notes, controllers and velocities must be followed by the note/controller number (n65, c7). If the number is left off a note event, the note number is the value of the channel. Other events, which are sent to the entire channel, do not need a trailing number (pc, pw). The channel prefix can be used to identify the MIDI channel the event should be sent on (i.e. \"ch1n45\" assigns that TouchDesigner channel to note 45 messages on MIDI channel 1).  Channels can always be renamed with a [[Rename CHOP]] before entering the [[MIDI Out CHOP]].\t\t\t\n\t\t\t\nThe MIDI Out CHOP sends MIDI velocity as well. The values of the channels entering the MIDI Out CHOPs are sent as the velocity of the note. If Normalize is \"None\", the channel needs to be 0 to 127. If Normalize is \"0 to 1\", channel values between 0 and 1 are scaled to be MIDI 0 to 127.\t\t\t\n\t\t\t\nThe \"Cook Every Frame\" option cooks the CHOP every frame, even if the CHOP isn't being displayed. All Volume Off and All Volume On flags are new and emit events for Controller 7 of all 16 channels. MIDI output go in a separate thread to allow output that slows TouchDesigner less. It now works in Time Slice mode for note events and controller events. (Not for Program Change or Sysex messages yet) Note channels only trigger anew Note On when the input channel goes from 0 or less to a value greater than zero. Similar for Note Off events.The channel name determines how it is interpreted.\t\t\t\n\t\t\t\nFor example,\t\t\t\n\t\t\t\n: ch3n60 - this channel is interpreted as channel3 note 60. A Note On event is sent when the value goes from 0 or less to greater than zero\t\t\t\n: ch5n - This channel will contain note numbers.\u00ac\u2020 The value quantized to an integer, and when the integer value changes, the note of the old value goes off and the note of the new value goes on. If the channel steps from 53 to 78, it sends a Note Off event for note 53, and a Note On event for note 78.\t\t\t\n: ch14c7 - the value of the channel is sent to controller 7 (volume) of channel 14. By default, the values 0 to 1 are mapped to MIDI value 0 to 127.\t\t\t\n\t\t\t\nThese features work in Time Slice mode:\t\t\t\n\t\t\t\n: By default, channels are to start with \"ch\" followed by the channel number (1-16). In the case of notes, it is followed by \"n\" for notes, then digits for the note number. In the case of controllers, it is followed by \"c\" and a controller number. These prefixes can be altered. MIDI Out now interprets aftertouch, pressure, pitchwheel channels, and outputs these events to the MIDI stream. Note-normalization is added allowing 0 to 127 and 0 to 1 ranges. MIDI Out reads a bar ramp channel to output MIDI clock events\u00ac\u2020 (with a channel popup menu to the parameter to select the channel name). Program change events are implemented through the \"pc\" channels.both 7 and 14 bit controller events can be output. You can capture a MIDI stream and output it to a file.\t\t\t\n\t\t\t\nSee also the [[MIDI In DAT]], [[MIDI Event DAT]], [[MIDI In Map CHOP]], [[MIDI In CHOP]], <code>midi</code> command.",
        "opLicense": "Non-Commercial",
        "opClass": "midioutCHOP_Class",
        "opLabel": "MIDI Out",
        "opFamily": "CHOP",
        "opType": "midiout",
        "short": "The MIDI Out CHOP sends MIDI events to any available MIDI devices when its input channels change.",
        "opCategories": ""
    },
    "mosysCHOP": {
        "label": "mosysCHOP",
        "members": [
            {
                "text": "Toggle : While on, the CHOP receives information sent to the network port. While Off, no updating occurs. Data sent to the port is lost.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : The network protocol to use. Refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : When using Multicast, this is the address that to listen for packets on.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port which MoSys CHOP will accept packets on.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to receive on, useful when the system has mulitple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Str : Used to filter out unwanted data packets when more than one camera is sending data to this machine. This parameter should be a number that matches the value in the camera id channel. Data received from cameras that do not match this id will be ignored. If this field is blank, the most recent data received each frame will be displayed regardless of what camera it comes from.",
                "type": "StrPar",
                "name": "cameraid",
                "items": []
            },
            {
                "text": "Int : The width of the camera image in pixels. It is used to convert the focal distance received by the camera into a FOV value.",
                "type": "IntPar",
                "name": "screenwidth",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "mosysCHOP",
        "opLabel": "MoSys",
        "opClass": "mosysCHOP_Class",
        "opFilter": "False",
        "opLicense": "Pro",
        "opCategories": "",
        "short": "The MoSys CHOP receives data from a MoSys camera tracking system.",
        "long": "The MoSys CHOP receives data from a MoSys camera tracking system. The channels can be used to control a virtual [[Camera COMP|camera]] and to implement lens distortion via the [[MoSys TOP]] as part of a virtual production system."
    },
    "mouseinCHOP": {
        "label": "mouseinCHOP",
        "members": [
            {
                "text": "Menu : While '''On''', the mouse movement will be output from and the CHOP will cook every frame. When set to '''Off''' it will not cook and the current mouse X or Y values will not be output. '''While Playing''' will capture mouse events only when the [[Timeline]] is playing forward.",
                "type": "MenuPar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Controls the range of the mouse Position X and Position Y.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Str : The name of the channel that returns the horizontal movement of the mouse.",
                "type": "StrPar",
                "name": "posxname",
                "items": []
            },
            {
                "text": "Str : The name of the channel that returns the vertical movement of the mouse.",
                "type": "StrPar",
                "name": "posyname",
                "items": []
            },
            {
                "text": "Str : The name of the channel that returns the state of the left button.",
                "type": "StrPar",
                "name": "lbuttonname",
                "items": []
            },
            {
                "text": "Str : The name of the channel that returns the state of the right button.",
                "type": "StrPar",
                "name": "rbuttonname",
                "items": []
            },
            {
                "text": "Str : The name of the channel that returns the state of the middle button.",
                "type": "StrPar",
                "name": "mbuttonname",
                "items": []
            },
            {
                "text": "Str : This channel goes up when the wheel is rolled away from the user and goes down when it is rolled the other way.",
                "type": "StrPar",
                "name": "wheel",
                "items": []
            },
            {
                "text": "Float : The amount that is added or subtracted to the current value of the Wheel channel when the wheel is moved.",
                "type": "FloatPar",
                "name": "wheelinc",
                "items": []
            },
            {
                "text": "Str : This channel returns which monitor the mouse cursor is currently on.",
                "type": "StrPar",
                "name": "monitor",
                "items": []
            },
            {
                "text": "PanelCOMP : Events are only triggered when the specified panel has focus.",
                "type": "PanelCOMPPar",
                "name": "panels",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Mouse In CHOP outputs X and Y screen values for the mouse device and monitors the up/down state of the three mouse buttons.\t\t\n\t\t\t\nWhen the Active flag is on, the Mouse X and Y positions are output through the channels named in the Position X and Y parameters and the button states are output through the channels named in the Left, Right and Middle Button parameters.\t\t\t\n\t\t\t\nThe button values are 0 for Button Up and 1 for Button Down.\t\t\t\n\t\t\t\nThe Mouse In CHOP and [[Keyboard In CHOP]]s are sometimes connected to the Position and Active inputs respectively of the [[Record CHOP]] to enable the recording of channels.",
        "opLicense": "Non-Commercial",
        "opClass": "mouseinCHOP_Class",
        "opLabel": "Mouse In",
        "opFamily": "CHOP",
        "opType": "mousein",
        "short": "The Mouse In CHOP outputs X and Y screen values for the mouse device and monitors the up/down state of the three mouse buttons.",
        "opCategories": ""
    },
    "mouseoutCHOP": {
        "label": "mouseoutCHOP",
        "members": [
            {
                "text": "Str : Channel name to look for that will drive the mouse U position.",
                "type": "StrPar",
                "name": "posu",
                "items": []
            },
            {
                "text": "Str : Channel name to look for that will drive the mouse V position.",
                "type": "StrPar",
                "name": "posv",
                "items": []
            },
            {
                "text": "Str : Channel name to look for that will drive the mouse's left button state.",
                "type": "StrPar",
                "name": "lbuttonname",
                "items": []
            },
            {
                "text": "Str : Channel name to look for that will drive the mouse's right button state.",
                "type": "StrPar",
                "name": "rbuttonname",
                "items": []
            },
            {
                "text": "Str : Channel name to look for that will drive the mouse's middle button state.",
                "type": "StrPar",
                "name": "mbuttonname",
                "items": []
            },
            {
                "text": "Toggle : Forces CHOP to cook every frame.",
                "type": "TogglePar",
                "name": "cookalways",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Mouse Out CHOP forces the mouse position and button status to be driven from TouchDesigner using the incoming CHOP channels. The <code>tx</code> and <code>ty</code> channels works in normalized coordinates, ranging from 0 to 1 for the left-to-right and bottom-to-top of the full desktop. If the Desktop is spread over two monitors, tx == 1 is the right of the second monitor.\t\n\t\t\nWARNING: If the incoming channels are changing every frame, it may be difficult to regain control of the mouse without using the keyboard or some other means to kill or suspend the process. However the Mouse Out CHOP does not control the mouse while the incoming channels are constant.",
        "opLicense": "Non-Commercial",
        "opClass": "mouseoutCHOP_Class",
        "opLabel": "Mouse Out",
        "opFamily": "CHOP",
        "opType": "mouseout",
        "short": "The Mouse Out CHOP forces the mouse position and button status to be driven from TouchDesigner using the incoming CHOP channels.",
        "opCategories": ""
    },
    "natnetinCHOP": {
        "label": "natnetinCHOP",
        "members": [
            {
                "text": "Toggle : While on, the CHOP receives information, while off no updating occurs.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Set this to the connection mode the server is set to.",
                "type": "MenuPar",
                "name": "connectiontype",
                "items": []
            },
            {
                "text": "Str : The computer name or IP address of the server computer. You can use an IP address (e.g. <code>100.123.45.78</code>) or the computer's network name can be used directly. If you put \"<code>localhost</code>\", it means the other end of the pipe is on the same computer. When using Multicast mode this should still be set to the server's address, not the multicast address. The server will negotiate the multicast address with the client and make it connect to it automatically.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Str : In cases where your computer has multiple network cards and IP address, this tells the node which local IP address to bind to for it's communication. For example say you have a WIFI connection whose IP address is 192.168.0.100 and a ethernet connection whose IP address is 24.100.200.50. If you want the node to communicate over the WIFI you can put 192.168.0.100 or 192.168.0.* into this parameter. If you want the node to communicate via the ethernet you'd set this to 24.100.200.50 or 24.100.200.* (or even 24.100.*.* etc.). Systems with a single network connection can leave this parameter blank.",
                "type": "StrPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Int : The command network port of the server.",
                "type": "IntPar",
                "name": "commandport",
                "items": []
            },
            {
                "text": "Int : The data port of the server.",
                "type": "IntPar",
                "name": "dataport",
                "items": []
            },
            {
                "text": "Int : The rate at which the data should be queried.",
                "type": "IntPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Pulse : Reset the data in this node.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The NatNet In CHOP is used to receive tracking data over the network data from [http://www.optitrack.com OptiTrack] systems. Currently the only data that is received is Rigid Body data.",
        "opLicense": "Non-Commercial",
        "opClass": "natnetinCHOP_Class",
        "opLabel": "NatNet In",
        "opFamily": "CHOP",
        "opType": "natnetin",
        "os": "Microsoft Windows",
        "short": "The NatNet In CHOP is used to receive tracking data over the network data from [http://www.optitrack.com OptiTrack] systems.",
        "opCategories": ""
    },
    "ncamCHOP": {
        "label": "ncamCHOP",
        "members": [
            {
                "text": "Toggle : Turn off this parameter to stop receiving data from the Ncam system.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : The network address of the Ncam server that is sending the data.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The network port to connect to on the Ncam server.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Menu : Select how the camera's orientation and position are outputted.",
                "type": "MenuPar",
                "name": "cameraview",
                "items": []
            },
            {
                "text": "Menu : Select how the camera's projection settings are outputted.",
                "type": "MenuPar",
                "name": "cameraproj",
                "items": []
            },
            {
                "text": "Menu : Controls the output of additional camera properties like zoom and focus. These properties can either be normalized (0 to 1) or in their native physical units.",
                "type": "MenuPar",
                "name": "cameraprops",
                "items": []
            },
            {
                "text": "Menu : Select whether the embedded timecode is presented as a single counter or in separate hour, minute, second and frame channels.",
                "type": "MenuPar",
                "name": "timecode",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "ncamCHOP",
        "opLabel": "Ncam",
        "opClass": "ncamCHOP_Class",
        "opFilter": "False",
        "opLicense": "Pro",
        "short": "The Ncam CHOP receives camera tracking data from an external Ncam Reality system for use in virtual production.",
        "long": "The Ncam CHOP receives camera tracking data from an external [https://www.ncam-tech.com/ Ncam Reality system] for use in virtual production. The data is received over a network using the TCP protocol and includes information on the camera's position, orientation and optical properties. This data can be used in a [[Camera COMP]] to render content from a virtual environment that is synced to the movement of a physical camera. An [[Ncam TOP]] can also be used to receive image data from the camera and to composite it with the rendered content.\n    \nFor additional tracking solutions, see the [[Stype CHOP]] and [[FreeD CHOP]].",
        "opCategories": ""
    },
    "noiseCHOP": {
        "label": "noiseCHOP",
        "members": [
            {
                "text": "Menu : The noise function used to generate noise. The functions available are:",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Float : Any number, integer or non-integer, which starts the random number generator. Each number gives completely different noise patterns, but with similar characteristics.",
                "type": "FloatPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Float : The approximate separation between peaks of a noise cycle. It is expressed in Units. Increasing the period stretches the noise pattern out.\t\n\t\t\t\nPeriod is the opposite of frequency. If the period is 2 seconds, the base frequency is 0.5 cycles per second, or 0.5Hz for short. Hz refers to Hertz, the electrical and audio engineer of the 19th century, not the car guy.\n\t\t\t\nIf the Type is set to Random, setting this to zero will produce completely random noise. Otherwise, the period should be greater than zero.",
                "type": "FloatPar",
                "name": "period",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, Seconds, or Fraction.",
                "type": "MenuPar",
                "name": "periodunit",
                "items": []
            },
            {
                "text": "Int : The number of higher frequency components to layer on top of the base frequency. The higher this number, the bumpier the noise will be (as long as roughness is not set to zero). 0 harmonics give the base shape.\t\n\t\t\t\nHarmonics with a base frequency of 0.1Hz will by default produce harmonics at 0.2Hz, 0.4Hz, 0.8Hz, etc. (up to the number of harmonics specified by the Harmonics parameter).",
                "type": "IntPar",
                "name": "harmon",
                "items": []
            },
            {
                "text": "Float : The factor by which the frequency of the harmonics are increased. It is normally 2. A spread of 3 and a base frequency of 0.1Hz will produce harmonics at 0.3Hz, 0.9Hz, 2.7Hz, etc. This parameter is only valid for the Harmonic Summation type.",
                "type": "FloatPar",
                "name": "spread",
                "items": []
            },
            {
                "text": "Float : Controls the effect of the higher frequency noise. When roughness is zero, all harmonics above the base frequency have no effect. At one, all harmonics are equal in amplitude to the base frequency. When roughness is between one and zero, the amplitude of higher harmonics drops off exponentially from the base frequency.\t\n\nThe default roughness is 0.5. This means the amplitude of the first harmonic is 0.5 of the base frequency, the second is 0.25, the third is 0.125. The harmonics are added to the base to give the final shape. The Harmonics parameter and the Roughness parameter must both be non-zero to see the harmonic effects.",
                "type": "FloatPar",
                "name": "rough",
                "items": []
            },
            {
                "text": "Float : Pushes the noise values toward 0, or +1 and -1. (It raises the value to the power of the exponent.) Exponents greater than one will pull the channel toward zero, and powers less than one will pull peaks towards +1 and -1. It is used to reshape the channels.",
                "type": "FloatPar",
                "name": "exp",
                "items": []
            },
            {
                "text": "Int : Defines the number of times to integrate (see the Area CHOP p. 114) the Brownian noise. Higher values produce smoother curves with fewer features. Values beyond 4 produce somewhat identical curves. This parameter is only valid for the Random noise type.",
                "type": "IntPar",
                "name": "numint",
                "items": []
            },
            {
                "text": "Float : Defines the noise value's amplitude (a scale on the values output).",
                "type": "FloatPar",
                "name": "amp",
                "items": []
            },
            {
                "text": "Toggle : Only available if operator's <code>Time Slice</code> Parameter is on. Toggling this parameter will reset the noise calculation and hold the value until the parameter is released again.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Only available if operator's <code>Time Slice</code> Parameter is on. Pulsing this parameter will reset the noise calculation.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "Menu : Changing the Transform Order will change where things go much the same way as going a block and turning east gets you to a different place than turning east and then going a block. In matrix math terms, if we use the 'multiply vector on the right' (column vector) convention, a transform order of Scale, Rotate, Translate would be written as T * R * S * Position",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : As with transform order (above), changing the order in which the rotations take place will alter the final position and orientation. A Rotation order of Rx Ry Rz would create the final rotation matrix as follows R = Rz * Ry * Rx",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : XYZ translation values.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : XYZ translation values.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : XYZ translation values.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : XYZ rotation, in degrees.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : XYZ rotation, in degrees.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : XYZ rotation, in degrees.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : XYZ scale to shrink or enlarge the transform.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : XYZ scale to shrink or enlarge the transform.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : XYZ scale to shrink or enlarge the transform.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : XYZ pivot to apply the above operations around.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : XYZ pivot to apply the above operations around.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : XYZ pivot to apply the above operations around.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            },
            {
                "text": "Menu : Constraint and its parameters allows the noise curve to start and/or end at selected values. The mean value may also be enforced. '''Note:''' This only works when Time Slice is Off because time slicing has no pre-determined start/end.",
                "type": "MenuPar",
                "name": "constraint",
                "items": []
            },
            {
                "text": "Float : Value for the starting position.",
                "type": "FloatPar",
                "name": "constrstart",
                "items": []
            },
            {
                "text": "Float : Value for the ending position.",
                "type": "FloatPar",
                "name": "constrend",
                "items": []
            },
            {
                "text": "Float : Value for the mean value of the noise.",
                "type": "FloatPar",
                "name": "constrmean",
                "items": []
            },
            {
                "text": "Toggle : Ensures that all noise curves fall between -1 and 1. Applied before the Amplitude parameter. Only valid for Random and Harmonic Summation noise types, since Hermite and Sparse noise are always normalized. Normalizing random noise occurs between integrations, producing a more controlled curve. '''Note:''' This only works when Time Slice is Off because time slicing has no pre-determined start/end.",
                "type": "TogglePar",
                "name": "normal",
                "items": []
            },
            {
                "text": "Str : You can creates many channels with simple patterns like \"<code>chan[1-20]</code>\", which generates 20 channels from chan1 to chan20. See the section, Common CHOP Parameters for a description of this and all Options. See [[CHOP Common Page#Scope|Scope and Channel Name Matching]] Options. Each channel has a unique seed, so all channels will be different with the same parameter settings.",
                "type": "StrPar",
                "name": "channelname",
                "items": []
            },
            {
                "text": "Float : Start of the interval, expressed in Units (seconds, frames or samples).",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : End of the interval, expressed in Units (seconds, frames or samples).",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second. Default: <syntaxhighlight lang=python inline=true>me.time.rate</syntaxhighlight>",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Noise CHOP makes an irregular wave that never repeats, with values approximately in the range -1 to +1.\t\t\n\t\t\t\nIt generates both smooth curves and noise that is random each sample. It uses the same math as the [[Noise SOP]].\t\t\t\n\t\t\t\nYou can create several curves with different shapes, and you can adjust period, amplitude, harmonics and more.\t\t\t\n\t\t\t\nOptionally, an input can be connected. It is assumed that the input contains 1 to 3 channels representing X, Y and Z coordinates of points in space, and are used to sample anywhere in 3D noise space. One index in the input produces one sample in the output.\t\t\t\n\t\t\t\nAll noise functions work identically with [[Time Slicing]] on and off, with the exception of Harmonic Summation and Brownian whose methods cannot be limited to 1 in Time Slice mode. When the [[Timeline]] wraps around to frame 1, the noise functions will continue uninterrupted.",
        "opLicense": "Non-Commercial",
        "opClass": "noiseCHOP_Class",
        "opLabel": "Noise",
        "opFamily": "CHOP",
        "opType": "noise",
        "short": "The Noise CHOP makes an irregular wave that never repeats, with values approximately in the range -1 to +1.",
        "opCategories": ""
    },
    "nullCHOP": {
        "label": "nullCHOP",
        "members": [
            {
                "text": "Menu : This controls how nodes downstream from the Null CHOP are triggered for recooking when the Null CHOP output changes. See also: [[Cook]]",
                "type": "MenuPar",
                "name": "cooktype",
                "items": []
            },
            {
                "text": "Toggle : Recook when the Null CHOP values change.",
                "type": "TogglePar",
                "name": "checkvalues",
                "items": []
            },
            {
                "text": "Toggle : Recook when the Null CHOP channel names change.",
                "type": "TogglePar",
                "name": "checknames",
                "items": []
            },
            {
                "text": "Toggle : Recook when the Null CHOP channel range changes.\t\n\t\t\t\nPlease note that downstream cooks may also cook for a variety of reasons including viewing the contents of the data while editing nodes, etc.",
                "type": "TogglePar",
                "name": "checkrange",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opClass": "nullCHOP_Class",
        "opFamily": "CHOP",
        "long": "The Null CHOP is used as a place-holder and does not alter the data coming in.\t\t\n\t\t\t\nIt is often used to [[Export]] channels to parameters, which allows you to experiment with the CHOPs that feed into the Null without having to un-export from one CHOP and re-export from another.\t\t\t\n\t\t\t\nThe Null CHOP also has options to force-cook nodes downstream from it, or the opposite, to stop cooking nodes downstream if its inputs are not changing.\t\t\t\n\t\t\t\n[[Image:NullCHOP.jpg]]",
        "short": "The Null CHOP is used as a place-holder and does not alter the data coming in.",
        "opFilter": "True",
        "opType": "null",
        "opLabel": "Null",
        "opCategories": ""
    },
    "oakdeviceCHOP": {
        "label": "oakdeviceCHOP",
        "members": [
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : Select the available OAK Device from the dropdown.",
                "type": "StrMenuPar",
                "name": "sensor",
                "items": []
            },
            {
                "text": "Pulse : Refresh the list of available Sensors.",
                "type": "PulsePar",
                "name": "refreshpulse",
                "items": []
            },
            {
                "text": "Pulse : Initialize is the signal to get the OAK Device into a ready state: The <syntaxhighlight lang=python inline=true>onInitialize()</syntaxhighlight> callback is run and on succesfully concluding will run the <syntaxhighlight lang=python inline=true>createPipeline()</syntaxhighlight> callback. It indicates that its ready by turning the <code>ready</code> channel on.",
                "type": "PulsePar",
                "name": "initialize",
                "items": []
            },
            {
                "text": "Pulse : ",
                "type": "PulsePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : The built-in Play parameter can toggle whether or not TouchDesigner processes the new messages it receives from the camera. For example, suppose multiple OAK Select CHOPs or TOPs are connected to the same OAK Device CHOP. By toggling play off, you will make all the OAK Select operators continue to receive whatever their most recently received message was, ignoring any new messages.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Pulse : ",
                "type": "PulsePar",
                "name": "gotodone",
                "items": []
            },
            {
                "text": "DAT : The path to the DAT containing callbacks for this OAK Device CHOP.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Str : Specify the name of the stream that can receive textures. The stream needs to be created in the depthai pipeline by creating a XLinkIn node: <syntaxhighlight lang=python inline=true>pipeline.create(dai.node.XLinkIn)</syntaxhighlight>",
                "type": "StrPar",
                "name": "streamname0",
                "items": []
            },
            {
                "text": "Float : Specify the frequency at which a texture is being send to the OAK device.",
                "type": "FloatPar",
                "name": "streamfrequency0",
                "items": []
            },
            {
                "text": "TOP : Specify the TOP operator that contains the texture to be send to the stream.",
                "type": "TOPPar",
                "name": "top0",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>initializing</code> = 1 while the OAK Device is initalizing (i.e. while the callback <syntaxhighlight lang=python inline=true>onInitialize()</syntaxhighlight> returns non-zero).",
                "type": "TogglePar",
                "name": "outinit",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>initialize_fail</code> = 1 if the OAK Device ran into an error while initializing or creating the pipeline.",
                "type": "TogglePar",
                "name": "outinitfail",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>ready</code> which is 1 after an Initialize and before a Start.",
                "type": "TogglePar",
                "name": "outready",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>running</code> which is 1 after a Start and before the Done.",
                "type": "TogglePar",
                "name": "outrunning",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>done</code> = 1 when done or complete.",
                "type": "TogglePar",
                "name": "outdone",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "outtimercount",
                "items": []
            },
            {
                "text": "Menu : Outputs the \"wall-clock\" time since Start occurred, no matter if the device's <code>Play</code> parameter was turned off or not. Will stop counting when the <code>Done</code> state has been reached.",
                "type": "MenuPar",
                "name": "outrunningcount",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "oakdeviceCHOP",
        "opLabel": "OAK Device",
        "opClass": "oakdeviceCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "The OAK Device CHOP serves as the main interface to an OAK camera.",
        "long": "The OAK Device CHOP serves as the main interface to an OAK camera. It also implements many of the features of the Timer CHOP such as timer counters, pulses, and custom Python callbacks.<!--\n-->{{OPSubSection\n|opFamily=CHOP\n|sectionName=Basic Usage\n|sectionSummary=Before starting TouchDesigner, connect any OAK Devices to the computer via USB or Power over Ethernet (PoE). If you connect any devices while TouchDesigner is running, you should pulse the Refresh Device List parameter on the OAK Device CHOP. Next, customize the Python createPipeline callback and pulse the start parameter to start the camera. It's ok if you save a project while a camera is running. The camera will know to automatically start when the project opens next time.}}<!--\n-->{{OPSubSection\n|opFamily=CHOP\n|sectionName=Resolution and ISP Scale\n|sectionSummary=The <code>depthai</code> python module has an enum for RGB resolution: [https://docs.luxonis.com/projects/api/en/latest/references/python/?highlight=dai.ColorCameraProperties.SensorResolution#depthai.ColorCameraProperties.SensorResolution dai.ColorCameraProperties.SensorResolution]. This enum currently includes THE_1080_P, THE_1200_P, THE_4_K, and many others. These options may not necessarily be compatible with your OAK hardware. The most commonly available RGB resolution is 1080p. You can save on bandwidth by selecting a lower resolution via the ISP scale. Selecting (2, 3) with THE_1080_P will result in a 1280x720 image.}}<!--\n-->{{OPSubSection\n|opFamily=CHOP\n|sectionName=Configs\n|sectionSummary=The DepthaiTestSuite.toe project includes several base components which help control settings of an OAK camera by sending messages via an OAK Device CHOP. For example, the oakDeviceConfig base enables the user to set the XLinkChunkSize, logging level, and infrared laser settings of a device. The oakCameraControl base helps control RGB camera settings. The oakStereoDepthConfig base helps control stereo depth settings. It is possible to use these configs while the camera is running.}}<!--\n-->{{OPSubSection\n|opFamily=CHOP\n|sectionName=Optimizing Latency and FPS\n|sectionSummary=Luxonis has a tutorial on [https://docs.luxonis.com/projects/api/en/latest/tutorials/low-latency/ low latency]. In some cases such as streaming 4K video, you'll want to set [https://docs.luxonis.com/projects/api/en/latest/references/python/?highlight=xlinkchunksize#depthai.GlobalProperties.xlinkChunkSize:~:text=disables%20consistent%20timesyncing-,setXLinkChunkSize,-(self%3A XLinkChunkSize] to zero. This can be done with the oakDeviceConfig.\n\nWhen creating <code>depthai</code> pipelines, it's possible to set FPS targets for various nodes such as the [https://docs.luxonis.com/projects/api/en/latest/components/nodes/color_camera/ ColorCamera] node. In general, the FPS cannot be changed after the pipeline has been loaded on the camera. You should pick high FPS values, but keep in mind that if you push these numbers too high, you may see the effective FPS as shown by an Info CHOP begin to fall.}}\nSee Also: [[OAK-D]], [[OAK Select CHOP]], [[OAK Select TOP]]"
    },
    "oakselectCHOP": {
        "label": "oakselectCHOP",
        "members": [
            {
                "text": "Toggle : Toggle whether the OAK Select CHOP cooks.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "CHOP : An OAK Device CHOP running a depthai pipeline.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "StrMenu : The name of the stream to be received.",
                "type": "StrMenuPar",
                "name": "stream",
                "items": []
            },
            {
                "text": "Int : For memory efficiency, this parameter controls the number of messages TouchDesigner reuses when receiving messages from OAK. See \"Queue Size\" below.",
                "type": "IntPar",
                "name": "queuesize",
                "items": []
            },
            {
                "text": "Int : This parameter helps the OAK Select CHOP output a consistent number of channels. When running an image detection pipeline, the number of detected items will vary from frame to frame, but we want TouchDesigner to output a consistent number of channels.",
                "type": "IntPar",
                "name": "maxitems",
                "items": []
            },
            {
                "text": "Menu : The default option \"Items As Separate Channels\" enables time-slicing while \"Items as Separate Samples\" does not. If the stream is one which automatically fills in the CHOP, then \"Items as Separate Samples\" is a useful way to make the CHOP output '''Max Items''' samples consistently.",
                "type": "MenuPar",
                "name": "outputformat",
                "items": []
            },
            {
                "text": "Toggle : Only use the most recently received message with the OAK Select CHOP. For example, for an IMU stream which is sending very high-frame rate data, toggling this parameter will only show the latest sample.",
                "type": "TogglePar",
                "name": "firstsample",
                "items": []
            },
            {
                "text": "Float : The sample rate of the CHOP. The default sample rate is <code>me.time.rate</code>.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "DAT : Specifies the DAT which holds the callbacks.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Pulse : Clicking the button runs the setupParameters() callback function.",
                "type": "PulsePar",
                "name": "setuppars",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "oakselectCHOP",
        "opLabel": "OAK Select",
        "opClass": "oakselectCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "Access a stream of the [[OAK Device CHOP]]",
        "long": "The OAK Select CHOP is like a [[Script CHOP]] combined with a [[Select CHOP]], and any of the other hardware-specific CHOPs. The basic operation involves providing an [[OAK Device CHOP]] and a stream name. In the simplest case, the stream's data will show up as well-named channels. For example, [https://docs.luxonis.com/projects/api/en/latest/components/messages/img_detections/ ImgDetections] messages indicating the 2D coordinates and labels of detected objects will show up as CHOP channels without any manual coding. In more complex cases such as hand landmark tracking, the stream may be of [https://docs.luxonis.com/projects/api/en/latest/components/messages/nn_data/ NNData] or [https://docs.luxonis.com/projects/api/en/latest/components/messages/buffer/ Buffer] type, requiring the user to implement a callback and parse the data."
    },
    "objectCHOP": {
        "label": "objectCHOP",
        "members": [
            {
                "text": "DAT : Uses a [[Table DAT]] to specify the target and reference objects to use. The first column will be the target objects while the second column will be the reference objects. No headers are used.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "Object : The object that is being compared to the position of the reference object. The Target Object can be expressed as a text string. This can be useful when the object name needs to be a variable - it allows you to type in a name which may include expressions or variables.",
                "type": "ObjectPar",
                "name": "target",
                "items": []
            },
            {
                "text": "Object : The object that acts as the origin of the comparison. The Reference Object can be expressed as a text string.",
                "type": "ObjectPar",
                "name": "reference",
                "items": []
            },
            {
                "text": "Toggle : Swap the objects defined above in the Target Object and Reference Object parameters.",
                "type": "TogglePar",
                "name": "swaptargetreference",
                "items": []
            },
            {
                "text": "Menu : Specify the information to output from the objects as described in the parameters below. Except for 'measurements', these match the standard transform formats as described by the [[Transform CHOP]].",
                "type": "MenuPar",
                "name": "compute",
                "items": []
            },
            {
                "text": "Toggle : The displacement from the reference object to the target object.",
                "type": "TogglePar",
                "name": "translate",
                "items": []
            },
            {
                "text": "Toggle : The orientation difference from the reference object to the target object.",
                "type": "TogglePar",
                "name": "rotate",
                "items": []
            },
            {
                "text": "Toggle : The scale difference from reference object to the target object.",
                "type": "TogglePar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Toggle : The quaternion from reference object to the target object.",
                "type": "TogglePar",
                "name": "quat",
                "items": []
            },
            {
                "text": "Toggle : The rotation necessary for the reference object to be facing the target object.",
                "type": "TogglePar",
                "name": "bear",
                "items": []
            },
            {
                "text": "Toggle : An angle representing where the target object is relative to the reference object. Zero degrees is directly in front, 90 degrees is beside and 180 degrees is behind.",
                "type": "TogglePar",
                "name": "singlebear",
                "items": []
            },
            {
                "text": "Toggle : The distance between the two objects.",
                "type": "TogglePar",
                "name": "distance",
                "items": []
            },
            {
                "text": "Toggle : The inverse squared distance between the two objects, useful for modeling electric forces, audio dropoff and gravity.",
                "type": "TogglePar",
                "name": "invsqr",
                "items": []
            },
            {
                "text": "Menu : The transform order to use for Rotation, Scale, Transform, Bearing, or Single Bearing Angle <span class=\"tipTextCHOP\">Compute</span> modes.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : The rotation order to use for Rotation, Scale, Transform, Bearing, or Single Bearing Angle <span class=\"tipTextCHOP\">Compute</span> modes.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "Toggle : Turn on to include channels for Transform Order and Rotate Order.",
                "type": "TogglePar",
                "name": "includeorderchans",
                "items": []
            },
            {
                "text": "Menu : Bearing requires a direction to use as a reference base.",
                "type": "MenuPar",
                "name": "bearingref",
                "items": []
            },
            {
                "text": "XYZ : An arbitrary base direction for the bearing calculation.",
                "type": "XYZPar",
                "name": "bearingx",
                "items": []
            },
            {
                "text": "XYZ : An arbitrary base direction for the bearing calculation.",
                "type": "XYZPar",
                "name": "bearingy",
                "items": []
            },
            {
                "text": "XYZ : An arbitrary base direction for the bearing calculation.",
                "type": "XYZPar",
                "name": "bearingz",
                "items": []
            },
            {
                "text": "Str : When one of the optional point inputs is connected, this determines which channels represent X, Y and Z.",
                "type": "StrPar",
                "name": "tscopex",
                "items": []
            },
            {
                "text": "Str : When one of the optional point inputs is connected, this determines which channels represent X, Y and Z.",
                "type": "StrPar",
                "name": "tscopey",
                "items": []
            },
            {
                "text": "Str : When one of the optional point inputs is connected, this determines which channels represent X, Y and Z.",
                "type": "StrPar",
                "name": "tscopez",
                "items": []
            },
            {
                "text": "Toggle : Adds a rotate attribute to any rotation channels the Object CHOP creates.",
                "type": "TogglePar",
                "name": "appendattribs",
                "items": []
            },
            {
                "text": "Toggle : When on outputs a smooth rotation curve without graphical jumps at 0, 90, etc.",
                "type": "TogglePar",
                "name": "smoothrotate",
                "items": []
            },
            {
                "text": "Menu : Sets how the created channels are named.",
                "type": "MenuPar",
                "name": "nameformat",
                "items": []
            },
            {
                "text": "Menu : The start and end time of the desired interval of the object path.",
                "type": "MenuPar",
                "name": "outputrange",
                "items": []
            },
            {
                "text": "Toggle : If the project has skipped one or more frames, this will attempt to cook it's inputs at multiple previous frames to avoid discontinuities in it's calculations.",
                "type": "TogglePar",
                "name": "cookpast",
                "items": []
            },
            {
                "text": "Float : The start time of the desired interval of the object path.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : The end time of the desired interval of the object path.",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Menu : The extend condition before the CHOP interval. They are:",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : Extend condition after the interval. Same options as Extend Left.",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.\t\n\t\t\t\n'''Note:''' When creating rotation channels, the [[Transform CHOP]] and Object CHOP will select values which minimize frame-to-frame discontinuity. The graphs will appear continuous and free of 180 degree shifts.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opClass": "objectCHOP_Class",
        "opFamily": "CHOP",
        "long": "The Object CHOP compares two objects and outputs channels containing their raw or relative positions and orientations. The information that can be output is:\t\t\n\t\t\t\n* Position of one object relative to another\t\t\t\n* Rotation of one object relative to another\t\t\t\n* Bearing of one object relative to another\t\t\t\n* Single Bearing Angle between two objects\t\t\t\n* Distance between the origin of two objects\t\t\t\n* Inverse Square of the Distance between two objects\t\t\t\n\t\t\t\nThe optional two inputs allow you to compare X,Y,Z points in world space with objects or each other. The inputs are expected to have three channels containing XYZ points (three channels with the suffix x, y and z). Alternatively, they can be in the standard transform formats as described by the [[Transform CHOP]] help. These inputs replace the target and/or reference objects. Object and points can be compared with each other, but \"Rotation\" mode will always return zero.\t\t\t\n\t\t\t\nSee also the [[SOP to CHOP]] and the [[Parameter CHOP]]. They retrieve other information from [[object]]s and [[SOP]]s.",
        "short": "The Object CHOP compares two objects and outputs channels containing their raw or relative positions and orientations.",
        "opFilter": "False",
        "opType": "object",
        "opLabel": "Object",
        "opCategories": ""
    },
    "oculusaudioCHOP": {
        "label": "oculusaudioCHOP",
        "members": [
            {
                "text": "Toggle : When enabled, will actively spatialize the audio input.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Object : A COMP that represents the listener's (ie. head) transform. Must be a COMP that contains transform data, such as a Geometry or Camera COMP.",
                "type": "ObjectPar",
                "name": "headobject",
                "items": []
            },
            {
                "text": "Object : A COMP that represents the audio source's transform. Must be a COMP that contains transform data, such as a Geometry or Camera COMP.",
                "type": "ObjectPar",
                "name": "sourceobject",
                "items": []
            },
            {
                "text": "Float : The minimum attenuation range of the audio source (in meters).",
                "type": "FloatPar",
                "name": "minrange",
                "items": []
            },
            {
                "text": "Float : The maximum attenuation range of the audio source (in meters)",
                "type": "FloatPar",
                "name": "maxrange",
                "items": []
            },
            {
                "text": "Float : The virtual diameter of the audio source. By default the diameter is 0 which means the audio source is just a point in space.",
                "type": "FloatPar",
                "name": "diameter",
                "items": []
            },
            {
                "text": "Menu : If the audio source content is known, this parameter can be set to improve overall sound quality.",
                "type": "MenuPar",
                "name": "bandhint",
                "items": []
            },
            {
                "text": "Toggle : When enabled, audio reflection and reverb will be enabled.",
                "type": "TogglePar",
                "name": "reflectrevert",
                "items": []
            },
            {
                "text": "Menu : Select attentuation calculation between the audio source and listener (head).",
                "type": "MenuPar",
                "name": "attenuation",
                "items": []
            },
            {
                "text": "Float : Set the fixed attenuation value when in Fixed Attenuation mode.",
                "type": "FloatPar",
                "name": "attenuationscale",
                "items": []
            },
            {
                "text": "Toggle : Enables box room calculations for reverberation.",
                "type": "TogglePar",
                "name": "boxroommode",
                "items": []
            },
            {
                "text": "XYZ : Sets the size of the box room.",
                "type": "XYZPar",
                "name": "roomsizex",
                "items": []
            },
            {
                "text": "XYZ : Sets the size of the box room.",
                "type": "XYZPar",
                "name": "roomsizey",
                "items": []
            },
            {
                "text": "XYZ : Sets the size of the box room.",
                "type": "XYZPar",
                "name": "roomsizez",
                "items": []
            },
            {
                "text": "Float : Reflection level for the left of the box (ie. what percentage of the audio is reflected back).",
                "type": "FloatPar",
                "name": "roomleftrelfect",
                "items": []
            },
            {
                "text": "Float : Reflection level for the right of the box (ie. what percentage of the audio is reflected back).",
                "type": "FloatPar",
                "name": "roomrightrelfect",
                "items": []
            },
            {
                "text": "Float : Reflection level for the bottom of the box (ie. what percentage of the audio is reflected back).",
                "type": "FloatPar",
                "name": "roombottomrelfect",
                "items": []
            },
            {
                "text": "Float : Reflection level for the top of the box (ie. what percentage of the audio is reflected back).",
                "type": "FloatPar",
                "name": "roomtoprelfect",
                "items": []
            },
            {
                "text": "Float : Reflection level for the front of the box (ie. what percentage of the audio is reflected back).",
                "type": "FloatPar",
                "name": "roomfrontrelfect",
                "items": []
            },
            {
                "text": "Float : Reflection level for the back of the box (ie. what percentage of the audio is reflected back).",
                "type": "FloatPar",
                "name": "roombackrelfect",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Oculus Audio CHOP uses the Oculus Audio SDK to take a mono sound channel and create a spatialized stereo pair or channels for that sound.\n\nSee also: [[Audio Render CHOP]]",
        "opLicense": "Non-Commercial",
        "opClass": "oculusaudioCHOP_Class",
        "opLabel": "Oculus Audio",
        "opFamily": "CHOP",
        "opType": "oculusaudio",
        "os": "Microsoft Windows",
        "short": "The Oculus Audio CHOP uses the Oculus Audio SDK to take a mono sound channel and create a spatialized stereo pair or channels for that sound.",
        "opCategories": ""
    },
    "oculusriftCHOP": {
        "label": "oculusriftCHOP",
        "members": [
            {
                "text": "Toggle : When on, this CHOP will update it's data when it cooks.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Switches between three different output modes.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Toggle : When on, the output channels will include sensor orientation.",
                "type": "TogglePar",
                "name": "orientation",
                "items": []
            },
            {
                "text": "Pulse : Resets the xyz positional components and the y orientation component of the tracking space for the HMD and controllers using the HMD's current tracking position.",
                "type": "PulsePar",
                "name": "recenter",
                "items": []
            },
            {
                "text": "Toggle : When on, the output channels will include acceleration.",
                "type": "TogglePar",
                "name": "acceleration",
                "items": []
            },
            {
                "text": "Toggle : When on, the output channels will include velocity.",
                "type": "TogglePar",
                "name": "velocity",
                "items": []
            },
            {
                "text": "Toggle : When on, the output channels will include device info.",
                "type": "TogglePar",
                "name": "deviceinfo",
                "items": []
            },
            {
                "text": "Toggle : When on, the output channels will include controller button states.",
                "type": "TogglePar",
                "name": "controllerbuttons",
                "items": []
            },
            {
                "text": "Float : Specifies the distance of the near clipping plane for the projection matrix.",
                "type": "FloatPar",
                "name": "near",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Oculus Rift CHOP connects to an [[Oculus Rift]] device and outputs several useful sets of channels that can be used to integrate the Oculus Rift into projects.\t\t\n\t\t\t\nYou can view the detected orientation of the device and put the rotation values directly into other operators. To help decrease latency, prediction can be used to guess what the orientation will be at some point in the future.\t\t\t\n\t\t\t\nThe raw sensor data is also available, with options for both sensor acceleration and angular velocity.\t\t\t\n\t\t\t\nThe devices calibration parameters are another option. These can be used to generate the projection matrices and distortion shaders, although both of these are already available (see below and [[Oculus Rift TOP]]). This data is constant, but may differ on future devices.\t\t\t\n\t\t\t\nThe last two things the Oculus Rift CHOP can output are the left and right eye projection matrices. These can be (and will need to be) passed into a camera's \"Custom Projection\" parameter in order to provide a proper 3D experience with the Oculus Rift. For convenience, the channels are aligned to be passed in directly by reference.\t\t\t\n\t\t\t\nWithout an Oculus Rift device connected the CHOP uses default values and will output channels corresponding to the Oculus Rift Developer Kit device. This allows you to design something for the Oculus Rift without actually having one.\t\t\t\n\t\t\t\nSee also [[Oculus Rift]]",
        "opLicense": "Non-Commercial",
        "opClass": "oculusriftCHOP_Class",
        "opLabel": "Oculus Rift",
        "opFamily": "CHOP",
        "opType": "oculusrift",
        "os": "Microsoft Windows",
        "short": "The Oculus Rift CHOP connects to an [[Oculus Rift]] device and outputs several useful sets of channels that can be used to integrate the Oculus Rift into projects.",
        "opCategories": ""
    },
    "openvrCHOP": {
        "label": "openvrCHOP",
        "members": [
            {
                "text": "Toggle : Control if this node is querying data from the OpenVR driver.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Controls what kind of category of data will be output from this node.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Int : The maximum number of trackers whose data should be output from this node.",
                "type": "IntPar",
                "name": "maxtrackers",
                "items": []
            },
            {
                "text": "Int : The first tracker number to be output. For example if this is set to 2 and Max Trackers is 2, then data for trackers 2 and 3 will be output.",
                "type": "IntPar",
                "name": "firsttracker",
                "items": []
            },
            {
                "text": "Toggle : When doing 'Sensor' output, controls if the orientation channels will be output. By default the units for orientation are 1 unit = 1 meter.",
                "type": "TogglePar",
                "name": "orientation",
                "items": []
            },
            {
                "text": "Toggle : When doing 'Sensor' output, controls of general information channels will be output, such as render resolution and play area size.",
                "type": "TogglePar",
                "name": "generalinfo",
                "items": []
            },
            {
                "text": "Float : When outputting 'Projection Matrices', controls the near plane the projection matrix will be built with.",
                "type": "FloatPar",
                "name": "near",
                "items": []
            },
            {
                "text": "Float : When outputting 'Projection Matrices', controls the far plane the projection matrix will be built with.",
                "type": "FloatPar",
                "name": "far",
                "items": []
            },
            {
                "text": "Float : OpenVR by default works in a scale where 1 unit = 1 meter. This parameter allows the scale to be changed incase a scene is imported with a different scale.",
                "type": "FloatPar",
                "name": "unitscale",
                "items": []
            },
            {
                "text": "Toggle : Turn on to allow specifying a custom [[OpenVR Actions]] manifest file.",
                "type": "TogglePar",
                "name": "customactions",
                "items": []
            },
            {
                "text": "File : A path to a [[OpenVR Actions]] manifest file. By default this is using the same manifest OpenVR uses when Custom Actions is disabled.",
                "type": "FilePar",
                "name": "actionmanifest",
                "items": []
            },
            {
                "text": "File : Use legacy channel naming convention coming from the Action Manifest. This should stay off unless loading existing old files.",
                "type": "FilePar",
                "name": "uselegacynames",
                "items": []
            },
            {
                "text": "Menu : Controls the range of motion of the skeleton values.",
                "type": "MenuPar",
                "name": "skeletonrange",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The OpenVR CHOP receives positional data, frame rendering info, and action data from the [[OpenVR]] SDK. Each CHOP can output in one of 5 modes: Sensors, Projection Matrices, Trackers, Frame Timings, Actions and Skeletons.\n\n=== Actions ===\n\nActions are described in more details in [[OpenVR Actions]].\n\t\t\t\n=== Getting Sensor Data at Higher Rates ===\t\t\t\n\t\t\t\nBy default when running a VR system the file will be throttled to the speed of the VR devices refresh rate by the OpenVR SDK. This helps ensure the low latency output required for a good VR experience. If only controllers/Vive trackers are being used for tracking in a non-VR situation, the file can run and sample those devices at a higher sample rate as long as no [[OpenVR TOP]] in the project. If an [[OpenVR TOP]] is present anywhere in the project, then playback will be throttled to the VR devices refresh rate.\t\t\t\n\t\t\t\nSee also [[OpenVR]], [[OpenVR TOP]], [[OpenVR SOP]], [[Audio Render CHOP]]",
        "opLicense": "Non-Commercial",
        "opClass": "openvrCHOP_Class",
        "opLabel": "OpenVR",
        "opFamily": "CHOP",
        "opType": "openvr",
        "os": "Microsoft Windows",
        "short": "The OpenVR CHOP receives positional data from the [[OpenVR]] SDK.",
        "opCategories": ""
    },
    "oscinCHOP": {
        "label": "oscinCHOP",
        "members": [
            {
                "text": "Toggle : While on, the CHOP receives information sent to the network port. While Off, no updating occurs. Data sent to the port is lost.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : The network protocol to use. Refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : When using Multicast, this is the address that OSC In will listen for packets on.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port which OSC-In will accept packets on.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to receive on, useful when the system has mulitple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Str : To reduce which channels are generated, you can use channel name patterns to include or exclude channels. For example, <code>^*accel*</code> will exclude accelerometer channels coming in from an iPhone or iOS app like mrmr. See [[Pattern Matching]] for the syntax of the possible channel name patterns.",
                "type": "StrPar",
                "name": "oscaddressscope",
                "items": []
            },
            {
                "text": "Toggle : When on, the CHOP will sample at the ''global'' sample rate specified by TouchDesigner.",
                "type": "TogglePar",
                "name": "useglobalrate",
                "items": []
            },
            {
                "text": "Int : When Use Global Rate is off, this parameter is used to determine the sample rate of this CHOP.",
                "type": "IntPar",
                "name": "samplerate",
                "items": []
            },
            {
                "text": "Toggle : Turn this on to enable queuing to help avoid lost messages. Use the parameters below to setup the queue behavior.",
                "type": "TogglePar",
                "name": "queued",
                "items": []
            },
            {
                "text": "Float : The target queue length the CHOP will attempt to maintain.",
                "type": "FloatPar",
                "name": "queuetarget",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "queuetargetunit",
                "items": []
            },
            {
                "text": "Float : The range around the Queue Target that's acceptable. If the queue's length is within the target and variance range, the CHOP will not bother to adjust the queue length.",
                "type": "FloatPar",
                "name": "queuevariance",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "queuevarianceunit",
                "items": []
            },
            {
                "text": "Float : Specifies how often to repeat/drop a samples in order to get closer to the queue target range. If the value = 1 and the units = seconds, then it will try to repeat/drop a sample once per second to maintain the queue target set in the <span class=\"tipTextCHOP\">Minimum Target</span> and <span class=\"tipTextCHOP\">Maximum Target</span> parameters above.",
                "type": "FloatPar",
                "name": "adjusttime",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "adjusttimeunit",
                "items": []
            },
            {
                "text": "Int : Strip a number of prefixes from the incoming address. Example:  An address of /a/b/c/d/e  with 3 segments removed would show d/e (or d_e as a final channel name).",
                "type": "IntPar",
                "name": "stripsegments",
                "items": []
            },
            {
                "text": "Toggle : Deletes all channels when set to On, new channels will not be added until Reset Channels is turned Off.",
                "type": "TogglePar",
                "name": "resetchannels",
                "items": []
            },
            {
                "text": "Pulse : Instantly resets all channels to 0.",
                "type": "PulsePar",
                "name": "resetchannelspulse",
                "items": []
            },
            {
                "text": "Toggle : Resets all channel values to 0 when On, channel values will not be updated until Reset Values is turned Off.",
                "type": "TogglePar",
                "name": "resetvalues",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The OSC In CHOP is used to accept Open Sound Control Messages. OSC In can be used to accept messages from either a 3rd party application which adheres to the Open Sound Control specification (http://www.cnmat.berkeley.edu/OpenSoundControl/). OSC In is based on a connection-less system, meaning that it can accept multiple messages for any number of sources at the same time. The user must specify a port number which OSC In will look for incoming messages. This port must not have anything running on it before OSC In attempts to use it. OSC CHOPs in TouchDesigner use the UDP transport protocol.\t\t\n\t\t\t\nSee also [[OSC_In_DAT|OSC In DAT]], [[OSC Out CHOP]], [[iOS and OSC]], [[Touch In CHOP]].\t\t\t\n\t\t\t\nThere are options which allow the user to adjust the default message queuing system to optimize it for their specific network conditions and usage needs. The Min/Max Target size specifies a range which the queue attempts to keep the buffer size at in seconds. Increasing the Queue Adjust Time will determine how long the queue can be outside that range before it tries to correct it.\t\t\t\n\t\t\t\nIf the user wishes to use OSC In to detect when messages are arriving, there is a Pulse Mode toggle which will read a single sample of any incoming message when it arrives and displays the pulse reset values any other time. This is useful for syncing beats between TouchDesigner and another applications.\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opLicense": "Non-Commercial",
        "opClass": "oscinCHOP_Class",
        "opLabel": "OSC In",
        "opFamily": "CHOP",
        "opType": "oscin",
        "short": "The OSC In CHOP is used to accept Open Sound Control Messages.",
        "opCategories": ""
    },
    "oscoutCHOP": {
        "label": "oscoutCHOP",
        "members": [
            {
                "text": "Toggle : While On, the CHOP sends information to the network port. When Off, data is not sent.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Selects the network protocol to use. Refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : The network address of the server computer. This address is a standard WWW address, such as 'foo' or 'foo.bar.com'. You can put an IP address (e.g. 100.123.45.78). If you put \"localhost\", it means the other end of the pipe is on the same computer.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port which OSC Out will send packets to.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to send from, useful when the system has mulitple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Float : Specifies the maximum number of messages OSC Out will try to send at a single time.",
                "type": "FloatPar",
                "name": "maxsize",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds",
                "type": "MenuPar",
                "name": "maxsizeunit",
                "items": []
            },
            {
                "text": "Toggle : Specifies that this CHOP should be cooked every frame regardless of CHOPs below it are cooking.",
                "type": "TogglePar",
                "name": "cookalways",
                "items": []
            },
            {
                "text": "Menu : Choose the data format to send data between 32-bit integer, 32-bit float, or 64-bit double.",
                "type": "MenuPar",
                "name": "numericformat",
                "items": []
            },
            {
                "text": "Menu : Specify how to format the outgoing messages.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "Int : Limits the size of the outgoing message packets and splits up the message accordingly.",
                "type": "IntPar",
                "name": "maxbytes",
                "items": []
            },
            {
                "text": "Toggle : When on, OSC Out will send all channels every cook regardless if the value has changed. When off, OSC Out only sends data which has changed.",
                "type": "TogglePar",
                "name": "sendevents",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "TheOSC Out CHOP sends all input channels to a specified network address and port. Each channel name and associated data is transmitted together to the specified location. TouchDesigner time stamps all outgoing Open Sound Control messages with the time of the outgoing frame relative to the system time when the first message was sent. OSC CHOPs in TouchDesigner use the UDP transport protocol.\t\t\n\t\t\t\nOSC Out will either send all the channels each cook or it will only send each channel depending on if it has changed at all since the last time it was sent. This is determined by the <span class=\"tipTextCHOP\">Send Events Every Cook</span> flag.\n\nOSC bundles allows you to send a group of messages in a single command rather than as separate, individual messages. The[[OSC Out DAT]] has a <code>sendOSC()</code> function that will accept a list of messages and send as a bundle. \n\t\nSee also [[OSC In CHOP]], [[OSC Out DAT]], [[OSC In DAT]], [[iOS and OSC]], [[Touch Out CHOP]], [[UDP Out DAT]], [[TCP/IP DAT]].\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opLicense": "Non-Commercial",
        "opClass": "oscoutCHOP_Class",
        "opLabel": "OSC Out",
        "opFamily": "CHOP",
        "opType": "oscout",
        "short": "The OSC Out CHOP sends all input channels to a specified network address and port.",
        "opCategories": ""
    },
    "outCHOP": {
        "label": "outCHOP",
        "members": [
            {
                "text": "Str : Creates a pop-up label when the cursor rolls over this Component output.",
                "type": "StrPar",
                "name": "label",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Out CHOP sends CHOP data from inside a components to other components or CHOPs.\t\n\t\t\nIt sends channels to one of the outputs of the component. For each Out CHOP, there is one output connector on the Out CHOP's parent component.",
        "opLicense": "Non-Commercial",
        "opClass": "outCHOP_Class",
        "opLabel": "Out",
        "opFamily": "CHOP",
        "opType": "out",
        "short": "The Out CHOP sends CHOP data from inside a components to other components or CHOPs.",
        "opCategories": ""
    },
    "overrideCHOP": {
        "label": "overrideCHOP",
        "members": [
            {
                "text": "Menu : Monitors the channels in each input and matches them according to this menu.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Toggle : Creates a channel (specified by the <span class=\"tipTextCHOP\">Channel Name</span> parameter below) that is an index indicating which input has the most recently changed channel.",
                "type": "TogglePar",
                "name": "makeindex",
                "items": []
            },
            {
                "text": "Str : Specifies the name of the index channel. Only used if the <span class=\"tipTextCHOP\">Create Input Index</span> checkbox is selected.",
                "type": "StrPar",
                "name": "indexname",
                "items": []
            },
            {
                "text": "Toggle : Deprecated.",
                "type": "TogglePar",
                "name": "cookmonitor",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Override CHOP lets you take inputs from several CHOP sources, and uses the most-recently changed input channels to determine the output. For example, if a 16-channel CHOP comes from one MIDI device, and another 16-channel CHOP comes from another place like another device or a preset, then Override selects the most recently-changed channels and outputs those values.\t\t\n\t\t\t\nThe Override CHOP outputs the same channels as the first input. If subsequent inputs have more or less channels than the first input, the missing/extra channels are ignored. The output defaults to the channel values of the first input, but when a value changes in any monitored channel, that value will become the new output for the corresponding channel name or number. If the same channel name or number is changing in two or more inputs at the same time, precedence is given by input order.\t\t\t\n\t\t\t\nThe Override CHOP output is reset to the default each time the number of inputs to the CHOP changes or the method of matching (by number or by name) changes.\t\t\t\n\t\t\t\nThe CHOP length is the length of the first input. From frame to frame, if all values are the same, the output is unchanged.\t\t\t\n\t\t\t\nAn optional channel can be created that will tell you which input has the most recently changed channel.",
        "opLicense": "Non-Commercial",
        "opClass": "overrideCHOP_Class",
        "opLabel": "Override",
        "opFamily": "CHOP",
        "opType": "override",
        "short": "The Override CHOP lets you take inputs from several CHOP sources, and uses the most-recently changed input channels to determine the output.",
        "opCategories": ""
    },
    "panelCHOP": {
        "label": "panelCHOP",
        "members": [
            {
                "text": "PanelCOMP : The path of the Component being referenced.",
                "type": "PanelCOMPPar",
                "name": "component",
                "items": []
            },
            {
                "text": "StrMenu : Specify which panel values to create channels for. Use * to select all panel values. Add individual values using the drop down menu on the right.",
                "type": "StrMenuPar",
                "name": "select",
                "items": []
            },
            {
                "text": "StrMenu : Rename the panel value channels selected with the Select parameter here. For example, if \"u v\" are selected in the Select parameter, you can rename these channels to horizontal and vertical by entering \"horizontal vertical\".",
                "type": "StrMenuPar",
                "name": "rename",
                "items": []
            },
            {
                "text": "Toggle : Queue all events that occur in a [[Time Slicing|time slice]]. Some [[Panel Value|panel values]], such as wheel or key, switches between a value and 0 in the same time slice and are considered instantaneous. When this parameter is off, only the last value in the time slice will be used, and changes could be missed. Turning this on will keep as many events as possible based on queue size. Each queued item will be released in the next time slice until the queue is empty, and value changes within the same time slice are synchronized.",
                "type": "TogglePar",
                "name": "queue",
                "items": []
            },
            {
                "text": "Int : Size of queue. If the number of events is larger than the queue size, earlier events will be discarded.",
                "type": "IntPar",
                "name": "queuesize",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Panel CHOP reads [[Panel Value]]s from [[Panel Component]]s into CHOP channels. Panel values can also be accessed by using the <code>panel</code> Member of the [[PanelCOMP Class]].",
        "opLicense": "Non-Commercial",
        "opClass": "panelCHOP_Class",
        "opLabel": "Panel",
        "opFamily": "CHOP",
        "opType": "panel",
        "short": "The Panel CHOP reads [[Panel Value]]s from [[Panel Component]]s into CHOP channels.",
        "opCategories": ""
    },
    "pangolinCHOP": {
        "label": "pangolinCHOP",
        "members": [
            {
                "text": "Toggle : When disabled, the CHOP will no longer send to Beyond. The corresponding image in Beyond will also be cleared.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select the source operator.",
                "type": "MenuPar",
                "name": "source",
                "items": []
            },
            {
                "text": "SOP : Path to the SOP.",
                "type": "SOPPar",
                "name": "sop",
                "items": []
            },
            {
                "text": "CHOP : Path to the CHOP. The input CHOP must have '''x''', '''y''' channels for the point positions. In addition, it also supports '''z''', '''r''', '''g''', '''b''', and '''id''' channels. The '''id''' channel is used for grouping points together as a single shape. By default when no '''id''' channel is present, each point is separate and unconnected.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Int : The index of the zone to send to in Beyond.",
                "type": "IntPar",
                "name": "zone",
                "items": []
            },
            {
                "text": "Menu : Select the mode for calculating the rate of the image in Beyond. Note: this is not the rate of the CHOP.",
                "type": "MenuPar",
                "name": "ratemode",
                "items": []
            },
            {
                "text": "Int : Specify the sample rate as a percent of the projector default sample rate.",
                "type": "IntPar",
                "name": "percent",
                "items": []
            },
            {
                "text": "Int : Specify the sample rate of the image in Beyond",
                "type": "IntPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Int : How often to repeat each point in the image (not including blanked points).",
                "type": "IntPar",
                "name": "repeat",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the image will be sent to Beyond as a vector frame. A vector frame will have extra computation done in Beyond, such as the addition of blanking points. When disabled, the image will be sent as points to the DAC, with nothing extra added.",
                "type": "TogglePar",
                "name": "vector",
                "items": []
            },
            {
                "text": "Pulse : Resend the image to Beyond.",
                "type": "PulsePar",
                "name": "resend",
                "items": []
            },
            {
                "text": "Pulse : Enables laser output in Beyond. Has the same effect as hitting the \"Enable Laser Output\" button in Beyond.",
                "type": "PulsePar",
                "name": "enableout",
                "items": []
            },
            {
                "text": "Pulse : Disables laser output in Beyond. Has the same effect as hitting the \"Disable Laser Output\" button in Beyond.",
                "type": "PulsePar",
                "name": "disableout",
                "items": []
            },
            {
                "text": "Pulse : Sends a blackout command to Beyond. Has the effect as hitting the \"Blackout\" button in Beyond.",
                "type": "PulsePar",
                "name": "blackout",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "pangolinCHOP",
        "opLabel": "Pangolin",
        "opClass": "pangolinCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "short": "The Pangolin CHOP interfaces with Pangolin's Beyond.",
        "long": "The Pangolin CHOP interfaces with Pangolin's [https://pangolin.com/collections/beyond-software Beyond]. Beyond is a professional laser and multimedia show control application. When Beyond is running, the Pangolin CHOP will send laser image frames to it. The image frames are created from either a SOP input or CHOP input.\n    \nThe Pangolin CHOP should work with any version of Beyond but it is recommended to use at least Beyond v5.1.\n    \n'''TouchDesigner Non-commercial will only work with the demo version of Beyond. TouchDesigner Commercial or Pro is required to interface with licensed versions of Beyond.'''\n    \nSee also: [[Laser CHOP]].",
        "opCategories": ""
    },
    "parameterCHOP": {
        "label": "parameterCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Parameter CHOP gets parameter values, including custom parameters, from all OP types.\t\t\n\t\t\t\n(This replaces the Fetch CHOP.)\t\t\t\n \t\t\t\nRetrieve from parameters alternatively using a <code>node.par.Customname</code> expression of the [[Par Class]], or the [[Parameter Execute DAT]].\t\t\t\n\t\t\t\nSee the [[Select CHOP]] for retrieving channels from the output of other CHOPs.",
        "opLicense": "Non-Commercial",
        "opClass": "parameterCHOP_Class",
        "opLabel": "Parameter",
        "opFamily": "CHOP",
        "opType": "par",
        "short": "The Parameter CHOP gets parameter values, including custom parameters, from all OP types."
    },
    "patternCHOP": {
        "label": "patternCHOP",
        "members": [
            {
                "text": "Menu : The shape of one cycle of the pattern.",
                "type": "MenuPar",
                "name": "wavetype",
                "items": []
            },
            {
                "text": "Int : Set the number of samples for this CHOP.",
                "type": "IntPar",
                "name": "length",
                "items": []
            },
            {
                "text": "Float : Set the number of repeating cycles of the Type shapes over the Length, except for Random.",
                "type": "FloatPar",
                "name": "numcycles",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "steppercycle",
                "items": []
            },
            {
                "text": "Int : ",
                "type": "IntPar",
                "name": "numsteps",
                "items": []
            },
            {
                "text": "Float : Makes Triangle type into a sawtooth wave, and sets the Square type variable-width.",
                "type": "FloatPar",
                "name": "bias",
                "items": []
            },
            {
                "text": "Float : The seed for the random Types.",
                "type": "FloatPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Float : Shifts the cycle.",
                "type": "FloatPar",
                "name": "phase",
                "items": []
            },
            {
                "text": "Float : Increases the phase for each channel. A Phase Step of .25 when there are 2 channels will shift the second channel to be 1/4 cycle later phase than the first phase, where if the 2 channels are used for x and y, will draw a circle when passed to a CHOP to SOP.",
                "type": "FloatPar",
                "name": "phasestep",
                "items": []
            },
            {
                "text": "Float : Two parameters to multiply by a line from <code>taper1</code> at the start to <code>taper2</code> at the end. The default of (<code>1 1</code>) has no effect.",
                "type": "FloatPar",
                "name": "taper",
                "items": []
            },
            {
                "text": "Float : An exponent that is applied to the result of the taper.",
                "type": "FloatPar",
                "name": "taperdecay",
                "items": []
            },
            {
                "text": "Float : See also the Range.",
                "type": "FloatPar",
                "name": "amp",
                "items": []
            },
            {
                "text": "Float : See also the Range.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Float : A value at each From Range will become its corresponding To Range value.",
                "type": "FloatPar",
                "name": "fromrange",
                "items": []
            },
            {
                "text": "Float : A value at each From Range will become its corresponding To Range value.",
                "type": "FloatPar",
                "name": "torange",
                "items": []
            },
            {
                "text": "Menu : A round-off menu to convert all numbers to integers.",
                "type": "MenuPar",
                "name": "integer",
                "items": []
            },
            {
                "text": "Toggle : Reverses the final order of the samples as in the [[Stretch CHOP]].",
                "type": "TogglePar",
                "name": "reverse",
                "items": []
            },
            {
                "text": "Pulse : When the Type parameter above is set to Random Non-Repeating Integers, this trigger will randomize all the values.",
                "type": "PulsePar",
                "name": "randomize",
                "items": []
            },
            {
                "text": "Str : You can creates many channels with simple patterns like <code>chan[1-20]</code>, which generates 20 channels from <code>chan1</code> to <code>chan20</code>, or <code>t[xyz]</code> which generates <code>tx</code>, <code>ty</code> and <code>tz</code>. See the section, Common CHOP Parameters for a description of this and all Options. See [[CHOP Common Page#Scope|Scope and Channel Name Matching]] Options.",
                "type": "StrPar",
                "name": "channelname",
                "items": []
            },
            {
                "text": "Menu : If an input CHOP is attached, it adopts the length and sample rate of the input CHOP, and",
                "type": "MenuPar",
                "name": "combine",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            },
            {
                "text": "Menu : The shape of one cycle of the pattern.",
                "type": "MenuPar",
                "name": "wavetype",
                "items": []
            },
            {
                "text": "Int : Set the number of samples for this CHOP.",
                "type": "IntPar",
                "name": "length",
                "items": []
            },
            {
                "text": "Float : Set the number of repeating cycles of the Type shapes over the Length, except for Random.",
                "type": "FloatPar",
                "name": "numcycles",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "steppercycle",
                "items": []
            },
            {
                "text": "Int : ",
                "type": "IntPar",
                "name": "numsteps",
                "items": []
            },
            {
                "text": "Float : Makes Triangle type into a sawtooth wave, and sets the Square type variable-width.",
                "type": "FloatPar",
                "name": "bias",
                "items": []
            },
            {
                "text": "Float : The seed for the random Types.",
                "type": "FloatPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Float : Shifts the cycle.",
                "type": "FloatPar",
                "name": "phase",
                "items": []
            },
            {
                "text": "Float : Increases the phase for each channel. A Phase Step of .25 when there are 2 channels will shift the second channel to be 1/4 cycle later phase than the first phase, where if the 2 channels are used for x and y, will draw a circle when passed to a CHOP to SOP.",
                "type": "FloatPar",
                "name": "phasestep",
                "items": []
            },
            {
                "text": "Float : Two parameters to multiply by a line from <code>taper1</code> at the start to <code>taper2</code> at the end. The default of (<code>1 1</code>) has no effect.",
                "type": "FloatPar",
                "name": "taper",
                "items": []
            },
            {
                "text": "Float : An exponent that is applied to the result of the taper.",
                "type": "FloatPar",
                "name": "taperdecay",
                "items": []
            },
            {
                "text": "Float : See also the Range.",
                "type": "FloatPar",
                "name": "amp",
                "items": []
            },
            {
                "text": "Float : See also the Range.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Float : A value at each From Range will become its corresponding To Range value.",
                "type": "FloatPar",
                "name": "fromrange",
                "items": []
            },
            {
                "text": "Float : A value at each From Range will become its corresponding To Range value.",
                "type": "FloatPar",
                "name": "torange",
                "items": []
            },
            {
                "text": "Menu : A round-off menu to convert all numbers to integers.",
                "type": "MenuPar",
                "name": "integer",
                "items": []
            },
            {
                "text": "Toggle : Reverses the final order of the samples as in the [[Stretch CHOP]].",
                "type": "TogglePar",
                "name": "reverse",
                "items": []
            },
            {
                "text": "Pulse : When the Type parameter above is set to Random Non-Repeating Integers, this trigger will randomize all the values.",
                "type": "PulsePar",
                "name": "randomize",
                "items": []
            },
            {
                "text": "Str : You can creates many channels with simple patterns like <code>chan[1-20]</code>, which generates 20 channels from <code>chan1</code> to <code>chan20</code>, or <code>t[xyz]</code> which generates <code>tx</code>, <code>ty</code> and <code>tz</code>. See the section, Common CHOP Parameters for a description of this and all Options. See [[CHOP Common Page#Scope|Scope and Channel Name Matching]] Options.",
                "type": "StrPar",
                "name": "channelname",
                "items": []
            },
            {
                "text": "Menu : If an input CHOP is attached, it adopts the length and sample rate of the input CHOP, and",
                "type": "MenuPar",
                "name": "combine",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Pattern CHOP generates a sequence of samples in a channel. Unlike the [[Wave CHOP]] its purpose is generating arrays of samples that have no reference to time (seconds or frames).\t\t\n \t\t\t\nIt is useful for curve generation like lookup tables, simple shapes that can be converted to SOPs, generating channels that are passed to the [[Geometry COMP]] to generate instances, and other non-time-based curve-generation, with as little need to make expressions in Python.\t\t\t\n\t\t\t\nAll defaults are in samples, not seconds or frames (though like all CHOPs, it carries with it a sample rate). There is no start-end, just Length in samples.\t\t\t\n\t\t\t\n'''Tip''': To display a CHOP viewer in the units of samples, make the [[Viewer Active]] and change [[Mouse Click|RMB]] -> Units to be Samples.\t\t\t\n \t\t\t\nThe Pattern CHOP optionally takes one input CHOP to match the length and sample rate, and, choosing via the Combine Channels menu, Appends or Inserts the new channel(s), Replaces the incoming channels, Adds to the incoming channels or Multiplies the incoming channels.\t\t\t\n\t\t\t\nThe Pattern CHOP defaults to one cycle of the curve over the length of the CHOP, no matter how many samples long.\t\t\t\n \t\t\t\n'''Tip: Customizing each channel:''' The python object for the Pattern CHOP has a <code>chanIndex</code> member, so if Pattern generates three channels you can put something like <code>[1, 3, 7][me.chanIndex]</code> in any parameter to customize its value for each channel. For example, in the Type parameter, put the expression <code>['sin', 'cos', 'ramp'][me.chanIndex]</code> to get 3 different curve types.",
        "opLicense": "Non-Commercial",
        "opClass": "patternCHOP_Class",
        "opLabel": "Pattern",
        "opFamily": "CHOP",
        "opType": "pattern",
        "short": "The Pattern CHOP generates a sequence of samples in a channel.",
        "opCategories": ""
    },
    "performCHOP": {
        "label": "performCHOP",
        "members": [
            {
                "text": "Toggle : The number of frames rendered in the last second.",
                "type": "TogglePar",
                "name": "fps",
                "items": []
            },
            {
                "text": "Toggle : Amount of time each frame takes to cook in msec.",
                "type": "TogglePar",
                "name": "msec",
                "items": []
            },
            {
                "text": "Toggle : Is equal to 1 when a frame is cooked and equal to 0 when a frame is skipped.  It is often useful to view this channel in a [[Trail CHOP]] to see when frames are skipped (dropped).",
                "type": "TogglePar",
                "name": "cook",
                "items": []
            },
            {
                "text": "Toggle : The number of frames dropped between the last frame and the current frame.",
                "type": "TogglePar",
                "name": "droppedframes",
                "items": []
            },
            {
                "text": "Toggle : How many times the movie read ahead failed to maintain the number of specified Read Ahead frames.",
                "type": "TogglePar",
                "name": "mvreadahead",
                "items": []
            },
            {
                "text": "Toggle : Amount of GPU memory used (in megabytes).",
                "type": "TogglePar",
                "name": "gpumemused",
                "items": []
            },
            {
                "text": "Toggle : Total amount of GPU memory available on the system (in megabytes).",
                "type": "TogglePar",
                "name": "totalgpumem",
                "items": []
            },
            {
                "text": "Toggle : How many OPs are actively cooking.",
                "type": "TogglePar",
                "name": "activeops",
                "items": []
            },
            {
                "text": "Toggle : Number of calls to cook a component that has its [[Cooking Flag]] turned off.",
                "type": "TogglePar",
                "name": "deactivatedops",
                "items": []
            },
            {
                "text": "Toggle : Total number of OPs in the [[.toe]] file.",
                "type": "TogglePar",
                "name": "totalops",
                "items": []
            },
            {
                "text": "Toggle : Amount of CPU memory used (in megabytes).",
                "type": "TogglePar",
                "name": "cpumemused",
                "items": []
            },
            {
                "text": "Toggle : Monitors which frames actually cooked. Pass the Perform CHOP to a Trail CHOP to properly see the trail of frames that did and did not cook. (It appears as always 1 because the viewer is displaying only the current frame and not frames it missed.)",
                "type": "TogglePar",
                "name": "cookstate",
                "items": []
            },
            {
                "text": "Toggle : Monitors the state of the realtime flag, determining if TouchDesigner is running in realtime mode or not.",
                "type": "TogglePar",
                "name": "cookrealtime",
                "items": []
            },
            {
                "text": "Toggle : The global target cook rate (frames per second) of the project. This is the frames per second of the root component, <code>root.time.rate</code>, typically <code>60</code>, though due to frames taking too long to cook, the actual frames per second may be lower.",
                "type": "TogglePar",
                "name": "cookrate",
                "items": []
            },
            {
                "text": "Toggle : The number of frames that TouchDesigner stepped forward for the current cook. It's the length of the [[Time Slice]] in frames. It will be equal to 1 when the system is taking <code>1000/root.time.rate</code> msec or less to complete one frame (16.666 msec for a rate of 60).",
                "type": "TogglePar",
                "name": "timeslicestep",
                "items": []
            },
            {
                "text": "Toggle : The length of the current [[Time Slice]] in milliseconds.",
                "type": "TogglePar",
                "name": "timeslicemsec",
                "items": []
            },
            {
                "text": "Toggle : Monitors the state of [[Perform Mode]].",
                "type": "TogglePar",
                "name": "performmode",
                "items": []
            },
            {
                "text": "Toggle : Monitors if the Perform Window currently has focus or not.",
                "type": "TogglePar",
                "name": "performfocus",
                "items": []
            },
            {
                "text": "Toggle : Monitors the temperature of the system's GPUs.",
                "type": "TogglePar",
                "name": "gputemp",
                "items": []
            },
            {
                "text": "Toggle : Indicates if the laptop's AC Charger is plugged in and active. 1 if AC line is detected, 0 otherwise.",
                "type": "TogglePar",
                "name": "aclinestatus",
                "items": []
            },
            {
                "text": "Toggle : Indicates if the battery is being charged. 1 if charging, 0 otherwise.",
                "type": "TogglePar",
                "name": "batterycharging",
                "items": []
            },
            {
                "text": "Toggle : Indicated charge remaining in battery, 1 is battery full, 0 is battery empty.",
                "type": "TogglePar",
                "name": "batterylife",
                "items": []
            },
            {
                "text": "Toggle : Estimated time remaining in battery charge. Only works if AC Line is disconnected and battery is not being charged.",
                "type": "TogglePar",
                "name": "batterytime",
                "items": []
            },
            {
                "text": "Toggle : The number of active python expressions found in the project.",
                "type": "TogglePar",
                "name": "activeexpressions",
                "items": []
            },
            {
                "text": "Toggle : The number of python expression that have been optimized, see [[Optimized Python Expressions]].",
                "type": "TogglePar",
                "name": "optimizedexpression",
                "items": []
            },
            {
                "text": "Toggle : The number of python expression that have been cached, see [[Optimized Python Expressions]].",
                "type": "TogglePar",
                "name": "cachedexpressions",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Perform CHOP outputs many channels like frames-per-second, describing the current state of the TouchDesigner process. As channels they can be manipulated into user interfaces and calculations to adjust real-time self-tuning of the process. \t\n\t\t\nIt outputs the \"cook time\" of the prior frame that was drawn, which is a reflection of how many frames TouchDesigner cooked in the prior second. The <code>cook</code>\n\n'''Tip''': Put a Trail CHOP after the Perform CHOP to watch its progress.\n\nchannel, when sent to a Trail CHOP shows which frames were cooked and which were skipped, useful in optimizing your work to reach a desired frame rate.\t\t\n\t\t\nThe Built-in Variables found on Dialogs -> Variables -> Built-in include more useful data on your running system. See also the Built-in Variables section of the [[Variables]] page.",
        "opLicense": "Non-Commercial",
        "opClass": "performCHOP_Class",
        "opLabel": "Perform",
        "opFamily": "CHOP",
        "opType": "perform",
        "short": "The Perform CHOP outputs many channels like frames-per-second, describing the current state of the TouchDesigner process.",
        "opCategories": ""
    },
    "phaserCHOP": {
        "label": "phaserCHOP",
        "members": [
            {
                "text": "Float : The separation edge of the phasing between two states. A smaller edge corresponds to sharper separation according to differences in phase. Edge Parameter will not be used if there is an Edge Input.",
                "type": "FloatPar",
                "name": "edge",
                "items": []
            },
            {
                "text": "Int : Specify the size of the output. This parameter will not be used if there is a phase input.",
                "type": "IntPar",
                "name": "nsamples",
                "items": []
            },
            {
                "text": "Menu : Specifies the format of the output.",
                "type": "MenuPar",
                "name": "outputformat",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "phaserCHOP",
        "opLabel": "Phaser",
        "opClass": "phaserCHOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The Phaser CHOP does staggered (time-offset) animation interpolation. Phaser outputs one channel with multi-samples. Each sample animates from 0 to 1 over a cycle, but each sample value rises from 0 and arrives at 1 at different times.",
        "long": "The Phaser CHOP does staggered (time-offset) animation interpolation. Phaser outputs one channel with multi-samples. Each sample animates from 0 to 1 over a cycle, but each sample value rises from 0 and arrives at 1 at different times.\n    \nFor example, you may have a set of N objects that you want to animate from a start position to an end position. You set Num Samples to N, which will make the Phaser CHOP output one channel with N samples that will animate the samples from 0 to 1 and be interpolated with an easing function. In the Phaser CHOP the start-to-end cycle is controlled by the first input of the CHOP, which is expected to be one channel with value between 0 to 1. \n\nThe 0-1 values can be used with the [[Lookup CHOP]] to animate groups of channels.\n\nBy default the timing is staggered uniformly.  If you want to stagger their transitions irregularly, you use the second input, a set of values in one CHOP channel (typically N samples) that are between 0 and 1. The phase value specifies the object's timing relationship with the rest of those in the CHOP. A phase value of 1 corresponds to an animated object thats \"ahead of the pack\" (ie. it will start animating before the others). A value of 0 corresponds to an object that is late (ie. it will be the last to start easing/animating). If a phase input is not provided then the phase will simply be i/N where N is the total number of objects (ie. samples), and i is the index of the current sample.\n    \nThere is also a notion of an \"Edge\" in the Phaser, which describes the cohesiveness of the group of animated objects and how fast the samples rise. A small value will cause the objects to go through the animation very quickly or at high value, very slowly and in unison with other samples.\n\nLook at David Braun's '''[https://www.youtube.com/watch?v=S4PQW4f34c8 TouchDesigner Summit Talk]''' to see the background of the Phaser CHOP. Its functionality draws heavily from David's research and development in quantitative easing. \n\nSee also the [[OP Snippets]].",
        "opCategories": ""
    },
    "pipeinCHOP": {
        "label": "pipeinCHOP",
        "members": [
            {
                "text": "Menu : Set operation as server or client.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Str : The network address of the server computer. This address is a standard WWW address, such as '<code>foo</code>' or '<code>foo.bar.com</code>'. You can use an IP address (e.g. <code>100.123.45.78</code>) or the computer's network name can be entered. If you put \"<code>localhost</code>\", it means the other end of the pipe is on the same computer.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The network port of the server.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : While On, the CHOP receives information from the pipe or server. While Off, no updating occurs. Data sent by a server is lost, but a pipe will store the data until Active is turned on again. If in Network mode, turning this parameter on initiates a connection, and turning it off breaks the connection.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : When checked on, the network queuing is enabled. See the following parameters.",
                "type": "TogglePar",
                "name": "queued",
                "items": []
            },
            {
                "text": "Float : The lower end of the queue target range. The Pipe In CHOP will try to maintain a queue length greater than or equal to this value.",
                "type": "FloatPar",
                "name": "mintarget",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "mintargetunit",
                "items": []
            },
            {
                "text": "Float : The upper end of the queue target range. The Pipe In CHOP will try to maintain a queue length less than or equal to this value.",
                "type": "FloatPar",
                "name": "maxtarget",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "maxtargetunit",
                "items": []
            },
            {
                "text": "Float : The maximum size of the queue when full. Incoming samples will be dropped if the maximum queue is reached. '''This also affects the maximum number of script commands that can be queued up before they start gettting dropped.'''",
                "type": "FloatPar",
                "name": "maxqueue",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "maxqueueunit",
                "items": []
            },
            {
                "text": "Float : Specifies how often to repeat/drop a samples in order to get closer to the queue target range. If the value = 1 and the units = seconds, then it will try to repeat/drop a sample once per second to maintain the queue target set in the Minimum Target and Maximum Target parameters above.",
                "type": "FloatPar",
                "name": "adjusttime",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "adjusttimeunit",
                "items": []
            },
            {
                "text": "Pulse : Discards and clears all channels and incoming data.",
                "type": "PulsePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Toggle : Incoming script commands will be ignored unless this parameter is turned On. Turning it Off is more secure.",
                "type": "TogglePar",
                "name": "allowscripts",
                "items": []
            },
            {
                "text": "Menu : Print all incoming commands (not channel data) to the Console which can be opened from the Dialogs menu. A good way to test a connection is to put \"<code>echo X</code>\" commands in the incoming stream.",
                "type": "MenuPar",
                "name": "echo",
                "items": []
            },
            {
                "text": "DAT : Path to a DAT containing callbacks for each event received. See [[pipeinCHOP_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Pipe In CHOP allows users to input from custom devices into CHOPs. It is implemented as a TCP/IP network connection.",
        "opType": "pipein",
        "opFilter": "False",
        "opClass": "pipeinCHOP_Class",
        "opLabel": "Pipe In",
        "long": "The Pipe In CHOP allows users to input from custom devices into CHOPs. It is implemented as a TCP/IP network connection.\t\t\n\t\t\t\nThe connection can be from a user-written program that outputs to the Pipe In CHOP's port, or from another TouchDesigner process, where the data is coming from a [[Pipe Out CHOP]].\t\t\t\n\t\t\t\nRegular channel data sent to Pipe In outputs has CHOP channels (channel names with floating point values every frame). Mixed with it can be TouchDesigner scripting commands that get executed when they arrive. \t\t\t\n\t\t\t\n'''TIP:''' The [[TCP/IP DAT]] or [[UDP In DAT]] is the preferred way to send script commands and other data packets over the network.\t\t\t\n\t\t\t\nThis node differs from the [[Touch In CHOP]] as it functions using a stream of commands, instead of a simple stream of channel data like the [[Touch In CHOP]]. Information comes in in various commands which are documented in the files located in your installation directory\t\t\t\n<code>C:/Program Files/Derivative/TouchDesigner*/touch/docs/pipe</code>.\t\t\t\n\t\t\t\nTo receive network data from another \"server\" computer (e.g. from a TouchDesigner Pipe Out CHOP running remotely), a connection must be established between the server and the Pipe In CHOP before data is sent. You must supply the Server Address and Port from which to receive incoming data to a channel. The server should be listening for connections on the port that this CHOP is using.\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''\t\t\n\t\t\t\nSee also [[Shared Mem In CHOP]].",
        "opCategories": ""
    },
    "pipeoutCHOP": {
        "label": "pipeoutCHOP",
        "members": [
            {
                "text": "Menu : Set operation as server or client.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Str : The computer name or IP address of the server computer. This address is a standard WWW address, such as '<code>foo</code>' or '<code>foo.bar.com</code>'. You can use an IP address (e.g. <code>100.123.45.78</code>) or the computer's network name can be entered. If you put \"<code>localhost</code>\", it means the other end of the pipe is on the same computer.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The network port to use.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : When Off, data is not sent.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : On/off toggle for sending the data connected to the Pipe Out CHOP's input.",
                "type": "TogglePar",
                "name": "sendinput",
                "items": []
            },
            {
                "text": "Toggle : This parameter is only enabled if the Pipe Out CHOP is not [[Time_Slicing|time sliced]] (See Common Page of parameters). If On, it only sends the current frame's sample. If Off, it sends all data between this frame and the last frame TouchDesigner cooked at. The difference arises when TouchDesigner is not cooking 60 frames per second and is skipping frames. If playback skips by 3 animation frames between screen draws, the On case sends only one frame of data, and the Off case sends 3 frames of data (a \"[[Time Slice]]\" in TouchDesigner-speak).",
                "type": "TogglePar",
                "name": "sendsingle",
                "items": []
            },
            {
                "text": "Menu : In single sample mode, this parameter determines which sample to send; the sample at frame 1 or the current sample.",
                "type": "MenuPar",
                "name": "sample",
                "items": []
            },
            {
                "text": "Pulse : When the button is pressed, sends all the channel names and their data once in one burst.",
                "type": "PulsePar",
                "name": "upload",
                "items": []
            },
            {
                "text": "Str : Use these parameters to send a one-time textport command through the pipe.",
                "type": "StrPar",
                "name": "script",
                "items": []
            },
            {
                "text": "Pulse : Use these parameters to send a one-time textport command through the pipe.",
                "type": "PulsePar",
                "name": "sendscript",
                "items": []
            },
            {
                "text": "Toggle : Turn this on to make sure this CHOP gets processed every frame. Usually CHOPs do not get processed every frame unless they are directly involved with some aspect of the geometry being displayed.",
                "type": "TogglePar",
                "name": "cookalways",
                "items": []
            },
            {
                "text": "Toggle : Sends pulses (a single null character) once a frame, to monitor the connection. This keeps the connection active, and keeps the Pipe In CHOP aware of the connection status so it can properly report its state.",
                "type": "TogglePar",
                "name": "pulse",
                "items": []
            },
            {
                "text": "Toggle : Print all outgoing data to the Console which can be opened from the Dialogs menu. See this option in the [[Pipe In CHOP]] for more details.",
                "type": "TogglePar",
                "name": "echo",
                "items": []
            },
            {
                "text": "DAT : Path to a DAT containing callback methods for each event sent. See [[pipeoutCHOP_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Pipe Out CHOP can be used to transmit data out of TouchDesigner to other processes running on a remote machine using a network connection.",
        "opType": "pipeout",
        "opFilter": "True",
        "opClass": "pipeoutCHOP_Class",
        "opLabel": "Pipe Out",
        "long": "The Pipe Out CHOP can be used to transmit data out of TouchDesigner to other processes running on a remote machine using a network connection. If the other process is another TouchDesigner process, a [[Pipe In CHOP]] in that process can be used to receive the data. Multiple PipeIn CHOPs can connect to a PipeOut CHOP.\n\nFor more information on how to connect two TouchDesigner processes running on different machines with a Pipe In and Pipe Out CHOP, see the [[Pipe In CHOP]].\t\n\t\t\t\n'''NOTE:''' For TouchDesigner-to-TouchDesigner communication of channel data, see the [[Touch In CHOP]] and [[Touch Out CHOP]] which offer optimized and [[Time Slice]]d data transfer.\t\t\t\n\t\t\t\n'''TIP:''' The [[TCP/IP DAT]] or [[UDP Out DAT]] is the preferred way to send script commands and other data packets over the network.\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''\t\t\t\t\t\n\t\t\t\nSee also [[OSC Out CHOP]], [[Shared Mem Out CHOP]].",
        "opCategories": ""
    },
    "posistagenetCHOP": {
        "label": "posistagenetCHOP",
        "members": [
            {
                "text": "Toggle : If turned off, the PosiStageNet CHOP will stop receiving data.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : Set this parameter to the network address of the PosiStageNet server, device, or software.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : By default, TCP Port uses 56565. Firewall settings may need to be adjusted to allow for the PosiStageNet CHOP to communicate properly.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Int : Specify the rate at which the incoming data is sampled.",
                "type": "IntPar",
                "name": "samplerate",
                "items": []
            },
            {
                "text": "Toggle : Include position channels.",
                "type": "TogglePar",
                "name": "pos",
                "items": []
            },
            {
                "text": "Toggle : Include orientation channels as Euler angles.",
                "type": "TogglePar",
                "name": "ori",
                "items": []
            },
            {
                "text": "Toggle : Include speed channels.",
                "type": "TogglePar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Toggle : Include acceleration channels.",
                "type": "TogglePar",
                "name": "accel",
                "items": []
            },
            {
                "text": "Toggle : Include the target position as channels.",
                "type": "TogglePar",
                "name": "targetpos",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "This operator decodes [http://www.posistage.net/ PosiStageNet] protocol data into CHOP channels. PosiStageNet will track any number of objects and output their position, orientation, speed, acceleration, or the objects' target position.\n\nPosiStageNet is a data exchange protocol created by [http://www.vyv.ca/ VYV] and [http://www.malighting.com MA Lighting], and has applications in on-stage lighting, sound, and projection mapping.\n\nSee also [[BlackTrax CHOP]].",
        "opLabel": "PosiStageNet",
        "opClass": "posistagenetCHOP_Class",
        "opType": "posistagenet",
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "This operator decodes PosiStageNet protocol data into CHOP channels.",
        "opCategories": ""
    },
    "pulseCHOP": {
        "label": "pulseCHOP",
        "members": [
            {
                "text": "Int : The number of pulses to generate.",
                "type": "IntPar",
                "name": "number",
                "items": []
            },
            {
                "text": "Menu : You can interpolate the values between pulses using the following function curves:",
                "type": "MenuPar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Float : By default, the pulses are a single sample long, but you can increase the Pulse Width so that the pulses are steps to the next pulse.",
                "type": "FloatPar",
                "name": "width",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "widthunit",
                "items": []
            },
            {
                "text": "Menu : Enable the Minimum and Maximum clamping values below with this menu.",
                "type": "MenuPar",
                "name": "limit",
                "items": []
            },
            {
                "text": "Float : The pulses can be restricted to a Minimum limit. If the Limit Type is Clamp, the graph has additional convenient handles at the minimum for each pulse.",
                "type": "FloatPar",
                "name": "min",
                "items": []
            },
            {
                "text": "Float : The pulses can be restricted to a Maximum limit. If the Limit Type is Clamp, the graph has additional convenient handles at the maximum for each pulse.",
                "type": "FloatPar",
                "name": "max",
                "items": []
            },
            {
                "text": "Toggle : In order to set the value at the last sample, the option Last Pulse at Last Sample is provided. Otherwise, the last pulse is prior to the last sample.",
                "type": "TogglePar",
                "name": "lastpulse",
                "items": []
            },
            {
                "text": "Float : The value of the sequence pulse.",
                "type": "FloatPar",
                "name": "pulse0",
                "items": []
            },
            {
                "text": "Str : You can creates many channels with simple patterns like \"<code>chan[1-20]</code>\", which generates 20 channels from chan1 to chan20. See the section, Common CHOP Parameters for a description of this and all Options. See [[CHOP Common Page#Scope|Scope and Channel Name Matching]] Options.",
                "type": "StrPar",
                "name": "channelname",
                "items": []
            },
            {
                "text": "Float : Start of the interval, expressed in Units (seconds, frames or samples).",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : End of the interval, expressed in Units (seconds, frames or samples).",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second. Default: <syntaxhighlight lang=python inline=true>me.time.rate</syntaxhighlight>",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Pulse CHOP generates pulses in one channel at regular intervals.",
        "opType": "pulse",
        "opFilter": "False",
        "opClass": "pulseCHOP_Class",
        "opLabel": "Pulse",
        "long": "The Pulse CHOP generates pulses in one channel at regular intervals. The amplitude of each pulse can be edited with the CHOP sliders or with handles on the graph.\t\t\n\t\t\t\nThe Pulse CHOP gives a set of pulses in a static channel of a specifiable length. \t\t\t\n\t\t\t\nSee also the [[LFO CHOP]] to get an endless stream of pulses that is [[Time Slice]]d, and the [[Pattern CHOP]] for a string of static pulses.\t\t\t\n\t\t\t\nThe Pulse CHOP can be used as triggers to the [[Copy CHOP]], and can represent regularly-timed events.\t\t\t\n\t\t\t\nBy default, the pulses are a single sample long, but you can increase the Pulse Width so that the pulses are steps to the next pulse. You can also interpolate the values between pulses, as Linear, Ease In Ease Out, Cubic or other curves.\t\t\t\n\t\t\t\nThe pulses can be restricted to a minimum / maximum limit. If the Limit Type is Clamp, the graph has additional convenient handles at the minimum and maximum for each pulse.\t\t\t\n\t\t\t\nThe Pulse CHOP generates a single channel of up to 32 pulses, and you can merge several Pulse CHOPs into a multi-channel CHOP.\t\t\t\n\t\t\t\nThe Pulse CHOP uses its optional first input as a start/end reference, so a number of Pulse CHOPs can be stretched to the same interval.\t\t\t\n\t\t\t\nIn order to set the value at the last sample, the option, Last Pulse at Last Sample is provided. Otherwise, the last pulse is prior to the last sample.",
        "opCategories": ""
    },
    "realsenseCHOP": {
        "label": "realsenseCHOP",
        "members": [
            {
                "text": "Toggle : When enabled, actively fetches skeleton tracking data from a RealSense TOP.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "TOP : The RealSense TOP camera to fetch skeleton data from.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Toggle : When enabled, displays the skeleton channels.",
                "type": "TogglePar",
                "name": "skeletons",
                "items": []
            },
            {
                "text": "Int : Specify the max number of players tracked.",
                "type": "IntPar",
                "name": "maxplayers",
                "items": []
            },
            {
                "text": "Toggle : When enabled, will display positions of each landmark in image pixels as x/y channels.",
                "type": "TogglePar",
                "name": "pos",
                "items": []
            },
            {
                "text": "Toggle : When enabled, will display normalized position values of each landmark as u/v channels.",
                "type": "TogglePar",
                "name": "norm",
                "items": []
            },
            {
                "text": "Toggle : When enabled, will display the confidence value of each landmark. When the confidence channel value is 0 the landmark is untracked.",
                "type": "TogglePar",
                "name": "confidence",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The RealSense CHOP references a [[RealSense TOP]] camera and fetches tracking data from it.",
        "opType": "realsense",
        "opFilter": "False",
        "opClass": "realsenseCHOP_Class",
        "opLabel": "RealSense",
        "long": "[[RealSense]] is a tracking device from Intel. The RealSense CHOP references a [[RealSense TOP]] camera and fetches tracking data from it. The RealSense CHOP supports skeleton tracking through the [https://www.intelrealsense.com/skeleton-tracking/ Cubemos Skeleton Tracking API]. [[Cubemos]] is Windows only. A Cubemos license is required to use the skeleton tracking.\n    \n==== Skeleton Tracking Setup ====\nThe [[RealSense CHOP]] supports skeleton tracking through the [https://www.intelrealsense.com/skeleton-tracking/ Cubemos RealSense Skeleton Tracking API]. The Cubemos API requires a license to use in TouchDesigner. A full license can be purchased [https://www.intelrealsense.com/skeleton-tracking here]; a trial license is also available. Installing their SDK is required to setup the license file. After installation of the SDK, the license can be setup with the <code>post_installation.bat</code> script in the <code>C:/Program Files/Cubemos/SkeletonTracking/scripts</code> folder. A model file (<code>.cubemos</code>) is also required for the skeleton tracking, two of which are packaged with the Cubemos Skeleton Tracking SDK, located in their <code>Cubemos/SkeletonTracking/models/skeleton-tracking</code> folder.\n\n'''NOTE:''' The [https://github.com/IntelRealSense/librealsense/releases librealsense SDK v2.50.0] does not look like it will be updated for Apple Silicon, so it is not an option to add to these builds.\n\nSee also: [[RealSense]], [[RealSense TOP]]",
        "opCategories": ""
    },
    "recordCHOP": {
        "label": "recordCHOP",
        "members": [
            {
                "text": "Menu : When and how much to record:",
                "type": "MenuPar",
                "name": "record",
                "items": []
            },
            {
                "text": "Menu : Determines whether record should sample the time slice or the current frame. You would generally want to use Current Time Slice, for audio, as all frames will be evaluated.\t\n\t\t\t\nIf the interval is set to be the Current Frame, it will always cook (only look at) the current frame (things downstream still cook regardless of this setting however). Thus, it should generally not be used for audio, but rather fro things like device input, because it interpolates the values between the captured frames.",
                "type": "MenuPar",
                "name": "sample",
                "items": []
            },
            {
                "text": "Menu : Determines how to compute missed input samples using interpolation. Using Hold Previous Value does just that; Linear and Cubic interpolation will create a mathematical blend of values in a linear (straight line between values in time), or cubic (smooth round-off curve between beginning and ending values).",
                "type": "MenuPar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Menu : Determines the frame range that gets output from the CHOP.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Float : The data gets recorded in a fixed-range interval and the most recent data gets recorded at the end of the interval and the remaining samples get shifted toward the start of the interval. This is useful for making snakes.",
                "type": "FloatPar",
                "name": "segment",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "segmentunit",
                "items": []
            },
            {
                "text": "Pulse : The current output is cleared and all subsequent channels will commence single sample lengths.",
                "type": "PulsePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Menu : Enabled when a CHOP is connected to the Record CHOP's 3rd input (ie. Input 2). Determines what condition is required to trigger a reset using this input.",
                "type": "MenuPar",
                "name": "resetcondition",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Record CHOP takes the channels coming in the first (Position) input, converts and records them internally, and outputs the stored channels as the CHOP output.",
        "opType": "record",
        "opFilter": "True",
        "opClass": "recordCHOP_Class",
        "opLabel": "Record",
        "long": "The Record CHOP takes the channels coming in the first (Position) input, converts and records them internally, and outputs the stored channels as the CHOP output. The optional second (Active) input is used to enable and disable the recording.\t\t\n\t\t\t\nDuring recording, the Record CHOP uses only the values of the first input at the current frame. The Type determines how the input values are converted.\t\t\t\n\t\t\t\n'''Tip''': The [[Trail CHOP]] also records the last window of samples, and more powerfully, the gestureCapture component in the Palette gives more control over multi-captures and smoothing channel data.\t\t\t\n\t\t\t\nIf Record is set to Auto Range, and the Active input goes on, and TouchDesigner is playing, then any existing storage array is cleared, and the channels are recorded in a new storage array until Active goes off. This behaves like a sampler.\t\t\t\n\t\t\t\nThe [[Mouse In CHOP]] and [[Keyboard In CHOP]] are often attached to the Position and Active inputs respectively of the Record CHOP to perform the recording of channels from mouse movements, enabled by pressing a keyboard key (see the [[Keyboard In CHOP]]).\t\t\t\n\t\t\t\nRecord Segment is useful for recording trails, snakes, and other models that use a time-history of motion.\t\t\t\n\t\t\t\nSee the [[Time Slice CHOP]] for input smoothing.",
        "opCategories": ""
    },
    "renameCHOP": {
        "label": "renameCHOP",
        "members": [
            {
                "text": "StrMenu : The channel pattern to rename. See [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "renamefrom",
                "items": []
            },
            {
                "text": "StrMenu : The replacement pattern for the channel names. See [[Pattern Replacement]].",
                "type": "StrMenuPar",
                "name": "renameto",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Rename CHOP renames channels. Channels names from the input CHOP are matched using the From pattern, and are renamed to the corresponding name in the To pattern.",
        "opType": "rename",
        "opFilter": "True",
        "opClass": "renameCHOP_Class",
        "opLabel": "Rename",
        "long": "The Rename CHOP renames channels. Channels names from the input CHOP are matched using the From pattern, and are renamed to the corresponding name in the To pattern. Channels that do not match the From pattern are not affected.\t\n \nIt uses [[Pattern Matching]] on the From string, and [[Pattern Replacement]] on the To string.\n\t\t\nThe channel values and the channel order are not affected, only their names change.\t\t\n\t\t\n(Note that the [[Constant CHOP]] (containing channel values of 0) added to another CHOP in a [[Math CHOP]] can also be used to rename channels.)\t\t\n\t\t\nSee also [[Select CHOP]]",
        "opCategories": ""
    },
    "renderpickCHOP": {
        "label": "renderpickCHOP",
        "members": [
            {
                "text": "Menu : Decides when to update values based on pick interactions.",
                "type": "MenuPar",
                "name": "strategy",
                "items": []
            },
            {
                "text": "Toggle : This parameter is only enabled when the Strategy is set to Hold Last Picked. When this is on, starting a new pick on empty space will clear the values. When off, the last values will be held if the pick starts on empty space.",
                "type": "TogglePar",
                "name": "clearprev",
                "items": []
            },
            {
                "text": "Menu : Determines when the values are updated.",
                "type": "MenuPar",
                "name": "responsetime",
                "items": []
            },
            {
                "text": "Int : Controls the radius of the search area for the pick. If nothing is found at the pick's center it will keep searching for geometry in the search area defined by the Pick Radius.",
                "type": "IntPar",
                "name": "pickradius",
                "items": []
            },
            {
                "text": "Int : Used to reduce the searching within the search area. The search area is sampled at locations that correspond to 'spokes' outwards from the center pick point.",
                "type": "IntPar",
                "name": "pickradstep",
                "items": []
            },
            {
                "text": "Int : Used to reduce the searching within the search area. The search area is sampled at locations that correspond to 'rings' outwards from the center pick point.",
                "type": "IntPar",
                "name": "pickcirstep",
                "items": []
            },
            {
                "text": "TOP : Specifies which render to sample.",
                "type": "TOPPar",
                "name": "rendertop",
                "items": []
            },
            {
                "text": "Toggle : When turned on only geometry whose [[Flag|Pickable Flag]] is on can be selected by the Render Pick CHOP. The [[Pickable Flag]] is found on all [[Object]] components.",
                "type": "TogglePar",
                "name": "usepickableflags",
                "items": []
            },
            {
                "text": "Toggle : Includes the non-pickable objects in the picking algorithm such that non-pickable objects may occlude pickable objects.  For example, if there is only one pickable object in the scene with lots of additional non-pickable geometry is present, turning this parameter on will prevent the pickable object from being selected if it is behind a non-pickage object (occluded by the non-pickage object).",
                "type": "TogglePar",
                "name": "includenonpickable",
                "items": []
            },
            {
                "text": "Menu : Determines how the pick location is set.",
                "type": "MenuPar",
                "name": "pickingby",
                "items": []
            },
            {
                "text": "PanelCOMP : Specifies which panel component to use when picking by panel.",
                "type": "PanelCOMPPar",
                "name": "panel",
                "items": []
            },
            {
                "text": "StrMenu : Specifies with panel value to use to trigger the pick when picking by panel.",
                "type": "StrMenuPar",
                "name": "panelvalue",
                "items": []
            },
            {
                "text": "Float : Sets the u coordinate when picking by parameters.",
                "type": "FloatPar",
                "name": "picku",
                "items": []
            },
            {
                "text": "Float : Sets the v coordinate when picking by parameters.",
                "type": "FloatPar",
                "name": "pickv",
                "items": []
            },
            {
                "text": "Toggle : When picking by parameters, picking is active when this parameter = 1.",
                "type": "TogglePar",
                "name": "select",
                "items": []
            },
            {
                "text": "Toggle : Enables Callback DAT for each pick event.",
                "type": "TogglePar",
                "name": "activatecallbacks",
                "items": []
            },
            {
                "text": "DAT : Path to a DAT containing callbacks for pick event received.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Returns the position of the point picked on the geometry. Channels ''tx, ty, tz''.",
                "type": "MenuPar",
                "name": "position",
                "items": []
            },
            {
                "text": "Menu : Returns the normals of the point picked on the geometry. Channels ''nx, ny, nz''.",
                "type": "MenuPar",
                "name": "normal",
                "items": []
            },
            {
                "text": "Object : Object used when fetching position or normals '''Relative to Object'''.",
                "type": "ObjectPar",
                "name": "referenceobj",
                "items": []
            },
            {
                "text": "Toggle : Returns the point color of the point picked on the geometry. Channels ''cr, cg, cb, ca''.",
                "type": "TogglePar",
                "name": "color",
                "items": []
            },
            {
                "text": "Toggle : Returns the texture coordinates of the point picked on the geometry. Channels ''mapu, mapv, mapw''.",
                "type": "TogglePar",
                "name": "uv",
                "items": []
            },
            {
                "text": "Toggle : Return the path to the object that is picked. This result requires and [[Info DAT]] with its '''Node Path''' parameter referecning the Render Pick CHOP.",
                "type": "TogglePar",
                "name": "path",
                "items": []
            },
            {
                "text": "Toggle : Returns the depth of the point picked on the geometry. This value a non-linear ratio of the point's position between the near and far planes of the [[Depth Buffer]]. Channel is ''depth''.",
                "type": "TogglePar",
                "name": "depth",
                "items": []
            },
            {
                "text": "Toggle : Returns the Instance ID of the object. This will always be 0 if instancing is off. Channel is ''instance''.",
                "type": "TogglePar",
                "name": "instanceid",
                "items": []
            },
            {
                "text": "Str : Specify which custom attributes to return from the object.",
                "type": "StrPar",
                "name": "customattrib1",
                "items": []
            },
            {
                "text": "Menu : The type of attribute is selected from this menu.",
                "type": "MenuPar",
                "name": "customattrib1type",
                "items": []
            },
            {
                "text": "Str : Specify which custom attributes to return from the object.",
                "type": "StrPar",
                "name": "customattrib2",
                "items": []
            },
            {
                "text": "Menu : The type of attribute is selected from this menu.",
                "type": "MenuPar",
                "name": "customattrib2type",
                "items": []
            },
            {
                "text": "Str : Specify which custom attributes to return from the object.",
                "type": "StrPar",
                "name": "customattrib3",
                "items": []
            },
            {
                "text": "Menu : The type of attribute is selected from this menu.",
                "type": "MenuPar",
                "name": "customattrib3type",
                "items": []
            },
            {
                "text": "Str : Specify which custom attributes to return from the object.",
                "type": "StrPar",
                "name": "customattrib4",
                "items": []
            },
            {
                "text": "Menu : The type of attribute is selected from this menu.",
                "type": "MenuPar",
                "name": "customattrib4type",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Render Pick CHOP samples a rendering (from a [[Render TOP]] or a [[Render Pass TOP]]) and returns 3D information from the geometry at that particular pick location.",
        "opType": "renderpick",
        "opFilter": "False",
        "opClass": "renderpickCHOP_Class",
        "opLabel": "Render Pick",
        "long": "The Render Pick CHOP samples a rendering (from a [[Render TOP]] or a [[Render Pass TOP]]) and returns 3D information from the geometry at that particular pick location. Values sampled can include position, normals, point color, texture coordinates, depth and the object's path.\tAn [[Info DAT]] should be used to retrieve the object's path.\n\t\t\t\nThe pick location is specified through uv coordinates of the rendering. These uv coordinates can be selected by clicking on a [[Panel Component]] or explicitly setting them in the U and V parameters in the Render Pick CHOP.\n\nAlong with the geometric data returned, this node has two channels 'picked' and 'trigger' that inform the picked status. 'picked' will be 1 when an object has been found at the search location. 'trigger' will be 1 when both an object has been found, and the 'Picking By' condition has been met. That is, either the 'Panel Value' is 1, or the 'Select' parmeter is 'On.\n\t\t\t\nSee also the multi-sample [[Render Pick DAT]].",
        "opCategories": ""
    },
    "renderstreaminCHOP": {
        "label": "renderstreaminCHOP",
        "members": [
            {
                "text": "Toggle : Controls if the RenderStream session is active.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Int : When waiting for a sync signal to start a frame, this controls how long the node will stall (in milliseconds), before giving up waiting for a sync signal.",
                "type": "IntPar",
                "name": "timeout",
                "items": []
            },
            {
                "text": "Int : Controls which stream index this node should be syncing with and getting channels from.",
                "type": "IntPar",
                "name": "streamindex",
                "items": []
            },
            {
                "text": "DAT : This should be a DAT with a table containing the schema information to create sequencable parameters in Disguise. The Schema DAT supports the columns: <code>group, label, name, type, default, min, max, step</code>, where <code>group, label, name, type</code> are required. The <code>type</code> column should be one of: <code>float, image, text</code>. Float data will come in via the primary channels in this node. Image data can be obtained using a [[RenderStream In TOP]]. Text data can be obtained using an [[Info DAT]] pointing to this node.",
                "type": "DATPar",
                "name": "schemadat",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "renderstreaminCHOP",
        "opLabel": "RenderStream In",
        "opClass": "renderstreaminCHOP_Class",
        "opFilter": "True",
        "opLicense": "Pro",
        "opCategories": "",
        "short": "=This node is the primary node to control and configure a connection with the [[RenderStream]] protocol from [https://www.disguise.one/en/products/renderstream/ Disguise].",
        "long": "This node is the primary node to control and configure a connection with the [[RenderStream]] protocol from [https://www.disguise.one/en/products/renderstream/ Disguise]. Along with being the sync-point for when a frame starts rendering, it also brings in all of the control channels, and also takes a DAT with schema information to create controllable parameters within Disguise.\n\nUsually you want to have the 'Real-Time' flag on the top of the TouchDesigner UI turned off when using this node, so that this node is what drives frame advancement, not the default TouchDesigner time advancement.\n\nSee also [[RenderStream Out TOP]], [[RenderStream In TOP]], [[RenderStream]]."
    },
    "reorderCHOP": {
        "label": "reorderCHOP",
        "members": [
            {
                "text": "Menu : There are three different reordering methods. You can enter a Numeric Pattern, a Character Pattern, or use an optional second input CHOP as an order reference.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Menu : Only enabled if a second input is present. Specifies the format of that input.",
                "type": "MenuPar",
                "name": "orderref",
                "items": []
            },
            {
                "text": "Str : This reorders the channels by channel number. Normally the index order is 0,1,2,3... etc.. The first channel is at index 0. Standard numeric patterns are allowed such as <code>\"0-6:1,2\"</code> or <code>\"!*:1,3\"</code>.",
                "type": "StrPar",
                "name": "numpattern",
                "items": []
            },
            {
                "text": "StrMenu : This reorders the channels by channel name. Standard character patterns are allowed such as <code>\"ch[XYZ]\"</code> or <code>\"chan[1-15:2,5]\"</code> or <code>\"chan? ch*\"</code>. See Scope and Channel Name Matching Options p. 102 in the section, Standard Options of CHOPs.",
                "type": "StrMenuPar",
                "name": "charpattern",
                "items": []
            },
            {
                "text": "Float : Only available if <code>Channel Reorder Method</code> is set to \"Random\", specify any number, integer or non-integer, which starts the random number generator. Each number gives completely different patterns, but with similar characteristics.",
                "type": "FloatPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Int : Only available if <code>Channel Reorder Method</code> is set to \"Merge N Groups\" or \"Every Nth Channel\".",
                "type": "IntPar",
                "name": "nvalue",
                "items": []
            },
            {
                "text": "Menu : Channels that do not match are called \"remaining\" and can also be ordered: they can be placed at the At Beginning or At Ending (in reference to the position of the matched channels).",
                "type": "MenuPar",
                "name": "rempos",
                "items": []
            },
            {
                "text": "Menu : The channels that did not match can have the Same as Input order, or can be sorted AlphaNumerically.",
                "type": "MenuPar",
                "name": "remorder",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Reorder CHOP re-orders the first input CHOP's channels by numeric or alphabetic patterns.",
        "opType": "reorder",
        "opFilter": "True",
        "opClass": "reorderCHOP_Class",
        "opLabel": "Reorder",
        "long": "The Reorder CHOP re-orders the first input CHOP's channels by numeric or alphabetic patterns. Either a channel pattern specifies the new order, or a number sequence specifies the new order.\t\t\n\t\t\t\nIf the second input, the Order Reference is present, the Numeric Pattern and Character Pattern are ignored, and the first input CHOP's channels are reordered to match as well as possible the reference CHOP's. In this case, Method is not used.\t\t\t\n\t\t\t\nChannel values are never affected.",
        "opCategories": ""
    },
    "replaceCHOP": {
        "label": "replaceCHOP",
        "members": [
            {
                "text": "Menu : Determines the start/end range of the output.",
                "type": "MenuPar",
                "name": "length",
                "items": []
            },
            {
                "text": "Toggle : A performance diagnostic that notifies the user when the input names change.",
                "type": "TogglePar",
                "name": "notify",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Replace CHOP can be used to replace channels very quickly.",
        "opType": "replace",
        "opFilter": "True",
        "opClass": "replaceCHOP_Class",
        "opLabel": "Replace",
        "long": "The Replace CHOP can be used to replace channels very quickly. The output of channels in <span class=\"tipTextCHOP\">Input1</span> will be replaced by channels found in <span class=\"tipTextCHOP\">Input2</span> if a matching channel exists in Input2. Any channels that are in Input1 and not in Input2 will be output without being replaced.\t\t\n\t\t\t\nYou can also use this to quickly delete channels (this method can be faster than the [[Delete CHOP]]). To do this send all the channels to Input2, then send the channels you want to keep to Input1.",
        "opCategories": ""
    },
    "resampleCHOP": {
        "label": "resampleCHOP",
        "members": [
            {
                "text": "Menu : The resample method to apply to the channels:",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Float : The new sample rate.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : Determines how the Start/End parameters are interpreted.",
                "type": "MenuPar",
                "name": "relative",
                "items": []
            },
            {
                "text": "Float : The CHOP's new start position.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : The CHOP's new end position.",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Toggle : Uses quaternions to blend between samples.",
                "type": "TogglePar",
                "name": "quatrot",
                "items": []
            },
            {
                "text": "Menu : The interpolation method to use when resampling:",
                "type": "MenuPar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Toggle : If enabled, keeps the area under the channel constant by scaling the values of the channel.",
                "type": "TogglePar",
                "name": "constarea",
                "items": []
            },
            {
                "text": "Toggle : If enabled, compensates for cyclic channels (such as angles) by always choosing the shortest step between samples, like 360 to 0 for angles.",
                "type": "TogglePar",
                "name": "correct",
                "items": []
            },
            {
                "text": "Float : The length of the cycle. 360 is typical for angles.",
                "type": "FloatPar",
                "name": "cyclelen",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Resample CHOP resamples an input's channels to a new sample rate and/or start/end interval.",
        "opType": "resample",
        "opFilter": "True",
        "opClass": "resampleCHOP_Class",
        "opLabel": "Resample",
        "long": "The Resample CHOP resamples an input's channels to a new sample rate and/or start/end interval. In all cases, the entire input interval is resampled to match the output interval.\t\t\n\t\t\t\nResample does a simple linear interpolation of the Time Slice in [[Time Slicing]] mode. Only the sample rate can be changed.",
        "opCategories": ""
    },
    "scurveCHOP": {
        "label": "scurveCHOP",
        "members": [
            {
                "text": "Menu : What Curve Type to Generate.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Int : Set the number of samples for this CHOP.",
                "type": "IntPar",
                "name": "length",
                "items": []
            },
            {
                "text": "Int : Add this number of samples to the beginning of the curve.",
                "type": "IntPar",
                "name": "prepend",
                "items": []
            },
            {
                "text": "Int : Add this number of samples to the end of the curve.",
                "type": "IntPar",
                "name": "append",
                "items": []
            },
            {
                "text": "Float : Controls the steepness of the S Curve.",
                "type": "FloatPar",
                "name": "steepness",
                "items": []
            },
            {
                "text": "Float : Control the amount of cruvature in the curve.",
                "type": "FloatPar",
                "name": "linearize",
                "items": []
            },
            {
                "text": "Float : Move the curve's bias backward or forward.",
                "type": "FloatPar",
                "name": "bias",
                "items": []
            },
            {
                "text": "Float : Specify the low and high range of the input index.",
                "type": "FloatPar",
                "name": "fromrange",
                "items": []
            },
            {
                "text": "Float : Specify the low and high range of the curve.",
                "type": "FloatPar",
                "name": "torange",
                "items": []
            },
            {
                "text": "Str : You can creates many channels with simple patterns like \"<code>chan[1-20]</code>\", which generates 20 channels from chan1 to chan20. See the section, Common CHOP Parameters for a description of this and all Options. See [[CHOP Common Page#Scope|Scope and Channel Name Matching]] Options.",
                "type": "StrPar",
                "name": "channelname",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second. Default: <syntaxhighlight lang=python inline=true>me.time.rate</syntaxhighlight>",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend condition (before range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "scurve",
        "opLabel": "S Curve",
        "opLicense": "Non-Commercial",
        "opClass": "scurveCHOP_Class",
        "opFilter": "False",
        "short": "This CHOP generates S curves.",
        "long": "This CHOP generates S curves.",
        "opCategories": ""
    },
    "scanCHOP": {
        "label": "scanCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Scan CHOP converts a [[SOP]] or [[TOP]] to oscilloscope or laser friendly control waves.",
        "opType": "scan",
        "opFilter": "False",
        "opClass": "scanCHOP_Class",
        "opLabel": "Scan",
        "long": "The Scan CHOP converts a [[SOP]] or [[TOP]] to oscilloscope or laser friendly control waves.  The output is usually in the audible range and can be heard directly via an [[Audio Device Out CHOP]], or used to drive the X and Y deflector inputs of an oscilloscope, or a laser projector recreating the imagery.\nThe output can also be visualized through use of a [[Limit SOP]].\t\t\n\t\t\t\nA sample component found at: [http://www.derivative.ca/Forum/viewtopic.php?f=22&t=1201 Op to Audio CHOP example]\t\t\t\n\t\t\t\nA sample video can be found at: [http://vimeo.com/channels/touchdesigner#3750626 Total Internal Reflection]\t\t\t\n\t\t\t\nSee also: [[EtherDream CHOP]], [[EtherDream DAT]]"
    },
    "scriptCHOP": {
        "label": "scriptCHOP",
        "members": [
            {
                "text": "DAT : Specifies the DAT which holds the callbacks.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Pulse : Clicking the button runs the <code>setupParameters()</code> callback function.",
                "type": "PulsePar",
                "name": "setuppars",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Script CHOP runs a script each time the Script CHOP cooks.",
        "opType": "script",
        "opFilter": "False",
        "opClass": "scriptCHOP_Class",
        "opLabel": "Script",
        "long": "The Script CHOP runs a script each time the Script CHOP cooks. By default, the Script CHOP is created with a docked DAT that contains three Python methods: <code>cook</code>, <code>onPulse</code>, and <code>setupParameters</code>. The <code>cook</code> method is run each time the Script CHOP cooks. The <code>setupParameters</code> method is run whenever the Setup Parameter button on the Script page is pressed. The <code>onPulse</code> method is run whenever a custom pulse parameter is pushed.\t\n\t\t\nRefer to Help -> Python Examples, and Help -> [[OP Snippets|Operator Snippets]].\t\t\n\t\t\nNote: Because the Script CHOP can get data from anywhere, it's difficult to determine what it procedurally depends on. So every time that any Script OP runs it will make a list of operators, parameters, nodes etc that it depends upon, and when they change, the Script OP will re-cook.\t\n\nThe [[Script CHOP]] enables numPy arrays to be converted into the CHOP's channels.  Also any CHOP can get its channels converted into numPy arrays. (May 2021) See <code>numPyArray()</code> in [[CHOP Class]].\n\t\nSee also: [[Script DAT]], [[Script SOP]], [[Script TOP]]",
        "opCategories": ""
    },
    "selectCHOP": {
        "label": "selectCHOP",
        "members": [
            {
                "text": "CHOP : The source(s) of the channels. (Assuming the CHOP is not directly connected).",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "StrMenu : The names of the channels to keep. Name patterns may be used. Ex:\t\n\t\t\t\n  chan[1-5] *x /project1/geo1:t[xyz]\t\t\t\n\t\t\t\nThe order of the names determine the order of the output channels. If a channel is specified multiple times, it is included in the output multiple times.",
                "type": "StrMenuPar",
                "name": "channames",
                "items": []
            },
            {
                "text": "StrMenu : The channel pattern to rename. See [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "renamefrom",
                "items": []
            },
            {
                "text": "StrMenu : The replacement pattern for the names. The default parameters do not rename the channels. See [[Pattern Replacement]].\t\n\t\t\t\n'''Example:'''\t\t\t\n\t\t\t\n: Channel Names: <code>c[1-10:2] ambient</code>\t\t\t\n: Rename From: <code>c* ambient</code>\t\t\t\n: Rename To: <code>b[1-5] amb</code>\t\t\t\n\t\t\t\nThis example fetches channels <code>c1 c3 c5 c7 c9</code> and <code>ambient</code>.\t\t\t\n\t\t\t\nThey are then renamed to to <code>b1 b2 b3 b4 b5</code> and <code>amb</code>.\t\t\t\n\t\t\t\nSee the [[Rename CHOP]] for a further description of rename patterns.",
                "type": "StrMenuPar",
                "name": "renameto",
                "items": []
            },
            {
                "text": "Toggle : This toggle enables the two parameters below to select channels with the specified digits at the end of their name. For examples, this can be used to selct all channels with a name ending in the digit \"1\", such as tx1, ty1, tz1, rotate1, etc.",
                "type": "TogglePar",
                "name": "filterbydigits",
                "items": []
            },
            {
                "text": "Integer : Specify the digit at then end of the channel names you want to select when using 'Filter by Digits'",
                "type": "IntegerPar",
                "name": "digits",
                "items": []
            },
            {
                "text": "Toggle : Then On, the selected channel names are output without the digits. When Off, the selected channel names are not changed.",
                "type": "TogglePar",
                "name": "stripdigits",
                "items": []
            },
            {
                "text": "Menu : This menu handles cases where multiple input CHOPs have different start or end times. All channels output from a CHOP share the same start/end interval, so the inputs must be treated with the Align Options:",
                "type": "MenuPar",
                "name": "align",
                "items": []
            },
            {
                "text": "Toggle : When 2 channels have the same name, turning on this option will add the node's name (or the node's parent's name, etc.) as a  prefix to the channel name. For example, if selecting a channel from <code>/wave1/chan1</code> and <code>/wave2/chan1</code>, the channels would be renamed <code>chan1</code> and <code>chan2</code> if this option is off. Once turned on the channels would be named <code>wave1:chan1</code> and <code>wave2:chan1</code>.",
                "type": "TogglePar",
                "name": "autoprefix",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Select CHOP selects and renames channels from other CHOPs of any CHOP network.",
        "opType": "select",
        "opFilter": "False",
        "opClass": "selectCHOP_Class",
        "opLabel": "Select",
        "long": "The Select CHOP selects and renames channels from other CHOPs of any CHOP network. You can select the channels from control panel gadgets like sliders and buttons. It retrieves channels from one or more CHOPs.\t\t\n\t\t\t\nIt selects only the channels you specify. Example: \"<code>c2 c5 c3 c3</code>\" will result in 4 channels, the last two identical, all in the specified order.\t\t\t\n\t\t\t\nThere are two ways of getting channels - through the CHOP and Channel Name parameters or directly from a CHOP connected to its input. All extract and renaming options apply when using the CHOP and Channel Name parameters instead of the wired input. \t\t\t\n\t\t\t\nSee [[Pattern Matching]] for selecting CHOPs and channels. \t\t\t\n\t\t\t\nIt can also rename channels by generating new channel names. See [[Pattern Replacement]] and [[Pattern Expansion]] for patterns you can use. \t\t\t\n\t\t\t\nSee [[Rename_CHOP#Channel_Naming_Patterns|Channel Naming Patterns]] for more ways to manipulate existing channel names into new ones.\t\t\t\n\t\t\t\n(The Select CHOP gets channels from any CHOP, the [[Parameter CHOP]] gets parameters of any OP.)\t\t\t\n\t\t\t\nSee also the [[Rename CHOP]] (Select CHOP does most of the same things and more.)",
        "opCategories": ""
    },
    "sequencerCHOP": {
        "label": "sequencerCHOP",
        "members": [
            {
                "text": "DAT : The table of CHOPs to sequence, the table contains the paths to the CHOPs to be sequenced.",
                "type": "DATPar",
                "name": "datlist",
                "items": []
            },
            {
                "text": "Str : Specifies which channels should blend between transitions, otherwise they add or jump.",
                "type": "StrPar",
                "name": "blendscope",
                "items": []
            },
            {
                "text": "Str : Specifies which channels should add during transitions, otherwise they blend or jump.",
                "type": "StrPar",
                "name": "addscope",
                "items": []
            },
            {
                "text": "Str : Specifies the channel that controls when to queue (pause).",
                "type": "StrPar",
                "name": "queue",
                "items": []
            },
            {
                "text": "Pulse : Begin transitioning immediately, instead of waiting until the end of the current CHOP channels.",
                "type": "PulsePar",
                "name": "trigger",
                "items": []
            },
            {
                "text": "Toggle : While On, resets the sequence to the default CHOP.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly resets the sequence.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "'''NOTE''': '''The [[Timer CHOP]] replaces the Sequencer CHOP'''.",
        "opType": "sequencer",
        "opFilter": "False",
        "opClass": "sequencerCHOP_Class",
        "opLabel": "Sequencer",
        "long": "'''NOTE''': '''The [[Timer CHOP]] replaces the Sequencer CHOP'''. Sequencer CHOP has been removed (it will still work in existing files). See the [[Timer CHOP]] examples in the OP Snippets (Help -> Operator Snippets). The Timer CHOP is an engine for running timed processes. It outputs channels such as timing fractions, counters, pulses and timer states, and it calls python functions (callbacks) on various timing events.",
        "opCategories": ""
    },
    "serialCHOP": {
        "label": "serialCHOP",
        "members": [
            {
                "text": "Toggle : This check box enables the serial connection.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : The type of input transition to monitor.",
                "type": "MenuPar",
                "name": "state",
                "items": []
            },
            {
                "text": "StrMenu : Selects the COM port that the serial connection will use.",
                "type": "StrMenuPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Int : The maximum number of bits of information, including \"control\" bits, that are transmitted per second. Check your input device's default baud rate and set accordingly.",
                "type": "IntPar",
                "name": "baudrate",
                "items": []
            },
            {
                "text": "Pulse : Use this menu to select from some commonly used baud rates.",
                "type": "PulsePar",
                "name": "baudmenu",
                "items": []
            },
            {
                "text": "Menu : This parameter sets the number of data bits sent in each. Data bits are transmitted \"backwards\". Backwards refers to the order of transmission, which is from least significant bit (LSB) to most significant bit (MSB). To interpret the data bits, you must read from right to left.",
                "type": "MenuPar",
                "name": "databits",
                "items": []
            },
            {
                "text": "Menu : This parameter can be set to none, even, or odd. The optional parity bit follows the data bits and is included as a simple means of error checking. Parity bits work by specifying ahead of time whether the parity of the transmission is to be even or odd. If the parity is set to be odd, the transmitter will then set the parity bit in such a way as to make an odd number of 1's among the data bits and the parity bit.",
                "type": "MenuPar",
                "name": "parity",
                "items": []
            },
            {
                "text": "Menu : The last part of transmission packet consists of 1 or 2 Stop bits. The connection will now wait for the next Start bit.",
                "type": "MenuPar",
                "name": "stopbits",
                "items": []
            },
            {
                "text": "Str : Enter the script for Script 0 here.",
                "type": "StrPar",
                "name": "script0",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Serial CHOP is used for serial communication through an external port, using the RS-232 protocol.",
        "opType": "serial",
        "opFilter": "True",
        "opClass": "serialCHOP_Class",
        "opLabel": "Serial",
        "long": "The Serial CHOP is used for serial communication through an external port, using the RS-232 protocol. These ports are usually a 9 pin connector, or a USB port on new machines. (Using a USB port requires a USB-to-serial adaptor and driver.) All of a computer's available serial ports can be found in the Device Manager under the Windows operating system. Their names begin with 'COM'. Example: COM1, COM2, COM3, etc.\t\t\n\t\t\t\nThis CHOP monitors changes in its input channels, and sends the corresponding script through the serial connection.\t\t\t\nAny ASCII numeric digits '0'..'9' that are received, are stored and reflected in the output channel named 'return'.\t\t\t\n\t\t\t\nWhen you need to receive more complex data, other than simple ASCII numbers use the [[Serial DAT]].\t\t\t\n\t\t\t\nSee also [[Serial DAT]], [[serialDAT_Class]], [[Arduino]].",
        "opCategories": ""
    },
    "sharedmeminCHOP": {
        "label": "sharedmeminCHOP",
        "members": [
            {
                "text": "Toggle : When active, the CHOP cooks and reads from the memory block.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The name of the memory block it reads from.",
                "type": "StrPar",
                "name": "name",
                "items": []
            },
            {
                "text": "Menu : Reads from a Local or a Global memory location.",
                "type": "MenuPar",
                "name": "memtype",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Commercial",
        "opFamily": "CHOP",
        "short": "The Shared Mem In CHOP receives CHOPs from a shared memory segment that is attached to a [[Shared Mem Out CHOP]] in another process or the same process.",
        "opType": "sharedmemin",
        "opFilter": "False",
        "opClass": "sharedmeminCHOP_Class",
        "opLabel": "Shared Mem In",
        "long": "The Shared Mem In CHOP receives CHOPs from a shared memory segment that is attached to a [[Shared Mem Out CHOP]] in another process or the same process.\t\t\t\n\t\t\t\nSee [[Using Shared Memory in TouchDesigner]], [[Write a Shared Memory CHOP]] and the [[Pipe In CHOP]].",
        "opCategories": ""
    },
    "sharedmemoutCHOP": {
        "label": "sharedmemoutCHOP",
        "members": [
            {
                "text": "Toggle : When active, the CHOP cooks its inputs and writes to the memory block.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : Name of the memory block that it writes to.",
                "type": "StrPar",
                "name": "name",
                "items": []
            },
            {
                "text": "Menu : Writes to a Local or a Global memory location.",
                "type": "MenuPar",
                "name": "memtype",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Commercial",
        "opFamily": "CHOP",
        "short": "The Shared Mem Out CHOP sends CHOPs to a shared memory segment that is attached to a [[Shared Mem In CHOP]] in another process or the same process.",
        "opType": "sharedmemout",
        "opFilter": "True",
        "opClass": "sharedmemoutCHOP_Class",
        "opLabel": "Shared Mem Out",
        "long": "The Shared Mem Out TOP is only available in TouchDesigner Commercial and Pro.\t\t\n\t\t\t\nThe Shared Mem Out CHOP sends CHOPs to a shared memory segment that is attached to a [[Shared Mem In CHOP]] in another process or the same process.\t\t\t\n\t\t\t\nSee [[Using Shared Memory in TouchDesigner]], [[Write a Shared Memory CHOP]] and [[Pipe Out CHOP]].",
        "opCategories": ""
    },
    "shiftCHOP": {
        "label": "shiftCHOP",
        "members": [
            {
                "text": "Menu : The start or the end of the channels can be used as the reference position. The channels are shifted by altering the reference position.",
                "type": "MenuPar",
                "name": "reference",
                "items": []
            },
            {
                "text": "Menu : Determines how the Start and End parameters are to be interpreted:",
                "type": "MenuPar",
                "name": "relative",
                "items": []
            },
            {
                "text": "Float : The start of the interval, absolute or relative to the input CHOP.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : The end of the interval, absolute or relative to the input CHOP.",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Float : Without changing the length of the CHOP, you can scroll the channels within its range, and scroll each channel a different amount. By using $C in the parameter, you can make the scroll amount dependent on the channel index.",
                "type": "FloatPar",
                "name": "scroll",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "scrollunit",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Shift CHOP time-shifts a CHOP, changing the start and end of the CHOP's interval. However, the contents of the channels remain the same.",
        "opType": "shift",
        "opFilter": "True",
        "opClass": "shiftCHOP_Class",
        "opLabel": "Shift",
        "long": "The Shift CHOP time-shifts a CHOP, changing the start and end of the CHOP's interval. However, the contents of the channels remain the same.\t\t\n\t\t\t\nEach channel can be shifted a different amount by using the $C variable in the Scroll parameter or the Start/End parameters.\t\t\t\n\t\t\t\nAn optional second input, the Start/End Reference, is used to align the first input CHOP relative to another reference CHOP. This outputs the channels of the first CHOP only, and the shifts are based on the interval of the second CHOP. It is useful for making several CHOPs match up to the same time.",
        "opCategories": ""
    },
    "shuffleCHOP": {
        "label": "shuffleCHOP",
        "members": [
            {
                "text": "Menu : Chooses the operation \"shuffle\" performs:",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Int : The value of N for Sequence: Every Nth Channel, Sequence N Channels, Split N Samples and Split Every Nth Sample.",
                "type": "IntPar",
                "name": "nval",
                "items": []
            },
            {
                "text": "Toggle : Just use the first sample of each channel.",
                "type": "TogglePar",
                "name": "firstsample",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Shuffle CHOP reorganizes the samples in a set of channels.",
        "opType": "shuffle",
        "opFilter": "True",
        "opClass": "shuffleCHOP_Class",
        "opLabel": "Shuffle",
        "long": "The Shuffle CHOP reorganizes the samples in a set of channels.\t\t\n\t\t\t\nIt is useful for transforming data received by the [[SOP to CHOP]] and [[TOP to CHOP]]s into channels containing only one row or column. Data can be easily manipulated, then transformed back if needed.",
        "opCategories": ""
    },
    "slopeCHOP": {
        "label": "slopeCHOP",
        "members": [
            {
                "text": "Menu : The type of slope to calculate.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : The sample pairs used to calculate the slope.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Toggle : Applies the slope to each sample of the channel instead of across the whole channel. Useful for working with multi-sample channels.",
                "type": "TogglePar",
                "name": "slopesamples",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Slope CHOP calculates the slope (or \"derivative\" in math-speak) of the input channels.",
        "opType": "slope",
        "opFilter": "True",
        "opClass": "slopeCHOP_Class",
        "opLabel": "Slope",
        "long": "The Slope CHOP calculates the slope (or \"derivative\" in math-speak) of the input channels.\t\t\n\t\t\t\nIf the input CHOP represents position, the slope can be interpreted as speed. By default, the Slope CHOP converts position to speed.\t\t\t\n\t\t\t\nIn mathematical terms, the slope is the first derivative of the channel curve. The second and third derivatives can also be calculated. The second derivative can be interpreted as acceleration (and the third derivative could be interpreted as the rate of change in acceleration).\t\t\t\n\t\t\t\nThis CHOP can be used in conjunction with the [[Speed CHOP]] to manipulate speed or acceleration directly. You can calculate the speed or acceleration of a moving object with a Slope CHOP and manipulate it with other CHOPs. Then you can convert the new speed or acceleration curve back to position data with a Speed CHOP. You may need to adjust the starting position, since the Slope CHOP removes this information. This can be done with the use of the Constant parameters in the Speed CHOP.\t\t\t\n\t\t\t\nThe Units option causes the output to be expressed as a change in value per sample, value per frame, or value per second.",
        "opCategories": ""
    },
    "soptoCHOP": {
        "label": "soptoCHOP",
        "members": [
            {
                "text": "SOP : Specifies which Object / SOP contains the geometry you want to fetch.",
                "type": "SOPPar",
                "name": "sop",
                "items": []
            },
            {
                "text": "StrMenu : Only points within the specified group are Fetched. If blank, all points are fetched.",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Toggle : When On will retrieve the position attributes (P) from the SOP and create channels tx, ty, tz.",
                "type": "TogglePar",
                "name": "position",
                "items": []
            },
            {
                "text": "Toggle : When On will retrieve the RGB color attributes (Cd0, Cd1, Cd2) from the SOP and create channels cr, cg, cb.",
                "type": "TogglePar",
                "name": "colorrgb",
                "items": []
            },
            {
                "text": "Toggle : When On will retrieve the Alpha color attribute (Cd4) from the SOP and create channel alpha.",
                "type": "TogglePar",
                "name": "coloralpha",
                "items": []
            },
            {
                "text": "Toggle : When On will retrieve the Normal attributes (N) from the SOP and create channels nx, ny, nz.",
                "type": "TogglePar",
                "name": "normal",
                "items": []
            },
            {
                "text": "Toggle : When On will retrieve the UV texture attributes (uv0, uv1) from the SOP and create channels u and v.",
                "type": "TogglePar",
                "name": "textureuv",
                "items": []
            },
            {
                "text": "Toggle : When On will retrieve the W texture attribute (uv2) from the SOP and create channel w.",
                "type": "TogglePar",
                "name": "texturew",
                "items": []
            },
            {
                "text": "Toggle : Turn On to output the point index of each point in the SOP in a channel called index.",
                "type": "TogglePar",
                "name": "pointindex",
                "items": []
            },
            {
                "text": "Toggle : Turn On",
                "type": "TogglePar",
                "name": "normpos",
                "items": []
            },
            {
                "text": "Toggle : Turn On to access any attributes in the SOP including Custom Attributes by using the two parameters below.",
                "type": "TogglePar",
                "name": "custom",
                "items": []
            },
            {
                "text": "Str : This selects the custom attributes of the SOP to acquire. \n\t\t\t\nYou can use any attribute. If you look at the SOP's info by middle-mouse clicking on the SOP and there are other attributes, you can specify them. For example \"pscale\" will the particel scale attribute if it exists.\t\t\n\t\t\t\nSee [[Attribute|Attributes]] for a complete list of attributes.",
                "type": "StrPar",
                "name": "attribscope",
                "items": []
            },
            {
                "text": "Str : This parameter matches each channel acquired in the Attribute Scope. There must be one name per attribute value. By default, it translates the P attribute (position of the point) to <code>tx</code>, <code>ty</code> and <code>tz</code> channels. You can use [[Pattern Matching]] to specify multiple channels.",
                "type": "StrPar",
                "name": "renamescope",
                "items": []
            },
            {
                "text": "Object : If a transform object is specified, the point values will be represented relative to that object's origin and rotation.",
                "type": "ObjectPar",
                "name": "transobj",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The SOP to CHOP uses a [[Geometry COMP|geometry object]] to choose a [[SOP]] from which the channels will be created.",
        "opType": "sopto",
        "opFilter": "False",
        "opClass": "soptoCHOP_Class",
        "opLabel": "SOP to",
        "long": "The SOP to CHOP uses a [[Geometry COMP|geometry object]] to choose a [[SOP]] from which the channels will be created. The channels are created from the point attributes of a SOP, such as the X, Y and Z of the point position.\t\t\n\t\t\t\nFrom the SOP you can select a subset of the points using Point Groups. The set of attributes that are converted to channels are chosen using the names of the attributes seen on the Info popup of SOP tiles (middle mouse click on a SOP in a SOP network pane).\t\t\t\n\t\t\t\nFor data going the opposite direction, see the [[CHOP to SOP|Channel SOP]].\t\t\t\n\t\t\t\n'''Note:''' This CHOP works in tandem with the [[CHOP to SOP|Channel SOP]]. Point data is modified in CHOPs as regular channel data (samples) and then fed back to geometry as point attributes through the Channel SOP.",
        "opCategories": ""
    },
    "sortCHOP": {
        "label": "sortCHOP",
        "members": [
            {
                "text": "Menu : There are three different sorting methods. CHOP samples can be reordered by increasing values, decreasing values or in random order.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Float : Any number, integer or non-integer, which starts the random number generator. Each number gives completely different noise patterns, but with similar characteristics.",
                "type": "FloatPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Menu : Specify if the channels to be sorted will be specified by index or name.",
                "type": "MenuPar",
                "name": "select",
                "items": []
            },
            {
                "text": "Str : Specify the index of the channel to be sorted. All not specified channels will reorder their samples according to the specified channels new sample order. If left empty, all channels will be sorted.",
                "type": "StrPar",
                "name": "indices",
                "items": []
            },
            {
                "text": "Str : Specify the name of the channel to be sorted. All not specified channels will reorder their samples according to the specified channels new sample order. If left empty, all channels will be sorted.",
                "type": "StrPar",
                "name": "names",
                "items": []
            },
            {
                "text": "Toggle : Enable to output an index channel which holds the former samples location before sorting.",
                "type": "TogglePar",
                "name": "indexchannel",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Sort CHOP re-orders the inputs channels samples by value or by random.",
        "opType": "sort",
        "opFilter": "True",
        "opClass": "sortCHOP_Class",
        "opLabel": "Sort",
        "long": "The Sort CHOP re-orders the inputs channels samples by value or by random. Specifying a channel to be sorted will reorder all channels samples according to the new order. This node does not change the order of the channels relative to each other. To sort the channels relative to each other use a [[Reorder CHOP]].\n\t\t\t\nAdditionally an index channel can be created which holds the former sample index before sorting.",
        "opCategories": ""
    },
    "speedCHOP": {
        "label": "speedCHOP",
        "members": [
            {
                "text": "Menu : Determines the order of the integral to use. If the input is a velocity, a First Order integral will return the position. If the input is an acceleration, a Second Order integral will return the position, and a First Order integral will return the velocity.",
                "type": "MenuPar",
                "name": "order",
                "items": []
            },
            {
                "text": "Float : Constant to add to the entire result after integrating once.",
                "type": "FloatPar",
                "name": "constant1",
                "items": []
            },
            {
                "text": "Float : Constant to add to the entire result after integrating twice.",
                "type": "FloatPar",
                "name": "constant2",
                "items": []
            },
            {
                "text": "Float : Constant to add to the entire result after integrating three times.",
                "type": "FloatPar",
                "name": "constant3",
                "items": []
            },
            {
                "text": "Menu : Select limit options such as loop, clamp, or zigzag from the menu. The value will remain in the range from Min to less than Max.",
                "type": "MenuPar",
                "name": "limittype",
                "items": []
            },
            {
                "text": "Float : The minimum value the output channel can have.",
                "type": "FloatPar",
                "name": "min",
                "items": []
            },
            {
                "text": "Float : The maximum value the output channel can have.",
                "type": "FloatPar",
                "name": "max",
                "items": []
            },
            {
                "text": "Toggle : Applies the speed to each sample of the channel instead of across the whole channel. Useful for working with multi-sample channels.",
                "type": "TogglePar",
                "name": "speedsamples",
                "items": []
            },
            {
                "text": "Menu : This menu determines how the Reset input triggers a reset of the channel(s).",
                "type": "MenuPar",
                "name": "resetcondition",
                "items": []
            },
            {
                "text": "Float : The channel(s) is set to this value when reset.",
                "type": "FloatPar",
                "name": "resetvalue",
                "items": []
            },
            {
                "text": "Toggle : While On, this toggle resets the channel(s) to the <span class=\"tipTextCHOP\">Reset Value</span>.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Click to instantly resets the channel(s) to the <span class=\"tipTextCHOP\">Reset Value</span>.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "Toggle : While On, the Speed CHOP will reset each time the .toe file is restarted. If the Speed CHOP's value gets too large it can start stepping as when it reaches the limit of CHOP's number resolution. This is useful for projects that run for a long time, restarting the file will reset this value.",
                "type": "TogglePar",
                "name": "resetonstart",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Speed CHOP converts speed (units per second) to distance (units) over a time range.",
        "opType": "speed",
        "opFilter": "True",
        "opClass": "speedCHOP_Class",
        "opLabel": "Speed",
        "long": "The Speed CHOP converts speed (units per second) to distance (units) over a time range. More generally, you give it a rate (the CHOP input) and it outputs a cumulative value. For example, the Speed CHOP converts rotation rate (rotations per second) into the number of rotation turns. ( Math-heads recognize this as an 'integral', which calculates the area under a curve. The curve is the incoming channel values over a time range, the output is the area.)\t\t\n\t\t\t\nIf you send a Constant CHOP channel that has value 1 into the Speed CHOP, then the Speed CHOP output will increase by 1 every second. If you feed it -2, it will decrease by 2 every second, and if you feed it 0, the output will not change. Use a Trail CHOP to see its results. You can reset the Speed CHOP to 0 by pressing the Reset parameter, or by sending in a channel (whose value is greater than 0) into the second input.\t\t\t\n\t\t\t\nThe first input contains the channels to be 'integrated'. By default, the Speed CHOP is time-sliced, so it keeps adding/subtracting to the output each frame it cooks. If you turn off its Time Slice parameter and send it a CHOP with a fixed frame range (like a default Noise CHOP), you can see the cumulative value starting from 0.\t\t\t\n\t\t\t\nThe output is calculated by adding the input's channel values for every sample, divided by the [[CHOP#Parts_of_a_CHOP|samples per second]] of the Speed CHOP (typically 60), starting with the sample at the Start index. Negative input values reduce the output, positive values increase it. The cumulative values are put in the output channels.\t\t\t\n\t\t\t\nWhen the CHOP is reset, its output can be set to any value via the <span class=\"tipTextCHOP\">Reset Value</span> parameter.\t\t\t\n\t\t\t\nWhen the second input is used to reset the output, where the second input is greater than 0, the area is reset and held to the reset value. For example, a [[Wave CHOP]] (which is negative half the time) when passed into the second input causes the output to be reset for half a cycle.\t\t\t\n\t\t\t\nSee also: [[Lookup CHOP]], [[Timer CHOP]], [[Count CHOP]], [[Event CHOP]]",
        "opCategories": ""
    },
    "spliceCHOP": {
        "label": "spliceCHOP",
        "members": [
            {
                "text": "Toggle : When Off the output is the spliced and trimmed channels based and on the parameters below. When On the output is the opposite and contains the trimmed out portion of the channels.",
                "type": "TogglePar",
                "name": "outputtrimmed",
                "items": []
            },
            {
                "text": "Menu : Specify which direction the Start and Trim parameters below work.",
                "type": "MenuPar",
                "name": "direction",
                "items": []
            },
            {
                "text": "Float : The position the Trim and Insert operations start from. This will be from the first sample or the last sample in the channel depending on the Direction parameter above.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Gives options for how to set the trim length.",
                "type": "MenuPar",
                "name": "trimmethod",
                "items": []
            },
            {
                "text": "Float : The how long the trimmed region is. To output just the trimmed region, switch Output Trimmed Section to On.",
                "type": "FloatPar",
                "name": "trimlength",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "trimlengthunits",
                "items": []
            },
            {
                "text": "Menu : Handles how the 2nd input is spliced into the channel.",
                "type": "MenuPar",
                "name": "insertmethod",
                "items": []
            },
            {
                "text": "Float : Used to set the length of the inserted data based on the Insert Method above. When set to Trim to Insert Length, the inserted data will be trimmed when this parameter value is shorter than the 2nd input and cycled when it is longer. When set to Stretch to Insert Length, the inserted data is stretched to fit this parameter value.",
                "type": "FloatPar",
                "name": "insertlength",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "insertunits",
                "items": []
            },
            {
                "text": "Menu : Choose interpolation method for stretched insert channel.",
                "type": "MenuPar",
                "name": "insertinterp",
                "items": []
            },
            {
                "text": "Menu : Match channels between inputs by name or number.",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Menu : Choose interpolation method for any channels that are unmatched using \"Match Channels\".",
                "type": "MenuPar",
                "name": "unmatchedinterp",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opFamily": "CHOP",
        "short": "The Splice CHOP inserts CHOP channels connected to the second input into the channels of the first input.",
        "opType": "splice",
        "opFilter": "True",
        "opClass": "spliceCHOP_Class",
        "opLabel": "Splice",
        "long": "The Splice CHOP inserts CHOP channels connected to the second input into the channels of the first input. You can specify the start sample and length of where to remove samples.\t\t\n\t\t\t\nThen the inserted data from the second input can be stretched in various ways, then spliced into the trimmed point in the channels.\t\t\t\n\t\t\t\nYou can match by channel number or channel name. Un-matched channels will have the samples in their gaps interpolate in one of three selectable ways.\t\t\t\n\t\t\t\nTo extract a sample from a CHOP, modify it and replace it at its original index, connect a Splice CHOP to the original, set Start and Trim Length where you want, turn on Output Trimmed Section, modify the result, then send that as second input to another Splice CHOP with first input from the the original CHOP, and with Start set to <syntaxhighlight lang=python inline>op('splice1').par.start</syntaxhighlight> and Trim Length set to <syntaxhighlight lang=python inline>op('splice1').par.trimlength</syntaxhighlight>.\t\t\t\n\t\t\t\nThe Splice CHOP can also smooth a section of a CHOP: Set the Start and Trim Length to that section. Give it a second input with no matching channels. Set Insert Method to Set to Trim Length, and adjust the Insert Interpolate menu.\t\t\t\n\t\t\t\nCheck [[OP Snippets]] for these and other tricks.\t\t\t\n\t\t\t\nSee also [[Delete CHOP]], [[Trim CHOP]], [[Select CHOP]]",
        "opCategories": ""
    },
    "springCHOP": {
        "label": "springCHOP",
        "members": [
            {
                "text": "Float : The strength of the spring. Larger spring constants produce higher frequency oscillations.",
                "type": "FloatPar",
                "name": "springk",
                "items": []
            },
            {
                "text": "Float : The mass of the object on the end of the spring. Higher masses will produce lower frequency oscillations, have higher amplitudes, and be more resistant to damping.",
                "type": "FloatPar",
                "name": "mass",
                "items": []
            },
            {
                "text": "Float : The amount of damping (resistance) applied to the spring action. Higher damping causes oscillations to die off more quickly.",
                "type": "FloatPar",
                "name": "dampingk",
                "items": []
            },
            {
                "text": "Menu : Determines whether the input channel(s) represents a position or a force.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Toggle : If On, the initial position and velocity are calculated from the values at the beginning of the channel.",
                "type": "TogglePar",
                "name": "condfromchan",
                "items": []
            },
            {
                "text": "Float : The initial position of the mass attached to the spring.",
                "type": "FloatPar",
                "name": "initpos",
                "items": []
            },
            {
                "text": "Float : The initial velocity of the mass attached to the spring.",
                "type": "FloatPar",
                "name": "initspeed",
                "items": []
            },
            {
                "text": "Toggle : While On resets the spring effect of the CHOP.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly reset the spring effect.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Spring",
        "short": "The Spring CHOP creates vibrations influenced by the input channels, as if a mass was attached to a spring.",
        "opFilter": "True",
        "long": "The Spring CHOP creates vibrations influenced by the input channels, as if a mass was attached to a spring.\t\t\n\t\t\t\nIt acts as if, for every channel, there is a mass at the end of a spring, affected by a distance from the actual position (the output of the channel at the previous frame) to the desired position (the input channel at the current frame). When the distance (output - input) is zero, there is no force and therefore no movement.\t\t\t\n\t\t\t\nAlternately, when Input Effect is force, the input is used as a force on the spring/mass, and the CHOP reacts to this force plus the force of the spring/mass. In this case, the mass would always stabilize at value 0 if the input is a force of 0.\t\t\t\n\t\t\t\nThe damping acts to make the spring system lose energy, so that higher damping makes everything come to rest sooner.\t\t\t\n\t\t\t\nIts behavior is best understood by feeding it a chop that steps from one constant value to another in sequence, then playing with the constants.",
        "opType": "spring",
        "opClass": "springCHOP_Class",
        "opCategories": ""
    },
    "stretchCHOP": {
        "label": "stretchCHOP",
        "members": [
            {
                "text": "Menu : The interpolation method to use when resampling.",
                "type": "MenuPar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Toggle : If enabled, keeps the area under the channel constant by scaling the values of the channel.",
                "type": "TogglePar",
                "name": "constarea",
                "items": []
            },
            {
                "text": "Menu : Determines how Start/End parameters are interpreted:",
                "type": "MenuPar",
                "name": "relative",
                "items": []
            },
            {
                "text": "Float : The CHOP's new start position.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : The CHOP's new end position.",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Float : Scales the length of the channel after determining the start/end interval. Good for doubling or halving the length.",
                "type": "FloatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Toggle : Reverses the channel so that it plays backwards.",
                "type": "TogglePar",
                "name": "reverse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Stretch",
        "short": "The Stretch CHOP preserves the shape of channels and the sampling rate, but resamples the channels into a new interval.",
        "opFilter": "True",
        "long": "The Stretch CHOP preserves the shape of channels and the sampling rate, but resamples the channels into a new interval. All data in the range is stretched or compressed to the new start and end positions.\t\t\n\t\t\t\nA Reverse Interval parameter reverses the order of the samples of each channel.",
        "opType": "stretch",
        "opClass": "stretchCHOP_Class",
        "opCategories": ""
    },
    "stypeCHOP": {
        "label": "stypeCHOP",
        "members": [
            {
                "text": "Menu : The network protocol to use. Refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : When using Multicast, this is the address that Stype will listen for packets on.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port which the Stype CHOP will accept packets on. The default for the protocol is 6301, but this should be set to match the current hardware output settings.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : When the sending machine is equipped with multiple network adapters, this parameter can be used to choose which adapter to send the data from by specifying its IP address here.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Toggle : While on, the CHOP receives information sent to the network port. While Off, no updating occurs. Data sent to the port is lost.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Float : A value from 0 to 1 indicating the percentage to increase the field of view in case the given lens distortion requires samples outside of the normal render area. It is used to calculate the padded field of view and can be used to calculate the resolution of the render node.",
                "type": "FloatPar",
                "name": "padding",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The Stype CHOP reads camera tracking information sent from a [[Stype]] ('''RedSpy''') device using the Stype HF protocol. The CHOP outputs channels that can be used to control a virtual camera and implement lens distortion via the [[Stype TOP]].\t\t\n\nThe channels exported by the Stype CHOP are:\n:''connected'' - 1 or 0, indicating whether the CHOP has received valid Stype messages within the last 500ms\n:''recording'' - 1 or 0, indicating the recording status on the Stype Kit (see Stype protocol for more information)\n:''focus_distance'' - 1 or 0, indicating how the focus field is used (see Stype protocol for more information)\n:''hours, minutes, seconds, frames'' - timecode, may be zero if time information is not present\n:''tx, ty, tz'' - camera position, can be connected to the [[Camera COMP]] Translate parameters\n:''rx, ry, rz'' - camera rotation, can be connected to the [[Camera COMP]] Rotate parameters\n:''fov'' - camera field of view, can be connected to the [[Camera COMP]] FOV Angle parameter\n:''padded_fov'' - field of view expanded by the padding parameter, can be used in [[Camera COMP]] FOV Angle parameter \n:''aspect'' - aspect ratio of the camera\n:''focus'' - camera focus from 0 (closest) to 1 (infinite), can be used to simulate depth of field\n:''zoom'' - camera zoom from 0 (wide) to 1 (tele)\n:''centerx, centery'' - offset of the camera sensor in mm, used by the [[Stype TOP]] for calculating lens correction\n:''k1, k2'' - radial lens distortion parameters, used by the [[Stype TOP]] for calculating lens correction\n:''pawidth, paheight'' - size of the sensor in mm, used by the [[Stype TOP]] for calculating lens correction\n\nFor more information or to diagnose connection problems, an [[Info CHOP]] can be connected to see if any packets have been dropped or skipped.\n\n'''NOTE:''' This CHOP works with [https://www.stype.tv Stype] hardware.\t\nFor more information refer to the [[Stype]] article.\n\nSee also [[Stype TOP]].",
        "opLicense": "Pro",
        "opClass": "stypeCHOP_Class",
        "opLabel": "Stype",
        "opFamily": "CHOP",
        "opType": "stype",
        "short": "The Stype CHOP reads camera tracking information sent from a Stype device.",
        "opCategories": ""
    },
    "stypeoutCHOP": {
        "label": "stypeoutCHOP",
        "members": [
            {
                "text": "Toggle : Turn this parameter off to stop sending out data packets.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Selects the network protocol to use. Refer to the Network Protocols article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : The network address of the computer to send the Stype data to. The address can be a domain name, an IP address (e.g. 100.123.45.78), or \"localhost\" to target the packets at another program on the same machine.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port to send the data packets to.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to send from. This is useful when the system has multiple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Menu : Determine how the packet number field is generated. The packet number generally increments by 1 each frame and loops from 255 to 0.",
                "type": "MenuPar",
                "name": "packetnumber",
                "items": []
            },
            {
                "text": "Toggle : Turn this parameter off to stop sending out data packets.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Selects the network protocol to use. Refer to the Network Protocols article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : The network address of the computer to send the Stype data to. The address can be a domain name, an IP address (e.g. 100.123.45.78), or \"localhost\" to target the packets at another program on the same machine.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port to send the data packets to.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to send from. This is useful when the system has multiple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Str : Set the time with a reference to a timecode. A reference to either a CHOP with channels 'hour', 'second', 'minute', 'frame', a DAT with a timecode string in its first cell, or a [[Timecode Class]] object. When a timecode is not reference, the Stype CHOP will instead use 'hour', 'second', 'minute', 'frame' channels from the input CHOP.",
                "type": "StrPar",
                "name": "timecodeop",
                "items": []
            },
            {
                "text": "Menu : Determine how the packet number field is generated. The packet number generally increments by 1 each frame and loops from 255 to 0.",
                "type": "MenuPar",
                "name": "packetnumber",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "stypeoutCHOP",
        "opLabel": "Stype Out",
        "opClass": "stypeoutCHOP_Class",
        "opFilter": "True",
        "opLicense": "Pro",
        "opCategories": "",
        "short": "",
        "long": "The Stype Out CHOP sends camera tracking information, including position, orientation and lens information, to an external device or program over the network using the Stype HF protocol. This can be used to emulate a physical [https://www.stype.tv Stype] camera or to send data to another program/device that can process Stype tracking data. Data packets are sent out once per frame based on the current data in the CHOP channels. If one of the expected channels is not found in the input, then a default value will be sent.\n    \nThe channels used by the Stype Out CHOP are:\n:''recording'' - 1 or 0, indicating the recording status on the Stype Kit (see Stype protocol for more information)\n:''focus_distance'' - 1 or 0, indicating how the focus field is used (see Stype protocol for more information)\n:''packet_number'' - a looping number from 0-255 indicating the packet number. By default the number is incremented each frame, but can also be generated manually (see Stype protocol for more information)\n:''hours, minutes, seconds, frames'' - timecode, may be zero if time information is not present\n:''tx, ty, tz'' - camera position, can be connected to the [[Camera COMP]] Translate parameters\n:''rx, ry, rz'' - camera rotation, can be connected to the [[Camera COMP]] Rotate parameters\n:''fov'' - camera field of view, can be connected to the [[Camera COMP]] FOV Angle parameter\n:''padded_fov'' - field of view expanded by the padding parameter, can be used in [[Camera COMP]] FOV Angle parameter \n:''aspect'' - aspect ratio of the camera\n:''focus'' - camera focus from 0 (closest) to 1 (infinite), can be used to simulate depth of field\n:''zoom'' - camera zoom from 0 (wide) to 1 (tele)\n:''centerx, centery'' - offset of the camera sensor in mm, used by the [[Stype TOP]] for calculating lens correction\n:''k1, k2'' - radial lens distortion parameters, used by the [[Stype TOP]] for calculating lens correction\n:''pawidth, paheight'' - size of the sensor in mm, used by the [[Stype TOP]] for calculating lens correction"
    },
    "switchCHOP": {
        "label": "switchCHOP",
        "members": [
            {
                "text": "Toggle : If enabled, it will use the first input CHOP's first channel to determine which input to select.",
                "type": "TogglePar",
                "name": "indexfirst",
                "items": []
            },
            {
                "text": "Int : The input index to use if First Input Is Index is off.",
                "type": "IntPar",
                "name": "index",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Switch",
        "short": "The Switch CHOP allows you to control the flow of channels through a CHOPnet.",
        "opFilter": "True",
        "long": "The Switch CHOP allows you to control the flow of channels through a CHOPnet. It selects one of the input CHOPs by index and copies it exactly. This is useful for selecting one of several \"gestures\" or actions. Only one input chop can be selected at a time.\t\n\t\t\nInputs are indexed starting at 0, so that the first input is 0, the second is 1, and so on.\t\t\n\t\t\nIf the First Input Is Index parameter is enabled, the first input is used as the \"switch\" and the remaining inputs will be selection choices. In this case, the second input will be indexed as 0, the third as 1, the fourth as 2, and so on (the Switch input chop is not indexed). The index value is determined by evaluating the first channel in the first input at the current frame. Only integer indices are used; fractional indices will be rounded down to the closest integer.\t\t\n\t\t\nIf the index is less than 0, then the index will be interpreted to be 0. If the index is greater than the number of input chops, the last input chop is selected.\t\t\n\t\t\nIf you wish to blend between inputs use the [[Cross CHOP]] or the [[Blend CHOP]].",
        "opType": "switch",
        "opClass": "switchCHOP_Class",
        "opCategories": ""
    },
    "syncinCHOP": {
        "label": "syncinCHOP",
        "members": [
            {
                "text": "Toggle : Whether or not the CHOP is currently attempting to synchronize itself to a [[Sync Out CHOP]].",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : An IP address to communicate on (224.0.0.1).",
                "type": "StrPar",
                "name": "multicastaddress",
                "items": []
            },
            {
                "text": "Int : The network port associated with the address.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Int : The maximum amount of time the CHOP will wait for synchronization signals from the other Sync CHOPs. This value is expressed in milliseconds.",
                "type": "IntPar",
                "name": "timeout",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Pro",
        "opLabel": "Sync In",
        "short": "The [[Sync In CHOP]] and [[Sync Out CHOP]] are used to keep timelines in two or more TouchDesigner processes within a single frame of each other.",
        "opFilter": "False",
        "long": "The [[Sync In CHOP]] and [[Sync Out CHOP]] are used to keep timelines in two or more TouchDesigner processes within a single frame of each other. One process will contain a [[Sync Out CHOP]] while one or more other processes contain [[Sync In CHOP]]s. The processes with [[Sync In CHOP]]s should have their '''Realtime flag checked off''', as their frame rates will be determined by the [[Sync Out CHOP]].  Also note, all monitors (including all clients and server) should be set to the '''same rate'''.  Note that unplugging or re-adding monitors may sometime change previously configured settings.\n\n\nThe CHOPs synchronize by pausing their own timeline until all Sync In/Out CHOPs have cooked. The [[Sync Out CHOP]] will be ahead of the [[Sync In CHOP]]s. If any CHOPs fail to communicate, the others will timeout, causing all processes to run slowly. \n\nClient machines may come online at any point, or be switched off as desired, as the [[Sync Out CHOP]] will adjust accordingly, either timing out, temporarily or permanently banning individual clients as specified.\n\nIn addition any extra CHOP channels sent through the [[Sync Out CHOP]] is received by the [[Sync In CHOP]]s. \n\t\t\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''\n\t\t\nAn [[Info DAT]], pointing to the [[Sync Out CHOP]], provides a detailed list of all clients:\t\t\n\t\t\nThe columns are:\t\t\n* <code>pid</code>: process id of the client\t\t\n* <code>address</code>: ip and port number\t\t\n* <code>machine_name</code>: client machine name\t\t\n* <code>filename</code>: name of the <code>.toe</code> file the client resides in\t\t\n* <code>op_path</code>: full operator path to the client\t\t\n* <code>include</code>:  when 1, the Sync Out CHOPs waits for a reply, when 0, it is ignored.\t\t\n* <code>timeout_total</code>:  The total number of times the Sync Out CHOP stalled waiting for this client\t\t\n* <code>timeout_consecutive</code>:  The running number of times the Sync Out CHOP stalled waiting for this client.\t\t\n* <code>steady_total</code>: The total number of times the Sync Out CHOP received a reply in time.\t\t\n* <code>steady_consecutive</code>: The running number of times the Sync Out CHOP received a reply in time:\t\t\n* <code>reply</code>:  The last reply from the client, all clients should have the same increasing value.\t\t\n\t\t\n<br>\t\t\n\t\t\nSimilarly, an [[Info CHOP]] will reveal further information: [[#Info_CHOP_Channels|Info CHOP Channels]]\t\n\t\t\n==Intermittent Connections==\t\t\nWhenever a client replies, it is immediately assumed reliable, and waited upon, by the [[Sync Out CHOP]] each frame thereafter.\t\t\nWhen a client times-out a number of times in a row, however, it is continuously ignored by the [[Sync Out CHOP]], until it replies on time again. \t\t\nThis also applies to clients that have stopped communicating altogether.\t\t\nThe number of consecutive timeouts is controlled by the <code>Client Timeouts (consecutive)</code> parameter and is reflected by the <code>timeout_consecutive</code> [[Info DAT]] column.\t\t\n\t\t\n==Fixing Dropped frames on Client==\t        \nIf a particular client is dropping frames, inspect the Sync Out CHOP on the server side with an info DAT.  Look at the column for timeout_consecutive. As well take note of the info chop channel for the sync in CHOP called sync_incompletes.  If one or both of these attributes are increasing, try adjusting the TimeOut parameter on the sync CHOP.  Increasing this value has been known to remedy this issue.\n\n\n==Banning==\t\t\nIf a client produces unreliable communication, sometimes steady, sometimes timing out, then it can be permanently ignored by enabling <code>Ban Clients</code> and setting the <code>Total Timeouts</code> accordingly.  Once a client timeouts a certain number of times, its Info DAT <code>include</code> column reports <code>banned</code> and it will always be ignored, even if it starts responding in time again.\t\t\n\t\t\n==Resetting==\t\t\nWhenever the Sync Out CHOP first starts any and all clients are accepted, and nothing is banned.  Pressing <code>Clear Stats</code> in the [[Sync Out CHOP]] also returns to this state, clearing all banned lists, and totals, even in the remote client [[Info CHOP|Info CHOPs]].\t\t\n<br>\t\t\n<br>\t\t\nSee also [[Syncing Multiple Computers]] and [[Hardware Frame Lock]].",
        "opType": "syncin",
        "opClass": "syncinCHOP_Class",
        "opCategories": ""
    },
    "syncoutCHOP": {
        "label": "syncoutCHOP",
        "members": [
            {
                "text": "Toggle : Whether or not the CHOP is currently attempting to synchronize itself.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : An IP address to communicate on (224.0.0.1).",
                "type": "StrPar",
                "name": "multicastaddress",
                "items": []
            },
            {
                "text": "Int : The network port associated with the address.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to send from, useful when the system has mulitple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Menu : Choose between automatically or manually selecting local port to use.",
                "type": "MenuPar",
                "name": "localportmode",
                "items": []
            },
            {
                "text": "Int : When the above parameter is set to 'Manual', enter the port number to use here.",
                "type": "IntPar",
                "name": "localport",
                "items": []
            },
            {
                "text": "Int : The maximum amount of time the CHOP will wait for synchronization signals from the other Sync CHOPs. This value is expressed in milliseconds.",
                "type": "IntPar",
                "name": "timeout",
                "items": []
            },
            {
                "text": "Int : The maximum number of consecutive timeouts a client must generate until it is ignored, causing no further timeouts. It will remain ignored until it replies on time again or this CHOP is reset.",
                "type": "IntPar",
                "name": "clienttimeouts",
                "items": []
            },
            {
                "text": "Toggle : Enables permanent banning of clients.",
                "type": "TogglePar",
                "name": "banclients",
                "items": []
            },
            {
                "text": "Int : The maximum number of timeouts a client must generate until it is permanently ignored. Only a reset will allow it to be included again.",
                "type": "IntPar",
                "name": "banclienttimeouts",
                "items": []
            },
            {
                "text": "Pulse : Pressing this button will clear all banned lists, as well as totals reported in an [[Info CHOP]].",
                "type": "PulsePar",
                "name": "clearstats",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Pro",
        "opLabel": "Sync Out",
        "short": "The [[Sync In CHOP]] and [[Sync Out CHOP]] are used to keep timelines in two or more TouchDesigner processes within a single frame of each other. One process will contain a [[Sync Out CHOP]] while one or more other processes contain [[Sync In CHOP]]s.",
        "opFilter": "True",
        "long": "The [[Sync In CHOP]] and [[Sync Out CHOP]] are used to keep timelines in two or more TouchDesigner processes within a single frame of each other. One process will contain a [[Sync Out CHOP]] while one or more other processes contain [[Sync In CHOP]]s. The processes with [[Sync In CHOP]]s should have their '''Realtime flag checked off''', as their frame rates will be determined by the [[Sync Out CHOP]]. Also note, all monitors (including all clients and server) should be set to the '''same rate'''.  Note that unplugging or re-adding monitors may sometime change previously configured settings.\n\nThe CHOPs synchronize by pausing their own timeline until all Sync In/Out CHOPs have cooked. The [[Sync Out CHOP]] will be ahead of the [[Sync In CHOP]]s. If any CHOPs fail to communicate, the others will timeout, causing all processes to run slowly. \n\nClient machines may come online at any point, or be switched off as desired, as the [[Sync Out CHOP]] will adjust accordingly, either timing out, temporarily or permanently banning individual clients as specified.\n\nIn addition any extra CHOP channels sent through the [[Sync Out CHOP]] is received by the [[Sync In CHOP]]s. \n\t\t\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''\n\nAn [[Info DAT]], pointing to the [[Sync Out CHOP]], provides a detailed list of all clients:\t\t\n\n\nThe columns are:\t\t\n* <code>pid</code>: process id of the client\t\t\n* <code>address</code>: ip and port number\t\t\n* <code>machine_name</code>: client machine name\t\t\n* <code>filename</code>: name of the <code>.toe</code> file the client resides in\t\t\n* <code>op_path</code>: full operator path to the client\t\t\n* <code>include</code>:  when 1, the Sync Out CHOPs waits for a reply, when 0, it is ignored.\t\t\n* <code>timeout_total</code>:  The total number of times the Sync Out CHOP stalled waiting for this client\t\t\n* <code>timeout_consecutive</code>:  The running number of times the Sync Out CHOP stalled waiting for this client.\t\t\n* <code>steady_total</code>: The total number of times the Sync Out CHOP received a reply in time.\t\t\n* <code>steady_consecutive</code>: The running number of times the Sync Out CHOP received a reply in time:\t\t\n* <code>reply</code>:  The last reply from the client, all clients should have the same increasing value.\t\t\t\t\n<br>\nSimilarly, an [[Info CHOP]] will reveal further information: [[#Info_CHOP_Channels|Info CHOP Channels]]\t\n\n==Intermittent Connections==\t\t\nWhenever a client replies, it is immediately assumed reliable, and waited upon, by the [[Sync Out CHOP]] each frame thereafter.\t\t\nWhen a client times-out a number of times in a row, however, it is continuously ignored by the [[Sync Out CHOP]], until it replies on time again. \t\t\nThis also applies to clients that have stopped communicating altogether.\t\t\nThe number of consecutive timeouts is controlled by the <code>Client Timeouts (consecutive)</code> parameter and is reflected by the <code>timeout_consecutive</code> [[Info DAT]] column.\t\n==Banning==\t\t\nIf a client produces unreliable communication, sometimes steady, sometimes timing out, then it can be permanently ignored by enabling <code>Ban Clients</code> and setting the <code>Total Timeouts</code> accordingly. Once a client timeouts a certain number of times, its Info DAT <code>include</code> column reports <code>banned</code> and it will always be ignored, even if it starts responding in time again.\t\t\t\n==Resetting==\t\t\nWhenever the Sync Out CHOP first starts any and all clients are accepted, and nothing is banned.  Pressing <code>Clear Stats</code> in the [[Sync Out CHOP]] also returns to this state, clearing all banned lists, and totals, even in the remote client [[Info CHOP|Info CHOPs]].\t\t\n\t\nSee also [[Syncing Multiple Computers]] and [[Hardware Frame Lock]].",
        "opType": "syncout",
        "opClass": "syncoutCHOP_Class",
        "opCategories": ""
    },
    "tabletCHOP": {
        "label": "tabletCHOP",
        "members": [
            {
                "text": "Str : The channel name for the movement of the pen in the x direction.",
                "type": "StrPar",
                "name": "xcoord",
                "items": []
            },
            {
                "text": "Str : The channel name for the movement of the pen in the y direction.",
                "type": "StrPar",
                "name": "ycoord",
                "items": []
            },
            {
                "text": "Str : The channel name for the pressure reported by the pen.",
                "type": "StrPar",
                "name": "pressure",
                "items": []
            },
            {
                "text": "Str : The channel name for the tilt of the pen in the x direction.",
                "type": "StrPar",
                "name": "xtilt",
                "items": []
            },
            {
                "text": "Str : The channel name for the tilt of the pen in the y direction.",
                "type": "StrPar",
                "name": "ytilt",
                "items": []
            },
            {
                "text": "Str : The channel name for a finger rollar wheel if available.",
                "type": "StrPar",
                "name": "tanpressure",
                "items": []
            },
            {
                "text": "Str : The channel name for a thumb rollar wheel if available.",
                "type": "StrPar",
                "name": "zcoord",
                "items": []
            },
            {
                "text": "Str : The channel name for the rotation the pen is reporting.",
                "type": "StrPar",
                "name": "rotation",
                "items": []
            },
            {
                "text": "Str : The channel name for the button reported as Button 1.",
                "type": "StrPar",
                "name": "button1",
                "items": []
            },
            {
                "text": "Str : The channel name for the button reported as Button 2.",
                "type": "StrPar",
                "name": "button2",
                "items": []
            },
            {
                "text": "Str : The channel name for the button reported as Button 3.",
                "type": "StrPar",
                "name": "button3",
                "items": []
            },
            {
                "text": "Str : The channel name for the button reported as Button 4.",
                "type": "StrPar",
                "name": "button4",
                "items": []
            },
            {
                "text": "Str : The channel name for the button reported as Button 5.",
                "type": "StrPar",
                "name": "button5",
                "items": []
            },
            {
                "text": "Menu : While '''On''', the pen movement will be output from and the CHOP will cook every frame. When set to '''Off''' it will not cook and the values will not be updated. '''While Playing''' will capture pen events only when the [[Timeline]] is playing forward.",
                "type": "MenuPar",
                "name": "active",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Tablet",
        "short": "The Tablet CHOP gets the [http://www.wacom.com Wacom] tablet X and Y values, and also gets pen tip pressure, X tilt and Y tilt, and the various pen buttons.",
        "opFilter": "False",
        "long": "The Tablet CHOP gets the [http://www.wacom.com Wacom] tablet X and Y values, and also gets pen tip pressure, X tilt and Y tilt, and the various pen buttons. Two pens can be used to output one set of channels for each pen. The Tablet CHOP will initialize/install when the CHOP is created. \t\t\n\t\t\t\nIt supports the simultaneous use of two devices (Stylus Pen, Airbrush or 4D Mouse) on the same tablet, with the \"1st Pen\" folder controlling the parameters of the primary device (the first one activated), and the \"2nd Pen\" folder controlling the parameters of the other device.\t\t\t\n\t\t\t\nPut a channel name in a parameter to create that channel.\t\t\t\n\t\t\t\nThe range of all axes is -1.0 to 1.0. The values of the Button parameters are 0 for Button Up and 1 for Button Down. All axis and button channels are active when the Active state is On.\t\t\t\n\t\t\t\nIn most parameter fields of this CHOP, if you put a channel name in the parameter, it will attempt to read that parameter and output the channel. Otherwise no channel is created.\t\t\t\n\t\t\t\nFor advice on setting up the tablet and tuning the sensitivity of the pen and tablet, please read the [[Wacom_Intuos_Tablet|Wacom Intuos]] article.",
        "opType": "tablet",
        "opClass": "tabletCHOP_Class",
        "opCategories": ""
    },
    "timesliceCHOP": {
        "label": "timesliceCHOP",
        "members": [
            {
                "text": "Menu : How to sample the input CHOP to create the output time slice. If the input CHOP is not time sliced and lies outside the current time slice region, its extend regions will be sampled.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Toggle : Rotation channels blended using quaternions. Channels must be tagged as rotation channels (For example with the [[Attribute CHOP]] or [[Object CHOP]]).",
                "type": "TogglePar",
                "name": "quatrot",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Time Slice",
        "short": "The Time Slice CHOP outputs a time slice of samples.",
        "opFilter": "True",
        "long": "The Time Slice CHOP outputs a time slice of samples. It is used to generate smooth in-betweens when TouchDesigner cannot cook/draw fast enough and keep up with the animation's frames per second. When you send it to a [[Record CHOP]] or [[Gesture CHOP]], you will see the channels recorded and playing back more smoothly.\t\t\n\t\t\t\nThe number and names of channels does not change between input and output, but the output's frame range is a time slice: it goes from the previous frame that TouchDesigner cooked plus one, to the current frame.\t\t\t\n\t\t\t\nFor example, assume the TouchDesigner frames per second is four frames to remain realtime. Say the input to the Time Slice CHOP is a slider which only gets sampled when TouchDesigner draws. We will have slider values for frames 231 and 235, but there are no slider values for frames 232, 233 and 234, the current frame is 235, and the previous frame that TouchDesigner cooked and drew was frame 231. It had to skip.\t\t\t\n\t\t\t\nWhen the Method is set to Linear in this example, the Time Slice CHOP will output a \"time slice\" which is a 4-sample CHOP for frames 232 to 235, and the values at frames 232 to 234 will be the values interpolated between the slider at frames 231 and 235.\t\t\t\n\t\t\t\nTherefore any CHOPs after the Time Slice CHOP, like Gesture, Record or [[Lag CHOP]] will get smooth data going into it, even though TouchDesigner isn't cooking every frame.",
        "opType": "timeslice",
        "opClass": "timesliceCHOP_Class",
        "opCategories": ""
    },
    "timecodeCHOP": {
        "label": "timecodeCHOP",
        "members": [
            {
                "text": "Toggle : When enabled the generated timecode will follow the [https://en.wikipedia.org/wiki/SMPTE_timecode SMPTE timecode] standard, meaning no negative timecodes, and the timecode will loop at 24 hours. When disabled, the format will be more general, allowing for negative numbers and a maximum timecode of 100 hours.",
                "type": "TogglePar",
                "name": "smpte",
                "items": []
            },
            {
                "text": "Menu : The source used for generating the timecode",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Float : The timecode FPS. The timecode's max frame value is equal to <code>rate-1</code>. If a fractional rate is provided then the rate is rounded up to the nearest whole number and drop-frames will be calculated if enabled on the Drop Frame parameter.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : Specify how to calculate [https://en.wikipedia.org/wiki/SMPTE_timecode#Drop-frame_timecode drop-frames]. Drop frames are used when the FPS is fractional. FPS cannot increment a fractional amount per frame so FPS is rounded to the next whole number and the accumulation of error is accommodated for by adding drop frames.",
                "type": "MenuPar",
                "name": "dropframe",
                "items": []
            },
            {
                "text": "Float : The index used to generate the timecode. Value is used in conjunction with the specified units.",
                "type": "FloatPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Menu : The index value units.",
                "type": "MenuPar",
                "name": "indexunit",
                "items": []
            },
            {
                "text": "Str : A timecode string following the format: <code>hh:mm:ss:ff</code> or <code>hh:mm:ss.ff</code>",
                "type": "StrPar",
                "name": "timecodestr",
                "items": []
            },
            {
                "text": "Int : Frame component of the timecode.",
                "type": "IntPar",
                "name": "frame",
                "items": []
            },
            {
                "text": "Float : Second component of the timecode.",
                "type": "FloatPar",
                "name": "second",
                "items": []
            },
            {
                "text": "Float : Minute component of the timecode. Allows for overflow.",
                "type": "FloatPar",
                "name": "minute",
                "items": []
            },
            {
                "text": "Float : Hour component of the timecode.",
                "type": "FloatPar",
                "name": "hour",
                "items": []
            },
            {
                "text": "Pulse : Used in sequential mode. Initializes the timecode value.",
                "type": "PulsePar",
                "name": "init",
                "items": []
            },
            {
                "text": "Pulse : Used in sequential mode. Starts the timecode sequential increment.",
                "type": "PulsePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the sequential timecode will step forward.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Str : A [[Timecode_Class|timecode object]].",
                "type": "StrPar",
                "name": "timecodeobj",
                "items": []
            },
            {
                "text": "CHOP : A CHOP reference which contains some or all of the following channels: negative, hour, minute, second, frame.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "OP : An OP reference that contains a timecode Python member: eg. [[MoviefileinTOP_Class]].",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Toggle : When enabled, outputs the negative channel, which is true when the timecode is negative. Always false when using SMPTE standard.",
                "type": "TogglePar",
                "name": "negativechan",
                "items": []
            },
            {
                "text": "Toggle : When enabled, outputs the frame channel.",
                "type": "TogglePar",
                "name": "framechan",
                "items": []
            },
            {
                "text": "Toggle : When enabled, outputs the second channel.",
                "type": "TogglePar",
                "name": "secondchan",
                "items": []
            },
            {
                "text": "Toggle : When enabled, outputs the minute channel.",
                "type": "TogglePar",
                "name": "minutechan",
                "items": []
            },
            {
                "text": "Toggle : When enabled, outputs the hour channel.",
                "type": "TogglePar",
                "name": "hourchan",
                "items": []
            },
            {
                "text": "Toggle : When enabled, outputs the total_seconds channel, which is the timecode converted into seconds.",
                "type": "TogglePar",
                "name": "totalseconds",
                "items": []
            },
            {
                "text": "Toggle : When enabled, outputs the total_frames channel, which is the timecode into frames.",
                "type": "TogglePar",
                "name": "totalframes",
                "items": []
            },
            {
                "text": "Toggle : When enabled, outputs the drop_frame channel, which is true when the timecode is drop-frame.",
                "type": "TogglePar",
                "name": "dropframechan",
                "items": []
            },
            {
                "text": "Toggle : When enabled, outputs the fps channel.",
                "type": "TogglePar",
                "name": "fpschan",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "timecodeCHOP",
        "opLabel": "Timecode",
        "opClass": "timecodeCHOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "",
        "long": "The Timecode CHOP generates timecode data, supporting a variety of different modes for doing so: including from a timecode string, sequentially, and more. The timecode data is output as both channel data in the CHOP, and as a [[Timecode_Class|timecode object]] via its [[TimecodeCHOP_Class#timecode|timecode member]] in Python.\n    \nThe timecode can follow the SMPTE standard (ie. non-negative, loops at 24 hours), or a more general format (ie. negative timecode allowed, loops at 100 hours).\n    \nOptionally, an input with negative, hour, minute, second, or frame channels can be provided that is added to the Timecode CHOP's output.\n\nSee also: [[Timecode]], [[Timecode Class]]."
    },
    "timelineCHOP": {
        "label": "timelineCHOP",
        "members": [
            {
                "text": "OP : This node is used to specify the time referenced by the Timeline CHOP. The time is defined by the Time COMP found at <code>me.time</code>",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Toggle : Output a channel for frame number.",
                "type": "TogglePar",
                "name": "frame",
                "items": []
            },
            {
                "text": "Toggle : Output a channel for the rate (frames per second).",
                "type": "TogglePar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the Start frame value.",
                "type": "TogglePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the End frame value.",
                "type": "TogglePar",
                "name": "end",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the Range Start frame value.",
                "type": "TogglePar",
                "name": "rangestart",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the Range End frame value.",
                "type": "TogglePar",
                "name": "rangeend",
                "items": []
            },
            {
                "text": "Toggle : Output a channel for the first number in the timing signature, how many beats are in a measure.",
                "type": "TogglePar",
                "name": "signature1",
                "items": []
            },
            {
                "text": "Toggle : Output a channel for the second number in the timing signature, which kind of note constitutes one beat.",
                "type": "TogglePar",
                "name": "signature2",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the BPM value.",
                "type": "TogglePar",
                "name": "bpm",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the current play state.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "OP : This node is used to specify the time referenced by the Timeline CHOP. The time is defined by the Time COMP found at <code>me.time</code>",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the CHOP will get its time from a timecode reference, rather than the Reference Operator. The Reference Operator will still be used for bpm, time signature, start, and end values.",
                "type": "TogglePar",
                "name": "usetimecode",
                "items": []
            },
            {
                "text": "Str : Reference a timecode that sets the time. Should be a reference to either a CHOP with channels 'hour', 'second', 'minute', 'frame', a DAT with a timecode string in its first cell, or a [[Timecode Class]] object. The Reference Operator will still be used to get bpm, time signature, start, and end values.",
                "type": "StrPar",
                "name": "timecodeop",
                "items": []
            },
            {
                "text": "Toggle : Output a channel for frame number.",
                "type": "TogglePar",
                "name": "frame",
                "items": []
            },
            {
                "text": "Toggle : Output a channel for the rate (frames per second).",
                "type": "TogglePar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the Start frame value.",
                "type": "TogglePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the End frame value.",
                "type": "TogglePar",
                "name": "end",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the Range Start frame value.",
                "type": "TogglePar",
                "name": "rangestart",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the Range End frame value.",
                "type": "TogglePar",
                "name": "rangeend",
                "items": []
            },
            {
                "text": "Toggle : Output a channel for the first number in the timing signature, how many beats are in a measure.",
                "type": "TogglePar",
                "name": "signature1",
                "items": []
            },
            {
                "text": "Toggle : Output a channel for the second number in the timing signature, which kind of note constitutes one beat.",
                "type": "TogglePar",
                "name": "signature2",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the BPM value.",
                "type": "TogglePar",
                "name": "bpm",
                "items": []
            },
            {
                "text": "Toggle : Output a channel with the current play state.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Timeline",
        "short": "The Timeline CHOP outputs time-based CHOP channels for a specific component.",
        "opFilter": "False",
        "long": "The Timeline CHOP outputs time-based CHOP channels for a specific component. The time channels are defined by a [[Time COMP|Time Component]] whose [[Network Path|Path]] can be determined using the python expression <code>me.time</code>. When a '''Reference Node''' is specified, the time defined at that node is used.  When the Reference Node is not specified, then the time defined at the Timeline CHOP's location is used (ie. time defined at <code>me.time</code>).",
        "opType": "timeline",
        "opClass": "timelineCHOP_Class",
        "opCategories": ""
    },
    "timerCHOP": {
        "label": "timerCHOP",
        "members": [
            {
                "text": "Toggle : While On, the CHOP operates normally. While Off, no updating occurs.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : '''Sequential''' (timeline-independent) or '''Locked to Timeline'''. In Locked to Timeline, non-deterministic features are disabled. '''External CHOP Channel''' lets you drive the master time (<code>.masterSeconds</code> etc) using a CHOP channel defined by the parameters on the External page.",
                "type": "MenuPar",
                "name": "timecontrol",
                "items": []
            },
            {
                "text": "Pulse : (pulse parameter) Initialize is the signal to get the timer ready: sets the counters to zero (delay, timer, cycle, segment), set the output channels in the proper state, <code>done</code> to be off, the onInitialize() callback is run, and when initialize is complete, it indicates it\u2019s ready by turning on the <code>ready</code> channel, awaiting a Start pulse.",
                "type": "PulsePar",
                "name": "initialize",
                "items": []
            },
            {
                "text": "Pulse : (pulse) Start is the signal to commence the timers counting. It will count through the delay first, then the timer length. It does an Initialize if it is not already initialized, and then starts counting.",
                "type": "PulsePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Describes how the length is defined.",
                "type": "MenuPar",
                "name": "lengthtype",
                "items": []
            },
            {
                "text": "Float : (float) the time-length of the timer. Set the Units menu to Seconds, Frames or Samples.",
                "type": "FloatPar",
                "name": "length",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "lengthunits",
                "items": []
            },
            {
                "text": "Float : (float) after Start, the delay before the timer begins counting.",
                "type": "FloatPar",
                "name": "delay",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "delayunits",
                "items": []
            },
            {
                "text": "Toggle : (onoff) Pauses the timer. It is basically a 0 or 1 multiplier on the Speed.",
                "type": "TogglePar",
                "name": "play",
                "items": []
            },
            {
                "text": "Float : (default 1) Slows down or speeds up the timer.",
                "type": "FloatPar",
                "name": "speed",
                "items": []
            },
            {
                "text": "Toggle : Freezes playing at the Cue Point.",
                "type": "TogglePar",
                "name": "cue",
                "items": []
            },
            {
                "text": "Pulse : Jump instantly to the Cue Point.",
                "type": "PulsePar",
                "name": "cuepulse",
                "items": []
            },
            {
                "text": "Float : Time (Seconds, Frames or Fraction) which the cue point is frozen to.",
                "type": "FloatPar",
                "name": "cuepoint",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, Seconds, Fraction(0-1) as the units for this parameter.",
                "type": "MenuPar",
                "name": "cueunits",
                "items": []
            },
            {
                "text": "Toggle : (default Off) causes the timer to loop back to 0 when it reaches the end of the cycle.",
                "type": "TogglePar",
                "name": "cycle",
                "items": []
            },
            {
                "text": "Toggle : When the Cycle parameter is On, this determines if it will cycle indefinitely or cycle some maximum number of cycles.",
                "type": "TogglePar",
                "name": "cyclelimit",
                "items": []
            },
            {
                "text": "Int : When Cycle is on and Cycle Limit is on, this sets the maximum number of cycles.",
                "type": "IntPar",
                "name": "maxcycles",
                "items": []
            },
            {
                "text": "Float : The number of seconds, frames or samples before a cycle, segment or done state is reached that the <code>onCycleEndAlert()</code> callback is called. This allows you to prepare for the next cycle, segment or timer.",
                "type": "FloatPar",
                "name": "cycleendalert",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "notifyunits",
                "items": []
            },
            {
                "text": "Pulse : When pulsed, it will exit the cycle (and segment) at the end of the currently-playing cycle.",
                "type": "PulsePar",
                "name": "exitendcycle",
                "items": []
            },
            {
                "text": "Pulse : When pulsed, it will exit the cycle (and segment) immediately.",
                "type": "PulsePar",
                "name": "gotoendcycle",
                "items": []
            },
            {
                "text": "Pulse : Will immediately go to the Done state.",
                "type": "PulsePar",
                "name": "gotodone",
                "items": []
            },
            {
                "text": "Menu : Determines which action to take when the timer gets to the end, ie \"is done\" or finished. Note there is also a onDone callback that can be used for customizing behavior.",
                "type": "MenuPar",
                "name": "ondone",
                "items": []
            },
            {
                "text": "DAT : The path to the DAT containing callbacks for this Timer CHOP.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "DAT : A table DAT that contains one row per timer (segment). The column headings can be <code>delay</code> or <code>begin</code>, <code>length</code>, <code>cycle</code>, <code>cyclelimit</code>, <code>maxcycles</code> and <code>cycleendalert</code>, which override the equivalent parameters. (These are the internal names for the corresponding parameters.) <code>begin</code> is unique as it replaces <code>delay</code>, and it represents the time from Start that the timer will begin counting, whether the CHOP is set to Serial Timers or Parallel Timers (see Segment Method). \t\n\t\t\t\nThe Segments DAT also can include any number of custom columns. See Columns to Custom Channels and Columns to Info DAT below.",
                "type": "DATPar",
                "name": "segdat",
                "items": []
            },
            {
                "text": "Menu : If the Segment Method is '''Serial Timers''', the timers will be played back-to-back. If the Segment Method is '''Parallel Timers''', the timers can be played at the same time, and a set of channels will be output for each timer.",
                "type": "MenuPar",
                "name": "segmethod",
                "items": []
            },
            {
                "text": "Menu : For the columns <code>delay</code>, <code>begin</code>, <code>length</code> and <code>cycleendalert</code>, you specify whether it\u2019s seconds, frames or samples with this menu.",
                "type": "MenuPar",
                "name": "segunits",
                "items": []
            },
            {
                "text": "Menu : Describes how the end time is calculated.",
                "type": "MenuPar",
                "name": "segsendtime",
                "items": []
            },
            {
                "text": "Str : Optional extra columns (any name) in the segments DAT can be output as extra channels (the columns must contain numbers). Specify their names in the Columns to Channels parameter. The channel name will be the column name. You can also output the <code>length</code>, <code>delay</code>, etc columns as channels.",
                "type": "StrPar",
                "name": "channelcolumns",
                "items": []
            },
            {
                "text": "Menu : By default, custom channels step to their new value at the begin of the segment. This menu lets you interpolate to the new value linearly, or any combination of ease-in and ease-out.",
                "type": "MenuPar",
                "name": "interpolation",
                "items": []
            },
            {
                "text": "Str : Optional extra columns (any name) in the segments DAT can be output to the Info DAT (attach an Info DAT to the Timer CHOP) if you specify their names in this parameter.",
                "type": "StrPar",
                "name": "infocolumns",
                "items": []
            },
            {
                "text": "Pulse : (pulse) Jump to Previous Segment.",
                "type": "PulsePar",
                "name": "gotoprevseg",
                "items": []
            },
            {
                "text": "Pulse : (pulse) Jump to Next Segment.\t\n\t\t\t\n''Lingo''\t\t\t\n* Segment \u2013 each segment acts as one timer, with delay time, length, number of cycles to repeat and other conditions.\t\t\t\n* Begin \u2013 in Parallel Timers, the number of seconds after a Start (frames or samples) after which each timer starts counting up from zero.\t\t\t\n* Done \u2013 The state it goes into when all the timers has finished counting, whether they are in Parallel or Serial, Segments or not.\t\t\t\n* End \u2013 Cycle End is the end of each cycle, Segment End is the end of the segment.\t\t\t\n* Cumulative Time \u2013 Zero at Start, a count that is affected by speed and rises while timers are active (not during delays).\t\t\t\n* Running Time \u2013 Zero at Start, the wall-clock time since Start was called no matter what are the delays, speeds, cycles or premature clicking of Go To Segment End. It stops counting when Done has been reached.",
                "type": "PulsePar",
                "name": "gotonextseg",
                "items": []
            },
            {
                "text": "Toggle : Turn this parameter on to limit the timer output to a subrange of the full length.",
                "type": "TogglePar",
                "name": "subrange",
                "items": []
            },
            {
                "text": "Float : The beginning point of the sub range.",
                "type": "FloatPar",
                "name": "substart",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "substartunits",
                "items": []
            },
            {
                "text": "Float : The end point of the sub range.",
                "type": "FloatPar",
                "name": "subend",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "subendunits",
                "items": []
            },
            {
                "text": "Menu : Controls the behavior once the sub range end point is reached: Loop at End, or Pause at End.",
                "type": "MenuPar",
                "name": "subendaction",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>timer_fraction</code> for each segment.",
                "type": "TogglePar",
                "name": "outfraction",
                "items": []
            },
            {
                "text": "Menu : Outputs the elapsed Seconds channel as <code>timer_seconds</code>, Frames outputs channel as <code>timer_frames</code>, or Samples outputs channel as <code>timer_samples</code>. Because this is elapsed time, <code>timer_frames</code> starts at 0, as do the others.",
                "type": "MenuPar",
                "name": "outtimercount",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>timer_active</code> which is on only while the timer fraction is counting (is non-zero).",
                "type": "TogglePar",
                "name": "outtimeractive",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>timer_pulse</code> when the timer reaches its length.",
                "type": "TogglePar",
                "name": "outtimerpulse",
                "items": []
            },
            {
                "text": "Toggle : Outputs a 0-1 fraction in <code>delay_fraction</code> while the delay occurs.",
                "type": "TogglePar",
                "name": "outdelayfraction",
                "items": []
            },
            {
                "text": "Menu : Outputs the delay count in seconds, frames or samples.",
                "type": "MenuPar",
                "name": "outdelaycount",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>initializing</code> = 1 while the timer is initalizing (i.e. while the callback <code>onInitialize()</code> returns non-zero).",
                "type": "TogglePar",
                "name": "outinit",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>ready</code> which is 1 after an Initialize and before a Start.",
                "type": "TogglePar",
                "name": "outready",
                "items": []
            },
            {
                "text": "Toggle : Outputs a pulse when initialization has finished and the timer is ready to start. It pulses even when the timer starts rights away after an initialization.",
                "type": "TogglePar",
                "name": "outreadypulse",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>running</code> which is 1 after a Start and before the Done.",
                "type": "TogglePar",
                "name": "outrunning",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>done</code> when done or complete.",
                "type": "TogglePar",
                "name": "outdone",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>done</code> when the all timers have reached their completion.",
                "type": "TogglePar",
                "name": "outdonepulse",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>cycles</code>, which is the number of cycles completed (In a segment), starting with 0 during the entire first cycle. If you jump to Done, cycle is incremented as if it played normally to the done state.",
                "type": "TogglePar",
                "name": "outcycle",
                "items": []
            },
            {
                "text": "Toggle : Outputs a pulse at the end of every cycle, even on the first and only cycle.",
                "type": "TogglePar",
                "name": "outcyclepulse",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>cycle_plus_fraction</code>, starting with 0 for entire first cycle.",
                "type": "TogglePar",
                "name": "outcycleplusfraction",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>segment</code>, starting with 0 for first segment.",
                "type": "TogglePar",
                "name": "outseg",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>segment_pulse</code> which is a pulse at the end of each segment.",
                "type": "TogglePar",
                "name": "outsegpulse",
                "items": []
            },
            {
                "text": "Toggle : Outputs channel <code>segment_plus_fraction</code>, starting with 0 for first segment ending at #segments at end.",
                "type": "TogglePar",
                "name": "outsegplusfraction",
                "items": []
            },
            {
                "text": "Menu : Outputs channel <code>length</code>, starting with 0 for first segment ending at #segments at end.",
                "type": "MenuPar",
                "name": "outlength",
                "items": []
            },
            {
                "text": "Menu : Outputs <code>cumulative_seconds</code>, <code>cumulative_frames</code> or <code>cumulative_samples</code>. It is a time count that adds up all the Timer Active times for all segments since Start: it is affected by \"Speed\", and counts up only while <code>timer_active</code> (Play) is on.   See the python member <code>.cumulativeSeconds</code>.",
                "type": "MenuPar",
                "name": "outcumulativecount",
                "items": []
            },
            {
                "text": "Menu : Outputs <code>playing_seconds</code>, <code>playing_frames</code> or <code>playing_samples</code>. It is a time count that adds up all the Timer Active times for all segments since Start: it is not affected by \"Speed\", and counts up only while <code>timer_active</code> and <code>play</code> is on.  See the python member <code>.playingSeconds</code>.",
                "type": "MenuPar",
                "name": "outplayingcount",
                "items": []
            },
            {
                "text": "Menu : Outputs the \"wall-clock\" time since Start occurred, no matter what are the delays, speeds, cycles or pre-mature clicking of Go To Segment End, etc. It stops counting when Done has been reached. <code>running_seconds</code>, <code>running_frames</code>, or <code>running_samples</code>. When CHOP is set to Parallel Timers, this will output a channel per segment plus one global running time channel.   See the python member <code>.runningSeconds</code>.",
                "type": "MenuPar",
                "name": "outrunningcount",
                "items": []
            },
            {
                "text": "Menu : Outputs <code>master_seconds</code>, <code>master_frames</code> or <code>master_samples</code>. It is a time count that adds up all the Timer Active times for all segments since Start: it is affected by \"Speed\", and counts up only while <code>timer_active</code> and <code>play</code> is on. It also includes any delay times.   See the python member <code>.masterSeconds</code>.",
                "type": "MenuPar",
                "name": "outmastercount",
                "items": []
            },
            {
                "text": "CHOP : The CHOP used to control the current point in the timer.",
                "type": "CHOPPar",
                "name": "extchop",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "extunits",
                "items": []
            },
            {
                "text": "StrMenu : The channel that will control the current point of the timer.",
                "type": "StrMenuPar",
                "name": "extchannel",
                "items": []
            },
            {
                "text": "Float : The sample rate that the CHOP outputs at, which is also used when the units of Length, Delay and Cycle End Alert time are set to Samples. The default sample rate is 60 samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Timer",
        "short": "The Timer CHOP is an engine for running timed processes. It outputs channels such as timing fractions, counters, pulses and timer states, and it calls python functions (callbacks) when various timing events occur.",
        "opFilter": "False",
        "long": "The Timer CHOP is an engine for running timed processes. It outputs channels such as timing fractions, counters, pulses and timer states, and it calls python functions (callbacks) when various timing events occur.\t\t\n\t\t\t\nExamples using the Timer CHOP include triggering multiple timed cues, running playlists, timelines, state machines, and driving pre-animated animation components in 3D scenes. See Help -> Operator Snippets for numerous examples.\t\t\t\n\t\t\t\nYou set a timer to a number of seconds, frames or samples, and trigger it to start via the Start parameter or the second input CHOP. The Timer CHOP outputs in seconds, frames, samples, fraction and on-off states as it\u2019s counting, including a <code>done</code> channel that goes on when it is complete.  When it reaches certain states like end-of-cycles or when it\u2019s done, various python callbacks are called allowing you to customize its behavior.\t\t\t\n \t\t\t\nThe Timer CHOP gets triggered by events (via pulsing its parameters or driving its two inputs). It takes events in, counts time, changes state. Via its python callback functions, you can send events out to other nodes, set parameters, get/set values in DATs, CHOPs and storage, restart itself, or trigger other nodes. As such, it can operate as a state machine.\t\t\t\n\t\t\t\nIt has play/pause, plus a speed control to slow down or speed up the timer.\t\t\t\n \t\t\t\nIt can also cycle indefinitely and then can be signaled to end immediately or at the end of the current cycle.\t\t\t\n\t\t\t\nOne Timer CHOP can also have multiple timers within it. By attaching a Table DAT you can define one timer (segment) per row. In Serial Timers mode it allows for one time segment followed by another. In Parallel Timers mode, the timers all run in parallel, each with its own begin time and length, and its own set of output channels.\t\t\t\n\t\t\t\n[[image:Timer CHOP.2.png]]\t\t\t\n\t\t\t\nThe Timer CHOP can be Locked to Timeline in a deterministic way, or run more freely in Sequential Mode. When run independently from the timeline, you can jump ahead, break out of cycles, pause, <code>goTo()</code> exact position or timecode in the timer, and dynamically adjust the speed.\n\nThe Timer CHOPs can be chained together, so that when one ends, the next can begin. They just need to all be Initialized together, where the <code>ready_pulse</code> channel of one Timer CHOP is exported to the Initialize parameter of the next Timer CHOP. Then they can be run in sequence, where the output of one Timer CHOP\u2019s <code>done_pulse</code> channel is wired to the Start input (or exported to the Start parameter) of the next Timer CHOP.  You start the chain of timers by starting the first Timer CHOP. By using some Timer CHOPs to loop awaiting input or response, or by adding logic to decide which CHOP to start next, state machines can be implemented.\t\t\t\n\nAttach an Info DAT to see the timecodes, or use the <code>.timecode</code> members. Custom text strings can be placed in the Info DAT for each segment, and custom animated channels can be created.\t\t\t\n\t\t\t\nTo make the entire CHOP loop after the last segment, set the On Done menu to Re-Start.\t\n\n'''Recommended''': the '''OP Snippets for Timer CHOP'''.  See the channel descriptions in [[Initialize Start]].\t\t\n\t\t\t\n===Callbacks===\nThe callbacks are called at different moments during the timer progression.\n\n<code>onInitialize()</code> gets called when you pulse the Initialize parameter. Here you can prepare any part of your setup prior to starting. At the end of Initialize the timer goes into a \"ready\" state.\n\n<code>onStart()</code> gets called on the frame that the Start parameter is pulsed. The timer then goes into a \"running\" state.\n\n<code>onTimerActive()</code> gets called every frame that the timer is running and there is no Delay or Play is off.\n\n<code>onCycleStart()</code> gets called if the timer is set to cycle via the Cycle parameters.\n\t\t\t\nBefore a cycle or segment ends, an <code>onCycleEndAlert()</code> callback based on the Cycle End Alert parameter can be called to allow you to prepare for the next cycle, segment or Timer CHOP.\n\n<code>onSegmentEnter()</code> and <code>onSegmentExit()</code> get called if the timer is being driven by a Segments DAT which acts like several timers in one.  The argument <code>segment</code> in these callbacks is actually an object with useful members including any custom columns you have in your segment table: In <code>onSegmentEnter()</code>, put the code <code>print(help(segment))</code>\n\n<code>onDone()</code> gets called when the timer reaches its finished state.\n\nYou can initialize at a specific time by using <code>.masterSeconds</code> in <code>onInitialize()</code>.\n\t\t\t\n'''See also''': [[Trigger CHOP]], [[Event CHOP]], [[Speed CHOP]], [[Count CHOP]], [[Beat CHOP]], [[Event CHOP]], [[Clock CHOP]], [[Delay CHOP]], [[CHOP Execute DAT]], [[LFO CHOP]]. \t\ntime measurements\n{{{!}} class=\"wikitable\"\n{{!}}+ Time Measurements and what affects them\n{{!}}-\n! Name !! Speed !! Play !! Cycles !! Go To and Cueing !! Subrange !! Delay Between Segments\n{{!}}-\n{{!}} Cumulative Time Count {{!}}{{!}} slows if speed<1 {{!}}{{!}} pauses when off {{!}}{{!}} jumps back {{!}}{{!}} jumps {{!}}{{!}} jumps {{!}}{{!}} pauses\n{{!}}-\n{{!}} Playing Time Count {{!}}{{!}} unaffected {{!}}{{!}} pauses when off {{!}}{{!}} keeps counting {{!}}{{!}} keeps counting {{!}}{{!}} keeps counting {{!}}{{!}} keeps counting\n{{!}}-\n{{!}} Running Time Count {{!}}{{!}} unaffected {{!}}{{!}} unaffected {{!}}{{!}} keeps counting {{!}}{{!}} keeps counting {{!}}{{!}} keeps counting {{!}}{{!}} keeps counting\n{{!}}-\n{{!}} Master Time Count {{!}}{{!}} slows if speed<1 {{!}}{{!}} pauses when off {{!}}{{!}} jumps back {{!}}{{!}} jumps {{!}}{{!}} jumps {{!}}{{!}} keeps counting\n{{!}}-\n{{!}} Segment + Fraction {{!}}{{!}} 0 to 1 per-segment {{!}}{{!}} pauses when off {{!}}{{!}} jumps back {{!}}{{!}} jumps {{!}}{{!}} jumps {{!}}{{!}} pauses\n{{!}}}",
        "opType": "timer",
        "opClass": "timerCHOP_Class",
        "opCategories": ""
    },
    "toptoCHOP": {
        "label": "toptoCHOP",
        "members": [
            {
                "text": "TOP : Specify the TOP operator whose image will be sampled.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Menu : Gives the option for a delayed data download from the GPU, which is much faster and does not stall the render.",
                "type": "MenuPar",
                "name": "downloadtype",
                "items": []
            },
            {
                "text": "Str : The prefix for channels created from the red pixels of the source image. If multiple red channels are created, they will have a numeric suffix that matches the vertical scanline number of the image e.g. <code>r0</code> - <code>r4</code>.",
                "type": "StrPar",
                "name": "r",
                "items": []
            },
            {
                "text": "Str : The prefix for channels created from the green pixels of the source image. If multiple green channels are created, they will have a numeric suffix that matches the scanline number of the image e.g. <code>g0</code> - <code>g4</code>.",
                "type": "StrPar",
                "name": "g",
                "items": []
            },
            {
                "text": "Str : The prefix for channels created from the blue pixels of the source image. If multiple blue channels are created, they will have a numeric suffix that matches the scanline number of the image e.g. <code>b0</code> - <code>b4</code>.",
                "type": "StrPar",
                "name": "b",
                "items": []
            },
            {
                "text": "Str : The prefix for channels created from the alpha pixels of the source image. If multiple alpha channels are created, they will have a numeric suffix that matches the scanline number of the image e.g. <code>a0</code> - <code>a4</code>.",
                "type": "StrPar",
                "name": "a",
                "items": []
            },
            {
                "text": "Toggle : Controls whether a channel is created for each scanline, or whether all scanlines are appended into a single channel set. A channel set refers to one CHOP channel per color channel of the source image e.g. 4 channels for an RGBA image.",
                "type": "TogglePar",
                "name": "singleset",
                "items": []
            },
            {
                "text": "Toggle : When enabled, pixels that have a NaN value in any of their channels will be skipped and not added to the CHOP channel.",
                "type": "TogglePar",
                "name": "excludenans",
                "items": []
            },
            {
                "text": "Menu : When enabled, only pixels that have a non-zero value in the selected active channel will be added to the CHOP channel.",
                "type": "MenuPar",
                "name": "activechannel",
                "items": []
            },
            {
                "text": "Menu : Scales the output to lie in the range 0-1, 0-255 or 0-65535.",
                "type": "MenuPar",
                "name": "rgbaunit",
                "items": []
            },
            {
                "text": "Menu : Specifies what to extract from the image.",
                "type": "MenuPar",
                "name": "crop",
                "items": []
            },
            {
                "text": "Menu : Specifies the units for the following 4 parameters. The parameters can use the local variables <code>$NR</code> and <code>$NC</code> for the number of rows and columns.",
                "type": "MenuPar",
                "name": "uvunits",
                "items": []
            },
            {
                "text": "Float : Starting point for sampling in U. Values outside the range of the image are determined by the image's extend conditions, in the extend page.",
                "type": "FloatPar",
                "name": "ustart",
                "items": []
            },
            {
                "text": "Float : Ending point for sampling in U.",
                "type": "FloatPar",
                "name": "uend",
                "items": []
            },
            {
                "text": "Float : Starting point for sampling in V.",
                "type": "FloatPar",
                "name": "vstart",
                "items": []
            },
            {
                "text": "Float : Ending point for sampling in V.",
                "type": "FloatPar",
                "name": "vend",
                "items": []
            },
            {
                "text": "Menu : Determines the interpolation method when UV sampling with an input CHOP.",
                "type": "MenuPar",
                "name": "interp",
                "items": []
            },
            {
                "text": "Menu : The image extend conditions when sampling the image with U less than 0.",
                "type": "MenuPar",
                "name": "imageleft",
                "items": []
            },
            {
                "text": "Menu : The image extend conditions for U greater than 1.",
                "type": "MenuPar",
                "name": "imageright",
                "items": []
            },
            {
                "text": "Menu : The image extend conditions for V less than 0.",
                "type": "MenuPar",
                "name": "imagebottom",
                "items": []
            },
            {
                "text": "Menu : The image extend conditions for V greater than 1.\t\n\t\t\t\nThe extend conditions are:",
                "type": "MenuPar",
                "name": "imagetop",
                "items": []
            },
            {
                "text": "RGBA : The color to use when outside the bounds of the image, and the Default Color extend condition is set.",
                "type": "RGBAPar",
                "name": "defcolorr",
                "items": []
            },
            {
                "text": "RGBA : The color to use when outside the bounds of the image, and the Default Color extend condition is set.",
                "type": "RGBAPar",
                "name": "defcolorg",
                "items": []
            },
            {
                "text": "RGBA : The color to use when outside the bounds of the image, and the Default Color extend condition is set.",
                "type": "RGBAPar",
                "name": "defcolorb",
                "items": []
            },
            {
                "text": "RGBA : The color to use when outside the bounds of the image, and the Default Color extend condition is set.",
                "type": "RGBAPar",
                "name": "defcolora",
                "items": []
            },
            {
                "text": "Float : The start position of the channel, expressed in units set by the units menu to the right (samples, frames or seconds). The channel length is determined by the number of pixels in each scanline that is converted into a channel.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "TOP to",
        "short": "The TOP to CHOP converts pixels in a [[TOP]] image to [[CHOP]] channels.",
        "opFilter": "False",
        "long": "The TOP to CHOP converts pixels in a [[TOP]] image to [[CHOP]] channels. Each pixel color element (RGBA) is placed in a separate channel. Depending on the parameter options, the node will either create a single set of channels for the whole image or it can create a separate set of channels for each scanline (row).\n\t\t\t\nA single pixel, rows of pixels, columns of pixels or rectangular regions can be extracted from the image. It is therefore important to be aware of how many pixels your source image is composed of.\n\nThe Exclude NaN and Active Mask parameters can be used to skip certain pixels so they are not included in the chop channels.\n\t\t\t\nThere is an optional input which supplies UV coordinates to sample the image. The input CHOP must contain 2 channels, for U and V. The first channel is always assumed to be U. The channels produced (red, green, blue and alpha) will be exactly as long as the input channel's length, with a value for each UV coordinate.\t\t\t\n\t\t\t\nIf you are grabbing pixels from a [[Depth TOP]], you will only get a single channel (the depth). This will be placed in the R channel.",
        "opType": "topto",
        "opClass": "toptoCHOP_Class"
    },
    "touchinCHOP": {
        "label": "touchinCHOP",
        "members": [
            {
                "text": "Menu : Selects which network protocol to use to transfer data. Different protocol's have methods of connecting and using the address parameter. For more information refer to the [[Network Protocols]] article.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : The computer name or IP address of the server computer. You can use an IP address (e.g. <code>100.123.45.78</code>) or the computer's network name can be used directly. If you put \"<code>localhost</code>\", it means the other end of the pipe is on the same computer.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The network port of the server.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : While on, the CHOP receives information from the pipe or server. While off, no updating occurs. Data sent by a server is lost, but a pipe will store the data until <span class=\"tipTextCHOP\">Active</span> is turned on again. If in Network mode, turning this parameter on initiates a connection, and turning it off breaks the connection.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Float : The target queue length the CHOP will attempt to maintain.",
                "type": "FloatPar",
                "name": "queuetarget",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "queuetargetunit",
                "items": []
            },
            {
                "text": "Float : The range around the Queue Target that's acceptable. If the queue's length is within the target and variance range, the CHOP will not bother to adjust the queue length.",
                "type": "FloatPar",
                "name": "queuevariance",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "queuevarianceunit",
                "items": []
            },
            {
                "text": "Float : The maximum size of the queue when full. Incoming samples will be dropped if the maximum queue is reached.",
                "type": "FloatPar",
                "name": "maxqueue",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "maxqueueunit",
                "items": []
            },
            {
                "text": "Float : Specifies how often to repeat/drop a samples in order to get closer to the queue target range. If the value = 1 and the units = seconds, then it will try to repeat/drop a sample once per second to maintain the queue target set in the <span class=\"tipTextCHOP\">Minimum Target</span> and <span class=\"tipTextCHOP\">Maximum Target</span> parameters above.",
                "type": "FloatPar",
                "name": "adjusttime",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for this parameter.",
                "type": "MenuPar",
                "name": "adjusttimeunit",
                "items": []
            },
            {
                "text": "Toggle : If the queue size goes outside of the target size range for more than the 'adjust time', then if this option is on it will stop delivering new data or throw away a lot of data, until queue size is back in the middle of the min/max target. If this option is of the queue size will be slowly inched towards the target size instead (by dropping or repeating single frames every once in a while).",
                "type": "TogglePar",
                "name": "recover",
                "items": []
            },
            {
                "text": "Menu : This parameter lets you send the the data in a single global pipe if required. This can be important if various data streams must be sent in frame sync.",
                "type": "MenuPar",
                "name": "syncports",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Touch In",
        "short": "The Touch In CHOP can be used to create a high speed connection between two TouchDesigner processes via CHOPs.",
        "opFilter": "False",
        "long": "The Touch In CHOP can be used to create a high speed connection between two TouchDesigner processes via CHOPs.\t\t\n\t\t\t\nData is sent over TCP/IP. The Touch In CHOP (client) receives its data from a [[Touch Out CHOP]] (server). The Touch In CHOP is similar to a [[Pipe In CHOP]] but highly optimized for TouchDesigner-to-TouchDesigner communication. For interfacing with other software or devices, see the [[Pipe In CHOP]] or the [[TCP/IP DAT]].\t\t\t\n\t\t\t\nTo receive network data from another \"server\" computer (e.g. from a Touch Out CHOP running remotely), a connection must be established between the server and the Touch In CHOP before data is sent.\t\t\t\n\t\t\t\nThe data is received as time slices, and can be used to eliminate frame dropping if the sender or receiver is not running at its target frame rate. See [[Time Slicing]] and the [[Time Slice CHOP]].\t\t\t\n\t\t\t\nTo analyze the timing of the messages coming in, attach an [[Info CHOP]] to the Touch In CHOP. It will show the internal queue size and whether it is dropping or missing data (<code>queue_advanced_total</code> and <code>queue_retarded_total</code> should not be increasing, and <code>queue_length</code> should not be zero).\n\n'''NOTE for Windows OS - If experiencing connection issues, confirm Windows Firewall is disabled for TouchDesigner.'''\t\t\n\t\t\t\nSee also: [[OSC In CHOP]]",
        "opType": "touchin",
        "opClass": "touchinCHOP_Class",
        "opCategories": ""
    },
    "touchoutCHOP": {
        "label": "touchoutCHOP",
        "members": [
            {
                "text": "Menu : Selects which network protocol to use to transfer data. Different protocol's have methods of connecting and using the address parameter. For more information refer to the [[Network Protocols]] article.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : The address to use, not all protocls require an address to be specified on the sending side.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The network port to use.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : When Off, data is not sent.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Float : Limits the number of events waiting to be sent. This prevents overflows if the connection is too slow.",
                "type": "FloatPar",
                "name": "maxsize",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for the Max Queue Size parameter.",
                "type": "MenuPar",
                "name": "maxsizeunit",
                "items": []
            },
            {
                "text": "Toggle : Specifies that this CHOP should be cooked every frame regardless of CHOPs below it are cooking.",
                "type": "TogglePar",
                "name": "cookalways",
                "items": []
            },
            {
                "text": "Pulse : Resends all the channel names. Generally you don't need to use this parameter, but it is provided just in-case.",
                "type": "PulsePar",
                "name": "resendnames",
                "items": []
            },
            {
                "text": "Menu : This parameter lets you send the the data in a single global pipe if required. This can be important if various data streams must be sent in frame sync.",
                "type": "MenuPar",
                "name": "syncports",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Touch Out",
        "short": "The Touch Out CHOP can be used to create high speed connection between two TouchDesigner processes.",
        "opFilter": "True",
        "long": "The Touch Out CHOP can be used to create high speed connection between two TouchDesigner processes. Data is sent over TCP/IP. The Touch Out CHOP (server) sends it's data to a [[Touch In CHOP]] (client). The Touch Out CHOP is similar to a [[Pipe Out CHOP]] but highly optimized for TouchDesigner-to-TouchDesigner communication. For interfacing with other software or devices, see the [[Pipe Out CHOP]].\t\t\n\t\t\t\nTo receive network data from another \"server\" computer (e.g. from a TouchDesigner Touch Out CHOP running remotely), a connection must be established between the server and the Touch In CHOP before data is sent. You must supply the Server Address and Port from which to receive incoming data to a channel. The server should be listening for connections on the port that this CHOP is using. Multiple Touch In CHOPs (clients) can receive data from a single Touch Out CHOP (server).\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opType": "touchout",
        "opClass": "touchoutCHOP_Class",
        "opCategories": ""
    },
    "trailCHOP": {
        "label": "trailCHOP",
        "members": [
            {
                "text": "Toggle : When On the Trail CHOP will record its input.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : When On the length of the Trail CHOP's recording will keep getting longer as the timeline moves forward. Use this for recording any length as needed.",
                "type": "TogglePar",
                "name": "growlength",
                "items": []
            },
            {
                "text": "Float : The amount of history recorded is set by Window Length. The Units menu on the right determine which units to use in the parameter (Samples, Frames, Seconds). A setting of 4 seconds will show the value of the input channel for the previous 4 seconds.",
                "type": "FloatPar",
                "name": "wlength",
                "items": []
            },
            {
                "text": "Menu : Choose between using Samples, Frames, or Seconds as the units for the Window Length parameter.",
                "type": "MenuPar",
                "name": "wlengthunit",
                "items": []
            },
            {
                "text": "Menu : Determines when to capture values.",
                "type": "MenuPar",
                "name": "capture",
                "items": []
            },
            {
                "text": "Toggle : Enable parameter below to resample the output to a different length.",
                "type": "TogglePar",
                "name": "resample",
                "items": []
            },
            {
                "text": "Int : Resample the output to this specified length.",
                "type": "IntPar",
                "name": "samples",
                "items": []
            },
            {
                "text": "Toggle : Enable parameter below to use a different sample rate.",
                "type": "TogglePar",
                "name": "setrate",
                "items": []
            },
            {
                "text": "Float : Resample using this sample rate instead of the global frame rate (<code>$FPS</code>).",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Toggle : While On, this toggle resets the channel(s) to 0.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Click to instantly resets the channel(s) to 0.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Trail",
        "short": "The Trail CHOP displays a history of its input channels back in time.",
        "opFilter": "True",
        "long": "The Trail CHOP displays a history of its input channels back in time. A window of time is displayed from the current frame back in time, the size of this window is set by the Window Length parameter. The last sample in the Trail CHOP is a sample of the input at the current frame. <br><br>'''Note:''' If the input channels change in number or names, the Trail CHOP clears its trails and begins anew.  You can use a [[Replace CHOP]] in this case to create stand in values.<br>",
        "opType": "trail",
        "opClass": "trailCHOP_Class",
        "opCategories": ""
    },
    "transformCHOP": {
        "label": "transformCHOP",
        "members": [
            {
                "text": "Toggle : This allows the input order, if provided, to be ignored and overridden by a custom order chosen by the following two parameters.",
                "type": "TogglePar",
                "name": "custinputorders",
                "items": []
            },
            {
                "text": "Menu : Changing the Transform order will change where things go much the same way as going a block and turning east gets you to a different place than turning east and then going a block. In matrix math terms, if we use the 'multiply vector on the right' (column vector) convention, a transform order of Scale, Rotate, Translate would be written as T * R * S * Position",
                "type": "MenuPar",
                "name": "inxord",
                "items": []
            },
            {
                "text": "Menu : As with transform order (above), changing the order in which the rotations take place will alter the final position and orientation. A Rotation order of Rx Ry Rz would create the final rotation matrix as follows R = Rz * Ry * Rx",
                "type": "MenuPar",
                "name": "inrord",
                "items": []
            },
            {
                "text": "Menu : Operation(s) to apply on the transforms on Input 0, before they are combined with other transforms.",
                "type": "MenuPar",
                "name": "input0preop",
                "items": []
            },
            {
                "text": "Menu : Operation(s) to apply on the transforms on Input 1, before they are combined with other transforms.",
                "type": "MenuPar",
                "name": "input1preop",
                "items": []
            },
            {
                "text": "Menu : The operation that should be applied between transforms coming from Input 0 and Input 1. Refer to the main description of this node for an explanation of how multiple samples and/or transform sets are combined between the two inputs.",
                "type": "MenuPar",
                "name": "inputoperation",
                "items": []
            },
            {
                "text": "Menu : See description from earlier Transform Order parameter.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : See description from earlier Rotate Order parameter.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : XYZ translation values.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : XYZ translation values.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : XYZ translation values.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : XYZ rotation, in degrees.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : XYZ rotation, in degrees.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : XYZ rotation, in degrees.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : XYZ scale to shrink or enlarge the transform.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : XYZ scale to shrink or enlarge the transform.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : XYZ scale to shrink or enlarge the transform.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : XYZ pivot to apply the above operations around.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : XYZ pivot to apply the above operations around.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : XYZ pivot to apply the above operations around.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            },
            {
                "text": "Menu : Operation(s) to apply on the transforms generated by the above parameters, before it is combined with other transforms.",
                "type": "MenuPar",
                "name": "preop",
                "items": []
            },
            {
                "text": "Menu : Controls how the input transform(s) are combined with the transform specified on this page. The below two descriptions use a multiply \"vector on the right\" convention (column vectors).",
                "type": "MenuPar",
                "name": "multiplyorder",
                "items": []
            },
            {
                "text": "Menu : Optionally applied one last operation to the final generated transform before it is output.",
                "type": "MenuPar",
                "name": "postop",
                "items": []
            },
            {
                "text": "Menu : Specify the format the transform will be output in.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Toggle : When outputting a matrix, it's determinant can also be output by enabling this parameter.",
                "type": "TogglePar",
                "name": "determ",
                "items": []
            },
            {
                "text": "Menu : Controls how channels that don't match the naming convention for the various transform format are treated.",
                "type": "MenuPar",
                "name": "unmatchedchans",
                "items": []
            },
            {
                "text": "Toggle : By default the output transforms will use the orders given on teh Transform page. Enabling this allows for custom orders to be used for the transform that is output. This doesn't change the transform itself, but the values of the channels will likely change since they are combined in a different order to obtain the same overall transform.",
                "type": "TogglePar",
                "name": "custoutputorders",
                "items": []
            },
            {
                "text": "Menu : See description from earlier Transform Order parameter.",
                "type": "MenuPar",
                "name": "outxord",
                "items": []
            },
            {
                "text": "Menu : See description from earlier Rotate Order parameter.",
                "type": "MenuPar",
                "name": "outrord",
                "items": []
            },
            {
                "text": "Toggle : Specified if the 'xord' and 'rord' channels should be output from this node. 'xord' will be output for 'Transform (Euler)' and 'Transform (Quaternion)' modes. 'rord' will be output for the 'Transform (Euler)' mode. The matrix and position modes do not include orders.",
                "type": "TogglePar",
                "name": "includeorderchans",
                "items": []
            },
            {
                "text": "Toggle : In the case the input has multiple samples, this will attempt to keep rotations of neighbouring samples continuous. Basically, it tries to avoid 360 degree jumps. 360-> 361 instead of 360 -> 1 (which is the same two rotations.",
                "type": "TogglePar",
                "name": "continuousrotations",
                "items": []
            },
            {
                "text": "Toggle : An initial rotation hint given in r[xyz] degrees to try to stay continuous against. Turning this on and using the <span class=\"tipTextCHOP\">Hint</span> parameter below allows you to specify approximate starting values for the rotation channels produced. This allows you to change the rotation channel solution to a specific starting point (e.g. for camera output control).",
                "type": "TogglePar",
                "name": "usehint",
                "items": []
            },
            {
                "text": "XYZ : Specify approximate starting values for the rotation channels produced.",
                "type": "XYZPar",
                "name": "hintx",
                "items": []
            },
            {
                "text": "XYZ : Specify approximate starting values for the rotation channels produced.",
                "type": "XYZPar",
                "name": "hinty",
                "items": []
            },
            {
                "text": "XYZ : Specify approximate starting values for the rotation channels produced.",
                "type": "XYZPar",
                "name": "hintz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Transform",
        "short": "The Transform CHOP takes transformations in various formats, applied operations to them, and outputs them in various formats.",
        "opFilter": "True",
        "long": "The Transform CHOP takes transformations in various formats, applied operations to them, and outputs them in various formats. It can be used to:\t\t\n\t\t\t\n* Change the position and orientation of an object.\t\t\t\n* Convertion transforms one format to another format.\n* Convert a set of transform channels with a certain transform order into an equivalent set of channels with a different transform order.\t\n* Change the direction, starting point and scale of motion capture data or other data being calibrated to match other reference frames.\t\t\t\n\t\n( See also the [[Transform XYZ CHOP]] for fdoing transforms on XYZ positions and vectors. )\n\nThree transform formats exists:\n* Transform with Euler angles for rotation. These are defined by channels with suffixes: <code>tx ty tz, rx ry rz, sx sy sz</code> and an optional transform and rotate order <code>xord and rord</code>.\n* Transform with Quaternion for rotation. These are defined by channels with suffixes: <code>tx ty tz, qx qy qx qw, sx sy sz</code> and an optional transform order <code>xord</code>.\n* A 4x4 or 3x3 matrix. These are defined by channels with suffixes: <code>m00, m10, m20, m30, m01, m11... m33</code>. Where the notation is <code>m[''row''][''col'']</code>. The matrix should be be in column-major order, that is to say, the translate portion should be in <code>m03, m13, m23</code>. The 4th row and column can be omitted to use a 3x3 matrix instead. Unlike the other formats, this format can not have arbitrary missing channels. Either 9 channels for 3x3 or 16 channels for 4x4 matrices must be provided.\n\nThe first two transform formats can be specified with missing channels, in which case default values will be used. 0s for translates and rotates, 1s for scale, and (0,0,0,1) for quaternion.\n\nFrequently the input channels come from an [[Object CHOP]] or [[Parameter CHOP]]. Examples are: \t\t\t\n\t\t\t\n* geo1:tx geo1:ty geo1:tz geo1:rx ...\t\t\t\n* headtx headty headtz headrx\t\t\t\n* tx ty tz rx ... (what you would get from a Parameter CHOP)\n* cam1:m00 cam1:m10 cam1:m20 .... cam1:m33\n\t\t\t\n===Multiple Transform Sets===\nAny of the above defines a transformation matrix. Multiple transform 'sets' can be specified by channels having different prefixes. Different sets using different formats can be all in the same CHOP. Formats can not be mixed within a set though. Each set will be combined with sets from the other input, and the transform on the 'Transform' page to create final transforms for each set.\n\nIf no inputs are connected to the CHOP, it will output the transform generated from the 'Transform' page.\n\nIf inputs are connected, the output will contain the same number of samples as the first input. Samples will be combined between the inputs 1:1, that is, the start/end range and the sample rate of the inputs are ignored. If the second input contains less samples than the first one, the extend conditions for that CHOP will be used to determine values for the samples coming from the 2nd CHOP that are out of range.\n\nIf multiple sets are provided, they will be matched 1st-to-1st set, 2nd-to-2nd set. If there are less sets in the second input than the first one, then it will loop over the sets. E.g if the first input as 5 sets and the second input as 2 sets, the matching will be 1st-to-1st, 2nd-to-2nd, 3rd-to-1st, 4th-to-2nd and 5th-to-1st.\n\n===Order of Operation===\nThe inputs will be combined together first, then the result from that will be combined with the transform defined on the 'Transform' page.\n\nThe channels of a Transform CHOP are frequently exported back to objects.",
        "opType": "transform",
        "opClass": "transformCHOP_Class",
        "opCategories": ""
    },
    "transformxyzCHOP": {
        "label": "transformxyzCHOP",
        "members": [
            {
                "text": "Menu : Choose if the input 0 values should be treated as a position or a vectors. Vectors will not have the translation portion of the transform applied to them, and can be normalized before and/or after the transformation is applied.",
                "type": "MenuPar",
                "name": "input0type",
                "items": []
            },
            {
                "text": "Toggle : If the input is vectors, they can be normalized before the transformation is applied.",
                "type": "TogglePar",
                "name": "innormalize",
                "items": []
            },
            {
                "text": "Toggle : This allows the input order for input 1, if provided, to be ignored and overridden by a custom order chosen by the following two parameters.",
                "type": "TogglePar",
                "name": "custinputorder",
                "items": []
            },
            {
                "text": "Menu : Changing the Transform order will change where things go much the same way as going a block and turning east gets you to a different place than turning east and then going a block. In matrix math terms, if we use the 'multiply vector on the right' (column vector) convention, a transform order of Scale, Rotate, Translate would be written as T * R * S * Position",
                "type": "MenuPar",
                "name": "inxord",
                "items": []
            },
            {
                "text": "Menu : As with transform order (above), changing the order in which the rotations take place will alter the final position and orientation. A Rotation order of Rx Ry Rz would create the final rotation matrix as follows R = Rz * Ry * Rx",
                "type": "MenuPar",
                "name": "inrord",
                "items": []
            },
            {
                "text": "Menu : Operation(s) to apply on the transforms on Input 1, before they are combined with other transforms.",
                "type": "MenuPar",
                "name": "input1preop",
                "items": []
            },
            {
                "text": "Menu : See description from earlier Transform Order parameter.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : See description from earlier Rotate Order parameter.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : XYZ translation values.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : XYZ translation values.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : XYZ translation values.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : XYZ rotation, in degrees.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : XYZ rotation, in degrees.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : XYZ rotation, in degrees.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : XYZ scale to shrink or enlarge the transform.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : XYZ scale to shrink or enlarge the transform.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : XYZ scale to shrink or enlarge the transform.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : XYZ pivot to apply the above operations around.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : XYZ pivot to apply the above operations around.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : XYZ pivot to apply the above operations around.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            },
            {
                "text": "Toggle : Turn this on to invert the transform generated by this page before combining it with the other terms.",
                "type": "TogglePar",
                "name": "preop",
                "items": []
            },
            {
                "text": "Menu : Controls how the input transform(s) are combined with the transform specified on this page. The below two descriptions use a multiply \"vector on the right\" convention (column vectors).",
                "type": "MenuPar",
                "name": "multiplyorder",
                "items": []
            },
            {
                "text": "Menu : Controls how channels that don't match the naming convention for the various transform format are treated.",
                "type": "MenuPar",
                "name": "unmatchedchans",
                "items": []
            },
            {
                "text": "Toggle : If the input data is being treated as vectors, they can be re-normalized after the transform by turning this on.",
                "type": "TogglePar",
                "name": "normalize",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "transformxyzCHOP",
        "opLabel": "Transform XYZ",
        "opClass": "transformxyzCHOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "Transforms positions and vectors.",
        "long": "The Transform XYZ CHOP is used to transform positions and vector. The difference between transforming a position vs. a vector is that a vector won't have the translation portion of the transformation applied to it.<br><br>The Transform XYZ CHOP first groups the channels from the first input by looking for '<code>x</code>', '<code>y</code>' and '<code>z</code>' as the last character in the channel names. Then it treats each of the sets created as either a Position or a Vector depending on the parameter choice. The second input can be connected, and must describe a transform in the same format of channels that the [[Transform CHOP]] supports. The second input is combined with the 'Transform' page parameters, and the resulting transform is applied to the input positions and vectors.<br><br>CHOPs with multiple-samples can be provided, which allows for larger amount of positional data to be transformed in a single CHOP.\n    \nSee also the [[Transform CHOP]].",
        "opCategories": ""
    },
    "triggerCHOP": {
        "label": "triggerCHOP",
        "members": [
            {
                "text": "Toggle : If on, the trigger and release thresholds are the same value.",
                "type": "TogglePar",
                "name": "threshold",
                "items": []
            },
            {
                "text": "Float : The trigger threshold (see above).",
                "type": "FloatPar",
                "name": "threshup",
                "items": []
            },
            {
                "text": "Float : The release threshold (see above).",
                "type": "FloatPar",
                "name": "threshdown",
                "items": []
            },
            {
                "text": "Float : The amount of time after a trigger point that a new trigger may occur.",
                "type": "FloatPar",
                "name": "retrigger",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "retriggerunit",
                "items": []
            },
            {
                "text": "Float : The minimum amount of time that the trigger will remain active.",
                "type": "FloatPar",
                "name": "mintrigger",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "mintriggerunit",
                "items": []
            },
            {
                "text": "Menu : Determines whether a trigger occurs on an increasing slope or decreasing slope when passing the trigger threshold. A release will occur on the opposite slope.",
                "type": "MenuPar",
                "name": "triggeron",
                "items": []
            },
            {
                "text": "Pulse : Instantly trigger an envelope (regardless of input).",
                "type": "PulsePar",
                "name": "triggerpulse",
                "items": []
            },
            {
                "text": "Float : The amount of time to delay the envelope after the trigger point.",
                "type": "FloatPar",
                "name": "delay",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "delayunit",
                "items": []
            },
            {
                "text": "Float : The amount of rise time from zero to the peak level.",
                "type": "FloatPar",
                "name": "attack",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "attackunit",
                "items": []
            },
            {
                "text": "Menu : The shape of the attack ramp.",
                "type": "MenuPar",
                "name": "ashape",
                "items": []
            },
            {
                "text": "Float : The peak level it will rise to in the attack phase.",
                "type": "FloatPar",
                "name": "peak",
                "items": []
            },
            {
                "text": "Float : The length of time of the peak is held before going into the decay phase.",
                "type": "FloatPar",
                "name": "peaklen",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "peaklenunit",
                "items": []
            },
            {
                "text": "Float : The amount of decay time from the peak level to the sustain level.",
                "type": "FloatPar",
                "name": "decay",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "decayunit",
                "items": []
            },
            {
                "text": "Menu : The shape of the decay ramp.",
                "type": "MenuPar",
                "name": "dshape",
                "items": []
            },
            {
                "text": "Float : The sustain level. This level is held until a release point is reached (the input goes below the threshold).",
                "type": "FloatPar",
                "name": "sustain",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "minsustain",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "minsustainunit",
                "items": []
            },
            {
                "text": "Float : The amount of release time from the sustain level to zero.",
                "type": "FloatPar",
                "name": "release",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "releaseunit",
                "items": []
            },
            {
                "text": "Menu : The shape of the release ramp.",
                "type": "MenuPar",
                "name": "rshape",
                "items": []
            },
            {
                "text": "Str : Name of channels output.",
                "type": "StrPar",
                "name": "channame",
                "items": []
            },
            {
                "text": "Toggle : Allows you to specify the sample rate in the <span class=\"tipTextCHOP\">Sample Rate</span> parameter below.",
                "type": "TogglePar",
                "name": "specifyrate",
                "items": []
            },
            {
                "text": "Float : Sets the sample rate of the output. Only used when <span class=\"tipTextCHOP\">Specify Rate</span> is turned on.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Toggle : If on, a complete envelope is produced for each trigger point. If off, the envelope may be terminated at any time by a release point.",
                "type": "TogglePar",
                "name": "complete",
                "items": []
            },
            {
                "text": "Menu : See Remainder Options. What to do with remaining samples at end of the interval:",
                "type": "MenuPar",
                "name": "remainder",
                "items": []
            },
            {
                "text": "Toggle : When triggering mulitple envelopes, add their values together.",
                "type": "TogglePar",
                "name": "multitriggeradd",
                "items": []
            },
            {
                "text": "Toggle : Clamp the additive effect of Multi-Triggers Additive at the level set in Peak Level parameter.",
                "type": "TogglePar",
                "name": "clamppeak",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Trigger",
        "short": "The Trigger CHOP starts an audio-style attack/decay/sustain/release (ADSR) envelope to all trigger pulses in the input channels.",
        "opFilter": "True",
        "long": "The Trigger CHOP starts an audio-style attack/decay/sustain/release (ADSR) envelope to all trigger pulses in the input channels. A trigger point occurs whenever the first input's channel increases across the trigger threshold value. Most commonly, an ADSR starts when the input goes from 0 to 1.\t\t\n\t\t\t\nThe envelope consists of six major sections: delay, attack, peak, decay, sustain and release.\t\t\t\n\t\t\t\nFrom the time the threshold is reached and while the channel's value is above the release threshold, the envelope is in its sustain phase during which it will delay, attack, peak-hold, decay and then maintain its sustain value.\t\t\t\n\t\t\t\nAfter the inputs drops below the release threshold, the envelope start its release phase and will drop to 0.\t\t\t\n\t\t\t\nThe peak and sustain levels can be set independently, but peak value can never be less than sustain.\t\t\t\n\t\t\t\nIf you don't connect an input to the Trigger CHOP and you set it to Time Slice off, a single full envelope is generated. \t\t\t\n\t\t\t\nThis CHOP works with both time-sliced inputs or with static input channels.\n\nFor jittery inputs, if you don't want it to trigger until its input has been On for some period, see the [[OP Snippets]] for the Trigger CHOP, example \"trigger after a time threshold\", which uses the Count CHOP.\n\t\t\t\n'''Note''': See examples in OP Snippets.\t\t\t\n\t\t\t\nSee also: [[Timer CHOP]], [[Count CHOP]], [[Speed CHOP]], [[Event CHOP]]",
        "opType": "trigger",
        "opClass": "triggerCHOP_Class",
        "opCategories": ""
    },
    "trimCHOP": {
        "label": "trimCHOP",
        "members": [
            {
                "text": "Menu : Determines whether the Start/End parameters are expressed as absolute numbers (relative to time 0) or numbers that are relative to the start and end of the input channels.",
                "type": "MenuPar",
                "name": "relative",
                "items": []
            },
            {
                "text": "Float : The start of the range to trim. The numbers are expressed in seconds, frames or samples, depending on units menu for each parameter.",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : The end of the range to trim. The numbers are expressed in seconds, frames or samples, depending on units menu for each parameter.",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Menu : Which part of the channel to discard:",
                "type": "MenuPar",
                "name": "discard",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Trim",
        "short": "The Trim CHOP shortens or lengthens the input's channels.",
        "opFilter": "True",
        "long": "The Trim CHOP shortens or lengthens the input's channels. A part of the interval can be preserved or removed. If the channels are being lengthened, the extend conditions of the channel will be used to get the new values.\t\t\n\t\t\t\nThe Trim CHOP is sometimes used to get a 1-sample value at the current frame, where the inputs are channels at frame 0 or channels at some other frame range.\t\t\t\n\t\t\t\nThe handles on the Trim CHOP in the graph can interactively adjust its length.\t\t\t\n\t\t\t\nSee also [[Splice CHOP]], [[Delete CHOP]], [[Select CHOP]]",
        "opType": "trim",
        "opClass": "trimCHOP_Class",
        "opCategories": ""
    },
    "warpCHOP": {
        "label": "warpCHOP",
        "members": [
            {
                "text": "Menu : The warping method to use: <span class=\"tipTextCHOP\">Rate</span> or <span class=\"tipTextCHOP\">Index Control</span>.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Toggle : If on, the minimum and maximum values in the Warp Curve are mapped to the beginning and end of the channels to be warped. Otherwise, the Warp Curve is applied as-is to the Pre-Warp Channels.\t\n\t\t\t\nThe Warp CHOP does linear interpolation of the Pre-Warped Channels when they are both stretched and compressed.",
                "type": "TogglePar",
                "name": "scaleindex",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Warp",
        "short": "The Warp CHOP time-warps the channels of the first input (the Pre-Warp Channels) using one warping channel in the second input (the Warp Curve).",
        "opFilter": "True",
        "long": "The Warp CHOP time-warps the channels of the first input (the Pre-Warp Channels) using one warping channel in the second input (the Warp Curve). The Warp Curve acts as either a rate control or an index control, as explained below. The Warp CHOP usually works on non-time-sliced channels, like pre-key-framed channels of motion. See also the [[Lookup CHOP]], the [[Speed CHOP]] and the [[Audio Oscillator CHOP]].\t\t\n\t\t\t\nIn the Rate Control Method, feeding the Warp CHOP a Warp Curve with a constant value of 1 makes the output identical to the Pre-Warp Channels, assuming the two inputs have the same start-end interval. That is, where the rate is 1, the Pre-Warp Channels are not warped.\t\t\t\n\t\t\t\nWhere the Warp Curve is above 1, it causes a speed-up in the animation. Where the Warp Curve is below 1, it causes a slow-down in the animation. Rates less than 0 cause the animation to go in reverse.\t\t\t\n\t\t\t\nIn the Index Control Method, the Warp Curve acts as an index into the first input. If the Warp Curve is a straight ramp with a slope of 1 (in Units), it produces unwarped output channels. If Units is set to Seconds, a Warp Curve value of 0 gets the Pre-Warp Channels' values at time 0 seconds. A Warp Curve value of 2 gets the Pre-Warp Channels' values at time 2 seconds.\t\t\t\n\t\t\t\nThe Warp CHOP will output the same number of channels and channel names as the Pre-Warp Channels input, and the sample rate will be the same as that of the Pre-Warp input. However, the CHOP will output the same start-end time interval as the Warp Curve input.\t\t\t\n\t\t\t\nIf you take a Warp Curve and pass it directly to a Warp CHOP with the Rate Control Method, it is equivalent to passing the same curve to an Speed CHOP and then passing it to the Warp CHOP with the Index Control Method.",
        "opType": "warp",
        "opClass": "warpCHOP_Class",
        "opCategories": ""
    },
    "waveCHOP": {
        "label": "waveCHOP",
        "members": [
            {
                "text": "Menu : There is a choice of waveforms shapes:",
                "type": "MenuPar",
                "name": "wavetype",
                "items": []
            },
            {
                "text": "Float : The period is the number of seconds, frames or samples that the waveform repeats in. It is expressed in the chop's Units (default is Seconds), found on the Common page.",
                "type": "FloatPar",
                "name": "period",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "periodunit",
                "items": []
            },
            {
                "text": "Float : The phase shifts the waveform in time, and is expressed as a fraction of a period, usually between 0 and 1.",
                "type": "FloatPar",
                "name": "phase",
                "items": []
            },
            {
                "text": "Float : You can vary the shape of some of the waveform types by changing the bias within the range -1 to +1.",
                "type": "FloatPar",
                "name": "bias",
                "items": []
            },
            {
                "text": "Float : The waveform's value can be offset. A sine wave can remain always positive by setting Offset to 1.",
                "type": "FloatPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Float : The wave's value can be scaled.",
                "type": "FloatPar",
                "name": "amp",
                "items": []
            },
            {
                "text": "Float : The wave's amplitude can be reduced over time with an \"exponential decay\". For example, if the Decay is 0.2 and the Units are seconds, then the amplitude will decay to 0.8 after 1 second, and 0.8 of 0.8 (or 0.64) after 2 seconds.",
                "type": "FloatPar",
                "name": "decay",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "decayunit",
                "items": []
            },
            {
                "text": "Float : Then a ramp is added to the result with a slope of Ramp. The channel increases by the Ramp Slope value every Unit of time. For example, if Ramp is 1.2, the channel increases by 1.2 every second, in addition to the shape of the wave.",
                "type": "FloatPar",
                "name": "ramp",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "rampunit",
                "items": []
            },
            {
                "text": "Float : If the waveform type is Expression, the Expression parameter is used to input a math expression. Some local variables are available: $I (Index), $L (the loop variable over the period 0 to 1), $C (the cycle variable, the integer number of cycles the waveform has passed at the current index).",
                "type": "FloatPar",
                "name": "exprs",
                "items": []
            },
            {
                "text": "Str : You can creates many channels with simple patterns like \"<code>chan[1-20]</code>\", which generates 20 channels from chan1 to chan20. See the section, Common CHOP Parameters for a description of this and all Options.  See [[CHOP Common Page#Scope|Scope and Channel Name Matching]] Options.",
                "type": "StrPar",
                "name": "channelname",
                "items": []
            },
            {
                "text": "Float : Start of the interval, expressed in Units (seconds, frames or samples).",
                "type": "FloatPar",
                "name": "start",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "startunit",
                "items": []
            },
            {
                "text": "Float : End of the interval, expressed in Units (seconds, frames or samples).",
                "type": "FloatPar",
                "name": "end",
                "items": []
            },
            {
                "text": "Menu : Select the units to use for this parameter, Samples, Frames, or Seconds.",
                "type": "MenuPar",
                "name": "endunit",
                "items": []
            },
            {
                "text": "Float : The sample rate of the channels, in samples per second.",
                "type": "FloatPar",
                "name": "rate",
                "items": []
            },
            {
                "text": "Menu : The left extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "left",
                "items": []
            },
            {
                "text": "Menu : The right extend conditions (before/after range).",
                "type": "MenuPar",
                "name": "right",
                "items": []
            },
            {
                "text": "Float : The value used for the Default Value extend condition.",
                "type": "FloatPar",
                "name": "defval",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opLicense": "Non-Commercial",
        "opLabel": "Wave",
        "short": "The Wave CHOP makes repeating waves with a variety of shapes.",
        "opFilter": "False",
        "long": "The Wave CHOP makes repeating waves with a variety of shapes. It is by default 10-seconds of 1-second sine waves, a total of 600 frames. You can adjust period (frequency), phase, shape, amplitude and offset.\t\t\n\t\t\t\nThe Wave CHOP gives a set of waves in channels of a specifiable time-range. It is superceded by the [[LFO CHOP]] which gives an endless stream of waves that is [[Time Slice]]d, and the [[Pattern CHOP]] that has more control over shaping waveform samples (and is time-independent). The [[Audio Oscillator CHOP]] also creates waveforms that are continually repeated, but its defaults are for higher-frequency waves at higher (audio) sample rates. \t\t\t\n\t\t\t\nBecause the Extend Conditions of the Wave CHOP are set to Repeat, the wave will repeat outside the 10-second range.\t\t\t\n\t\t\t\nApplied to the actual waveform can be an offset, decay and ramp.\n\t\t\t\nMultiple channels can be generated in the Channel Name parameter using [[Pattern Expansion]]. A few examples of name pattern name expansion:\t\t\t\n\t\t\t\n* <code>tx ty tz</code>\t\t\t\n* <code>t[xyz]</code> - expands to <code>tx ty tz</code>\t\t\t\n* <code>chan[1-4]</code> - expands to <code>chan1 chan2 chan3 chan4</code>\t\t\t\n* <code>c[xyz][1-5:2]</code> - expands to <code>cx1 cx3 cx5 cy1 cy3 cy5 cz1 cz3 cz5</code>\t\t\t\n\t\t\t\nSee also: [[LFO CHOP]], [[Pattern CHOP]], [[Audio Oscillator CHOP]].",
        "opType": "wave",
        "opClass": "waveCHOP_Class",
        "opCategories": ""
    },
    "wrnchaiCHOP": {
        "label": "wrnchaiCHOP",
        "members": [
            {
                "text": "Str : Add the Edge License Key from your wrnchAI account here. Requires a separate license from [https://wrnch.ai/ wrnchAI].",
                "type": "StrPar",
                "name": "license",
                "items": []
            },
            {
                "text": "Folder : Specify the path the the folder that contains the trained models. See Quickstart Guide above for details.",
                "type": "FolderPar",
                "name": "modelfolder",
                "items": []
            },
            {
                "text": "Menu : A menu of available GPU(s) to run wrnchAI on. Selecting 'Default' uses the same GPU TouchDesigner is currently running on.",
                "type": "MenuPar",
                "name": "gpu",
                "items": []
            },
            {
                "text": "TOP : Specify the TOP to process for tracking.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Toggle : Enable the channels (tx, ty, tz) for body tracking points in 3D space.",
                "type": "TogglePar",
                "name": "body3d",
                "items": []
            },
            {
                "text": "Toggle : Enable the channels (u, v) for body tracking points in 2D.",
                "type": "TogglePar",
                "name": "body2d",
                "items": []
            },
            {
                "text": "Toggle : Enable the IK channels (tx, ty, tz, rx, ry, rz and associated roll channels) for body tracking points in 3D space.",
                "type": "TogglePar",
                "name": "body3dik",
                "items": []
            },
            {
                "text": "Toggle : Enable the position and bounds channels (u, v, width, height) for faces.",
                "type": "TogglePar",
                "name": "facebounds",
                "items": []
            },
            {
                "text": "Toggle : Enable the position channels (u, v) for all face tracking points.",
                "type": "TogglePar",
                "name": "face",
                "items": []
            },
            {
                "text": "Toggle : Enable the position and bounds channels (u, v, width, height) for hands.",
                "type": "TogglePar",
                "name": "handsbounds",
                "items": []
            },
            {
                "text": "Toggle : Enable the position channels (u, v) for all hand tracking points.",
                "type": "TogglePar",
                "name": "hands",
                "items": []
            },
            {
                "text": "Int : Sets the maximum number of people that can be tracked. For each person/player a new set of channels is created prefixed p1, p2, p3, ... etc.\n\n'''NOTE''': The parameter slider goes to 10 but higher numbers of players can be tracked by setting a higher Max Player value.",
                "type": "IntPar",
                "name": "maxplayers",
                "items": []
            },
            {
                "text": "Toggle : Adjusts the values of u and v channels to take the TOP's aspect ratio into account. When using non-square input TOP, turn this on to line up u and v position with the image.",
                "type": "TogglePar",
                "name": "aspectcorrectuv",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "CHOP",
        "opType": "wrnchaiCHOP",
        "opLabel": "wrnchAI",
        "opClass": "wrnchaiCHOP_Class",
        "opFilter": "False",
        "opLicense": "Pro",
        "short": "Uses the wrnchAI engine to track human motion in any video stream.",
        "long": "'''Note: Wrnch has be acquired by another company and it is no longer possible to obtain a license to use it anymore. This CHOP has been removed in 2022.20000+ builds.'''\n\nUsing the [[wrnchAI]] engine to track human motion in any video stream, this CHOP will output channels for Body, Face and Hand positions. Multiple people can be tracked at the same time with low-latency, and the system compatible with all cameras and video feeds. TouchDesigner used the wrnchAI Edge SDK and all computation is done locally in realtime utilizing Nvidia GPUs and the NVIDIA CUDA\u00ae Deep Neural Network library ([https://developer.nvidia.com/cudnn cuDNN]). This can offer skeletal tracking of multiple people at 60fps or higher (90-120fps etc).\n    \n '''Requires a separate license from wrnchAI''' to run in TouchDesigner. Requires '''Nvidia GPU on Windows OS''' and TouchDesigner Pro. \n Make sure to install TouchDesigner from the Full Installer, the Lite Installer does not include wrnchAI libraries.\n\n===== Quickstart Guide =====\nOnce you have a wrnchAI license (purchased or trial), you will have access to your '''wrnchAI licenses''' page and the '''wrnchAI Edge Releases''' page.\n\n# Go to your [https://devportal.wrnch.ai/licenses wrnchAI licenses page]. Click on the 'key' icon and copy the '''Edge License Key''' into the CHOP's 'wrnchAI License' parameter.\n# Go to [https://devportal.wrnch.ai/wrnchai_edge/releases wrnchAI Edge Releases page] and download the '''wrnchAI Engine for Win10'''. The file will be something like <code>wrnchAI-Engine-1.17.0-GPU-Win10.zip</code>\n# Once downloaded, extract the .zip file and locate the '''wrnchAI trained models folder''' for use in the CHOP's 'Model Folder' parameter. It should be located here: <code>wrnchAI-engine-GPU-1.17.0-Windows-amd64/bin/wrModels</code>\nThe wrnchAI CHOP will take a few moments to initialize and then will be ready for tracking. Initializing is only required when a new Model Folder is introduced, it will not need to re-initialize each time the project is started.",
        "opCategories": ""
    },
    "zedCHOP": {
        "label": "zedCHOP",
        "members": [
            {
                "text": "Toggle : When 'On' data is captured from the ZED camera.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "StrMenu : Selects which ZED camera to use.",
                "type": "StrMenuPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "Pulse : Zeros out the current camera position, effectively makes the current position the new origin.",
                "type": "PulsePar",
                "name": "resetcameraposition",
                "items": []
            },
            {
                "text": "Toggle : Enables plane at point, which returns the position of the plane corresponding the UV coordinate.",
                "type": "TogglePar",
                "name": "planeorientation",
                "items": []
            },
            {
                "text": "Toggle : Returns the camera position relative to the initial position of the camera. A <code>tx</code>, <code>ty</code>, <code>tz</code> triplet of channels will be output for the position of the camera in meters. An <code>rx</code>, <code>ry</code>, <code>rz</code> triplet will be output for the orientation.",
                "type": "TogglePar",
                "name": "getplane",
                "items": []
            },
            {
                "text": "Float : Sets the U coordinate of the point in the image to extract plane position.",
                "type": "FloatPar",
                "name": "u",
                "items": []
            },
            {
                "text": "Float : Sets the V coordinate of the point in the image to extract plane position.",
                "type": "FloatPar",
                "name": "v",
                "items": []
            },
            {
                "text": "Toggle : Returns <code>tx</code>, <code>ty</code>, and <code>tz</code> position channels of the center of the plane.",
                "type": "TogglePar",
                "name": "planeposition",
                "items": []
            },
            {
                "text": "Toggle : Returns <code>rx</code>, <code>ry</code>, and <code>rz</code> rotation channels for the plane.",
                "type": "TogglePar",
                "name": "planerotation",
                "items": []
            },
            {
                "text": "Toggle : Returns <code>nx</code>, <code>ny</code>, and <code>nz</code> normal channels of the plane.",
                "type": "TogglePar",
                "name": "planenormal",
                "items": []
            },
            {
                "text": "Toggle : Returns size of the bounding rectangle of the plane.",
                "type": "TogglePar",
                "name": "planesize",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "long": "The ZED CHOP reads positional and plane tracking from the ZED camera. It can additionally use a UV to find plane in the room, and return information about that plane such as it's size/orientation either relative to the camera, or the room itself.\n\t\t\t\n'''NOTE:''' This CHOP works with the [https://www.stereolabs.com/zed/ Stereolabs ZED] hardware.\t\nFor more information and to know what ZED SDK to install refer to the [[ZED]] article.\n\nSee also [[ZED TOP]] and [[ZED SOP]].",
        "opLicense": "Non-Commercial",
        "opClass": "zedCHOP_Class",
        "opLabel": "ZED",
        "opFamily": "CHOP",
        "os": "Microsoft Windows",
        "opType": "zed",
        "short": "The ZED CHOP reads positional tracking data from the ZED camera.",
        "opCategories": ""
    },
    "alignSOP": {
        "label": "alignSOP",
        "members": [
            {
                "text": "StrMenu : A subset of primitives to align (accepts patterns, as described in Pattern Matching in the [http://www.derivativeinc.com/Tools/Touch000/Manual/Guides/ScriptingGuide/ScriptingGuide.pdf Scripting Guide]). If blank, it aligns the entire input.",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Can optionally align subgroups of ''n'' primitives or every ''n''th primitive in a cyclical manner.",
                "type": "MenuPar",
                "name": "align",
                "items": []
            },
            {
                "text": "Int : Determines the number of primitives to be either grouped or skipped.\nExample: Assume there are six primitives numbered for 0 - 5, and N = 2. Then:\t\n\n'''a)'''<br />'''b)'''",
                "type": "IntPar",
                "name": "inc",
                "items": []
            },
            {
                "text": "Float : Determines which primitive remains unaffected: 0 Left, 1 Right.",
                "type": "FloatPar",
                "name": "bias",
                "items": []
            },
            {
                "text": "Float : Pivot Location for each \"left\" primitive.",
                "type": "FloatPar",
                "name": "leftuv",
                "items": []
            },
            {
                "text": "Float : Pivot location for each \"right\" primitive.",
                "type": "FloatPar",
                "name": "rightuv",
                "items": []
            },
            {
                "text": "Float : If an auxiliary input is used, this location specifies an end point for the alignment. Left primitives are then distributed uniformly between the <code>Right UV</code> and the <code>Right UV End</code>.",
                "type": "FloatPar",
                "name": "rightuvend",
                "items": []
            },
            {
                "text": "Toggle : Causes each primitive of the input to be aligned. If unchecked, only the first primitive is aligned and all others are placed relative to it, preserving the spatial layout of the left primitives.",
                "type": "TogglePar",
                "name": "individual",
                "items": []
            },
            {
                "text": "Toggle : When enabled, translates primitives during alignment by translating the left UV position to the right UV position.",
                "type": "TogglePar",
                "name": "dotrans",
                "items": []
            },
            {
                "text": "Toggle : When enabled, rotates primitives during alignment by aligning the left UV tangents (at the left UV position) to the right UV tangents (at the right UV position).",
                "type": "TogglePar",
                "name": "dorotate",
                "items": []
            },
            {
                "text": "Menu : Sets the overall transform and rotation order for the transformations. The transform and rotation order determines the order in which transformations take place. Depending on the order, you can achieve different results using the exact same values.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : Sets the overall transform and rotation order for the transformations. The transform and rotation order determines the order in which transformations take place. Depending on the order, you can achieve different results using the exact same values.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of translation about the local <code>xyz</code> axes.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of translation about the local <code>xyz</code> axes.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of translation about the local <code>xyz</code> axes.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of rotation about the local <code>xyz</code> axes.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of rotation about the local <code>xyz</code> axes.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of rotation about the local <code>xyz</code> axes.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of scaling about the local <code>xyz</code> axes.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of scaling about the local <code>xyz</code> axes.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of scaling about the local <code>xyz</code> axes.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of translation / rotation / scaling about the local <code>xyz</code> axes",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of translation / rotation / scaling about the local <code>xyz</code> axes",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : Allows you to perform a post-alignment transformation. Specify the amount of translation / rotation / scaling about the local <code>xyz</code> axes",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "alignSOP_Class",
        "opType": "align",
        "short": "The Align SOP aligns a group of primitives to each other or to an auxiliary input, by translating or rotating each primitive along any pivot point.",
        "opFilter": "True",
        "opLabel": "Align",
        "long": "The Align SOP aligns a group of primitives to each other or to an auxiliary input, by translating or rotating each primitive along any pivot point.\t\t\n\t\t\t\n'''Left and Right Primitives''' - The notions of \"left\" and \"right\" which follow depend on context. If an auxiliary input is used, it is always the right primitive and the primary input geometry are all left primitives. If only one input is used, then for each pair being aligned, there is a left and a right primitive. This means that relative to neighbouring primitives, one primitive can be both left and right.\t\t\t\n\t\t\t\n<div><center>[[Image:TouchGeometry72.gif]]</center></div>",
        "opFamily": "SOP",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "armSOP": {
        "label": "armSOP",
        "members": [
            {
                "text": "Menu : You can use either '''Ellipses''' or '''Capture Regions''' as deformation geometry. Ellipses are for use with the Skeleton SOP. Capture Regions are for use with the Capture SOP.",
                "type": "MenuPar",
                "name": "capttype",
                "items": []
            },
            {
                "text": "Menu : Position the model along the +X or -X axis.",
                "type": "MenuPar",
                "name": "axis",
                "items": []
            },
            {
                "text": "Float : Controls the scale of the circle radii.",
                "type": "FloatPar",
                "name": "bonerad",
                "items": []
            },
            {
                "text": "Toggle : This parameter rotates the hand and the wrist joint to match the orientation of the hand-print object. In order to operate correctly, the end-affector (hand print) scale transformations must remain at 1.\t\n\t\t\t\n'''Note:''' If the channel is set to 0, then the hand rotations are relative to the forearm. If the channel is set to 1, the hand rotations are the same orientation as the end affector.",
                "type": "TogglePar",
                "name": "rotatehand",
                "items": []
            },
            {
                "text": "Toggle : This parameter affects the default twist of the elbow joint to a more natural position.",
                "type": "TogglePar",
                "name": "autoelbow",
                "items": []
            },
            {
                "text": "Float : Specifies the rotation angle of the elbow joint.",
                "type": "FloatPar",
                "name": "elbowtwist",
                "items": []
            },
            {
                "text": "Toggle : This toggle positions the arm using an alternative elbow position solution.",
                "type": "TogglePar",
                "name": "flipelbow",
                "items": []
            },
            {
                "text": "Float : Control bone lengths, as illustrated above.",
                "type": "FloatPar",
                "name": "clavlength",
                "items": []
            },
            {
                "text": "Float : Control bone lengths, as illustrated above.",
                "type": "FloatPar",
                "name": "humlength",
                "items": []
            },
            {
                "text": "Float : Control bone lengths, as illustrated above.",
                "type": "FloatPar",
                "name": "ulnalength",
                "items": []
            },
            {
                "text": "Float : Control bone lengths, as illustrated above.",
                "type": "FloatPar",
                "name": "handlength",
                "items": []
            },
            {
                "text": "Float : Control the joint lengths, as illustrated above.",
                "type": "FloatPar",
                "name": "shoulder",
                "items": []
            },
            {
                "text": "Float : Control the joint lengths, as illustrated above.",
                "type": "FloatPar",
                "name": "elbow",
                "items": []
            },
            {
                "text": "Float : Control the joint lengths, as illustrated above.",
                "type": "FloatPar",
                "name": "wrist",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the first shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder1tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the first shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder1ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the first shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder1tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the second shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder2tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the second shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder2ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the second shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder2tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the third shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder3tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the third shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder3ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the third shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder3tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fourth shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder4tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fourth shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder4ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fourth shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder4tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fifth shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder5tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fifth shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder5ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fifth shoulder circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "shoulder5tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the first elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow1tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the first elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow1ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the first elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow1tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the second elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow2tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the second elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow2ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the second elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow2tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the third elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow3tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the third elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow3ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the third elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow3tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fourth elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow4tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fourth elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow4ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fourth elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow4tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fifth elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow5tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fifth elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow5ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fifth elbow circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "elbow5tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the first wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist1tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the first wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist1ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the first wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist1tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the second wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist2tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the second wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist2ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the second wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist2tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the third wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist3tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the third wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist3ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the third wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist3tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fourth wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist4tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fourth wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist4ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fourth wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist4tz",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fifth wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist5tx",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fifth wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist5ty",
                "items": []
            },
            {
                "text": "XYZ : The X, Z position of the fifth wrist circle, as well as its overall scale.",
                "type": "XYZPar",
                "name": "wrist5tz",
                "items": []
            },
            {
                "text": "Object : Allows the end affector to be another object, or simply defined by a default box, which is controlled by the transformations below.",
                "type": "ObjectPar",
                "name": "affector",
                "items": []
            },
            {
                "text": "XYZ : End Affector Translation. For a full explanation of transforms, see the [[Transform SOP]].",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : End Affector Translation. For a full explanation of transforms, see the [[Transform SOP]].",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : End Affector Translation. For a full explanation of transforms, see the [[Transform SOP]].",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : End Affector Rotation. For a full explanation of transforms, see the [[Transform SOP]].",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : End Affector Rotation. For a full explanation of transforms, see the [[Transform SOP]].",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : End Affector Rotation. For a full explanation of transforms, see the [[Transform SOP]].",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : End Affector Scale. For a full explanation of transforms, see the [[Transform SOP]].",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : End Affector Scale. For a full explanation of transforms, see the [[Transform SOP]].",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : End Affector Scale. For a full explanation of transforms, see the [[Transform SOP]].",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opLicense": "Non-Commercial",
        "opClass": "armSOP_Class",
        "opFamily": "SOP",
        "long": "The Arm SOP creates all the necessary geometry for an arm, and provides a smooth, untwisted skin that connects the arm to the body. It is controlled through inverse kinematics linked to a handprint.",
        "short": "The Arm SOP creates all the necessary geometry for an arm, and provides a smooth, untwisted skin that connects the arm to the body.",
        "opFilter": "False",
        "opType": "arm",
        "opLabel": "Arm",
        "opCategories": ""
    },
    "basisSOP": {
        "label": "basisSOP",
        "members": [
            {
                "text": "Toggle : Enable editing of the U Basis.",
                "type": "TogglePar",
                "name": "ubasis",
                "items": []
            },
            {
                "text": "Menu : Select the method of parameterization in u from the options below.",
                "type": "MenuPar",
                "name": "uparmtype",
                "items": []
            },
            {
                "text": "Str : The basis of the first spline primitive in the input loads its knot sequence with the data specified in this field when the <span class=\"tipTextSOP\">Parameterization</span> is set to <span class=\"tipTextSOP\">Manual</span>. The values must be in ascending order, and their total count must match the number of knots in the basis. To ensure an exact count, click on the <span class=\"tipTextSOP\">Read Basis</span> button to read the original knot sequence into this field.<!--TDparEnd-->\t\n\t\t\t\n'''Note:''' Bezier bases cannot have repeated knots. NURBS bases accept repeated knots as long as the knot multiplicity does not exceed the degree of the basis. The first two and last two knots of a NURBS basis must be identical.",
                "type": "StrPar",
                "name": "uknots",
                "items": []
            },
            {
                "text": "Pulse : Loads the original knots of the basis into the <span class=\"tipTextSOP\">Knot Sequence</span> field when the <span>Parameterization</span> type is <span class=\"tipTextSOP\">Manual</span>.",
                "type": "PulsePar",
                "name": "uread",
                "items": []
            },
            {
                "text": "Float : Range specifies the domain interval to be shifted. All the knots captured in this range are shifted by the same amount as far as the closest neighbouring knot on either side.",
                "type": "FloatPar",
                "name": "urange",
                "items": []
            },
            {
                "text": "Float : Bias indicates the direction and the amount of translation. A <span class=\"tipTextSOP\">Bias</span> of 0.5 does not displace the knots at all. As the <span class=\"tipTextSOP\">Bias</span> decreases, the knot cluster migrates closer to its left-neighbouring knot. A <span class=\"tipTextSOP\">Bias</span> greater than 0.5 forces a migration to the right.<!--TDitemEnd-->\t\nSometimes a <span class=\"tipTextSOP\">Bias</span> of 0 or 1 does not clamp the knot cluster to the closest neighbouring knot. The reason for this behaviour is that the knot multiplicity cannot be allowed to exceed the <span>degree</span> of the basis. For example, an order 4 (degree 3, or \"cubic\") spline can have at most 3 identical knots in sequence.\t\t\t\nWhen sliding the knot of a NURBS basis, a larger area of that spline is affected. This may create the impression than more knots than those in the cluster are being displaced.",
                "type": "FloatPar",
                "name": "ubias",
                "items": []
            },
            {
                "text": "Toggle : Indicates whether the bases of the input spline primitives should be concatenated such that the last knot of the first primitive coincides with the first knot of the second primitive, and so on. This operation is performed before the ones below it, thus allowing a whole set of bases to be mapped onto a given interval (usually [0,1]) while enforcing basis continuity.",
                "type": "TogglePar",
                "name": "uconcat",
                "items": []
            },
            {
                "text": "Toggle : Enables the Origin parameter.",
                "type": "TogglePar",
                "name": "udoorigin",
                "items": []
            },
            {
                "text": "Float : The new origin of the basis, or the origin of the cummulated bases if <span class=\"tipTextSOP\">Concatenation</span> is <span class=\"tipTextSOP\">On</span>.",
                "type": "FloatPar",
                "name": "uorigin",
                "items": []
            },
            {
                "text": "Toggle : Enables the Length parameter.",
                "type": "TogglePar",
                "name": "udolength",
                "items": []
            },
            {
                "text": "Float : The new length of the basis, or the total length of the cummulated bases if <span class=\"tipTextSOP\">Concatenation</span> is <span class=\"tipTextSOP\">On</span>. The <span class=\"tipTextSOP\">Length</span>, which represents the distance between the first and last knot, must be greater than zero.",
                "type": "FloatPar",
                "name": "ulength",
                "items": []
            },
            {
                "text": "Toggle : Enables the Scale parameter.",
                "type": "TogglePar",
                "name": "udoscale",
                "items": []
            },
            {
                "text": "Float : The multiplier applied to the basis starting at the basis origin. The <span class=\"tipTextSOP\">Scale</span> must be greater than zero.",
                "type": "FloatPar",
                "name": "uscale",
                "items": []
            },
            {
                "text": "Toggle : Enables the Raise to parameter.",
                "type": "TogglePar",
                "name": "uraise",
                "items": []
            },
            {
                "text": "Int : The only operation here is raising the order (or degree) of the spline basis. Valid orders range from 2 to 11. Orders lower than the current spline order are ignored. The operation preserves the shape of the primitive.<!--TDparEnd-->\t\n\t\t\t\n'''Production Tip:''' Before applying a spline-based texture projection with the Texture SOP, remap the U and/or V bases of the spline surface between 0 and 1 to ensure a complete mapping of the texture. If a single texture map must be shared by several surfaces, the surface bases should be concatenated prior to being remapped.",
                "type": "IntPar",
                "name": "orderu",
                "items": []
            },
            {
                "text": "Toggle : Enable editing of the V Basis.",
                "type": "TogglePar",
                "name": "vbasis",
                "items": []
            },
            {
                "text": "Menu : Select the method of parameterization in v from the options below.",
                "type": "MenuPar",
                "name": "vparmtype",
                "items": []
            },
            {
                "text": "Str : The basis of the first spline primitive in the input loads its knot sequence with the data specified in this field when the <span class=\"tipTextSOP\">Parameterization</span> is set to <span class=\"tipTextSOP\">Manual</span>. The values must be in ascending order, and their total count must match the number of knots in the basis. To ensure an exact count, click on the <span class=\"tipTextSOP\">Read Basis</span> button to read the original knot sequence into this field.<!--TDparEnd-->\t\n\t\t\t\n'''Note:''' Bezier bases cannot have repeated knots. NURBS bases accept repeated knots as long as the knot multiplicity does not exceed the degree of the basis. The first two and last two knots of a NURBS basis must be identical.",
                "type": "StrPar",
                "name": "vknots",
                "items": []
            },
            {
                "text": "Pulse : Loads the original knots of the basis into the <span class=\"tipTextSOP\">Knot Sequence</span> field when the <span>Parameterization</span> type is <span class=\"tipTextSOP\">Manual</span>",
                "type": "PulsePar",
                "name": "vread",
                "items": []
            },
            {
                "text": "Float : Range specifies the domain interval to be shifted. All the knots captured in this range are shifted by the same amount as far as the closest neighbouring knot on either side.",
                "type": "FloatPar",
                "name": "vrange",
                "items": []
            },
            {
                "text": "Float : Bias indicates the direction and the amount of translation. A <span class=\"tipTextSOP\">Bias</span> of 0.5 does not displace the knots at all. As the <span class=\"tipTextSOP\">Bias</span> decreases, the knot cluster migrates closer to its left-neighbouring knot. A <span class=\"tipTextSOP\">Bias</span> greater than 0.5 forces a migration to the right.<!--TDitemEnd-->\t\nSometimes a <span class=\"tipTextSOP\">Bias</span> of 0 or 1 does not clamp the knot cluster to the closest neighbouring knot. The reason for this behaviour is that the knot multiplicity cannot be allowed to exceed the <span>degree</span> of the basis. For example, an order 4 (degree 3, or \"cubic\") spline can have at most 3 identical knots in sequence.\t\t\t\nWhen sliding the knot of a NURBS basis, a larger area of that spline is affected. This may create the impression than more knots than those in the cluster are being displaced.",
                "type": "FloatPar",
                "name": "vbias",
                "items": []
            },
            {
                "text": "Toggle : Indicates whether the bases of the input spline primitives should be concatenated such that the last knot of the first primitive coincides with the first knot of the second primitive, and so on. This operation is performed before the ones below it, thus allowing a whole set of bases to be mapped onto a given interval (usually [0,1]) while enforcing basis continuity.",
                "type": "TogglePar",
                "name": "vconcat",
                "items": []
            },
            {
                "text": "Toggle : Enables the Origin parameter.",
                "type": "TogglePar",
                "name": "vdoorigin",
                "items": []
            },
            {
                "text": "Float : The new origin of the basis, or the origin of the cummulated bases if <span class=\"tipTextSOP\">Concatenation</span> is <span class=\"tipTextSOP\">On</span>.",
                "type": "FloatPar",
                "name": "vorigin",
                "items": []
            },
            {
                "text": "Toggle : Enables the Length parameter.",
                "type": "TogglePar",
                "name": "vdolength",
                "items": []
            },
            {
                "text": "Float : The new length of the basis, or the total length of the cummulated bases if <span class=\"tipTextSOP\">Concatenation</span> is <span class=\"tipTextSOP\">On</span>. The <span class=\"tipTextSOP\">Length</span>, which represents the distance between the first and last knot, must be greater than zero.",
                "type": "FloatPar",
                "name": "vlength",
                "items": []
            },
            {
                "text": "Toggle : Enables the Scale parameter.",
                "type": "TogglePar",
                "name": "vdoscale",
                "items": []
            },
            {
                "text": "Float : The multiplier applied to the basis starting at the basis origin. The <span class=\"tipTextSOP\">Scale</span> must be greater than zero.",
                "type": "FloatPar",
                "name": "vscale",
                "items": []
            },
            {
                "text": "Toggle : Enables the Raise to parameter.",
                "type": "TogglePar",
                "name": "vraise",
                "items": []
            },
            {
                "text": "Int : The only operation here is raising the order (or degree) of the spline basis. Valid orders range from 2 to 11. Orders lower than the current spline order are ignored. The operation preserves the shape of the primitive.<!--TDparEnd-->\t\n\t\t\t\n'''Production Tip:''' Before applying a spline-based texture projection with the Texture SOP, remap the U and/or V bases of the spline surface between 0 and 1 to ensure a complete mapping of the texture. If a single texture map must be shared by several surfaces, the surface bases should be concatenated prior to being remapped.",
                "type": "IntPar",
                "name": "orderv",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "basisSOP_Class",
        "opType": "basis",
        "short": "The Basis SOP provides a set of operations applicable to the parametric space of spline curves and surfaces.",
        "opFilter": "True",
        "opLabel": "Basis",
        "long": "The Basis SOP provides a set of operations applicable to the parametric space of spline curves and surfaces. The parametric space, also known as the \"domain\" of a NURBS or Bzier primitive, is defined by one basis in the U direction and, if the primitive is a surface, another basis in the V direction. The size of the domain is given by the values of the knots that make up the basis.\t\t\n\t\t\t\n<div><center>[[Image:BasisSOP.gif]]</center></div>\t\t\t\n\t\t\t\nThe Basis SOP contains both ratio-preserving and non ratio-preserving operations.\t\t\t\n\t\t\t\nIf the basis reparameterization does not change the distance ratios between knots, the shape of a NURBS primitive is not affected. If the ratios are not preserved, however, a NURBS primitive will change shape in the area influenced by the modified knots; furthermore, if the primitive is a NURBS or Bzier surface, any profiles it may contain will be affected as well.\t\t\t\n\t\t\t\nFor more information about bases and knots see Breakpoints, Knots, and Spline Basis in the Geometry Types Guide.",
        "opFamily": "SOP",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "blendSOP": {
        "label": "blendSOP",
        "members": [
            {
                "text": "StrMenu : Specifies a point or primitive group in the first input. If, for example, a group is specified containing the first and third points, then the first and third point of every input will be blended whereas the second, fourth, fifth, etc. points will be set to match the first input source. Accepts patterns, as described in: [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Toggle : Generates exaggerated blends between objects where values above 1 or less than 0 will result in over-scaled blends.\t\n\t\t\nWhen this option is checked, the above channel values are not summed and scaled to 1. The first input is considered a reference; Blend computes the difference between the first input and the others for each point; values greater than 1 and less than 0 produce exaggerations of the shapes for inputs 2 and higher. The first input, however, cannot be exaggerated by its blend channel, /blend1, and it is considered to be the \"base\". When using Differencing, the /blend1 channel has no effect. If the geometry in the first input must be deformed, feed it into another input, where the blend channels have an effect.",
                "type": "TogglePar",
                "name": "diff",
                "items": []
            },
            {
                "text": "Toggle : When checked, the point positions of the inputs will be blended based on the weights of the blend channels. If not checked, the input geometry will not change, only allowing Blending of Colors, Normals and Textures if selected.",
                "type": "TogglePar",
                "name": "dopos",
                "items": []
            },
            {
                "text": "Toggle : When checked, the point colors of the geometry inputs will be blended based on the weights of the blend channels.",
                "type": "TogglePar",
                "name": "doclr",
                "items": []
            },
            {
                "text": "Toggle : When checked, the point normals of the geometry inputs will be blended based on the weights of the blend channels.",
                "type": "TogglePar",
                "name": "donml",
                "items": []
            },
            {
                "text": "Toggle : When checked, the point texture co-ordinates of the geometry inputs will be blended based on the weights of the blend channels.",
                "type": "TogglePar",
                "name": "douvw",
                "items": []
            },
            {
                "text": "Toggle : When checked, the Up Vector of the geometry inputs will be blended based on the weights of the blend channels.",
                "type": "TogglePar",
                "name": "doup",
                "items": []
            },
            {
                "text": "Float : The weight or contribution of this input. 0 has no contribution, 1 is full contribution.",
                "type": "FloatPar",
                "name": "weight1",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "blendSOP_Class",
        "opType": "blend",
        "short": "The Blend SOP provides 3D metamorphosis between shapes with the same topology. It can blend",
        "opFilter": "True",
        "opLabel": "Blend",
        "long": "The Blend SOP provides 3D metamorphosis between shapes with the same topology. It can blend between sixteen input SOPs using the average weight of each input's respective channel. It will also interpolate point colors and/or texture co-ordinates between shapes.\t\n\t\t\nFor best results, there should be the same number of points / CVs (and faces) in the geometry of each SOP. The points should have a similar order; if point 17 in one source is on the left side, and point 17 in another Source is on the right side, it will move across the object during the blend, which may create distorted and twisted shapes. To ensure that this doesn't happen, you can make all the pieces to be blended by editing point positions of one common base shape. Each of the pieces to be morphed must be in different SOPs.\t\t\n\t\t\nFor example, when editing the shapes in the Model Editor, each particular geometry can be saved and then read in, or input the Model SOP directly into the Blend SOP. You would then have the base model geometry entering the Blend SOP in the first Blend, then up to 15 Model SOPs feeding from the SOP containing the base model geometry, which in turn would feed into the Blend SOP. Remember that Model SOPs cannot be unlocked and, therefore, are a safe way to store data without using a File In SOP.\t\t\n\t\t\nThe Blend SOP now only cooks non-zero-weighted inputs.\t\t\n\t\t\nSee also [[Sequence Blend SOP]].",
        "opFamily": "SOP",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "booleanSOP": {
        "label": "booleanSOP",
        "members": [
            {
                "text": "Menu : Some of the operations below produce guide geometry to give you visual feedback on the results of the operation being performed. The appearance of the geometry is context sensitive - if you are performing an intersect operation, or either of the edge operations the guide will be both inputs; if you are doing A minus B then the guide will be B and if B minus A then the guide will be A. If you are doing union then there will be no guide geometry.\t\n\t\t\nIf the guide geometry is too distracting, you can disable it by entering the Viewport options dialog and clicking on the Guide geometry button so that it no longer appears indented. This procedure is global and will disable the guide geometry of other SOPs as well.\n\nThe Boolean SOP will automatically orient polygons so they face the same way. This may not be enough in some cases because Boolean results in some unshared edges where the intersection cut took place. If the shading is still not good enough, you are best to follow Boolean with a Facet SOP. In it, Consolidate Points, Orient Polygons and finally Cusp.\t\t\n\t\t\nIf you have really strange shaped polygons, you can first triangulate one or both of the inputs with the Divide SOP.",
                "type": "MenuPar",
                "name": "booleanop",
                "items": []
            },
            {
                "text": "Toggle : If selected, all inputs are convexed to triangles, otherwise they are convexed to quadrilaterals.",
                "type": "TogglePar",
                "name": "accattrib",
                "items": []
            },
            {
                "text": "Toggle : If selected, a group is created containing all faces pertaining to the first input, and a second group containing all faces of the second input.",
                "type": "TogglePar",
                "name": "creategroup",
                "items": []
            },
            {
                "text": "Str : When Create Groups = On, specify a name for Group A.",
                "type": "StrPar",
                "name": "groupa",
                "items": []
            },
            {
                "text": "Str : When Create Groups = On, specify a name for Group B.",
                "type": "StrPar",
                "name": "groupb",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "booleanSOP_Class",
        "opType": "boolean",
        "short": "The Boolean SOP takes two closed polygonal sets, A and B. Set these Sources to the SOPs with the 3D shapes that you wish to operate on.",
        "opFilter": "True",
        "opLabel": "Boolean",
        "long": "The Boolean SOP takes two closed polygonal sets, A and B. Set these Sources to the SOPs with the 3D shapes that you wish to operate on. There are two important requirements for input geometry:\t\n\t\t\n* Shapes must be completely closed. A tube with open ends is not an acceptable input. You can close Tube ends with an end-cap. An extruded letter with no back polygons output is also unacceptable (even with backs output it can be unacceptable because of the second requirement).\t\t\n* All polygons must be convex and coplanar. In the case of the Extrude SOP, you must select Output Convex Faces for front and back faces. It will now be a usable input for Boolean. The Divide SOP also offers a convexing function for geometry not created with the Extrude SOP.\t\t\n\t\t\nOther caveats for Boolean are the following:\t\t\n\t\t\n* Point colors and texture UV coordinates are not interpolated correctly.\t\t\n* In some cases polygons can be reversed so that all normals point outwards. The polygon reversal should not usually present much of a problem (use a Primitive SOP &gt; Face/Hull page &gt; Vertex &gt; Reverse to reverse them if necessary).\t\t\n\n* A [[Facet SOP]] can be used to prepare inputs when the Boolean SOP complaints they are not closed. In that case, use both the Consolidate Points and Orient Polygons options.\n\t\t\nThis SOP is quite visual and intuitive; you can experiment with the different combinations on screen to see the effects.\t\t\n\t\t\n'''Note:''' The Boolean SOP handles polygonal geometry types. For boolean-type operations with nurbs and Bezier surfaces - see [[Surfsect SOP]].",
        "opFamily": "SOP",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "bridgeSOP": {
        "label": "bridgeSOP",
        "members": [
            {
                "text": "StrMenu : The <span class=\"tipTextSOP\">Group</span> edit field allows you to enter profile groups for profiles and/or faces to bridge. This is optional if you have regular geometric curves or surfaces, however, you must enter something here in order for Bridge to work with profile curves. For example <code>*.0</code> will Bridge the 0th (first) profiles of all incoming primitives.<!--TDparEnd-->\t\t\n\t\t\t\n'''Note:''' Always specify the curves on surface if you want the Bridge SOP bridge curves on surfaces; otherwise it will attempt to bridge free-floating curves.",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Allows bridging of subgroups of N primitives or patterns of primitives.",
                "type": "MenuPar",
                "name": "bridge",
                "items": []
            },
            {
                "text": "Int : Determines the pattern of primitives to bridge using this SOP.",
                "type": "IntPar",
                "name": "inc",
                "items": []
            },
            {
                "text": "Int : Sets the spline order for both profile extraction and skinning operations.",
                "type": "IntPar",
                "name": "order",
                "items": []
            },
            {
                "text": "Int : The minimum number of cross-sections in the resulting skin. If you create a high-density surface, TouchDesigner's level of detail may display the surface less smoothly than it actually is. You can increase the level of detail by adjusting the viewdisplay options (e.g. <code>viewdisplay -l 1.5 SOPmain.persp1</code> ) for the Viewport.<!--TDparEnd-->\t\n\t\t\t\n'''Production Tip:''' If, in generating a smooth surface, you create an extremely complex surface, some of the complexity can be removed without damaging the appearance of the surface by appending a Refine SOP, and using its '''Unrefine''' option. In the Refine SOP, set the '''First U''' parameter to zero and, in the '''Unrefine''' option's parameters, set the '''U''' value close to the order of the surface created in the Bridge SOP.",
                "type": "IntPar",
                "name": "isodivs",
                "items": []
            },
            {
                "text": "Menu : Specifies the type of normal to use for computing direction:",
                "type": "MenuPar",
                "name": "frenet",
                "items": []
            },
            {
                "text": "Toggle : Tells TouchDesigner to try to generate a round fillet rather than a free-form fillet. Only the sign (positive or negative) of the tangent scales is used; the scale magnitude is ignored when building a circular fillet.\t\n\t\t\t\nThe radius of the fillet is computed automatically and adjusted according to the distance between the rails (curves and/or profiles) and their tangents.",
                "type": "TogglePar",
                "name": "circular",
                "items": []
            },
            {
                "text": "Float : The scaling and rotation parameters contain three fields. The rotation fields (degrees) apply further rotation to the tangents, while the scale parameter further scales the tangents.",
                "type": "FloatPar",
                "name": "rotatet",
                "items": []
            },
            {
                "text": "Float : The scaling and rotation parameters contain three fields. The rotation fields (degrees) apply further rotation to the tangents, while the scale parameter further scales the tangents.",
                "type": "FloatPar",
                "name": "scalet",
                "items": []
            },
            {
                "text": "Toggle : Takes curvature into consideration as well.",
                "type": "TogglePar",
                "name": "curvature",
                "items": []
            },
            {
                "text": "Float : Further scaling of the curvature.\t\n\t\t\t\n'''Note:''' If the resulting skin bulges too greatly, you can achieve a smooth resulting transition between surfaces by disabling the <span class=\"tipTextSOP\">Preserve Tangent</span> &amp; <span class=\"tipTextSOP\">Preserve Curvature Magnitude</span> parameters, and manually tweaking the Tangent Scales and the Curvature Scales. In general, avoid tweaking the Rotations of the Tangents unless you wish to deform the resulting surface.\t\t\t\n\t\t\t\nIf the bridge bulges on one side but not the other, try increasing the <span class=\"tipTextSOP\">Min. Number of Cross sections</span> in the bridge.",
                "type": "FloatPar",
                "name": "scalec",
                "items": []
            },
            {
                "text": "Int : Number of 2-D points evaluated in each span.",
                "type": "IntPar",
                "name": "sdivs",
                "items": []
            },
            {
                "text": "Float : Precision of 2-D fitting algorithm.",
                "type": "FloatPar",
                "name": "tolerance",
                "items": []
            },
            {
                "text": "Toggle : Enables or disables fitting of sharp turns. If cracks appear in the resulting skin, <span class=\"tipTextSOP\">Preserve Sharp Corners</span> is usually a good solution; however, it may add additional knots which can create undesirable \"ripples\" in some cases.<!--TDparEnd-->\t\n\t\t\t\nIf this option is disabled, fewer isoparms are generated and the surface may not follow the contours of the profile curves perfectly unless the profile curves were built using the <code>Preserve Sharp Corners</code> option.",
                "type": "TogglePar",
                "name": "csharp",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "bridgeSOP_Class",
        "opType": "bridge",
        "short": "The Bridge SOP is useful for skinning trimmed surfaces, holes, creating highly controllable joins between arms and body, branches or tube intersections.",
        "opFilter": "True",
        "opLabel": "Bridge",
        "long": "The Bridge SOP is useful for skinning trimmed surfaces, holes, creating highly controllable joins between arms and body, branches or tube intersections.\t\t\n\t\t\t\nThe Bridge SOP is similar to the Skin SOP but with much greater control over the resulting surface. Given a set of profiles (i.e. curves on surface) and/or spatial faces, the Bridge SOP builds a NURBS skin with specified tangent and curvature characteristics. The precision of the resulting surface is highly dependent on the number of required cross-sections and on the quality of the profile extraction. High precisions will generate a very dense surface with, potentially, many multiple knots.\t\t\t\n\t\t\t\nIn general, the higher the order of the curve, the better the fit the Bridge SOP will be able to provide. However, it is generally better to stick to cubics (order 4) curves, as the software is optimized for cubics.\t\t\t\n\t\t\t\nBecause the Bridge SOP can join both a set of spatial curves and trim curves, it can be used much like the Skin SOP and/or the Fillet <span>SOP</span>. However, bridging trimmed surfaces is more expensive than bridging carved surfaces.\t\t\t\n\t\t\t\nYou will usually need a Trim, Bridge, or Profile SOP after a Project SOP.\t\t\t\n\t\t\t\n* Use a Trim SOP to cut a hole in the projected surface\t\t\t\n* Use a Bridge SOPto skin the profile curve to another profile curve.\t\t\t\n* Use a Profile SOP to extract the curve on surface or remap it's position.\t\t\t\n\t\t\t\n'''Note:''' To texture-map the resulting skin, use an Orthographic projection rather than a Spline-based projection. This results in better continuity across the surfaces.",
        "opFamily": "SOP",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "cacheSOP": {
        "label": "cacheSOP",
        "members": [
            {
                "text": "Toggle : While On, this node will cache a single snapshot of it's input's geometry each cook.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : Cooks 'Cache Size' number of times to fill the Cache SOP with geometry. When set > 0, it will fill the cache. If set > 0 during playback, it will fill immediately. If set > 0 and saved out, then next time the file is opened the cache will pre-fill. While this is > 0, the node behaves as if the 'On' parameter is 0. If set to 0, then back > 0, it will clear the previous data, and pre-fill again. For more information refer to the [[Pre-Filling]] article.",
                "type": "TogglePar",
                "name": "prefill",
                "items": []
            },
            {
                "text": "Int : The size of the cache.",
                "type": "IntPar",
                "name": "cachesize",
                "items": []
            },
            {
                "text": "Int : The number of frames that the node will cook before it caches another geometry. When set to 1, it will cache every cook, when set to 2, it will cache every two cooks, etc.",
                "type": "IntPar",
                "name": "step",
                "items": []
            },
            {
                "text": "Float : Determines which cached geometry to output. 0 is the most recent cached geometry. Valid values are between 0 and cachesize - 1.",
                "type": "FloatPar",
                "name": "outputindex",
                "items": []
            },
            {
                "text": "Toggle : Store a single topology for the first cached geometry and only point data for the remaining geometries.",
                "type": "TogglePar",
                "name": "cachepoints",
                "items": []
            },
            {
                "text": "Toggle : Interpolate points between geometries.",
                "type": "TogglePar",
                "name": "blendpos",
                "items": []
            },
            {
                "text": "Toggle : When On, clears out all of the cached geometry.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly clears out all of the cached geometry.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "cacheSOP_Class",
        "opType": "cache",
        "short": "The Cache SOP collects its input geometry in a cache for faster random-access playback of multiple SOPs.",
        "opFilter": "True",
        "opLabel": "Cache",
        "long": "The Cache SOP collects its input geometry in a cache for faster random-access playback of multiple SOPs. It should be used when cook times for a chain of <span>SOP</span>s is long and a quicker playback is needed.\n\t\nOnce cached, the geometries can be accessed in any order. This is advantageous to a 2D flipbook or scene render since the geometry is still fully 3-Dimensional. The upshot being that you can scrub otherwise sluggish animations in real time because things are precomputed and stored in a cache.",
        "opFamily": "SOP",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "captureregionSOP": {
        "label": "captureregionSOP",
        "members": [
            {
                "text": "Menu : Defines the direction axis of the region. Use Z axis when the region is inside a bone object.\t\n\t\t\t\n[[Image:TouchGeometry46.gif]]",
                "type": "MenuPar",
                "name": "orient",
                "items": []
            },
            {
                "text": "XYZ : Position of the center of the region.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Position of the center of the region.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Position of the center of the region.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "Float : Height of the region from the centre to the top cap.",
                "type": "FloatPar",
                "name": "theight",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "tcapx",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "tcapy",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "tcapz",
                "items": []
            },
            {
                "text": "Float : Height of the region from the centre to the top cap.",
                "type": "FloatPar",
                "name": "bheight",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "bcapx",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "bcapy",
                "items": []
            },
            {
                "text": "XYZ : The X, Y, Z radii of the top/bottom hemisphere.",
                "type": "XYZPar",
                "name": "bcapz",
                "items": []
            },
            {
                "text": "Float : Defines the weight of a point exactly on the centre line and edge of the region respectively. Point weights in-between are blended.",
                "type": "FloatPar",
                "name": "weight",
                "items": []
            },
            {
                "text": "RGB : The Capture Region SOP<uses region colors for helpful feedback.\t\n\t\t\t\nBy default the region inherits the color of its containing object (via an expression).",
                "type": "RGBPar",
                "name": "colorr",
                "items": []
            },
            {
                "text": "RGB : The Capture Region SOP<uses region colors for helpful feedback.\t\n\t\t\t\nBy default the region inherits the color of its containing object (via an expression).",
                "type": "RGBPar",
                "name": "colorg",
                "items": []
            },
            {
                "text": "RGB : The Capture Region SOP<uses region colors for helpful feedback.\t\n\t\t\t\nBy default the region inherits the color of its containing object (via an expression).",
                "type": "RGBPar",
                "name": "colorb",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Capture Region SOP defines capture region (cregion), which is a type of primitive which can be thought of as a modified tube primitive (a tube with half a sphere on either end). The hemispheres on the ends of the tubes are called \"caps\". Like any other primitive, each Capture Region has a primitive number and can be assigned primitive attributes. A Capture Region is simply a volume which is used to define the point capture weighting for a geometry. It is then animated to deform the geometry.\t\t\n\t\t\t\nCapture Regions are always shown in wireframe (even in shaded mode) so that you can focus on the geometry for which the region will act on.",
        "opLabel": "Capture Region",
        "opLicense": "Non-Commercial",
        "opFamily": "SOP",
        "short": "The Capture Region SOP defines capture region (cregion), which is a type of primitive which can be thought of as a modified tube primitive (a tube with half a sphere on either end).",
        "opType": "cregion",
        "opFilter": "False",
        "opClass": "captureregionSOP_Class",
        "opCategories": ""
    },
    "captureSOP": {
        "label": "captureSOP",
        "members": [
            {
                "text": "StrMenu : Specify the point groups from the first input (input0) to operate on.",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Object : An object hierarchy is traversed to find the Capture Regions with which to do the weighting. This parameter specifies the top of the traversal hierarchy.",
                "type": "ObjectPar",
                "name": "rootbone",
                "items": []
            },
            {
                "text": "Menu : Use this menu to specify where to get the weight from.",
                "type": "MenuPar",
                "name": "weightfrom",
                "items": []
            },
            {
                "text": "Int : Specifies the frame number to do the capture computations. Every time TouchDesigner reaches this frame, the geometry will be re-captured. It is a common practice to set the <span class=\"tipTextSOP\">Capture Frame</span> to an frame outside of your animation range, -1 for example. Specifies the frame number to do the capture computations. Every time TouchDesigner reaches this frame, the geometry will be re-captured. It is a common practice to set the <span class=\"tipTextSOP\">Capture Frame</span> to an frame outside of your animation range, -1 for example.\t\n\t\t\t\n'''Note:''' When a .toe file is loaded, all of the associated capture regions are evaluated at the <span class=\"tipTextSOP\">Capture Frame</span>. Keyframes must be set to position the capture regions properly at the <span class=\"tipTextSOP\">Capture Frame</span>, otherwise the geometry will be weighted incorrectly upon the subsequent file loads.",
                "type": "IntPar",
                "name": "captframe",
                "items": []
            },
            {
                "text": "Menu : This option colors each point by capture region (using point attributes) according to its capture weight. The points inherit their colors from the Capture Region(s) in which they lie. For example, if a point falls within a blue capture region and also a yellow capture region, the point will be colored green (more blue near if the blue weighting dominates, and more yellow if the yellow weight dominates). In addition, the points become darker as the weighting gets lighter. For example, near the edge of a blue region, a caught point will appear dark blue. Near the centre, it will appear bright blue. If a point is not caught by any region, it is colored bright red.",
                "type": "MenuPar",
                "name": "color",
                "items": []
            },
            {
                "text": "File : The name of the capture override file (<code>*.ocapt</code>). This file is loaded after TouchDesigner completes its point weighting. Each line of the override file lists a point number, a region (path and primitive number) and a weight. The points on the geometry are modified to use these custom weights.<!--TDparEnd-->\t\n\t\t\t\n'''Override File Format''' - Each line in the override file must have the following format:\t\t\t\n\t\t\t\nFor example:\t\t\t\n 0 /obj/chain_bone1/cregion 0 0.0 \t\t\t\n 0 /obj/chain_bone2/cregion 0 3.757989 \t\t\t\n 0 /obj/chain_bone3/cregion 0 1.757989\t\t\t\n\t\t\t\n\t\t\t\nThis weights point 0 to three regions (actually only two because the first entry has a weight of zero). Remember that the <span class=\"tipTextSOP\">Override File</span> is read after TouchDesigner does it's own capture weight computation, so in this case, if point 0 was originally assigned to region <code>/obj/chain_bone4/cregion 0</code>, this part of its weighting would be unchanged.\t\t\t\nThere is no upper limit to the number of regions that can be weighted to a point. If a point/region combination is in the file twice, the second one is used.\t\t\t\n\t\t\t\nFor example:\t\t\t\n 0 /obj/chain_bone1/cregion 0 1.0\t\t\t\n 0 /obj/chain_bone1/cregion 0 2.0\t\t\t\n\t\t\t\nThis causes the first entry to be ignored (a weighting of 2.0 is used).\t\t\t\n\t\t\t\nThe weight field is used to prescribe the relative amount of influence a region has on a point. It can be any number. The range of the weights computed by TouchDesigner are specified by the <span class=\"tipTextSOP\">Inner/Outer Weight</span> parameter of each Capture Region (please see [[Capture Region SOP]]).\t\t\t\nThe easiest way to a capture <span class=\"tipTextSOP\">Override File</span> is to use the <span class=\"tipTextSOP\">Save Override File</span> button (see below) and start from the file produced by TouchDesigner.",
                "type": "FilePar",
                "name": "captfile",
                "items": []
            },
            {
                "text": "File : The file specified here can be used as a \"working file\" to save the point weighting of all the points or a selected subset of points. The file format for the capture override files is fairly straight-forward (see above), so this is a good place to start if you need to do custom overriding.",
                "type": "FilePar",
                "name": "savefile",
                "items": []
            },
            {
                "text": "Toggle : This increments the <span class=\"tipTextSOP\">Save File</span> name before saving. Be careful about turning this option off because there is no warning or confirm dialog to prevent you from overwriting an .ocapt file.",
                "type": "TogglePar",
                "name": "autoincr",
                "items": []
            },
            {
                "text": "Pulse : This saves the point weighting of all points to the <span class=\"tipTextSOP\">Save File</span>.",
                "type": "PulsePar",
                "name": "savecaptfile",
                "items": []
            },
            {
                "text": "Pulse : This saves the point weighting only for the points that are selected in the viewport.\t\n\t\t\t\n<span class=\"tipTextSOP\">Note:</span> you must be editing this particular SOP in the Viewport for this selection to apply to this SOP.",
                "type": "PulsePar",
                "name": "savesel",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "capture",
        "opFilter": "True",
        "short": "The Capture SOP is used to weight points in a geometry to capture regions.",
        "opLicense": "Non-Commercial",
        "opClass": "captureSOP_Class",
        "opLabel": "Capture",
        "long": "The Capture SOP is used to weight points in a geometry to capture regions. The weighting scheme is described in the next section, [[Capture Region SOP]].\t\t\n\t\t\t\nThe weights and the regions they correspond to are transferred down the SOP chain as point and detail attributes.\t\t\t\n\t\t\t\nThe Capture SOP can take an optional second input to specify extra capture regions to use in the capture process. Any capture regions that are in this second input are processed after the capture regions that are in the object hierarchy specified by the <span class=\"tipTextSOP\">Hierarchy</span> parameter. You can also specify a second input and not specify a Parent Object at all.",
        "opFamily": "SOP",
        "opCategories": ""
    },
    "choptoSOP": {
        "label": "choptoSOP",
        "members": [
            {
                "text": "StrMenu : Modify only the points within this point group. If blank, all points are modified. Accepts patterns, as described in: [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "CHOP : Specifies which CHOP Network / CHOP contains the sample data to fetch.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "XYZ : Sets the bounds for positions that are not defined by a channel, ie. a channel is not set to one of the P attributes.",
                "type": "XYZPar",
                "name": "startposx",
                "items": []
            },
            {
                "text": "XYZ : Sets the bounds for positions that are not defined by a channel, ie. a channel is not set to one of the P attributes.",
                "type": "XYZPar",
                "name": "startposy",
                "items": []
            },
            {
                "text": "XYZ : Sets the bounds for positions that are not defined by a channel, ie. a channel is not set to one of the P attributes.",
                "type": "XYZPar",
                "name": "startposz",
                "items": []
            },
            {
                "text": "XYZ : Sets the bounds for positions that are not defined by a channel, ie. a channel is not set to one of the P attributes.",
                "type": "XYZPar",
                "name": "endposx",
                "items": []
            },
            {
                "text": "XYZ : Sets the bounds for positions that are not defined by a channel, ie. a channel is not set to one of the P attributes.",
                "type": "XYZPar",
                "name": "endposy",
                "items": []
            },
            {
                "text": "XYZ : Sets the bounds for positions that are not defined by a channel, ie. a channel is not set to one of the P attributes.",
                "type": "XYZPar",
                "name": "endposz",
                "items": []
            },
            {
                "text": "StrMenu : The names to use to modify the attributes.",
                "type": "StrMenuPar",
                "name": "chanscope",
                "items": []
            },
            {
                "text": "StrMenu : A string list of attributes to modify in the SOP. List of Common Attributes:\t\n\t\t\n* <code>'''P'''</code> - Point position (X, Y, Z) - 3 values\t\t\n* <code>'''Pw'''</code> - Point weight - 1 value\t\t\n* <code>'''Cd'''</code> - Point color (red, green, blue, alpha) - 4 values\t\t\n* <code>'''N'''</code> - Point normal (X, Y, Z) - 3 values\t\t\n* <code>'''uv'''</code> - Point texture coordinates (U, V, W) - 3 values\t\t\n\t\t\nSee [[Attributes]] for a complete listing of attributes.",
                "type": "StrMenuPar",
                "name": "attscope",
                "items": []
            },
            {
                "text": "Menu : Determines how the CHOP samples are mapped to the geometry points.",
                "type": "MenuPar",
                "name": "mapping",
                "items": []
            },
            {
                "text": "Toggle : Creates normals on the geometry.",
                "type": "TogglePar",
                "name": "compnml",
                "items": []
            },
            {
                "text": "Toggle : Creates tangents on the geometry.",
                "type": "TogglePar",
                "name": "comptang",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "chopto",
        "opFilter": "False",
        "short": "The CHOP to SOP takes CHOP channels and generates 3D polygons in a SOP.",
        "opLicense": "Non-Commercial",
        "opClass": "choptoSOP_Class",
        "opLabel": "CHOP to",
        "long": "The CHOP to SOP takes CHOP channels and generates 3D polygons in a SOP. It reads sample data from a [[CHOP]] and converts it into point positions and point attributes. This makes it complementary to the [[SOP to CHOP]]. The Channels created by the [[SOP to CHOP]] can be modified and then re-inserted into the SOP network via a CHOP to SOP.\t\n\t\t\nBy default, the SOP is a line from (<code>-1 0 0</code>) to (<code>1 0 0</code>) containing one point for every sample in the CHOP.\t\t\n \t\t\nIt matches the input channels to the Channel Scope (<code>tx ty tz</code>) where possible. If <code>tx</code> or <code>ty</code> or <code>tz</code> don\u2019t match anything, it just uses the value from the default line, and it only shows a Warning.\t\t\n\t\t\nThe simplest thing to do is to send it a channel named <code>ty</code>, which will make a 3D curve that looks like the CHOP curve.\t\t\n\t\t\nThis does what a [[Point SOP]] with a <code>op('wave1')['chan1'].eval(0)</code> function can do, but is much faster.\t\t\n\t\t\nBy using point groups from the incoming SOP, the channels can be inserted only into the group's points.\t\t\n\t\t\nThe CHOP to SOP also supports custom attributes. If the user maps a channel to an attribute that is not found, that attribute is added to the points.  Currently, all custom attributes are floats and of size = 1. \t\t\n\t\t\nIn its default state it will attempt to replace the point positions (<code>P(0) P(1) P(2)</code>) with the channels named <code>tx ty</code> and <code>tz</code>.\t\t\n\t\t\nThe channel and attribute scope are first expanded into individual names and matched on a 1 to 1 basis. If you are filling P it doesn't matter if you specify <code>t[xyz]</code> or <code>tx ty tz</code>, both will replace <code>P(0) P(1) P(2)</code>, which can be collapsed to <code>P</code>.\t\t\n\t\t\nFor example: Add custom attributes \"Scale\", \"Twist\" or \"Roll\" to the backbone's points with a CHOP to SOP.\t\t\n\t\t\nIf you connect a SOP to its input, it will use the SOP as a starting geometry versus the default line.",
        "opFamily": "SOP",
        "opCategories": ""
    },
    "circleSOP": {
        "label": "circleSOP",
        "members": [
            {
                "text": "Menu : For information on the different types, see the [http://www.derivativeinc.com/Tools/Touch000/Manual/Guides/GeoTypesGuide/GeometryTypes.pdf Geometry Types Guide]. Depending on the primitive type chosen, some SOP options may not apply.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : The plane on which the circle lies.",
                "type": "MenuPar",
                "name": "orient",
                "items": []
            },
            {
                "text": "Toggle : Available only when an input is connected to the Curcle SOP to set bounds for the sphere. When Modify Bounds = On the transform parameters below will further modify the radius and position of the bounds.",
                "type": "TogglePar",
                "name": "modifybounds",
                "items": []
            },
            {
                "text": "XY : The Radius of the Circle in the X and Y directions.",
                "type": "XYPar",
                "name": "radx",
                "items": []
            },
            {
                "text": "XY : The Radius of the Circle in the X and Y directions.",
                "type": "XYPar",
                "name": "rady",
                "items": []
            },
            {
                "text": "XYZ : The Center of the Circle in X, Y and Z.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : The Center of the Circle in X, Y and Z.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : The Center of the Circle in X, Y and Z.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "Toggle : Invert the direction of anchors.",
                "type": "TogglePar",
                "name": "reverseanchors",
                "items": []
            },
            {
                "text": "Float : Set the point in X about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchoru",
                "items": []
            },
            {
                "text": "Float : Set the point in Y about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorv",
                "items": []
            },
            {
                "text": "Int : If a spline curve is selected, it is built at this order.",
                "type": "IntPar",
                "name": "order",
                "items": []
            },
            {
                "text": "Int : The number of edges (points +1) used to describe the circle. This option applies to polygons and imperfect splines. The more <span class=\"tipTextSOP\">Divisions</span> a circle has, the smoother it looks. Using three divisions makes a triangle, four divisions a diamond, five divisions a pentagon, and so on. Also, for open arc types, the number of points will equal <span class=\"tipTextSOP\">Divisions</span> + 1, and for closed arc types, <span class=\"tipTextSOP\">Divisions</span> + 2.",
                "type": "IntPar",
                "name": "divs",
                "items": []
            },
            {
                "text": "Menu : Determines how the circle should be drawn. Applies to polygons and imperfect splines only.",
                "type": "MenuPar",
                "name": "arc",
                "items": []
            },
            {
                "text": "Float : The beginning and ending angles of the arc. An arc will start at the beginning angle, and proceed towards the ending angle. If beginning=0 and end=360 it will be a full circle. As a reference:\t\n\t\t\n<div><center>[[Image:TouchGeometry222.gif]]</center></div>\t\t\n\t\t\n'''Note:''' The total angle can exceed 360, making multiple wraps of the circle.",
                "type": "FloatPar",
                "name": "angle",
                "items": []
            },
            {
                "text": "Toggle : This option applies only to Bezier and NURBS circles. If selected, the circles are approximated non-rational curves, otherwise they are perfect rational closed curves.",
                "type": "TogglePar",
                "name": "imperfect",
                "items": []
            },
            {
                "text": "Menu : Option to include texture cooordinates or not.",
                "type": "MenuPar",
                "name": "texture",
                "items": []
            },
            {
                "text": "Toggle : When On, normals are created for the surface.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "circle",
        "opFilter": "False",
        "short": "The Circle SOP creates open or closed arcs, circles and ellipses.",
        "opLicense": "Non-Commercial",
        "opClass": "circleSOP_Class",
        "opLabel": "Circle",
        "long": "The Circle SOP creates open or closed arcs, circles and ellipses.\t\n\t\t\nIf two NURBS circles that are non-rational (i.e. their X and Y radii are unequal) are skinned, more isoparms may be generated than expected. This is because non-rational NURBS circles parameterise their knots based on chord length, and the Skin SOP must consolidate the total number of knots between the two circles before skinning.\t\t\n\t\t\nTo remedy this, you may want to use a Refine SOP, and unrefine the resulting skin, or better yet - before unrefining, start with the same circle and use a Primitive or Transform SOP to deform the second copy before skinning.",
        "opFamily": "SOP",
        "opCategories": ""
    },
    "claySOP": {
        "label": "claySOP",
        "members": [
            {
                "text": "Toggle : Determines whether the clay operation affects the U parametric direction. Both faces and surfaces respond to this option. If the primitives are face types and the toggle is off, clay doesn't change the inputs at all. If the inputs are surfaces and U is off, clay will pull the surfaces along the entire V direction (if V is on) or not at all.",
                "type": "TogglePar",
                "name": "uwarp",
                "items": []
            },
            {
                "text": "Float : This value defines a point in the parametric space of a face, representing the location to be affected by the clay operation. This location is referred to as the \"target\". For surfaces, U defines a line of constant value in the parametric space of the primitive and requires a second coordinate - V - to specify a unique location (see the V> Page below). Spline faces and surfaces have explicit parametric spaces known as domains; since domains are not restricted to the unit range [0, 1], the Clay SOP maps U to the real domain value of the primitive. For polygons and meshes, U is expressed in terms of the number or vertices and columns respectively and in terms of their relative positions.",
                "type": "FloatPar",
                "name": "u",
                "items": []
            },
            {
                "text": "Toggle : Indicates whether the clay algorithm should use the bias it thinks works best for the given U parameter, or take the value explicitly stated beside the toggle. Since clay affects the CVs in the neighbourhood of the given parametric location, the bias can influence the amount of pull applied to the CVs on either side of this location. The effect is a slant of the \"wave\" the parametric point rides on - towards one side or the other.",
                "type": "TogglePar",
                "name": "uusebias",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "ubias",
                "items": []
            },
            {
                "text": "Float : This parameter affects only NURBS curves and surfaces. The pull generated by clay on these primitives can be smooth or sharp depending on the position of the target relative to the underlying domain (the farther away from a knot, the rounded the bulge) and the knot multiplicity near the target (the higher the multiplicity the sharper the pull). If the pull is too round or affects too big an area in U, the U Sharpness parameter can reduce it by inserting one or more knots at the target U value. When the U Sharpness is zero no knots are inserted. When the U Sharpness is 1, all \"degree\" knots are inserted and the shape becomes very sharp. The U Sharpness varies in discrete steps; the number of steps equals the U degree of the spline.\t\n\t\t\t\n'''Note:''' The range of the U Sharpness slider varies with the degree of the spline (i.e. the closer it is to 1, the more knots it adds). Since the number of knots added forms a discrete sequence, the slider will automatically jump to the valid positions.",
                "type": "FloatPar",
                "name": "usharp",
                "items": []
            },
            {
                "text": "Toggle : Determines whether the clay operation affects the V parametric direction of the surface. If the inputs are surfaces and V if off, clay will pull the surfaces along the entire U direction (if U is on) or not at all. If both U and V are on, clay will pull the surface at the target (U, V) point specified in the U and V folders below. This option does not affect face types.",
                "type": "TogglePar",
                "name": "vwarp",
                "items": []
            },
            {
                "text": "Float : This value affects only surface types. V defines a line of constant value in the parametric space of the surface and together with U specifies a unique location in that space. Spline surfaces have explicit parametric spaces known as domains; since domains are not restricted to the unit range [0, 1], the Clay SOP maps V to the real domain value of the surface. For meshes, V is expressed in terms of the number or rows and their relative positions.",
                "type": "FloatPar",
                "name": "v",
                "items": []
            },
            {
                "text": "Toggle : Indicates whether the clay algorithm should use the bias it thinks works best for the given V parameter, or take the value explicitly stated beside the toggle. Since clay affects the CVs in the neighbourhood of the given parametric location, the bias can influence the amount of pull applied to the CVs on either side of this location. The effect is a slant of the \"wave\" the parametric point rides on -- towards one side or the other.",
                "type": "TogglePar",
                "name": "vusebias",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "vbias",
                "items": []
            },
            {
                "text": "Float : This parameter affects only NURBS surfaces. The pull generated by clay on these primitives can be smooth or sharp depending on the position of the target relative to the underlying domain (the farther away from a knot, the rounded the bulge) and the knot multiplicity near the target (the higher the multiplicity the sharper the pull). If the pull is too round or affects too big an area in V, the V Sharpness parameter can reduce it by inserting one or more knots at the target V value. When the V Sharpness is zero no knots are inserted. When the V Sharpness is 1, all \"degree\" knots are inserted and the surface becomes very sharp. The V Sharpness varies in discrete steps; the number of steps equals the V degree of the spline.\t\n\t\t\t\n'''Note:''' The range of the V Sharpness slider varies with the degree of the spline (i.e. the closer it is to 1, the more knots it adds). Since the number of knots added forms a discrete sequence, the slider will automatically jump to the valid positions.",
                "type": "FloatPar",
                "name": "vsharp",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "clay",
        "opFilter": "True",
        "short": "The Clay SOP deforms faces and surfaces by pulling points that lie directly on them.",
        "opLicense": "Non-Commercial",
        "opClass": "claySOP_Class",
        "opLabel": "Clay",
        "long": "The Clay SOP deforms faces and surfaces by pulling points that lie directly on them. As opposed to the Point SOP or other SOPs that manipulate control points (CVs), the Clay SOP operates on the primitive contours themselves, providing a direct, intuitive, and unconstrained way of reshaping geometry. Thus, rather than translating CVs to change the aspect of the primitive, the Clay SOP takes the inverse approach of manipulating the primitive's skin to reposition the CVs.\t\t\n\t\t\t\nThe point that defines the area to be modified is called a \"target point\" or \"target\" for short. It is expressed as a (u,v) pair in the parametric space of the primitive and ranges between 0 and 1 in both U and V. The image of the target point on the primitive is a 3D point which Clay can displace in several ways. Furthermore, if the primitive is a surface, there is are options to pull only the point or a whole isoparametric curve in either U or V.\t\t\t\n\t\t\t\nClay does not refine the faces and surfaces unless asked to, so the complexity of the geometry does not increase. The area affected by the change varies with each primitive type and topology. In all cases it is possible to reduce to amount of change by inserting a Refine SOP before the Clay SOP and inserting detail around the target point. For other ways to increase the locality of the deformation as well as its sharpness, see U and V Sharpness below.\t\t\t\n\t\t\t\nIf a second input is present, it is possible to snap the target (u,v) point to an (s,t) point on the first primitive of the second input. Without a second input, the primitives can be made to snap to themselves. Moreover, the Clay SOP is able to snap the target to arbitrary points in space.\t\t\t\n\t\t\t\nBoth this SOP and the Align SOP can be used effectively as snapping tools and building blocks for curve networks. The main difference between the two SOPs is that Clay deforms the inputs partially, while Align translates and/or rotates the whole primitive.\t\t\t\n\t\t\t\nThe Clay SOP accepts a mix of any combination of face and surface types.",
        "opFamily": "SOP",
        "opCategories": ""
    },
    "clipSOP": {
        "label": "clipSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in Pattern Matching in the [http://www.derivativeinc.com/Tools/Touch000/Manual/Guides/ScriptingGuide/ScriptingGuide.pdf Scripting Guide.]",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Options controlling what part of the clip to keep:",
                "type": "MenuPar",
                "name": "clipop",
                "items": []
            },
            {
                "text": "Float : Allows you to move the cutting plane along the Direction vector. If the <span class=\"tipTextSOP\">Direction</span> (plane's normal) is <code>0 1 0</code>, putting a positive number in the <span class=\"tipTextSOP\">Distance</span> field moves the plane up in Y.",
                "type": "FloatPar",
                "name": "dist",
                "items": []
            },
            {
                "text": "XYZ : The default values of <code>0 1 0</code> creates a Normal vector straight up in Y, which is perpendicular to the XZ plane, which becomes the clipping plane. <code>1 0 0</code> points the normal in positive X, giving a clipping plane in YZ. The plane may be positioned at an angle by using values typed in (<code>1 1 0</code> gives a 45 angle plane) or interactively by using the direction vector jack.",
                "type": "XYZPar",
                "name": "dirx",
                "items": []
            },
            {
                "text": "XYZ : The default values of <code>0 1 0</code> creates a Normal vector straight up in Y, which is perpendicular to the XZ plane, which becomes the clipping plane. <code>1 0 0</code> points the normal in positive X, giving a clipping plane in YZ. The plane may be positioned at an angle by using values typed in (<code>1 1 0</code> gives a 45 angle plane) or interactively by using the direction vector jack.",
                "type": "XYZPar",
                "name": "diry",
                "items": []
            },
            {
                "text": "XYZ : The default values of <code>0 1 0</code> creates a Normal vector straight up in Y, which is perpendicular to the XZ plane, which becomes the clipping plane. <code>1 0 0</code> points the normal in positive X, giving a clipping plane in YZ. The plane may be positioned at an angle by using values typed in (<code>1 1 0</code> gives a 45 angle plane) or interactively by using the direction vector jack.",
                "type": "XYZPar",
                "name": "dirz",
                "items": []
            },
            {
                "text": "Toggle : When checked, allows you to generate specific groups for the geometry above and below the cutting plane. See the two group option fields below. This option is only available when <span class=\"tipTextSOP\">All Primitives</span> are kept.",
                "type": "TogglePar",
                "name": "newg",
                "items": []
            },
            {
                "text": "Str : When <span class=\"tipTextSOP\">Create Groups</span> is checked, you can assign the geometry below the cutting plane to the <span class=\"tipTextSOP\">Group</span> name typed in this field.",
                "type": "StrPar",
                "name": "above",
                "items": []
            },
            {
                "text": "Str : When <span class=\"tipTextSOP\">Create Groups</span> is checked, you can assign the geometry above the cutting plane to the <span class=\"tipTextSOP\">Group</span> name typed in this field.",
                "type": "StrPar",
                "name": "below",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "clip",
        "opFilter": "True",
        "short": "The Clip SOP cuts and creases source geometry with a plane.",
        "opLicense": "Non-Commercial",
        "opClass": "clipSOP_Class",
        "opLabel": "Clip",
        "long": "The Clip SOP cuts and creases source geometry with a plane.",
        "opFamily": "SOP",
        "opCategories": ""
    },
    "convertSOP": {
        "label": "convertSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Determines which geometry by type will be converted. The default is All Types:",
                "type": "MenuPar",
                "name": "fromtype",
                "items": []
            },
            {
                "text": "Menu : Determines what the above From Type geometry will be converted to. Conversion to Polygons is the default:\t\n\t\t\n\t\t\n'''Notes''':\t\t\nNot all geometry can be converted to specific types. For example, a triangulated polygon surface to a single NURBS surface, or a Mesh sphere into a primitive sphere. Also, certain conversions will preserve shapes. For example, converting a Bzier curve to a NURBS curve or a polygonal mesh to a NURBS Surface.\t\t\n\t\t\n'''Circle Notes''': Converting to primitive circles is available for action users who are used to working with polygon circles so that you can convert them to primitive circles for the TouchDesigner Skeleton, Arm, and Limb SOPs.\t\t\n\t\t\n'''Trimmed Surface Notes''': If the primitive to be converted is a curve (NURBS or Bezier) and is flat, a trimmed surface will be generated such that the visible piece coincides with the curve. If the curve is not flat, it will be converted to a non-trimmed surface. The advantage of the trimmed solution is that it yields a very clean surface and handles concave curves perfectly.",
                "type": "MenuPar",
                "name": "totype",
                "items": []
            },
            {
                "text": "Menu : This option is used to select how the points of the created surface are connected.",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "Float : When set to Level of Detail, controls the number of points or CVs that are used in the newly generated geometry depending on the above setting. Converting a NURBS surface into a polygon mesh with a Level of Detail of 1 results in a fair approximation of the NURBS surface whereas a value of 2 generates a very dense polygonal mesh.\n\t\t\nWhen set to Divisions per Span, specificies the number of divisions per span.\t\t\n\t\t\n'''Tip:''' Animate the Level of Detail based on how close your character or geometry is to the camera by using the <code>primdist()</code> expression. Then the detail will increase/decrease as the camera gets closer/further away.",
                "type": "FloatPar",
                "name": "lodu",
                "items": []
            },
            {
                "text": "Float : When set to Level of Detail, controls the number of points or CVs that are used in the newly generated geometry depending on the above setting. Converting a NURBS surface into a polygon mesh with a Level of Detail of 1 results in a fair approximation of the NURBS surface whereas a value of 2 generates a very dense polygonal mesh.\n\t\t\nWhen set to Divisions per Span, specificies the number of divisions per span.\t\t\n\t\t\n'''Tip:''' Animate the Level of Detail based on how close your character or geometry is to the camera by using the <code>primdist()</code> expression. Then the detail will increase/decrease as the camera gets closer/further away.",
                "type": "FloatPar",
                "name": "lodv",
                "items": []
            },
            {
                "text": "Float : The trimmed part of a surface will be converted using this Trim lod (level of detail) instead of using an implicit \"1\" constant.",
                "type": "FloatPar",
                "name": "lodtrim",
                "items": []
            },
            {
                "text": "Int : When set to Level of Detail, controls the number of points or CVs that are used in the newly generated geometry depending on the above setting. Converting a NURBS surface into a polygon mesh with a Level of Detail of 1 results in a fair approximation of the NURBS surface whereas a value of 2 generates a very dense polygonal mesh.\n\t\t\nWhen set to Divisions per Span, specificies the number of divisions per span.\t\t\n\t\t\n'''Tip:''' Animate the Level of Detail based on how close your character or geometry is to the camera by using the <code>primdist()</code> expression. Then the detail will increase/decrease as the camera gets closer/further away.",
                "type": "IntPar",
                "name": "divu",
                "items": []
            },
            {
                "text": "Int : When set to Level of Detail, controls the number of points or CVs that are used in the newly generated geometry depending on the above setting. Converting a NURBS surface into a polygon mesh with a Level of Detail of 1 results in a fair approximation of the NURBS surface whereas a value of 2 generates a very dense polygonal mesh.\n\t\t\nWhen set to Divisions per Span, specificies the number of divisions per span.\t\t\n\t\t\n'''Tip:''' Animate the Level of Detail based on how close your character or geometry is to the camera by using the <code>primdist()</code> expression. Then the detail will increase/decrease as the camera gets closer/further away.",
                "type": "IntPar",
                "name": "divv",
                "items": []
            },
            {
                "text": "Int : The trimmed part of a surface will be converted using this Trim lod (level of detail) instead of using an implicit \"1\" constant.",
                "type": "IntPar",
                "name": "divtrim",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "convert",
        "opFilter": "True",
        "short": "The Convert SOP converts geometry from one geometry type to another type.",
        "opLicense": "Non-Commercial",
        "opClass": "convertSOP_Class",
        "opLabel": "Convert",
        "long": "The Convert SOP converts geometry from one geometry type to another type. Types include polygon, mesh, Bezier patche, particle and sphere primitive.",
        "opFamily": "SOP",
        "opCategories": ""
    },
    "copySOP": {
        "label": "copySOP",
        "members": [
            {
                "text": "StrMenu : Specifies a subset of input primitives to copy from. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "sourcegrp",
                "items": []
            },
            {
                "text": "StrMenu : Specifies a subset of template primitives from which to copy onto. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "templategrp",
                "items": []
            },
            {
                "text": "Int : Sets number of Copies to be made of the source. For a template input, it specifies the number of copies to be placed at each point of the template.",
                "type": "IntPar",
                "name": "ncy",
                "items": []
            },
            {
                "text": "Int : Defines how many primitives to copy from each point.",
                "type": "IntPar",
                "name": "nprims",
                "items": []
            },
            {
                "text": "Toggle : Only used when a template input is specified. If the template is a sphere, and the first input is a circle, a circle is placed at each point of the sphere. With this option on, all the circles will re-orient to face the surface of the sphere (a default sphere has normals radiating outwards from the center).\t\n\t\t\t\nIf an up attribute exists on the template geometry, then this will be used (along with the normal) to fully define the rotates for the copies. An up attribute is created with the Point SOP.",
                "type": "TogglePar",
                "name": "nml",
                "items": []
            },
            {
                "text": "Toggle : Each transformation \"builds\" on the location left by the one before it. Transformations are cumulative as the Copy SOP produces new copies.",
                "type": "TogglePar",
                "name": "cum",
                "items": []
            },
            {
                "text": "Menu : Sets the overall transform order for the transformations. The <span class=\"tipTextSOP\">Transform Order</span> determines the order in which transformations take place. Depending on the order, you can achieve different results using the exact same values. Choose the appropriate order from the menu.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : Sets the order of the rotations within the overall transform order.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : These allow you to specify the Translation (how much it moves over in a given direction), Rotation, and the Scale between each copy. Three columns are given for X, Y, and Z coordinates. Guide geometry is provided for the Pivot's translations. The Pivot is represented by a single red dot in the Viewport. Changing the Pivot parameters moves this point of reference.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            },
            {
                "text": "Float : Uniform Scale allows you to shrink or enlarge geometry along all three axes simultaneously.",
                "type": "FloatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Toggle : Vector type attributes (i.e. normals, velocity) maintain the same length under transforms. i.e. When geometry is scaled, the normals remain constant in length.",
                "type": "TogglePar",
                "name": "vlength",
                "items": []
            },
            {
                "text": "Toggle : If selected, this creates a group for each copy number, and places each primitive created at that stage into it.",
                "type": "TogglePar",
                "name": "newg",
                "items": []
            },
            {
                "text": "Str : Defines the base name of the groups created.",
                "type": "StrPar",
                "name": "copyg",
                "items": []
            },
            {
                "text": "OBJ : Orients the copied geometry to lookat, or point to, the [[Object|object]] component specified in the parameter.",
                "type": "OBJPar",
                "name": "lookat",
                "items": []
            },
            {
                "text": "XYZ : When specifying a Look At, it is possible to specify an up vector for the lookat. Without using an up vector, it is possible to get poor animation when the lookat object passes through the Y axis of the target object.",
                "type": "XYZPar",
                "name": "upvectorx",
                "items": []
            },
            {
                "text": "XYZ : When specifying a Look At, it is possible to specify an up vector for the lookat. Without using an up vector, it is possible to get poor animation when the lookat object passes through the Y axis of the target object.",
                "type": "XYZPar",
                "name": "upvectory",
                "items": []
            },
            {
                "text": "XYZ : When specifying a Look At, it is possible to specify an up vector for the lookat. Without using an up vector, it is possible to get poor animation when the lookat object passes through the Y axis of the target object.",
                "type": "XYZPar",
                "name": "upvectorz",
                "items": []
            },
            {
                "text": "Toggle : When enabled, it will Stamp proceeding variables for each input copied.",
                "type": "TogglePar",
                "name": "stamp",
                "items": []
            },
            {
                "text": "Str : Token of each stamp variable. Stamped parameters are accessible via the global <syntaxhighlight lang=python inline>fetchStamp()</syntaxhighlight> method in the [[td Module]] in python, or <code>param()</code> in tscript. See the example, below.",
                "type": "StrPar",
                "name": "param1",
                "items": []
            },
            {
                "text": "Float : Value of each stamp variable. Stamped parameters are accessible via the global <syntaxhighlight lang=python inline>fetchStamp()</syntaxhighlight> method in the [[td Module]] in python, or <code>param()</code> in tscript. See the example, below.",
                "type": "FloatPar",
                "name": "val1",
                "items": []
            },
            {
                "text": "Toggle : Enables the parameters below to allow template point attributes to be applied to the copied source geometry.",
                "type": "TogglePar",
                "name": "doattr",
                "items": []
            },
            {
                "text": "StrMenu : Copy the attributes to the source geometry's points.",
                "type": "StrMenuPar",
                "name": "setpt",
                "items": []
            },
            {
                "text": "StrMenu : Copy the attributes to the source geometry's primitives.",
                "type": "StrMenuPar",
                "name": "setprim",
                "items": []
            },
            {
                "text": "StrMenu : Copy the attributes to the source geometry's vertices.",
                "type": "StrMenuPar",
                "name": "setvtx",
                "items": []
            },
            {
                "text": "StrMenu : Multiply the attributes with the source geometry's point attributes.",
                "type": "StrMenuPar",
                "name": "mulpt",
                "items": []
            },
            {
                "text": "StrMenu : Multiply the attributes with the source geometry's primitive attributes.",
                "type": "StrMenuPar",
                "name": "mulprim",
                "items": []
            },
            {
                "text": "StrMenu : Multiply the attributes with the source geometry's vertex attributes.",
                "type": "StrMenuPar",
                "name": "mulvtx",
                "items": []
            },
            {
                "text": "StrMenu : Add the attributes to the source geometry's point attributes.",
                "type": "StrMenuPar",
                "name": "addpt",
                "items": []
            },
            {
                "text": "StrMenu : Add the attributes to the source geometry's primitive attributes.",
                "type": "StrMenuPar",
                "name": "addprim",
                "items": []
            },
            {
                "text": "StrMenu : Add the attributes to the source geometry's vertex attributes.",
                "type": "StrMenuPar",
                "name": "addvtx",
                "items": []
            },
            {
                "text": "StrMenu : Subtract the attributes from the source geometry's point attributes.",
                "type": "StrMenuPar",
                "name": "subpt",
                "items": []
            },
            {
                "text": "StrMenu : Subtract the attributes from the source geometry's primitive attributes.",
                "type": "StrMenuPar",
                "name": "subprim",
                "items": []
            },
            {
                "text": "StrMenu : Subtract the attributes from the source geometry's vertex attributes.",
                "type": "StrMenuPar",
                "name": "subvtx",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "SOP",
        "opFilter": "True",
        "opType": "copy",
        "opLicense": "Non-Commercial",
        "opClass": "copySOP_Class",
        "short": "The Copy SOP lets you make copies of the geometry of other SOPs and apply a transformation to each copy.",
        "long": "The Copy SOP lets you make copies of the geometry of other SOPs and apply a transformation to each copy.\t\t\n\t\t\t\nIt also allows you to copy geometry to points on an input template.",
        "opLabel": "Copy",
        "opCategories": ""
    },
    "cplusplusSOP": {
        "label": "cplusplusSOP",
        "members": [
            {
                "text": "File : The path to the plugin you want to load.",
                "type": "FilePar",
                "name": "plugin",
                "items": []
            },
            {
                "text": "Toggle : When this parameter is On, it will delete the instance of the class created by the plugin, and create a new one.",
                "type": "TogglePar",
                "name": "reinit",
                "items": []
            },
            {
                "text": "Pulse : Instantly reinitialize the class.",
                "type": "PulsePar",
                "name": "reinitpulse",
                "items": []
            },
            {
                "text": "Toggle : When this parameter goes above 1, it will delete the instance of the class created by the plugin and unload the plugin. If multiple SOPs have loaded the same plugin they will all need to unload it to release the file.",
                "type": "TogglePar",
                "name": "unloadplugin",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "SOP",
        "opType": "cplusplus",
        "opLabel": "CPlusPlus",
        "opLicense": "Non-Commercial",
        "opClass": "cplusplusSOP_Class",
        "opFilter": "False",
        "short": "The CPlusPlus SOP allows you to make custom SOP operators by writing your own plugin using C++.",
        "long": "The CPlusPlus SOP allows you to make custom SOP operators by writing your own plugin using C++.\n\nSee [[Write a CPlusPlus Plugin]] and the other articles in the [[:Category:C++|C++ category]] for more detailed information on how to make .dll for use with this SOP.\n \nThe C++ code can be written for GPU or CPU loading. The ease of developing C++ code for either of these two options are fairly similar. Nevertheless, by setting the \u201c<code>directToGPU</code>\u201d flag within the C++ code, only one of these modes is recognized as a valid mode. Different classes are dedicated for each of these two modes, so bear in mind that setting the \u201c<code>directToGPU</code>\u201d flag to \u201c<code>true</code>\u201d or \u201c<code>false</code>\u201d requires different classes and functions to be called within either of <code>execute()</code> or <code>executeVBO()</code>.\n\nIn CPU mode, the geometry data can be added one at a time or all at once. As well, in CPU mode the CPlusPlus SOP can use wired SOP inputs and SOP to DAT, SOP to CHOP, or SOP output OPs as well. Additionally DAT, CHOP, and TOP 'non-wired' input operators can be used as custom parameters. In this case, the custom parameters must be first handled in the C++ code to be able to accept any input from the other operators. \n\nThe GPU direct mode is similar to CPU mode, but it cannot use any output SOPs downstream or be accessed by SOP to DAT or SOP to CHOP operators. In GPU direct mode the data is added to the VBO buffers immediately which improves the performance through faster updating, however the size of the vertices and face array indices must be known prior to filling the buffers. \n\nExample for CPlusPlus SOP as a Visual Studio project in Windows are available in <code>C:/Program Files/Derivative/TouchDesigner/Samples/CPlusPlus/SimpleShapesSOP</code> or your custom TouchDesigner installation folder. (NOTE: On macOS it is here: <code>TouchDesigner.app/Contents/Resources/tfs/Samples/CPlusPlus/SimpleShapesSOP</code>)\n\n'''Custom Parameters''' - Custom Parameters can be automatically created by the C++ SOP <code>.dll</code>. This custom parameter page can be removed, edited, or appended to from within the <code>setupParameters()</code> function in SimpleShapes.cpp. The defined custom parameters can be enabled or disabled depending on whether they are valid for a specific task or not. \n\n'''Geometry Data''' - Geometry within the C++ SOP code can be defined by any algorithm or even imported from external files. The possible geometries are triangular meshes and particle systems. Note that if your original geometry has polygons with more than 3 vertices, they must be converted to triangles with known and valid vertex indices, before being added to the list of triangles.\n\nThe geometry data for exporting to TouchDesigner can have point, normal, and texture coordinates, RGBA colors, triangle information in case of meshes and/or particle systems, as well as custom attributes with an arbitrary name, float or integer type, and up to 4 components (ie. Cd0, Cd1, Cd2, Cd3).",
        "opCategories": ""
    },
    "creepSOP": {
        "label": "creepSOP",
        "members": [
            {
                "text": "Pulse : Reset's the creep state based on Reset Method parameter below.",
                "type": "PulsePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Menu : The Source Input is Translated, Rotated and Scaled so as to complete the given options listed below.",
                "type": "MenuPar",
                "name": "resetmethod",
                "items": []
            },
            {
                "text": "XYZ : Translate the Source Input Creep geometry on the surface of the Path Input.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Translate the Source Input Creep geometry on the surface of the Path Input.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Translate the Source Input Creep geometry on the surface of the Path Input.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : Rotate the Source Input creep geometry on the surface of the Path Input.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : Rotate the Source Input creep geometry on the surface of the Path Input.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : Rotate the Source Input creep geometry on the surface of the Path Input.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : Scale the Source Input creep geometry on the surface of the Path Input.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : Scale the Source Input creep geometry on the surface of the Path Input.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : Scale the Source Input creep geometry on the surface of the Path Input.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "SOP",
        "opFilter": "True",
        "opType": "creep",
        "opLicense": "Non-Commercial",
        "opClass": "creepSOP_Class",
        "short": "The Creep SOP lets you deform and animate Source Input geometry along the surface of the Path Input geometry.",
        "long": "The Creep SOP lets you deform and animate Source Input (input0) geometry along the surface of the Path Input (input1) geometry.",
        "opLabel": "Creep",
        "opCategories": ""
    },
    "curveclaySOP": {
        "label": "curveclaySOP",
        "members": [
            {
                "text": "StrMenu : Subset of faces (NURBS, B\u00e9zier, Polygons) to project, or subset of proles to deform, depending on how many inputs are connected.\t\t\nExamples include: 0.5 1.2-3.9 5.*\t\t\t\n\t\t\t\nThis group can even take surfaces (possibly intermixed with profile curves) when the 2nd input is not present, indicating that all the surface\u2019s proles must be used. <br>\t\t\t\nThen, the example above becomes: 0.5 1.2-3.9 5",
                "type": "StrMenuPar",
                "name": "facegroup",
                "items": []
            },
            {
                "text": "StrMenu : Subset of spline surfaces to be deformed when all three SOP inputs are connected.",
                "type": "StrMenuPar",
                "name": "surfgroup",
                "items": []
            },
            {
                "text": "Int : The number of points to evaluate on the proles or the faces. This SOP works by using a straight line approximation of the given curve to deform the surface. Thus, more segments are slower, but the result looks better. Fewer divisions need to be specified when deforming proles and when the rest and deforming faces have an equal number of breakpoints.",
                "type": "IntPar",
                "name": "divs",
                "items": []
            },
            {
                "text": "Float : Species the area around the face to deform. The larger the sharpness is, the smaller the deformation area around them (thus having a sharper pull on the surface).",
                "type": "FloatPar",
                "name": "sharp",
                "items": []
            },
            {
                "text": "Float : Usually, CurveClay automatically renes the surface. However, you may specify some degree of renement control. In general, the more rened the surface is, the smoother the result. Better renement results in a denser surface. You should experiment with values between -1 and 1. When the value is negative, the SOP will rst rene the surface to the same detail level as when renement is 0, and then it unrenes it. The lower the value, the more unrened it becomes.",
                "type": "FloatPar",
                "name": "refine",
                "items": []
            },
            {
                "text": "Menu : Choice of several projection axes:",
                "type": "MenuPar",
                "name": "projop",
                "items": []
            },
            {
                "text": "Float : Specify the direction vector of the projection.",
                "type": "FloatPar",
                "name": "projdir",
                "items": []
            },
            {
                "text": "Menu : Choice of several projection axes:",
                "type": "MenuPar",
                "name": "deformop",
                "items": []
            },
            {
                "text": "Float : Specify the direction vector of the displacement.",
                "type": "FloatPar",
                "name": "deformdir",
                "items": []
            },
            {
                "text": "Float : Distance deformed along the vector.",
                "type": "FloatPar",
                "name": "deformlen",
                "items": []
            },
            {
                "text": "Toggle : Check if the inside of closed loops should be deformed.",
                "type": "TogglePar",
                "name": "deforminside",
                "items": []
            },
            {
                "text": "Toggle : Check if multiple curves form a closed loop.",
                "type": "TogglePar",
                "name": "individual",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "SOP",
        "opFilter": "True",
        "opType": "curveclay",
        "opLicense": "Non-Commercial",
        "opClass": "curveclaySOP_Class",
        "short": "The Curveclay SOP is similar to the Clay SOP in that you deform a spline surface not by modifying the CVs but by directly manipulating the surface.",
        "long": "The Curveclay SOP is similar to the Clay SOP in that you deform a spline surface not by modifying the CVs but by directly manipulating the surface. However, instead of using a point on the surface, you use one or more faces to deform that surface. Also, CurveClay does not yet support polygonal meshes. <br><br>\t\t\nThe combination of inputs will determine the modes of transformation. For any combination of inputs, the following parameters modify the following behaviors of the SOP.",
        "opLabel": "Curveclay",
        "opCategories": ""
    },
    "dattoSOP": {
        "label": "dattoSOP",
        "members": [
            {
                "text": "DAT : DAT with point data. The optional <code>''index''</code> indicates the point number, if none is specified, row number will be used. Attributes can be specified in <code>''attribute_name''(attribute_index)</code>. If there are no named column headings for the Point DAT, the index column should be removed and the list of attributes is assumed to be in order <code>P(0) P(1) P(2) Pw Cd(0) Cd(1) Cd(2) Cd(3) N(0) N(1) N(2) uv(0) uv(1) uv(2)</code> for the first 14 columns. Sample point data:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    index\tP(0)\tP(1)\tP(2)\tPw\tN(0)\tN(1)\tN(2)\t\t\t\t\t\t\t\t\t\n    0\t\t-0.5\t-0.5\t-0.5\t1\t0\t0\t-1\t\t\t\t\t\t\t\t\n    1\t\t-0.5\t0.5\t-0.5\t1\t0\t0\t-1\t\t\t\t\t\t\t\t\n    2\t\t0.5\t0.5\t-0.5\t1\t0\t0\t-1\t\t\t\t\t\t\t\t\n    3\t\t0.5\t-0.5\t-0.5\t1\t0\t0\t-1\t\t\t\t\t\t\t\t\n    ...\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nThe common columns attributes include point position <code>P(0) P(1) P(2)</code>, point weight <code>Pw</code>, the color and alpha <code>Cd(0) Cd(1) Cd(2) Cd(3)</code>, texture coordinates <code>uv(0) uv(1) uv(2)</code>, and point normal <code>N(0) N(1) N(2)</code>.   See [[Attribute#Point_Attributes|Point Attributes]] for a list of attributes.",
                "type": "DATPar",
                "name": "pointsdat",
                "items": []
            },
            {
                "text": "DAT : DAT with vertex data.  <code>index</code> indicates the primitive number and <code>vindex</code> the vertex number in that primitive.  Attributes are specified in the same manner as for points.  ample vertex data:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    index\tvindex\tuv(0)\tuv(1)\tuv(2)\t\t\t\t\t\t\t\t\t\t\t\t\n    0\t\t0\t0\t0\t0\t\t\t\t\t\t\t\t\t\t\t\n    0\t\t1\t0\t1\t0\t\t\t\t\t\t\t\t\t\t\t\n    0\t\t2\t1\t1\t0\t\t\t\t\t\t\t\t\t\t\t\n    0\t\t3\t1\t0\t0\t\t\t\t\t\t\t\t\t\t\t\n    1\t\t0\t1\t0\t0\t\t\t\t\t\t\t\t\t\t\t\n    1\t\t1\t1\t1\t0\t\t\t\t\t\t\t\t\t\t\t\n    1\t\t2\t1\t1\t1\t\t\t\t\t\t\t\t\t\t\t\n    1\t\t3\t1\t0\t1\t\t\t\t\t\t\t\t\t\t\t\n    ...\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nCommon attributes include the color and alpha <code>Cd(0) Cd(1) Cd(2) Cd(3)</code>, texture coordinates <code>uv(0) uv(1) uv(2)</code>, and vertex normal <code>N(0) N(1) N(2)</code>.  See [[Attribute#Vertex_Attributes|Vertex Attributes]] for a list of attributes.",
                "type": "DATPar",
                "name": "verticesdat",
                "items": []
            },
            {
                "text": "DAT : DAT with primitive data. The optional <code>index</code> indicates the primitive number, if none is specified, row number will be used. Column headings are required; <code>vertices</code> list the point numbers in order, <code>close</code> indicates whether the primitive is a closed or open curve. Attributes are specified in the same manner as for points.  Sample primitive data:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    index\tvertices\tclose\tCd(0)\tCd(1)\tCd(2)\tCd(3)\t\t\t\t\t\t\t\t\t\t\n    0\t\t0 1 2 3\t\t1\t0.2\t1\t1\t1\t\t\t\t\t\t\t\t\n    1\t\t4 5 6 7\t\t1\t0.2\t0.2\t0.5\t1\t\t\t\t\t\t\t\t\n    2\t\t8 9 10 11\t1\t0.2\t0.2\t0.2\t1\t\t\t\t\t\t\t\t\t\nCommon attributes include the color and alpha <code>Cd(0) Cd(1) Cd(2) Cd(3)</code>. See [[Attribute#Primitive_Attributes|Primitive Attributes]] for a list of attributes.",
                "type": "DATPar",
                "name": "primsdat",
                "items": []
            },
            {
                "text": "DAT : DAT with detail data. Attribute names are specified on the first row and attribute data on the second row. Sample detail data:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    pCaptPath\t\tpCaptData(0)\tpCaptData(1)\tpCaptData(2)\t...\t\t\t\t\t\t\t\t\t\t\t\n    /bone1/cregion \t0\t\t3.33333\t\t0\t\t...",
                "type": "DATPar",
                "name": "detaildat",
                "items": []
            },
            {
                "text": "Menu : Specify whether to merge point data or primitive data. This parameter is only enabled when there is an input connected to the SOP.",
                "type": "MenuPar",
                "name": "merge",
                "items": []
            },
            {
                "text": "StrMenu : Add a non-standard attribute specified in the point or primitive DAT as a float.",
                "type": "StrMenuPar",
                "name": "float",
                "items": []
            },
            {
                "text": "StrMenu : Add a non-standard attribute specified in the point or primitive DAT as an int. It will not be added if it has already been specified in the Float attributes.",
                "type": "StrMenuPar",
                "name": "int",
                "items": []
            },
            {
                "text": "StrMenu : Add a non-standard attribute specified in the point or primitive DAT as a string. It will not be added if it has already been specified in the Float or Int attributes.",
                "type": "StrMenuPar",
                "name": "string",
                "items": []
            },
            {
                "text": "Menu : Specifies how to build geometry.",
                "type": "MenuPar",
                "name": "build",
                "items": []
            },
            {
                "text": "Int : Number of points used for building primitives.",
                "type": "IntPar",
                "name": "n",
                "items": []
            },
            {
                "text": "Toggle : Closed curves in U.",
                "type": "TogglePar",
                "name": "closed",
                "items": []
            },
            {
                "text": "Toggle : Closed curves in V.",
                "type": "TogglePar",
                "name": "closedv",
                "items": []
            },
            {
                "text": "Menu : Connectivity of polygons.",
                "type": "MenuPar",
                "name": "connect",
                "items": []
            },
            {
                "text": "Menu : When creating a particle system, specify to render the particles as lines or point sprites.",
                "type": "MenuPar",
                "name": "prtype",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The DAT to SOP can be used to create geometry from DAT tables, or if a SOP input is specified, to modify attributes on existing geometry.",
        "opLicense": "Non-Commercial",
        "opClass": "dattoSOP_Class",
        "opLabel": "DAT to",
        "long": "The DAT to SOP can be used to create geometry from DAT tables, or if a SOP input is specified, to modify attributes on existing geometry. See also the [[Add SOP]].\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nWithout a SOP input, the output is created entirely from the DAT, one SOP point per row of the DAT, except for an optional top row with column headings. The common columns headings include the point number <code>index</code>, point position <code>P(0) P(1) P(2)</code>, point weight <code>Pw</code>, the color and alpha <code>Cd(0) Cd(1) Cd(2) Cd(3)</code>, texture coordinates <code>uv(0) uv(1) uv(2)</code>, and point normal <code>N(0) N(1) N(2)</code>. If no index column is specified, row number is used as the point number. If there is no heading for the Point DAT, the list of attributes is assumed to be in order <code>P(0) P(1) P(2) Pw Cd(0) Cd(1) Cd(2) Cd(3) N(0) N(1) N(2) uv(0) uv(1) uv(2)</code> for the first 14 columns.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nIf an input is used, attributes are read in and replace the ones in the existing geometry. The <span class=\"tipTextSOP\">Merge</span> parameter will be enabled when an input is connected. Depending on the Merge menu setting, either the  <span class=\"tipTextSOP\">Points DAT</span> or  <span class=\"tipTextSOP\">Primitive DAT</span> parameter used for the merge data. If an input is used, the Points or Primitives DAT must have a column named <code>''index''</code>. This column is used to match the point or primitive to the incoming geometry by point or primitive number.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nAttributes in the columns headings should have column name ''<code>attrib</code>'' if it is a single value attribute, or have multiple columns named <code>''attrib''(0)</code>, <code>''attrib''(1)</code>, <code>''attrib''(2)</code> etc if it is a multiple-value attribute.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nData can also be converted into a form that can be rendered as particles.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n'''Example File :''' [[File:SOPtoDATtoSOP.tox]]",
        "opType": "datto",
        "opCategories": ""
    },
    "extrudeSOP": {
        "label": "extrudeSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified for the source. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "sourcegrp",
                "items": []
            },
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified for the cross-section. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "xsectiongrp",
                "items": []
            },
            {
                "text": "Menu : This should almost always be turned on when cross-sections are used. It consolidates points of polygons that would otherwise cross or overlap when the bevel takes place.",
                "type": "MenuPar",
                "name": "dofuse",
                "items": []
            },
            {
                "text": "Menu : Control how the front face of the extrusion should be built. You may wish to have a \"No Output\" because some faces are never actually seen when doing animation and, therefore, would only take up additional overhead if left on.",
                "type": "MenuPar",
                "name": "fronttype",
                "items": []
            },
            {
                "text": "Menu : This value controls whether or not the back of the extruded object will have a face or not. The options are the same as the Front Face options above.",
                "type": "MenuPar",
                "name": "backtype",
                "items": []
            },
            {
                "text": "Menu : Controls how the cross-section(s) will be extruded. If the input cross-section is a Bzier or NURBS curve, the surface will be constructed with a patch of the same geometry type.",
                "type": "MenuPar",
                "name": "sidetype",
                "items": []
            },
            {
                "text": "Pulse : If the cross-section face that you created doesn't match up nicely to the size of the geometry you are extruding, this command will scale and translate it so that it fits nicely.\t\n\t\t\t\nThe reason it might not be nice to begin with is that the curve wasn't drawn exactly on the world-axis in Model-mode and/or was drawn at a grossly different scale than the object it is extruding.",
                "type": "PulsePar",
                "name": "initextrude",
                "items": []
            },
            {
                "text": "Float : Shifts the cross-section profile perpendicularly to the normals of the input geometry. This relates to the X axis of the cross-section profile. When used with text, this typically has the effect of making the text lighter (narrower) or heavier (bolder).",
                "type": "FloatPar",
                "name": "thickxlate",
                "items": []
            },
            {
                "text": "Float : Scales the cross-section profile perpendicularly to the normals of the input geometry. This is equivalent to scaling the cross-section in its X axis. This parameter has no effect on the default profile, which is equivalent to a vertical line along the Y axis. Negative scaling values are allowed.",
                "type": "FloatPar",
                "name": "thickscale",
                "items": []
            },
            {
                "text": "Float : Moves the cross-section in the direction of the normal. Positive values will move backwards to the direction of the normal. Depth movement relates to the Y axis of the input cross-section. Using this parameter will shift the position of the output geometry in direction of the normal.",
                "type": "FloatPar",
                "name": "depthxlate",
                "items": []
            },
            {
                "text": "Float : Scales the cross-section in the direction of the source geometry's normals. This is equivalent to scaling the input cross-section in its Y axis and will determine how deep (thick) the resulting extrusion is.",
                "type": "FloatPar",
                "name": "depthscale",
                "items": []
            },
            {
                "text": "Int : Translates the cross-section such that the vertex specified is at the cross-section origin.",
                "type": "IntPar",
                "name": "vertex",
                "items": []
            },
            {
                "text": "Toggle : Determines whether or not sides are to be smooth-shaded or faceted using the angle value in Side Cusp Angle field.\t\n\t\t\t\nCusping lets you specify at which angle between adjacent polygons, a sharp edge (faceted edge where vertices are un-shared) should be displayed instead.",
                "type": "TogglePar",
                "name": "docusp",
                "items": []
            },
            {
                "text": "Float : When checked, this value will control the angle at which faceting of the sides will occur. A value of 20 is default.",
                "type": "FloatPar",
                "name": "cuspangle",
                "items": []
            },
            {
                "text": "Toggle : If selected the extrusion will share points between the front face and the first row of the side mesh and between the last face and the last row of the side mesh.",
                "type": "TogglePar",
                "name": "sharefaces",
                "items": []
            },
            {
                "text": "Toggle : Prevents the creation of duplicate sides.",
                "type": "TogglePar",
                "name": "removesharedsides",
                "items": []
            },
            {
                "text": "Toggle : When this option is checked, it causes the Extrude SOP to generate three new groups representing the primitives belonging to the front faces, back faces, and the side bevel/extrusion. The name of the groups are determined by the three option fields below.",
                "type": "TogglePar",
                "name": "newg",
                "items": []
            },
            {
                "text": "Str : Output group name to create for front face geometry.",
                "type": "StrPar",
                "name": "frontgrp",
                "items": []
            },
            {
                "text": "Str : Output group name to create for back face geometry.",
                "type": "StrPar",
                "name": "backgrp",
                "items": []
            },
            {
                "text": "Str : Output group name to create for side bevel/extrude geometry.",
                "type": "StrPar",
                "name": "sidegrp",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "extrudeSOP_Class",
        "opType": "extrude",
        "opLicense": "Non-Commercial",
        "opLabel": "Extrude",
        "long": "The Extrude SOP can be used for:\t\t\n* Extruding and bevelling Text and other geometry\t\t\t\n* Cusping the bevelled edges to get sharp edges\t\t\t\n* Making primitives thicker or thinner'''\t\t\t\n\t\nThe default is a 1 unit extrusion directly backwards from the input geometry's normals.\n\nIt uses the normal of the surface to determine the direction of extrusion. In the case of planar or open polygons, the normal is difficult to determine, and may not always provide the result that you expect. Turn on the Primitive Normals display in the [[Viewer]] display options to see the normals.\n\nThe extrusion is created by extending surfaces from the vertices of the input geometry along the cross-section curve given in the second input (Input 1). The first vertex of the cross-section curve is placed by default at the vertices of the input geometry and aligned so that the curve's positive Y axis extends opposite to the input geometry's normal. The cross-section's positive X axis by default extends outwards from center of the input geometry.\n\nIf no cross-section curve is given, a vertical line going from (0,0,0) to (0,1,0) is used. This results in a 1 unit extrusion directly backwards from the input geometry's normals. As another example, using a straight line from (0,0,0) to (.1,.1,0) will result in an extrusion that extends 1 unit backwards from the input and flares .1 unit outwards on all sides. The Thickness and Depth parameters can be used to shift and scale the cross-section without directly changing the curve.\n\n'''Note:''' The shape of the cross-section is always relative to its first vertex, so shifting the entire cross-section curve will have no effect. Also, only the X and Y axes of the curve are used i.e. Z position values are ignored.\n\nAfter the new geometry is created, normals are computed by default.\n\n'''Warning:''' If you take a default output from a [[Text SOP]] and Extrude it, it may have bad rendering artifacts (and too many polygons) as it's extruding each of the triangles of the triangulated letters. You need to change the Output parameter of the Text SOP to Closed Polygons. See [[OP Snippets]].",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Extrude SOP can be used for extruding and bevelling Text and other geometry, cusping the bevelled edges to get sharp edges, and making primitives thicker or thinner.",
        "opCategories": ""
    },
    "facetrackSOP": {
        "label": "facetrackSOP",
        "members": [
            {
                "text": "CHOP : The path to the Face Track CHOP that generates the mesh.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Toggle : When active, the mesh will be transferred directly to the GPU. This method is much faster, but does not allow it to be transformed further by additional SOPs.",
                "type": "TogglePar",
                "name": "directtogpu",
                "items": []
            },
            {
                "text": "Toggle : The fitted mesh will be transformed to align with the input image that was used to create the mesh. When disabled, the mesh will be positioned at the origin at its original scale.",
                "type": "TogglePar",
                "name": "pretransform",
                "items": []
            },
            {
                "text": "Toggle : Enable to automatically generate smooth vertex normals for the face mesh.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "SOP",
        "opType": "facetrackSOP",
        "opLabel": "Face Track",
        "opClass": "facetrackSOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "os": "Microsoft Windows",
        "hardware": "This operator uses the Augmented Reality (AR) SDK of the Nvidia Maxine system and requires a 20 or 30 series Nvidia RTX card to operate. 40 series cards are supported in 2023 and newer releases.",
        "short": "Provides accesses to the fitted face mesh generated by the Face Track CHOP.",
        "long": "The Face Track SOP provides accesses to the fitted face mesh generated by the Face Track CHOP. It can either be uploaded directly to the GPU for rendering or passed along to other SOPs for further modification. By default, the mesh is pre-transformed to align with the source face of the input image (x, y positions equal image u,v positions). However, you can also disable the pre-transform which will leave the fitted mesh at the origin in the original scale. The mesh can still be aligned with the image using the tx, ty, rx, etc channels of the [[Face Track CHOP]].\n    \n'''Note: ''' To use this feature you will need to provide a compatible 3D morphable face mesh file in Nvidia 'nvf' format to the 'Mesh File' parameter of the [[Face Track CHOP]]. This file does not ship with TouchDesigner, but instructions on creating one are provided on the [[Face Track CHOP]] page.",
        "opCategories": ""
    },
    "facetSOP": {
        "label": "facetSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Toggle : Checking this option will normalize the length of normals to a length of one unit.",
                "type": "TogglePar",
                "name": "unit",
                "items": []
            },
            {
                "text": "Toggle : Checking this option means that the surface normals will be computed. Where points are shared between polygons, smooth shading results, and where points are not shared (unique), faceted edges result. If you compute normals at this stage, they are computed based on the incoming geometry.",
                "type": "TogglePar",
                "name": "prenml",
                "items": []
            },
            {
                "text": "Toggle : Makes each vertex have a unique point. The result of selecting this option is that all vertices are made into unique points, thus making all edges hard, with no smooth shading.",
                "type": "TogglePar",
                "name": "unique",
                "items": []
            },
            {
                "text": "Menu : Consolidate eliminates the redundancy of having many points that are close to each other, by merging them together to form a fewer set of common points. Consolidate is useful for cleaning up an edge that may appear between adjacent polygons that have been merged.",
                "type": "MenuPar",
                "name": "cons",
                "items": []
            },
            {
                "text": "Float : Points and normals less than this distance apart will be consolidated, or have their normals averaged, based on the setting in the Consolidate menu.\t\nUsually very small numbers, such as <code>0.01</code> should be used here. If the value is <code>0.0</code>, then points must be in exactly the same position (co-incident) in order to be considered for the consolidation/averaging function.",
                "type": "FloatPar",
                "name": "dist",
                "items": []
            },
            {
                "text": "Toggle : Removes points that lie inline with its neighboring points.",
                "type": "TogglePar",
                "name": "inline",
                "items": []
            },
            {
                "text": "Float : Set the distance threshold for removing inline points when the above parameter is On.",
                "type": "FloatPar",
                "name": "inlinedist",
                "items": []
            },
            {
                "text": "Toggle : Orients all polygons so they have the same winding direction.",
                "type": "TogglePar",
                "name": "orientpolys",
                "items": []
            },
            {
                "text": "Toggle : Most of the time, you want some polygons to be smooth shaded and others to be faceted. Usually polygons that meet at low angles should be smooth shaded, and polygon edges that meet at sharper angles should be faceted.",
                "type": "TogglePar",
                "name": "cusp",
                "items": []
            },
            {
                "text": "Float : Cusping allows you to specify the threshold angle at which the edges become faceted. A good typical value is 20.",
                "type": "FloatPar",
                "name": "angle",
                "items": []
            },
            {
                "text": "Toggle : Sometimes (not often) your geometry can get messed up, where there are points hanging around that are not used for anything, or there are primitives that don't make sense. This option checks for these cases and removes them.",
                "type": "TogglePar",
                "name": "remove",
                "items": []
            },
            {
                "text": "Toggle : Again, allows you to compute the normals after the consolidation or cusping stages. You should select this if you have set either the Cusp or Consolidate option.",
                "type": "TogglePar",
                "name": "postnml",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "facetSOP_Class",
        "opType": "facet",
        "opLicense": "Non-Commercial",
        "opLabel": "Facet",
        "long": "The Facet SOP lets you control the smoothness of faceting of a given object. It also lets you consolidate points or surface normals.\t\n\t\t\nThe Facet SOP, like [[Divide SOP]], works as a pipeline to change geometry in stages. For this reason, Compute Normals appears twice. For example, you can compute surface normals before making vertices (the points of each polygon) unique, which gives you the unusual result of smooth shading and unique point, as the normals get computed while the points are still shared.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Facet SOP lets you control the smoothness of faceting of a given object.",
        "opCategories": ""
    },
    "fileinSOP": {
        "label": "fileinSOP",
        "members": [
            {
                "text": "File : Contains the full pathname of the geometry file to be read in.\n\t\nSome of the geometry formats that can be read:\t\n\t\n* TouchDesigner : .tog\t\n* Houdini : .classic, .bhclassic\n* Common : .obj",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : Flips the primitive faces of the geometry.",
                "type": "TogglePar",
                "name": "flipfacing",
                "items": []
            },
            {
                "text": "Toggle : Creates normals if the geometry does not have them.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            },
            {
                "text": "Toggle : Reload the file when this parameter is set to On.",
                "type": "TogglePar",
                "name": "refresh",
                "items": []
            },
            {
                "text": "Pulse : Instantly reload the file from disk.",
                "type": "PulsePar",
                "name": "refreshpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "fileinSOP_Class",
        "opType": "filein",
        "opLicense": "Non-Commercial",
        "opLabel": "File In",
        "long": "The File In SOP allows you to read a geometry file that may have been previously created in the Model Editor, output geometry from a SOP, or generated from other software such as [http://www.sidefx.com Houdini]. The geometry file can be read in from disk or from the web. Use http:// when specifying a URL.",
        "opFilter": "False",
        "opFamily": "SOP",
        "short": "The File In SOP allows you to read a geometry file that may have been previously created in the Model Editor, output geometry from a SOP, or generated from other software such as [http://www.sidefx.com Houdini].",
        "opCategories": ""
    },
    "fitSOP": {
        "label": "fitSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Specifies one of two fitting styles: approximation or interpolation. Each style has a number of parameters that are accessible from the respective folder. For more information see the Approximation and Interpolation pages below.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Menu : The output of the Fit SOP is a NURBS or Bzier primitive. All input faces are fitted to Spline curves, and all input surfaces are fitted to spline surfaces. The resulting shapes are identical whether created as NURBS or as Bzier primitives.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : This option is used to select the type of surface, when using a Mesh Primitive Type.",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "Int : If the input is a face, this is the order of the Spline curve to be generated. If the input is a surface, this is the order of the fitted spline surface in the U parametric direction.",
                "type": "IntPar",
                "name": "orderu",
                "items": []
            },
            {
                "text": "Int : If the input is a surface, this is the order of the fitted Spline surface in the V parametric direction. The V order is irrelevant if the input is a face.",
                "type": "IntPar",
                "name": "orderv",
                "items": []
            },
            {
                "text": "Float : This is the primary precision factor in approximation fitting. The smaller the tolerance, the closer the fit and the higher the number of generated vertices. If a small tolerance causes unwanted twists or contortions in the fitted primitive, it may help to vary the Spline order and/or enable the Multiple Knots flag.",
                "type": "FloatPar",
                "name": "tol",
                "items": []
            },
            {
                "text": "Float : For a set tolerance, the smoothness factor allows for more or less roundness in the generated shape. If this parameter is zero, it does not mean that the fit will be sharp. It simply indicates that no additional smoothing is required past the level of smoothness already achieved with the given tolerance.",
                "type": "FloatPar",
                "name": "smooth",
                "items": []
            },
            {
                "text": "Toggle : Sometimes the data set has sharp bends that must be preserved in the fitted shape. In this case, inserting multiple knots in the areas of sharp curvature will usually produce the right effect. Sometimes, however, the simulated sharpness induces unwanted twists immediately before or after the corner. Lowering the Spline order and/or reducing the tolerance may help diminish this side-effect.",
                "type": "TogglePar",
                "name": "multipleu",
                "items": []
            },
            {
                "text": "Toggle : Sometimes the data set has sharp bends that must be preserved in the fitted shape. In this case, inserting multiple knots in the areas of sharp curvature will usually produce the right effect. Sometimes, however, the simulated sharpness induces unwanted twists immediately before or after the corner. Lowering the Spline order and/or reducing the tolerance may help diminish this side-effect.",
                "type": "TogglePar",
                "name": "multiplev",
                "items": []
            },
            {
                "text": "Menu : Scope establishes the interpolation method.",
                "type": "MenuPar",
                "name": "scope",
                "items": []
            },
            {
                "text": "Menu : Specifies the parameterization of the data in the U direction (the only direction if the input is a curve). The data parameterization can be uniform, chord length, or centripetal.\t\n\t\t\t\n: Uniform Uniform parameterization uses equally spaced parameter values. It works best when the geometry is very regular. When the data is unevenly spaced, this approach can produce very unintuitive shapes, and is not recommended.\t\t\t\n: Chord Length Chord length computes the parameterization of the data based on the relative distances between successive data points. It is the most commonly used approach because is tends to produce the most accurate results.\t\t\t\n: Centripetal Centripetal parameterization is similar to chord length, but yields better results when the data has very sharp corners.",
                "type": "MenuPar",
                "name": "dataparmu",
                "items": []
            },
            {
                "text": "Menu : V data parameterization is identical to U data parameterization, but it affects the V direction when the input is a surface. It is not used when the input is a face.",
                "type": "MenuPar",
                "name": "dataparmv",
                "items": []
            },
            {
                "text": "Menu : This menu determines whether the fitted curve should be closed, or whether the fitted surface should be wrapped in the U parametric direction. The options are to open (Off), close (On), or inherit the closure type from the input primitive.",
                "type": "MenuPar",
                "name": "closeu",
                "items": []
            },
            {
                "text": "Menu : This menu determines whether the fitted surface should be wrapped in the V parametric direction. The options are to open (Off), close (On), or inherit the closure type from the input primitive. V Wrap is ignored when the input is a face.",
                "type": "MenuPar",
                "name": "closev",
                "items": []
            },
            {
                "text": "Toggle : Specifies whether corners in the data should be preserved when doing local curve interpolation.",
                "type": "TogglePar",
                "name": "corners",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "fitSOP_Class",
        "opType": "fit",
        "opLicense": "Non-Commercial",
        "opLabel": "Fit",
        "long": "The Fit SOP fits a Spline curve to a sequence of points or a Spline surface to an m X n mesh of points.\t\t\n\t\t\t\nAny type of face or surface represents a valid input. The Fit SOP looks only at the control vertices (CVs) of the primitives, treating the CVs as data points to run the fit through. For example, if a cubic NURBS surface and a mesh have the same number of rows and columns and identical points, they will yield an identical fit because the Spline bases of the input NURBS surface are ignored.\t\t\t\n\t\t\t\nThe Fit SOP generates two types of outputs: primitives that roughly follow the path of the data points without necessarily going through the data points; and primitives that touch all the data points. The first type, known as \"approximation\", is used primarily to extract a lean, smooth shape from a heavy data set, lending itself well to data reduction. The second type, known as \"interpolation\", often serves as a smoothing tool for paths that must go through specified target positions.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Fit SOP fits a Spline curve to a sequence of points or a Spline surface to an m X n mesh of points.",
        "opCategories": ""
    },
    "fontSOP": {
        "label": "fontSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "fontSOP_Class",
        "opType": "font",
        "opLicense": "Non-Commercial",
        "opLabel": "Font",
        "long": "'''Note''': Font SOP deprecated build 2019.14650, use [[Text TOP]]. \n    \nThe Font SOP allows you to create text in your model from Adobe Type 1 Postscript Fonts.\t\n\t\t\nTo install fonts, copy the font files to the <code>$TFS/touch/fonts</code> directory of your installation path. They will be ready to be used in the Font SOP after restarting TouchDesigner.\t\t\n\t\t\nThe fonts located in <code>$TFS/touch/fonts_g</code>l are not for the Font SOP, they are for the TouchDesigner UI only.",
        "opFilter": "False",
        "opFamily": "SOP",
        "short": "'''Note''': Font SOP deprecated build 2019.14650, use [[Text TOP]]. The Font SOP allows you to create text in your model from Adobe Type 1 Postscript Fonts."
    },
    "fractalSOP": {
        "label": "fractalSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Int : The number of subdivisions of the input geometry. Values in the range of 1 - 3 are reasonable to start with. Higher values cause excessive geometry and should be used with caution.",
                "type": "IntPar",
                "name": "divs",
                "items": []
            },
            {
                "text": "Float : The smoothness value scales the deviations. The range is usually between 0 and 1, and small numbers create larger deviations than large numbers. Smoothness and Scale have a similar effect, but there is a subtle difference. Smoothness is calculated for each iteration of the SOP. The number of Iterations is, in turn set by the number of Divisions. Scale, by contrast, is a global scaling of the amplitude of the deviations, with no consideration of the stage at which they are created. Using low values of smoothness (producing large deviations) and a small scale value will give a slightly more random looking result than doing the opposite; high roughness values (small deviations) and large scale values, providing Divisions is greater than 1.",
                "type": "FloatPar",
                "name": "smooth",
                "items": []
            },
            {
                "text": "Float : Global setting of the fractal divisions. See the above discussion about Smoothness vs. Scale.",
                "type": "FloatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Int : The random seed used for fractalising. Specifying a different integer value gives a different shape.",
                "type": "IntPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Toggle : When enabled, this option prevents Fractal from applying any deviations to the edges (boundaries) so that you could, for example, fractalise a plane and still be able to connect the edges of the plane to the sides of the box. This is achieved by first refining the surface between all breakpoints, and then fractalized.",
                "type": "TogglePar",
                "name": "fixed",
                "items": []
            },
            {
                "text": "Toggle : Instead of using the Direction fields below, this sets the direction of the fractalisation at any given point to be the direction of the vertex normals of the input. This may be preferable when using a sphere or other rounded object as the input, as the deviations will originate from the center of the sphere instead of all being the same direction.",
                "type": "TogglePar",
                "name": "vtxnms",
                "items": []
            },
            {
                "text": "XYZ : The direction of the Fractalisation. The default values of <code>0, 0, 1</code> make the fractal deviations point in the Z direction. Can be overridden by: Use Vertex Normals.",
                "type": "XYZPar",
                "name": "dirx",
                "items": []
            },
            {
                "text": "XYZ : The direction of the Fractalisation. The default values of <code>0, 0, 1</code> make the fractal deviations point in the Z direction. Can be overridden by: Use Vertex Normals.",
                "type": "XYZPar",
                "name": "diry",
                "items": []
            },
            {
                "text": "XYZ : The direction of the Fractalisation. The default values of <code>0, 0, 1</code> make the fractal deviations point in the Z direction. Can be overridden by: Use Vertex Normals.",
                "type": "XYZPar",
                "name": "dirz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "fractalSOP_Class",
        "opType": "fractal",
        "opLicense": "Non-Commercial",
        "opLabel": "Fractal",
        "long": "The Fractal SOP allows you created jagged mountain-like divisions of the input geometry. It will create random-looking deviations and sub-divisions along either a specified normal vector (the Direction xyz fields) or the vertex normals of the input geometry. This is great for the creation of terrains and landscapes.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Fractal SOP allows you created jagged mountain-like divisions of the input geometry.",
        "opCategories": ""
    },
    "gridSOP": {
        "label": "gridSOP",
        "members": [
            {
                "text": "Menu : Select from the following types. For information on the different types, see the Geometry Types section. Depending on the primitive type chosen, some SOP options may not apply.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : (Results only viewable for polygons and meshes).",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "Menu : Specifies on which plane the Grid is built.",
                "type": "MenuPar",
                "name": "orient",
                "items": []
            },
            {
                "text": "Toggle : Enabled only when an input is connected to the Grid SOP to set bounds for the grid. Turn Modify Bounds = On to enable the transform parameters below to further modify the position and scale of the bounds.",
                "type": "TogglePar",
                "name": "modifybounds",
                "items": []
            },
            {
                "text": "XY : The X and Y scale of the grid.",
                "type": "XYPar",
                "name": "sizex",
                "items": []
            },
            {
                "text": "XY : The X and Y scale of the grid.",
                "type": "XYPar",
                "name": "sizey",
                "items": []
            },
            {
                "text": "XYZ : Center of grid in X, Y, and Z.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Center of grid in X, Y, and Z.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Center of grid in X, Y, and Z.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "Toggle : Invert the direction of anchors.",
                "type": "TogglePar",
                "name": "reverseanchors",
                "items": []
            },
            {
                "text": "Float : Set the point in X about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchoru",
                "items": []
            },
            {
                "text": "Float : Set the point in Y about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorv",
                "items": []
            },
            {
                "text": "Int : The number of rows and columns. Rows are horizontal lines; Columns are vertical lines. Two rows by two columns makes a square or rectangle. For example, one row and two columns makes a single line if Connectivity is set to Rows.\t\n\t\t\nFor NURBS and Bzier surfaces, the Rows &amp; Cols refer to the surface hull construction, and as such, the number of Rows and Cols should not be less than the Order in U or V.",
                "type": "IntPar",
                "name": "rows",
                "items": []
            },
            {
                "text": "Int : The number of rows and columns. Rows are horizontal lines; Columns are vertical lines. Two rows by two columns makes a square or rectangle. For example, one row and two columns makes a single line if Connectivity is set to Rows.\t\n\t\t\nFor NURBS and Bzier surfaces, the Rows &amp; Cols refer to the surface hull construction, and as such, the number of Rows and Cols should not be less than the Order in U or V.",
                "type": "IntPar",
                "name": "cols",
                "items": []
            },
            {
                "text": "Int : U Order Degree of spline basis +1 in the U parametric direction.",
                "type": "IntPar",
                "name": "orderu",
                "items": []
            },
            {
                "text": "Int : V Order Degree of spline basis +1 in the V parametric direction.",
                "type": "IntPar",
                "name": "orderv",
                "items": []
            },
            {
                "text": "Toggle : End-point interpolate in U Extends the surface to touch the end point in the U direction.",
                "type": "TogglePar",
                "name": "interpu",
                "items": []
            },
            {
                "text": "Toggle : End-point interpolate in V Extends the surface to touch the end point in the V direction.",
                "type": "TogglePar",
                "name": "interpv",
                "items": []
            },
            {
                "text": "Menu : This adds uv coordinates to the geometry created by the Grid SOP.",
                "type": "MenuPar",
                "name": "texture",
                "items": []
            },
            {
                "text": "Toggle : Checking this option On will compute surface normals.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "gridSOP_Class",
        "opType": "grid",
        "opLicense": "Non-Commercial",
        "opLabel": "Grid",
        "long": "The Grid SOP allows you to create grids and rectangles using polygons, a mesh, Bzier and NURBS surfaces, or multiple lines using open polygons.",
        "opFilter": "False",
        "opFamily": "SOP",
        "short": "The Grid SOP allows you to create grids and rectangles using polygons, a mesh, Bzier and NURBS surfaces, or multiple lines using open polygons.",
        "opCategories": ""
    },
    "holeSOP": {
        "label": "holeSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Toggle : This function checks for bridges to holes in the input and removes the bridges, leaving the interior freestanding. At times you may need to unhole faces so that you can connect them in some other way.",
                "type": "TogglePar",
                "name": "unbridge",
                "items": []
            },
            {
                "text": "Float : Interior polygons that are not in exactly the same plane as the exteriors can still become holes. The <span class=\"tipTextSOP\">Distance Tolerance</span> value tells the Hole SOP how far away potential holes can be from the exterior surfaces. Faces beyond this distance will not become holes.",
                "type": "FloatPar",
                "name": "dist",
                "items": []
            },
            {
                "text": "Float : Interior faces that are rotated in relation to the exterior faces can become holes. The <span class=\"tipTextSOP\">Angle</span> value sets the maximum rotation of the potential holes from the exteriors. Faces beyond this rotation will not become holes.",
                "type": "FloatPar",
                "name": "angle",
                "items": []
            },
            {
                "text": "Toggle : Points of any holes that are rotated or translated away from the exterior (or outline) plane will be moved so that they lie on the surface of the outline plane, thus avoiding twisted faces.",
                "type": "TogglePar",
                "name": "snap",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "holeSOP_Class",
        "opType": "hole",
        "opLicense": "Non-Commercial",
        "opLabel": "Hole",
        "long": "The Hole SOP is for making holes where faces are enclosed, even if they are not in the same plane. It can also remove existing holes from the input geometry.\n\t\nThe holes are made by searching for faces which are enclosed by other faces and creating bridges to the interior faces. It offers more flexibility than either the [[Extrude SOP]] or [[Divide SOP]]'s hole-making capabilities because it can deal with interior faces which are not exactly in the same orientation as the exterior ones. It can also remove existing bridges that it finds in the input geometry if needed.\t\n\t\n'''Note:''' This SOP works with Polygonal and Bezier geometry types only. NURBS surfaces will be converted internally to Beziers.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Hole SOP is for making holes where faces are enclosed, even if they are not in the same plane. It can also remove existing holes from the input geometry.",
        "opCategories": ""
    },
    "inSOP": {
        "label": "inSOP",
        "members": [
            {
                "text": "Str : Creates a pop-up label when the cursor rolls over this Component input.",
                "type": "StrPar",
                "name": "label",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "inSOP_Class",
        "opType": "in",
        "opLicense": "Non-Commercial",
        "opLabel": "In",
        "long": "The In SOP creates a SOP input in a Component. Component inputs are positioned alphanumerically on the left side of the node.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The In SOP creates a SOP input in a Component. Component inputs are positioned alphanumerically on the left side of the node.",
        "opCategories": ""
    },
    "isosurfaceSOP": {
        "label": "isosurfaceSOP",
        "members": [
            {
                "text": "Float : Enter the function for implicit surface building here.\t\n\t\t\nExample 1: <syntaxhighlight lang=python inline>(me.curPos.x**2) / (4*4) - (me.curPos.y**2) / (3*3) + me.curPos.z</syntaxhighlight>\t\n\t\t\nThis formula creates a hyperbolic paraboloid, or saddle shape.\t\t\n\t\t\nExample 2: <syntaxhighlight lang=python inline>(me.curPos.x**2) / 0.1 + (me.curPos.y**2) / 2 + (me.curPos.z**2) / 6 - 1</syntaxhighlight>\t\t\n\t\t\nThis formula creates an ellipsoid.\t\t\n\t\t\nTry loading some of the sample functions in <code>$TFS/touch/presets</code>.",
                "type": "FloatPar",
                "name": "func",
                "items": []
            },
            {
                "text": "XYZ : Determines the minimum clipping plane boundary for display of iso surface.",
                "type": "XYZPar",
                "name": "minx",
                "items": []
            },
            {
                "text": "XYZ : Determines the minimum clipping plane boundary for display of iso surface.",
                "type": "XYZPar",
                "name": "miny",
                "items": []
            },
            {
                "text": "XYZ : Determines the minimum clipping plane boundary for display of iso surface.",
                "type": "XYZPar",
                "name": "minz",
                "items": []
            },
            {
                "text": "XYZ : Determines maximum clipping plane boundary for display of iso surfaces.",
                "type": "XYZPar",
                "name": "maxx",
                "items": []
            },
            {
                "text": "XYZ : Determines maximum clipping plane boundary for display of iso surfaces.",
                "type": "XYZPar",
                "name": "maxy",
                "items": []
            },
            {
                "text": "XYZ : Determines maximum clipping plane boundary for display of iso surfaces.",
                "type": "XYZPar",
                "name": "maxz",
                "items": []
            },
            {
                "text": "Int : The density, or resolution of the iso surface polygons in X, Y and Z.",
                "type": "IntPar",
                "name": "divs",
                "items": []
            },
            {
                "text": "Toggle : Adds normals to the surface.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "isosurfaceSOP_Class",
        "opType": "iso",
        "opLicense": "Non-Commercial",
        "opLabel": "Iso Surface",
        "long": "The Iso Surface SOP uses implicit functions to create 3D visualizations of isometric surfaces found in Grade 12 Functions and Relations textbooks.\t\n\t\t\nAn implicit function is defined so that it = 0. For example with:\t\t\n<syntaxhighlight lang=python>x2 + y2 = r2</syntaxhighlight>\t\n\t\t\nthe implicit function is:\t\t\n\t\t\n<syntaxhighlight lang=python>f(x, y) = x2 + y2 - r2 = 0</syntaxhighlight>",
        "opFilter": "False",
        "opFamily": "SOP",
        "short": "The Iso Surface SOP uses implicit functions to create 3D visualizations of isometric surfaces found in Grade 12 Functions and Relations textbooks.",
        "opCategories": ""
    },
    "joinSOP": {
        "label": "joinSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Toggle : Determines the way the primitives are joined. A blended face or surface will typically reposition the ends to be joined and convert them into a single, common point, row or column respectively. The amount of change can be reduced or eliminated by lowering the tolerance (see Tolerance below). When not blended, the original shapes remain unaffected. Instead, the chosen ends are joined by an arc-like fillet. In either case, the result is a single primitive.",
                "type": "TogglePar",
                "name": "blend",
                "items": []
            },
            {
                "text": "Float : The meaning of the tolerance varies with the type of join. The shapes of blended primitives will change less if the tolerance is low. If the tolerance is &lt; <code>1</code>, a new point, knot, row or column is inserted between the last and before-last point, row or column. The lower the tolerance, the closer the insertion to the ends being pulled together, and thus the smaller the region affected. When the tolerance is zero the blended inputs do not change at all: the faces are connected by a straight line and the surfaces by a flatish, linear patch.\t\n\t\t\nTolerance also affects the size and roundness of the fillet built between non-blended primitives. A zero tolerance yields a short, flat fillet; a unit tolerance generates pointed, non self-intersected fillet.",
                "type": "FloatPar",
                "name": "tolerance",
                "items": []
            },
            {
                "text": "Float : Affects only blended primitives by varying the position of the common point, row or column linearly between the two original ends. If the bias is zero, the common part will coincide with the end of the second primitive and the end of the first primitive will be stretched all the way to it. If the bias is one, the common part will coincide with the end of the first primitive and the second primitive will be stretched.\t\n\t\t\nThe bias is irrelevant when the blend tolerance is 0.",
                "type": "FloatPar",
                "name": "bias",
                "items": []
            },
            {
                "text": "Toggle : Affects the number of knots inserted at the blend point and thus allows for smooth or pointed connections. The connection will be pointed when the Multiplicity is on. When Blend is not on, an active multiplicity influences the shape and the tightness of the fillet by forcing a multiple knot insertion when on.\t\n\t\t\nThe fillet tends to be better behaved when multiplicity in on. However, this means that the resulting face or surface is built with a discontinuity at the connection points and might not lend itself to point modeling in that area too well.\t\t\n\t\t\nMultiplicity has no effect on polygons and meshes.",
                "type": "TogglePar",
                "name": "knotmult",
                "items": []
            },
            {
                "text": "Toggle : The Join SOP connects the tail of the first primitive with the head on the next primitive, and so on unless this toggle is on, in which case the closest ends are chosen instead. For surfaces, this option enables the proximity test in U or V, as specified in the Direction parameter below.",
                "type": "TogglePar",
                "name": "proximity",
                "items": []
            },
            {
                "text": "Menu : This menu determines the parametric direction of the joining operation, which can be in U or in V, and is meaningful only when the inputs are surfaces. The U direction is associated with columns; the V direction refers to rows. For example, joining two surfaces in U will generate a surface with more columns than either input. The number of rows might be higher too, but only if the two inputs have a different number of rows or a different V basis.",
                "type": "MenuPar",
                "name": "dir",
                "items": []
            },
            {
                "text": "Menu : Can optionally join subgroups of n primitives or every nth primitive in a cyclical manner.\t\n\t\t\n'''For Example'''; assume there are six primitives numbered for 0 - 5, and N = 2. Then, \t\t\n\t\t\n# Groups will generate 0-1 2-3 4-5\t\t\n# Skipping will generate 0-2-6 and 1-3-5.",
                "type": "MenuPar",
                "name": "joinop",
                "items": []
            },
            {
                "text": "Int : Determines the number of primitives to be either grouped or skipped. N2.",
                "type": "IntPar",
                "name": "inc",
                "items": []
            },
            {
                "text": "Toggle : If enabled, it connects the beginning of the first primitive to the end of the last primitive, thus forming a single, closed face or hull. If a single, open primitive exists in the input, it will be closed. The [[Primitive SOP]] provides a more direct way of closing primitives but offers almost no shape controls.",
                "type": "TogglePar",
                "name": "loop",
                "items": []
            },
            {
                "text": "Toggle : If this button is not checked, the input primitives will be deleted after being joined. If checked, they will be preserved.",
                "type": "TogglePar",
                "name": "prim",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "joinSOP_Class",
        "opType": "join",
        "opLicense": "Non-Commercial",
        "opLabel": "Join",
        "long": "The Join SOP connects a sequence of faces or surfaces into a single primitive that inherits their attributes. Faces of different types can be joined together, and so can surfaces. Mixed face-surface types are not allowed. The surfaces do not have to have the same number of rows or columns in the side being joined. Spline types of different orders and parameterization are all valid inputs. The Join SOP converts simpler primitives such as polygons into Bziers and NURBS if necessary.\t\n\t\t\nJoining is different from filleting (see [[Fillet SOP]]) or stitching (see [[Stitch SOP]]) because it takes n primitives and converts them into one after possibly changing the connected ends of the primitives. Filleting creates a new primitive between each input pair and never affects the original shapes. Stitching changes the original shapes but does not change the number of resulting primitives.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Join SOP connects a sequence of faces or surfaces into a single primitive that inherits their attributes.",
        "opCategories": ""
    },
    "jointSOP": {
        "label": "jointSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field causes the SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Int : Allows you to specify the number of circles between each pair of input circles.",
                "type": "IntPar",
                "name": "divs",
                "items": []
            },
            {
                "text": "Toggle : Preserves the first input circle being fed into the SOP.",
                "type": "TogglePar",
                "name": "preserve1",
                "items": []
            },
            {
                "text": "Toggle : Preserves the last input circle.",
                "type": "TogglePar",
                "name": "preserve2",
                "items": []
            },
            {
                "text": "Toggle : This helps to create a joint that blends between the input circles without flattening or curving outwards. In order to do this, there may be a reversal of the normal of each input circle. For example, if the normals of the two input circles are facing away from each other, the joint created (if this option was not enabled) would appear to connect the circles the long way around. This option would reorient the joint such that the shorter distance is used to create the joint.",
                "type": "TogglePar",
                "name": "orient",
                "items": []
            },
            {
                "text": "Toggle : If not on, the joint circles are blended linearly. Otherwise, they are placed along a cubic piece-wise Bzier curve between the circle centres. This is useful when the input contains more than two circles and the joints must be continuous to each other. If this option isn't enabled, the interpolation may be sharper than desired.",
                "type": "TogglePar",
                "name": "smoothpath",
                "items": []
            },
            {
                "text": "Toggle : Each joint circle is rotated slightly such that its X and Y axis align as it approaches an input circle. This toggle causes the adjustments to be an incremental, or piece-wise, Bzier function. Again this is useful for multi-circle inputs.",
                "type": "TogglePar",
                "name": "smoothtwist",
                "items": []
            },
            {
                "text": "Toggle : If enabled, this option aligns the first circle's largest axis to the last circle's largest axis. If disabled, the first and last circles' x axes are aligned. This option can help minimize the twist in the joint ellipses between bones.",
                "type": "TogglePar",
                "name": "majoraxes",
                "items": []
            },
            {
                "text": "Toggle : If on, the rotations of the added circles are calculated such that they never rotate further than one half turn in either direction. This leads to a visually continuous layout suitable for creating a skeleton, but will cause problems if the circles are later skinned since the beginnings of each circle may no longer be continuously aligned.",
                "type": "TogglePar",
                "name": "mintwist",
                "items": []
            },
            {
                "text": "Float : These parameters control the shape of the smooth path, varying the shape of the implied curve from the left or right. If the Orient Circles option is on, the sign of the scale has no effect. For a discussion of the relative terms right and left, see [[Align SOP]].",
                "type": "FloatPar",
                "name": "lrscale",
                "items": []
            },
            {
                "text": "Float : These parameters allow you to override the distance between circles, thereby affecting the shape of the joint.",
                "type": "FloatPar",
                "name": "lroffset",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "long": "The Joint SOP will aid in the creation of circle-based skeletons by creating a series of circles between each pair of input circles. This SOP requires at least a pair of circles in order to work correctly.",
        "opLicense": "Non-Commercial",
        "opClass": "jointSOP_Class",
        "opLabel": "Joint",
        "opFamily": "SOP",
        "opType": "joint",
        "short": "The Joint SOP will aid in the creation of circle-based skeletons by creating a series of circles between each pair of input circles.",
        "opCategories": ""
    },
    "kinectSOP": {
        "label": "kinectSOP",
        "members": [
            {
                "text": "Menu : Only Kinect v1 sensors supported at this time.",
                "type": "MenuPar",
                "name": "hwversion",
                "items": []
            },
            {
                "text": "StrMenu : Selects which Kinect sensor to use. Only available when using Kinect v1.",
                "type": "StrMenuPar",
                "name": "sensor",
                "items": []
            },
            {
                "text": "Menu : Only used for Kinect 1 devices. Specify whether to track full skeleton or seated skeleton.",
                "type": "MenuPar",
                "name": "skeleton",
                "items": []
            },
            {
                "text": "Toggle : Only used for Kinect 1 devices. Enables near mode which allows camera to see objects as close as 40cm to the camera (instead of the default 80cm).",
                "type": "TogglePar",
                "name": "neardepthmode",
                "items": []
            },
            {
                "text": "Toggle : Creates normals on the geometry.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "kinectSOP_Class",
        "opType": "kinect",
        "opLicense": "Non-Commercial",
        "opLabel": "Kinect",
        "long": "The Kinect SOP uses the Kinect v1 sensor to scan and create geometry.",
        "opFilter": "False",
        "opFamily": "SOP",
        "short": "The Kinect SOP uses the Kinect v1 sensor to scan and create geometry.",
        "opCategories": ""
    },
    "latticeSOP": {
        "label": "latticeSOP",
        "members": [
            {
                "text": "StrMenu : Subset of points in the first input to be deformed. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Choose if deformation should be done using a regularly spaced lattice or an arbitary point cloud.",
                "type": "MenuPar",
                "name": "deformtype",
                "items": []
            },
            {
                "text": "Int : Must be set to match the number of divisions in the lattice grid object(s).",
                "type": "IntPar",
                "name": "divs",
                "items": []
            },
            {
                "text": "StrMenu : Deformation by specifying a Kernal Function and Points makes it easier to deform arbitrary clouds of points, as this makes the topology of the lattice behave more like a metaball rather than as a fixed lattice. ''Kernel Function'' determines which meta kernel to use to determine the influence of a point. For more information on kernel types check here: [[Metaball#Metaball_Model_Types|Metaball Model Types]]",
                "type": "StrMenuPar",
                "name": "kernel",
                "items": []
            },
            {
                "text": "Float : The size of the points capture regions.",
                "type": "FloatPar",
                "name": "radius",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "latticeSOP_Class",
        "opType": "lattice",
        "opLicense": "Non-Commercial",
        "opLabel": "Lattice",
        "long": "The Lattice SOP allows you to create animated deformations of its input geometry by manipulating grids or a subdivided box that encloses the input source's geometry.\t\t\n\t\t\t\nIt is much easier to deform an object by moving a few grids than trying to animate every single point of an object.\t\t\t\n\t\t\t\nThis SOP has very few buttons and looks simple, but it is important to understand how it works. The first input, called '''Geometry to Deform''', is for the geometry you wish to deform. The second input, called '''Rest Geometry''', must be an evenly spaced grid which fully encloses the geometry to deform. The third input, called '''Deformed Geometry''', is a copy of the initial grid that is altered in some way, either by moving parts of it with animation channels, dragging its points in the Model Editor, or by running it through a [[Spring SOP]] which distorts it with the forces which simulate the laws of physics. Lattice computes a deformation based on the difference between the Rest Geometry and the Deformed Geometry, and applies it to the input geometry. The output of the SOP is the deformation of the geometry in the input source. If the Deformed Geometry is being animated, the output will also bend, twist and stretch every frame.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Lattice SOP allows you to create animated deformations of its input geometry by manipulating grids or a subdivided box that encloses the input source's geometry.",
        "opCategories": ""
    },
    "lineSOP": {
        "label": "lineSOP",
        "members": [
            {
                "text": "XYZ : These X,Y, and Z values set the position of the beginning of the line.",
                "type": "XYZPar",
                "name": "pax",
                "items": []
            },
            {
                "text": "XYZ : These X,Y, and Z values set the position of the beginning of the line.",
                "type": "XYZPar",
                "name": "pay",
                "items": []
            },
            {
                "text": "XYZ : These X,Y, and Z values set the position of the beginning of the line.",
                "type": "XYZPar",
                "name": "paz",
                "items": []
            },
            {
                "text": "XYZ : These X,Y, and Z values set the position of the end of the line.",
                "type": "XYZPar",
                "name": "pbx",
                "items": []
            },
            {
                "text": "XYZ : These X,Y, and Z values set the position of the end of the line.",
                "type": "XYZPar",
                "name": "pby",
                "items": []
            },
            {
                "text": "XYZ : These X,Y, and Z values set the position of the end of the line.",
                "type": "XYZPar",
                "name": "pbz",
                "items": []
            },
            {
                "text": "Int : The number of points the line is made of. Minimum is 2 points.",
                "type": "IntPar",
                "name": "points",
                "items": []
            },
            {
                "text": "Menu : Texture adds (0,1) coordinates to the vertices when set to Unit. Creates a rectangle without uv attributes when set to Off.",
                "type": "MenuPar",
                "name": "texture",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "lineSOP_Class",
        "opType": "line",
        "opLicense": "Non-Commercial",
        "opLabel": "Line",
        "long": "The Line SOP creates straight lines.",
        "opFilter": "False",
        "opFamily": "SOP",
        "short": "The Line SOP creates straight lines.",
        "opCategories": ""
    },
    "linethickSOP": {
        "label": "linethickSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this <span>SOP</span> to act only upon the group specified. Accepts patterns.",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Float : Controls the width of the surface created at the start of the line. Startwidth1 adjusts the width on the inside of the curve, Startwidth2 adjusts the width on the outside of the curve.",
                "type": "FloatPar",
                "name": "startwidth",
                "items": []
            },
            {
                "text": "Float : Controls the width of the surface created at the end of the line. Endwidth1 adjusts the width on the inside of the curve, Endwidth2 adjusts the width on the outside of the curve.",
                "type": "FloatPar",
                "name": "endwidth",
                "items": []
            },
            {
                "text": "Int : Number of Divisions (Columns) in the surface geometry created.",
                "type": "IntPar",
                "name": "divisions",
                "items": []
            },
            {
                "text": "Int : Number of Rows in the surface geometry created.",
                "type": "IntPar",
                "name": "rows",
                "items": []
            },
            {
                "text": "Float : Fraction of the input curve that is used to create the new surface geometry. Domain1 sets position on the curve for Startwidth, Domain2 sets position on the curve for Endwidth.",
                "type": "FloatPar",
                "name": "domain",
                "items": []
            },
            {
                "text": "Menu : This menu selects the type of interpolation used between Startwidth and Endwidth.",
                "type": "MenuPar",
                "name": "shape",
                "items": []
            },
            {
                "text": "Toggle : When this is selected, the Endwidth is positioned at the middlepoint on the curve between Domain1 and Domain2. Startwidth is placed at Domain1 and Domain2. The result is a symmetric surface.",
                "type": "TogglePar",
                "name": "symmetric",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "linethickSOP_Class",
        "opType": "linethick",
        "opLicense": "Non-Commercial",
        "opLabel": "Line Thick",
        "long": "The Line Thick SOP extrudes a surface from a curved line. The line can be of polygon, NURBS, or Bezier geometry type.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Line Thick SOP extrudes a surface from a curved line.",
        "opCategories": ""
    },
    "lsystemSOP": {
        "label": "lsystemSOP",
        "members": [
            {
                "text": "Menu : Provides two options for output geometry:",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Float : Determines the number of times to apply the rules to the initial string. This value controls the growth of the L-system. Place a time-based function here to animate the L-system growth.",
                "type": "FloatPar",
                "name": "generations",
                "items": []
            },
            {
                "text": "Float : Random Scale as a percentage. This will apply a random scale to the changing geometry's lengths, angles and thickness.",
                "type": "FloatPar",
                "name": "randscale",
                "items": []
            },
            {
                "text": "Int : Random Seed for the SOP. This value can be used to select different sequences of random values.",
                "type": "IntPar",
                "name": "randseed",
                "items": []
            },
            {
                "text": "Toggle : Calculates the incremental angles of branches, if a non-integer generational value is used. If the Generations field is animating, this should be set to ensure smooth growth.",
                "type": "TogglePar",
                "name": "contangl",
                "items": []
            },
            {
                "text": "Toggle : Calculates the incremental lengths of the geometry points if a non-integer generational value is used. As with Continuous Angles, if the Generations field is animating, this should be set to ensure smooth, continuous growth. The Continuous Width field applies to tube thickness.",
                "type": "TogglePar",
                "name": "contlength",
                "items": []
            },
            {
                "text": "Toggle : Calculates the incremental lengths of the geometry points if a non-integer generational value is used. As with Continuous Angles, if the Generations field is animating, this should be set to ensure smooth, continuous growth. The Continuous Width field applies to tube thickness.",
                "type": "TogglePar",
                "name": "contwidth",
                "items": []
            },
            {
                "text": "Toggle : Use a TOP to apply color to the L-system as it grows.",
                "type": "TogglePar",
                "name": "docolor",
                "items": []
            },
            {
                "text": "TOP : Defines a TOP to use when the Apply Color button is selected. Also see the ` and # turtle operators.",
                "type": "TOPPar",
                "name": "colormap",
                "items": []
            },
            {
                "text": "UV : Defines the default color U, V index increments when the turtle symbols ` or # are used.",
                "type": "UVPar",
                "name": "inc",
                "items": []
            },
            {
                "text": "Toggle : Adds a point <code>width</code> attribute to each point in the geometry. This width is effected by the Thickness and Thickness Scale parameters on the Tube Page.",
                "type": "TogglePar",
                "name": "pointwidth",
                "items": []
            },
            {
                "text": "Int : The first option sets the number of tube sides and the second sets the number of divisions per step length if tube geometry is selected.",
                "type": "IntPar",
                "name": "rows",
                "items": []
            },
            {
                "text": "Int : The first option sets the number of tube sides and the second sets the number of divisions per step length if tube geometry is selected.",
                "type": "IntPar",
                "name": "cols",
                "items": []
            },
            {
                "text": "Float : Tension defines the smoothness of branching corners.",
                "type": "FloatPar",
                "name": "tension",
                "items": []
            },
            {
                "text": "Float : Enabling this option allows a child branch to be continuously joined to its parent branch.",
                "type": "FloatPar",
                "name": "smooth",
                "items": []
            },
            {
                "text": "Float : This number defines the default tube thickness.",
                "type": "FloatPar",
                "name": "thickinit",
                "items": []
            },
            {
                "text": "Float : This number is the scale factor used with the ! or ? operator.",
                "type": "FloatPar",
                "name": "thickscale",
                "items": []
            },
            {
                "text": "Toggle : When enabled, UV texture coordinates are applied to the tube segments, such that the texture wraps smoothly and continuously over branches.",
                "type": "TogglePar",
                "name": "dotexture",
                "items": []
            },
            {
                "text": "Float : Defines the vertical spacing of texture coordinates over tube geometry when tube texture is applied.",
                "type": "FloatPar",
                "name": "vertinc",
                "items": []
            },
            {
                "text": "Float : Step Size allows you to define the default length of the edges when new geometry is generated.",
                "type": "FloatPar",
                "name": "stepinit",
                "items": []
            },
            {
                "text": "Float : Step Size Scale defines the scale by which the geometry will be modified by the \" or _ (double quote, or underscore) turtle operators.",
                "type": "FloatPar",
                "name": "stepscale",
                "items": []
            },
            {
                "text": "Float : Angle defines the default turning angle for turns, rolls and pitches.",
                "type": "FloatPar",
                "name": "angleinit",
                "items": []
            },
            {
                "text": "Float : Angle Scale allows you to enter the scaling factor to be employed when the ; or @ operators are used.",
                "type": "FloatPar",
                "name": "anglescale",
                "items": []
            },
            {
                "text": "Float : Substitutes user-defined b, c and d variables in rules or premise. These variables are expanded and so may include system variables such as <code>$F</code> and <code>$T</code>.",
                "type": "FloatPar",
                "name": "varb",
                "items": []
            },
            {
                "text": "Float : Substitutes user-defined b, c and d variables in rules or premise. These variables are expanded and so may include system variables such as <code>$F</code> and <code>$T</code>.",
                "type": "FloatPar",
                "name": "varc",
                "items": []
            },
            {
                "text": "Float : Substitutes user-defined b, c and d variables in rules or premise. These variables are expanded and so may include system variables such as <code>$F</code> and <code>$T</code>.",
                "type": "FloatPar",
                "name": "vard",
                "items": []
            },
            {
                "text": "Float : This parameter determines the amount of gravity applied to the geometry via the T (tropism vector) turtle operator. '''Tropism''' is when a plant bends or curves in response to an external stimulus. L-systems employ a tropism vector to simulate this behaviour. The bending is characterised by the fact that the thicker or shorter parts bend less than the longer or thinner parts.",
                "type": "FloatPar",
                "name": "gravity",
                "items": []
            },
            {
                "text": "TOP : This is the TOP which the pic() function uses. See [[#Expressions L-system Specific Expression Functions]] below.",
                "type": "TOPPar",
                "name": "pictop",
                "items": []
            },
            {
                "text": "Str : If the production g(n) is encountered, all subsequent geometry is included in a primitive group prefixed with this label and ending with the ascii value of n. See [[#CreateGroup Creating Groups within L-systems]] below for an example.",
                "type": "StrPar",
                "name": "grpprefix",
                "items": []
            },
            {
                "text": "Str : If the expression chan(n) is encountered, it is replaced with the local channel prefixed with this label and ending with the ascii value of n.",
                "type": "StrPar",
                "name": "chanprefix",
                "items": []
            },
            {
                "text": "Str : You can determine which parameters are used by leaves.<br /> See [[#CreateGroup Creating Groups within L-systems]] below for an example.",
                "type": "StrPar",
                "name": "stampa",
                "items": []
            },
            {
                "text": "Str : You can determine which parameters are used by leaves.<br /> See [[#CreateGroup Creating Groups within L-systems]] below for an example.",
                "type": "StrPar",
                "name": "stampb",
                "items": []
            },
            {
                "text": "Str : You can determine which parameters are used by leaves.<br /> See [[#CreateGroup Creating Groups within L-systems]] below for an example.",
                "type": "StrPar",
                "name": "stampc",
                "items": []
            },
            {
                "text": "DAT : Path to the DAT defining the rules for the LSystem. \t\n*Context Ignore <code>context_ignore:</code> - Defining this in the Rules DAT specifies all characters which are to be skipped when testing context sensitivity in the rules below.\t\t\t\n*Premise <code>premise:</code> - Define an initial string of characters to which the substitution rules are applied.\t\t\t\n*Rules - This is where the turtle substitution rules are defined.",
                "type": "DATPar",
                "name": "rules",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "lsystemSOP_Class",
        "opType": "lsystem",
        "opLicense": "Non-Commercial",
        "opLabel": "LSystem",
        "long": "The Lsystem SOP implements L-systems (Lindenmayer-systems, named after Aristid Lindenmayer (1925-1989)), allow definition of complex shapes through the use of iteration. They use a mathematical language in which an initial string of characters is evaluated repeatedly, and the results are used to generate geometry. The result of each evaluation becomes the basis for the next iteration of geometry, giving the illusion of growth.\t\t\n\t\t\t\nYou begin building an L-system by defining a sequence of rules which are evaluated to produce a new string of characters. Each character of the new string represents one command which affects an imaginary stylus, or \"turtle\". Repeating this process will grow your geometry.\t\t\t\n\t\t\t\nYou can use L-systems to create things such as:\t\t\t\n* Create organic objects such as trees, plants, flowers over time.\t\t\t\n* Create animated branching objects such as lightning and snowflakes.\t\t\t\n\t\t\t\nThe file can be read in from disk or from the web. Use http:// when specifying a URL.\t\t\t\n\t\t\t\n===<div class=\"subSectionLineSOP\">The Algorithmic Beauty of Plants</div>===\t\t\t\n\t\t\t\nThe descriptions located here should be enough to get you started in writing your own L-system rules, however, if you have any serious interests in creating L-systems, you should obtain the book:\t\t\t\n\t\t\t\n The Algorithmic Beauty of Plants\t\t\t\n Przemyslaw Prusinkiewicz &amp; Aristid Lindenmayer\t\t\t\n Springer-Verlag, New York, Phone: 212.460.1500\t\t\t\n ISBN: 0-387-94676-4, 1996.\t\t\t\n\t\t\t\nwhich is the definitive reference on the subject. It contains a multitude of L-systems examples complete with descriptions of the ideas and theories behind modelling realistic plant growth.",
        "opFilter": "False",
        "opFamily": "SOP",
        "short": "The Lsystem SOP implements L-systems (Lindenmayer-systems, named after Aristid Lindenmayer (1925-1989)), allow definition of complex shapes through the use of iteration.",
        "opCategories": ""
    },
    "magnetSOP": {
        "label": "magnetSOP",
        "members": [
            {
                "text": "StrMenu : Allows you to specify a group of geometry to be deformed, and a group that will act as the magnet respectively. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "deformgrp",
                "items": []
            },
            {
                "text": "StrMenu : Allows you to specify a group of geometry to be deformed, and a group that will act as the magnet respectively. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "magnetgrp",
                "items": []
            },
            {
                "text": "Menu : Sets the overall transform order for the transformations. The transform order determines the order in which transformations take place. Depending on the order, you can achieve different results using the exact same values. Choose the appropriate order from the menu.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : Sets the order of the rotations within the overall transform order.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the Source geometry in the three axes. The Translates of the metaball only affect the position of the area of influence. The influence itself is provided by an imaginary magnet within the Magnet SOP itself, and the attitude of this influence is determined by the Translates of the Magnet SOP.\t\n\t\t\t\n'''Note:''' If the '''Translate''' values of the Magnet SOP are all zero, the magnet will have no deforming influence. The weight of the [[Metaball SOP]] scales the influence of the Magnet SOP's Translates.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the Source geometry in the three axes. The Translates of the metaball only affect the position of the area of influence. The influence itself is provided by an imaginary magnet within the Magnet SOP itself, and the attitude of this influence is determined by the Translates of the Magnet SOP.\t\n\t\t\t\n'''Note:''' If the '''Translate''' values of the Magnet SOP are all zero, the magnet will have no deforming influence. The weight of the [[Metaball SOP]] scales the influence of the Magnet SOP's Translates.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the Source geometry in the three axes. The Translates of the metaball only affect the position of the area of influence. The influence itself is provided by an imaginary magnet within the Magnet SOP itself, and the attitude of this influence is determined by the Translates of the Magnet SOP.\t\n\t\t\t\n'''Note:''' If the '''Translate''' values of the Magnet SOP are all zero, the magnet will have no deforming influence. The weight of the [[Metaball SOP]] scales the influence of the Magnet SOP's Translates.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the input geometry in the three axes.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the input geometry in the three axes.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the input geometry in the three axes.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations. Not the same as the pivot point in the pivot channels.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations. Not the same as the pivot point in the pivot channels.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations. Not the same as the pivot point in the pivot channels.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            },
            {
                "text": "Toggle : Allow the magnet to affect the position of the input geometry. This is enabled by default.",
                "type": "TogglePar",
                "name": "position",
                "items": []
            },
            {
                "text": "Toggle : Allow the magnet to affect the point color of the input geometry.\t\n\t\t\t\n'''Tip:''' To control the contribution of each magnet on the surface's Point Color when the '''Affect Point Color''' option is enabled, set your point colors to black (0,0,0) before the Magnet SOP by using a [[Point SOP]]. The Translate fields in the Magnet SOP will then add per-point rgb color with values of 2,2,2 approaching white. \t\t\t\n\t\t\t\nThe scale and rotate channels of the magnet move you about in 3D color space. This is not recommended.",
                "type": "TogglePar",
                "name": "color",
                "items": []
            },
            {
                "text": "Toggle : Allow the magnet to affect the point normals of the input geometry.",
                "type": "TogglePar",
                "name": "nml",
                "items": []
            },
            {
                "text": "Toggle : Allow the magnet to affect the velocity of the input geometry.",
                "type": "TogglePar",
                "name": "velocity",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "magnetSOP_Class",
        "opType": "magnet",
        "opLicense": "Non-Commercial",
        "opLabel": "Magnet",
        "long": "The Magnet SOP allows you to affect deformations of the input geometry with another object using a \"magnetic field\" of influence, defined by a metaball field. It allows the creation of animated bumps and dents within objects, and other special effects.\t\t\n\t\t\t\nIt is important to note that the actual deformation comes from the <span class=\"tipTextSOP\">Translate</span> parameters of the Magnet SOP, and not from the metaball. The metaball defines the area of effect for the <span class=\"tipTextSOP\">Translate</span> parameters of the Magnet SOP. The weight of the metaball determines the effectiveness of the <span class=\"tipTextSOP\">Translate</span> within the Magnet SOP.\t\t\t\n\t\t\t\nThe power of the magnet is greatest at the centre of a metaball field and diminishes to nothing at the edge of the field.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Magnet SOP allows you to affect deformations of the input geometry with another object using a \"magnetic field\" of influence, defined by a metaball field.",
        "opCategories": ""
    },
    "mergeSOP": {
        "label": "mergeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "mergeSOP_Class",
        "opType": "merge",
        "opLicense": "Non-Commercial",
        "opLabel": "Merge",
        "long": "The Merge SOP merges geometry from multiple SOPs. You can merge SOPs by wiring them into the Merge SOP, and/or you can specify the names in the SOPs parameter, where you can include wildcard [[Pattern Matching]] to merge large sets of SOPs with similar names.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Merge SOP merges geometry from multiple SOPs.",
        "opCategories": ""
    },
    "metaballSOP": {
        "label": "metaballSOP",
        "members": [
            {
                "text": "Toggle : Available only when an input is connected to the Metaball SOP to set bounds for the metaball. When Modify Bounds = On the transform parameters below will further modify the position and radius of the bounds.",
                "type": "TogglePar",
                "name": "modifybounds",
                "items": []
            },
            {
                "text": "XYZ : Controls the radius of the metaball field.",
                "type": "XYZPar",
                "name": "radx",
                "items": []
            },
            {
                "text": "XYZ : Controls the radius of the metaball field.",
                "type": "XYZPar",
                "name": "rady",
                "items": []
            },
            {
                "text": "XYZ : Controls the radius of the metaball field.",
                "type": "XYZPar",
                "name": "radz",
                "items": []
            },
            {
                "text": "XYZ : Metaball center in X, Y and Z.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Metaball center in X, Y and Z.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Metaball center in X, Y and Z.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "Float : Defines the weight of the Metaball iso-surface within metaball field. An increase in weight makes the density of the metaball greater, and thus the defined implicit surface of it and surrounding metaballs will be enlarged.",
                "type": "FloatPar",
                "name": "metaweight",
                "items": []
            },
            {
                "text": "StrMenu : There are four different metaball interpretations: Wyvill, Elendt, Blinn and Links. See the [[:Category:Geometry|Geometry]] articles for illustrations of the differences between these.",
                "type": "StrMenuPar",
                "name": "kernel",
                "items": []
            },
            {
                "text": "Float : The XY Exponent determines inflation / contraction in the X and Y axes.",
                "type": "FloatPar",
                "name": "expxy",
                "items": []
            },
            {
                "text": "Float : The Z Exponent determines inflation / contraction in the Z axis.",
                "type": "FloatPar",
                "name": "expz",
                "items": []
            },
            {
                "text": "Toggle : Creates normals on the geometry.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "The Metaball SOP creates metaballs and meta-superquadric surfaces. Metaballs can be thought of as spherical force fields whose surface is an implicit function defined at any point where the density of the force field equals a certain threshold. Because the density of the force field can be increased by the proximity of other metaball force fields, metaballs have the unique property that they change their shape to adapt and fuse with surrounding metaballs. This makes them very effective for modeling organic surfaces. For example, below we have a metaball. The surface of the metaball exists whenever the density of the metaball's field reaches a certain threshold:\t\n\t\t\n[[Image:MetaExample1.jpg]]\t\t\n\t\t\nWhen two or more metaball force fields are combined, as in the illustration below, the resulting density of the force fields is added, and the surface extends to include that area where the force fields intersect and create density values with a value of one. For more information on metaballs, see [[Metaball]]s.\t\t\n\t\t\n[[Image:MetaExample2.jpg]]\t\t\n{{OPSubSection\n|opFamily=SOP\n|sectionName=Level of Detail for Metaball Display\n|sectionSummary=You can change the level of detail of the metaball and NURBS display by adjusting the Level of Detail parameter in the Display Option Dialog &gt; Viewport page &gt; <span class=\"tipTextSOP\">Level of Detail</span> option. To open the Display Options Dialog, press \"p\" in a SOP viewport.\n}}\n{{OPSubSection\n|opFamily=SOP\n|sectionName=Better Metaball Shading Tip\n|sectionSummary=Accurate metaball normals will be computed if the normal attribute exists when conversion to polygons is done. Thus, to get improved shading on polygonized metaballs, it's a good idea to add the normal attribute (i.e. use a [[Facet SOP]]) before converting the metaballs.\n}}",
        "opLabel": "Metaball",
        "opLicense": "Non-Commercial",
        "opFamily": "SOP",
        "short": "The Metaball SOP creates metaballs and meta-superquadric surfaces.",
        "opType": "metaball",
        "opFilter": "False",
        "opClass": "metaballSOP_Class",
        "opCategories": ""
    },
    "modelSOP": {
        "label": "modelSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "modelSOP_Class",
        "opType": "model",
        "opLicense": "Non-Commercial",
        "opLabel": "Model",
        "long": "The Model SOP holds the surface modeler in TouchDesigner. It is designed to hold raw model geometry constructed using the SOP Editor (aka Modeler). It holds modeled data and cannot be unlocked - protecting you from losing your model data.\n\t\nAny SOP can be [[Lock Flag|locked]] and modified with the modeler.",
        "opFilter": "False",
        "opFamily": "SOP",
        "short": "The Model SOP holds the surface modeler in TouchDesigner.",
        "opCategories": ""
    },
    "noiseSOP": {
        "label": "noiseSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : This menu sets which attribute of the geometry the Noise SOP acts on.",
                "type": "MenuPar",
                "name": "attribute",
                "items": []
            },
            {
                "text": "Menu : The noise function used to generate noise. The functions available are:",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Float : Any number, integer or non-integer, which starts the random number generator. Each number gives completely different noise patterns, but with similar characteristics.",
                "type": "FloatPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Float : The approximate separation between peaks of a noise cycle. It is expressed in Units. Increasing the period stretches the noise pattern out.\t\n\t\t\t\nPeriod is the opposite of frequency. If the period is 2 seconds, the base frequency is 0.5 cycles per second, or 0.5Hz for short. Hz refers to Hertz, the electrical and audio engineer of the 19th century, not the car guy.\t\t\t\n\t\t\t\nIf the Type is set to Random, setting this to zero will produce completely random noise. Otherwise, the period should be greater than zero.",
                "type": "FloatPar",
                "name": "period",
                "items": []
            },
            {
                "text": "Int : The number of higher frequency components to layer on top of the base frequency. The higher this number, the bumpier the noise will be (as long as roughness is not set to zero). 0 Harmonics give the base shape.\t\n\t\t\t\nHarmonics with a base frequency of 0.1Hz will by default produce harmonics at 0.2Hz, 0.4Hz, 0.8Hz, etc. (up to the number of harmonics specified by the Harmonics parameter).",
                "type": "IntPar",
                "name": "harmon",
                "items": []
            },
            {
                "text": "Float : The factor by which the frequency of the harmonics are increased. It is normally 2. A spread of 3 and a base frequency of 0.1Hz will produce harmonics at 0.3Hz, 0.9Hz, 2.7Hz, etc.. This parameter is only valid for the Harmonic Summation type.",
                "type": "FloatPar",
                "name": "spread",
                "items": []
            },
            {
                "text": "Float : Controls the effect of the higher frequency noise. When Roughness is zero, all harmonics above the base frequency have no effect. At one, all harmonics are equal in amplitude to the base frequency. When Roughness is between one and zero, the amplitude of higher harmonics drops off exponentially from the base frequency.\t\n\t\t\t\nThe default roughness is 0.5. This means the amplitude of the first harmonic is 0.5 of the base frequency, the second is 0.25, the third is 0.125. The harmonics are added to the base to give the final shape. The Harmonics parameter and the Roughness parameter must both be non-zero to see the harmonic effects.",
                "type": "FloatPar",
                "name": "rough",
                "items": []
            },
            {
                "text": "Float : Pushes the noise values toward 0, or +1 and -1. (It raises the value to the power of the exponent.) Exponents greater than one will pull the channel toward zero, and powers less than one will pull peaks towards +1 and -1. It is used to reshape the channels.",
                "type": "FloatPar",
                "name": "exp",
                "items": []
            },
            {
                "text": "Int : Defines the number of times to integrate (see the [[Speed CHOP]]) the Brownian noise. Higher values produce smoother curves with fewer features. Values beyond 4 produce somewhat identical curves. This parameter is only valid for the Random noise type.",
                "type": "IntPar",
                "name": "numint",
                "items": []
            },
            {
                "text": "Float : Defines the noise value's amplitude (a scale on the values output).",
                "type": "FloatPar",
                "name": "amp",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "keepnormals",
                "items": []
            },
            {
                "text": "Menu : The menu attached to this parameter allows you to specify the order in which the transforms will take place. Changing the Transform order will change where things go much the same way as going a block and turning east gets you to a different place than turning east and then going a block.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : The rotational matrix presented when you click on this option allows you to set the transform order for the rotations. As with transform order (above), changing the order in which the rotations take place will alter the final position.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : Translate the sampling plane through the noise space.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Translate the sampling plane through the noise space.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Translate the sampling plane through the noise space.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : Rotate the sampling plane in the noise space.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : Rotate the sampling plane in the noise space.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : Rotate the sampling plane in the noise space.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : Scale the sampling plane.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : Scale the sampling plane.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : Scale the sampling plane.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : Control the pivot for the transform of the sampling plane.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : Control the pivot for the transform of the sampling plane.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : Control the pivot for the transform of the sampling plane.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "noiseSOP_Class",
        "opType": "noise",
        "opLicense": "Non-Commercial",
        "opLabel": "Noise",
        "long": "The Noise SOP displaces geometry points using noise patterns. It uses the same math as the [[Noise CHOP]].",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Noise SOP displaces geometry points using noise patterns.",
        "opCategories": ""
    },
    "nullSOP": {
        "label": "nullSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "nullSOP_Class",
        "opType": "null",
        "opLicense": "Non-Commercial",
        "opLabel": "Null",
        "long": "The Null SOP has no effect on the geometry. It is an instance of the SOP connected to its input. The Null SOP is often used when making reference to a SOP network, allowing new SOPs to be added to the network (upstream) without the need to update the reference.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Null SOP has no effect on the geometry. It is an instance of the SOP connected to its input.",
        "opCategories": ""
    },
    "oculusriftSOP": {
        "label": "oculusriftSOP",
        "members": [
            {
                "text": "Menu : Select which controller model to load.",
                "type": "MenuPar",
                "name": "model",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "SOP",
        "opType": "oculusrift",
        "opLabel": "Oculus Rift",
        "opLicense": "Non-Commercial",
        "opClass": "oculusriftSOP_Class",
        "opFilter": "False",
        "short": "Loads geometry for the Oculus Rift Touch controllers.",
        "os": "Microsoft Windows",
        "long": "Loads geometry for the Oculus Rift Touch controllers.",
        "opCategories": ""
    },
    "outSOP": {
        "label": "NotSet",
        "members": [
            {
                "text": "Str : Creates a pop-up label when the cursor rolls over this Component output.",
                "type": "StrPar",
                "name": "label",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": []
    },
    "particleSOP": {
        "label": "particleSOP",
        "members": [
            {
                "text": "StrMenu : Limit the particle emission to the points found in the specified point groups.",
                "type": "StrMenuPar",
                "name": "sourcegrp",
                "items": []
            },
            {
                "text": "Menu : Selects how the particles are rendered.",
                "type": "MenuPar",
                "name": "prtype",
                "items": []
            },
            {
                "text": "Menu : Select between emitting particles from the geometry's points or deforming the original geometry using the Particle SOP's behavior.",
                "type": "MenuPar",
                "name": "behave",
                "items": []
            },
            {
                "text": "Toggle : Creates normals on the geometry.  Only used when <span class=\"tipTextSOP\">Behaviour</span> is set to <span class=\"tipTextSOP\">Modify Source Geometry</span>.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            },
            {
                "text": "Menu : Decide how the internal memory for points is reused when a point needs to be created or when a point dies.",
                "type": "MenuPar",
                "name": "ptreuse",
                "items": []
            },
            {
                "text": "Float : How many seconds of the simulation to bypass, after the reset time is reached. For example, if you put the number <code>33</code> into this field (and reset is at <code>Tstart</code>), frame one will show the simulation that was at a time of 33 seconds. In other words, the first thirty-two seconds have been bypassed, and the time at thirty-three seconds is shifted to frame one. The first thirty-two seconds must still be calculated in order to compute the status of the points, so you will notice some delay upon reset.",
                "type": "FloatPar",
                "name": "timepreroll",
                "items": []
            },
            {
                "text": "Float : The <span class=\"tipTextSOP\">Time Inc</span> parameter determines how often to cook the SOP. By default, this parameter is set to <code>1/$FPS</code>. This means that the SOP will cook once for every frame. When complex dynamics are involved, the SOP may require more frequent cooking for increased mathematical accuracy. To get sub-frame accuracy in the cooking, set the <span class=\"tipTextSOP\">Time Inc</span> to something smaller than <code>1/$FPS</code>.\t\n\t\t\t\n'''For example:''' Setting the <span class=\"tipTextSOP\">Time Inc</span> to <code>0.5/$FPS</code> will mean that the SOP gets cooked twice for every frame.\t\t\t\n\t\t\t\n'''Note:''' Never set this parameter to be greater than <code>1/$FPS</code>.",
                "type": "FloatPar",
                "name": "timeinc",
                "items": []
            },
            {
                "text": "Int : Limits how far back in time TouchDesigner calculates particle positions for proper interactions.  If frame rates are slow this computation back in time can become high, this parameter limits that effect.",
                "type": "IntPar",
                "name": "maxsteps",
                "items": []
            },
            {
                "text": "Toggle : This allows you to jitter the location pixels of each particle as they are born.",
                "type": "TogglePar",
                "name": "jitter",
                "items": []
            },
            {
                "text": "Toggle : This option makes the particles move more accurately between frames by calculating their trajectories for fractional frame values.",
                "type": "TogglePar",
                "name": "accurate",
                "items": []
            },
            {
                "text": "Toggle : Removes all unused points from the input geometry. This is provided as an explicit option instead of automatically because it saves the time needed to purge the points from memory during the simulation. This prevents unnecessary slowdowns during the simulation.",
                "type": "TogglePar",
                "name": "rmunused",
                "items": []
            },
            {
                "text": "Menu : Select which mode of attraction to use for Surface Attractors.",
                "type": "MenuPar",
                "name": "attractmode",
                "items": []
            },
            {
                "text": "Toggle : When On the particle system is held in a reset state and does not emit particles.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Instantly reset the particle system to its starting state.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            },
            {
                "text": "XYZ : Forces of gravity acting on the particles. When drag is zero, the particles can accelerate with no limit on their speed.",
                "type": "XYZPar",
                "name": "externalx",
                "items": []
            },
            {
                "text": "XYZ : Forces of gravity acting on the particles. When drag is zero, the particles can accelerate with no limit on their speed.",
                "type": "XYZPar",
                "name": "externaly",
                "items": []
            },
            {
                "text": "XYZ : Forces of gravity acting on the particles. When drag is zero, the particles can accelerate with no limit on their speed.",
                "type": "XYZPar",
                "name": "externalz",
                "items": []
            },
            {
                "text": "XYZ : Wind forces acting on the particles. Similar to <span class=\"tipTextSOP\">External Force</span>. Using <span class=\"tipTextSOP\">Wind</span> (and no other forces, such as <span class=\"tipTextSOP\">Turbulence</span>), the particles will not exceed the wind velocity.\t\n\t\t\t\n====Discussion - Wind vs External Force====\t\t\t\n\t\t\t\nThe application of <span class=\"tipTextSOP\">External Force</span> directly affects a particles' acceleration, the rate of which is determined by the mass (F = Mass  Acceleration). <span class=\"tipTextSOP\">Wind</span> is an additional force, but one that is velocity sensitive. If a particle is already travelling at wind velocity, then it shouldn't receive any extra force from it. This implies a maximum velocity when using <span class=\"tipTextSOP\">Wind</span> on its own.\t\t\t\n\t\t\t\nAn increase in mass impedes acceleration for a given constant force. <span class=\"tipTextSOP\">Drag</span> is a force opposing the direction of motion which is velocity sensitive, i.e. the larger the velocity, the greater the effect of drag. Its useful for limiting the velocity of particles.",
                "type": "XYZPar",
                "name": "windx",
                "items": []
            },
            {
                "text": "XYZ : Wind forces acting on the particles. Similar to <span class=\"tipTextSOP\">External Force</span>. Using <span class=\"tipTextSOP\">Wind</span> (and no other forces, such as <span class=\"tipTextSOP\">Turbulence</span>), the particles will not exceed the wind velocity.\t\n\t\t\t\n====Discussion - Wind vs External Force====\t\t\t\n\t\t\t\nThe application of <span class=\"tipTextSOP\">External Force</span> directly affects a particles' acceleration, the rate of which is determined by the mass (F = Mass  Acceleration). <span class=\"tipTextSOP\">Wind</span> is an additional force, but one that is velocity sensitive. If a particle is already travelling at wind velocity, then it shouldn't receive any extra force from it. This implies a maximum velocity when using <span class=\"tipTextSOP\">Wind</span> on its own.\t\t\t\n\t\t\t\nAn increase in mass impedes acceleration for a given constant force. <span class=\"tipTextSOP\">Drag</span> is a force opposing the direction of motion which is velocity sensitive, i.e. the larger the velocity, the greater the effect of drag. Its useful for limiting the velocity of particles.",
                "type": "XYZPar",
                "name": "windy",
                "items": []
            },
            {
                "text": "XYZ : Wind forces acting on the particles. Similar to <span class=\"tipTextSOP\">External Force</span>. Using <span class=\"tipTextSOP\">Wind</span> (and no other forces, such as <span class=\"tipTextSOP\">Turbulence</span>), the particles will not exceed the wind velocity.\t\n\t\t\t\n====Discussion - Wind vs External Force====\t\t\t\n\t\t\t\nThe application of <span class=\"tipTextSOP\">External Force</span> directly affects a particles' acceleration, the rate of which is determined by the mass (F = Mass  Acceleration). <span class=\"tipTextSOP\">Wind</span> is an additional force, but one that is velocity sensitive. If a particle is already travelling at wind velocity, then it shouldn't receive any extra force from it. This implies a maximum velocity when using <span class=\"tipTextSOP\">Wind</span> on its own.\t\t\t\n\t\t\t\nAn increase in mass impedes acceleration for a given constant force. <span class=\"tipTextSOP\">Drag</span> is a force opposing the direction of motion which is velocity sensitive, i.e. the larger the velocity, the greater the effect of drag. Its useful for limiting the velocity of particles.",
                "type": "XYZPar",
                "name": "windz",
                "items": []
            },
            {
                "text": "XYZ : The amplitude of turbulent (chaotic) forces along each axis. Use positive values, if any.",
                "type": "XYZPar",
                "name": "turbx",
                "items": []
            },
            {
                "text": "XYZ : The amplitude of turbulent (chaotic) forces along each axis. Use positive values, if any.",
                "type": "XYZPar",
                "name": "turby",
                "items": []
            },
            {
                "text": "XYZ : The amplitude of turbulent (chaotic) forces along each axis. Use positive values, if any.",
                "type": "XYZPar",
                "name": "turbz",
                "items": []
            },
            {
                "text": "Float : A small period means that the turbulence varies quickly over a small area, while a larger value will cause points close to each other to be affected similarly.",
                "type": "FloatPar",
                "name": "period",
                "items": []
            },
            {
                "text": "Int : Random number seed for the particle simulation.",
                "type": "IntPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Toggle : Adds an ID number to each particle as it is born. '''Note:''' New attributes only appear once the particle system is reset via the <code>reset<code> parameter or loads for first time.",
                "type": "TogglePar",
                "name": "doid",
                "items": []
            },
            {
                "text": "Toggle : When selected, calculates the mass of the particle, as specified in the <span class=\"tipTextSOP\">Mass</span> field.",
                "type": "TogglePar",
                "name": "domass",
                "items": []
            },
            {
                "text": "Float : The relative mass of each particle. Heavier particles take longer to start moving, and longer to slow down.",
                "type": "FloatPar",
                "name": "mass",
                "items": []
            },
            {
                "text": "Toggle : When selected, calculates the drag coefficient of the particle, as entered in the <span class=\"tipTextSOP\">Drag</span> field.",
                "type": "TogglePar",
                "name": "dodrag",
                "items": []
            },
            {
                "text": "Float : Drag of each particle.",
                "type": "FloatPar",
                "name": "drag",
                "items": []
            },
            {
                "text": "Float : The number of particles born each second. Particles are not released in clusters. They are born at random times during the first frame of their existence. Their birth time is set randomly during the first frame.",
                "type": "FloatPar",
                "name": "birth",
                "items": []
            },
            {
                "text": "Float : How long each particle will exist, in seconds. The default is <code>3</code> seconds. You may want to adjust this number based on the length of your animation.",
                "type": "FloatPar",
                "name": "life",
                "items": []
            },
            {
                "text": "Float : Variance of a particle's life expectancy in seconds. If life expectancy is one second, and the variance is zero seconds, each particle will live exactly one second. If variance is set to 0.5, then some particles will live only a half second, while others will live a second and a half. The rest will live some time in-between. This randomness gives a more natural look to the particle births.",
                "type": "FloatPar",
                "name": "lifevar",
                "items": []
            },
            {
                "text": "Float : As a particle goes faster, it should become more transparent. The <span class=\"tipTextSOP\">Alpha Speed</span> parameter defaults to 0, which doesn't change alpha as the speed increases. A typical value of 0.5 causes the particle to be 70% opaque when it's going 1 unit/second. Increasing the <span class=\"tipTextSOP\">Alpha Speed</span> parameter makes it more transparent at a given speed. At zero speed, a particle is always 100% opaque.",
                "type": "FloatPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "XYZ : The particles will die or bounce off the limit planes when it reaches them. The six limit plane fields define a bounding cube. The default settings are <code>1000</code> units away, which is very large. Reduce the values to about one to see the effect.",
                "type": "XYZPar",
                "name": "limitposx",
                "items": []
            },
            {
                "text": "XYZ : The particles will die or bounce off the limit planes when it reaches them. The six limit plane fields define a bounding cube. The default settings are <code>1000</code> units away, which is very large. Reduce the values to about one to see the effect.",
                "type": "XYZPar",
                "name": "limitposy",
                "items": []
            },
            {
                "text": "XYZ : The particles will die or bounce off the limit planes when it reaches them. The six limit plane fields define a bounding cube. The default settings are <code>1000</code> units away, which is very large. Reduce the values to about one to see the effect.",
                "type": "XYZPar",
                "name": "limitposz",
                "items": []
            },
            {
                "text": "XYZ : The particles will die or bounce off the limit planes when it reaches them. The six limit plane fields define a bounding cube. The default settings are <code>1000</code> units away, which is very large. Reduce the values to about one to see the effect.",
                "type": "XYZPar",
                "name": "limitnegx",
                "items": []
            },
            {
                "text": "XYZ : The particles will die or bounce off the limit planes when it reaches them. The six limit plane fields define a bounding cube. The default settings are <code>1000</code> units away, which is very large. Reduce the values to about one to see the effect.",
                "type": "XYZPar",
                "name": "limitnegy",
                "items": []
            },
            {
                "text": "XYZ : The particles will die or bounce off the limit planes when it reaches them. The six limit plane fields define a bounding cube. The default settings are <code>1000</code> units away, which is very large. Reduce the values to about one to see the effect.",
                "type": "XYZPar",
                "name": "limitnegz",
                "items": []
            },
            {
                "text": "Menu : Control over what happens when a particle hits either the six collision planes or the collide object. The options are:",
                "type": "MenuPar",
                "name": "hit",
                "items": []
            },
            {
                "text": "Float : Friction parameters which can be regarded as energy loss upon collision. The first parameter affects the energy loss (gain) perpendicular to the surface. 0 means all energy (velocity) is lost, 1 means no energy is lost perpendicular to surface. The second parameter is the energy gain tangent to the surface.",
                "type": "FloatPar",
                "name": "gaintan",
                "items": []
            },
            {
                "text": "Float : Friction parameters which can be regarded as energy loss upon collision. The first parameter affects the energy loss (gain) perpendicular to the surface. 0 means all energy (velocity) is lost, 1 means no energy is lost perpendicular to surface. The second parameter is the energy gain tangent to the surface.\t\n\t\t\t\n<!--TDitemStart-->* 1 and 1 means nothing is lost or gained.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* 0.1 and 1 cause the particles to strike the surface and dribble along it, like rain atop a roof.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* 1 and 0 makes them bounce perpendicular to the surface, no matter what angle they came in at.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* -1 and 1 makes the particle bounce back from whence it came.<!--TDitemEnd-->\t\t\t\n<!--TDitemStart-->* Gains greater than 1 cause energy gain (like a pinball machine bumper).<!--TDitemEnd-->",
                "type": "FloatPar",
                "name": "gainnorm",
                "items": []
            },
            {
                "text": "Menu : Select if the particle will split and under what conditions.",
                "type": "MenuPar",
                "name": "splittype",
                "items": []
            },
            {
                "text": "Int : When a particle splits, it splits into a number of other particles. The number of particles is randomly set between this range.",
                "type": "IntPar",
                "name": "split",
                "items": []
            },
            {
                "text": "XYZ : Each split particle is given this base velocity.",
                "type": "XYZPar",
                "name": "splitvelx",
                "items": []
            },
            {
                "text": "XYZ : Each split particle is given this base velocity.",
                "type": "XYZPar",
                "name": "splitvely",
                "items": []
            },
            {
                "text": "XYZ : Each split particle is given this base velocity.",
                "type": "XYZPar",
                "name": "splitvelz",
                "items": []
            },
            {
                "text": "XYZ : This is a random amount that is added to the split velocity. When creating fireworks, the variance is large while the velocity is low. When rendering raindrops splashing, the split velocity is large in Y, and the variance in X and Z causes the particles to bounce up - but randomly - in the XZ plane.",
                "type": "XYZPar",
                "name": "splitvarx",
                "items": []
            },
            {
                "text": "XYZ : This is a random amount that is added to the split velocity. When creating fireworks, the variance is large while the velocity is low. When rendering raindrops splashing, the split velocity is large in Y, and the variance in X and Z causes the particles to bounce up - but randomly - in the XZ plane.",
                "type": "XYZPar",
                "name": "splitvary",
                "items": []
            },
            {
                "text": "XYZ : This is a random amount that is added to the split velocity. When creating fireworks, the variance is large while the velocity is low. When rendering raindrops splashing, the split velocity is large in Y, and the variance in X and Z causes the particles to bounce up - but randomly - in the XZ plane.",
                "type": "XYZPar",
                "name": "splitvarz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "particleSOP_Class",
        "opType": "particle",
        "opLicense": "Non-Commercial",
        "opLabel": "Particle",
        "long": "The Particle SOP is used for creating and controlling motion of \"particles\" for particle systems simulations. Particle systems are often used to create simulations of natural events such as rain and snow, or effects such as fireworks and sparks. In Touch, the points of the input geometry are used as the starting positions of the particles. Each point of the input can be affected by external force (gravity) and wind. Particles can collide and bounce off another object, set by the <span class=\"tipTextSOP\">Collision Source</span>. They can also bounce off, or die at, limit planes set in X, Y and Z.\t\n    \nParticles are created with an initial velocity/direction that comes from the source geometry\u2019s point normals, and that velocity can be controlled by modifying the normals using, for instance, a [[Point SOP]], [[Facet SOP]] or [[Script SOP]]. A point with a Normal of magnitude 1 emit bear particles with a velocity of 1 unit per second in the direction of the normal. \n\t\t\t\nParticles have various [[Attribute]]s that regular geometry do not have, such as velocity, life expectancy and age. These attributes must be carried with each point in order to carry out the simulation.\t\t\t\n\t\t\t\nThe fourth input is Surface Attractors that cause the particles to be attached to areas of a surface. Each particle's id is used to determine a random target primitive, and random u,v on that primitive.  That target position is used to modify the current velocity.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Particle SOP is used for creating and controlling motion of \"particles\" for particle systems simulations.",
        "opCategories": ""
    },
    "pointSOP": {
        "label": "pointSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this <code>SOP</code> to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "XYZ : Expressions to translate the XYZ coordinates of a given point can be entered here. The attributes to modify here are: <syntaxhighlight lang=python inline>me.inputPoint.x</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputPoint.y</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputPoint.z</syntaxhighlight>.\t\n\t\t\t\nSimply entering <syntaxhighlight lang=python inline>me.inputPoint.x</syntaxhighlight> into the Position X field means that the X coordinate of each point that comes in is passed straight through with no modification.\t\t\t\n\t\t\t\nChanging this entry to <syntaxhighlight lang=python inline>me.inputPoint.x+5</syntaxhighlight> means that the X coordinate of each point that comes in will be displaced by 5 units. This expression can be expanded to produce many useful effects. Transformations can also be effected in the Y and Z fields.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Expressions to translate the XYZ coordinates of a given point can be entered here. The attributes to modify here are: <syntaxhighlight lang=python inline>me.inputPoint.x</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputPoint.y</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputPoint.z</syntaxhighlight>.\t\n\t\t\t\nSimply entering <syntaxhighlight lang=python inline>me.inputPoint.x</syntaxhighlight> into the Position X field means that the X coordinate of each point that comes in is passed straight through with no modification.\t\t\t\n\t\t\t\nChanging this entry to <syntaxhighlight lang=python inline>me.inputPoint.x+5</syntaxhighlight> means that the X coordinate of each point that comes in will be displaced by 5 units. This expression can be expanded to produce many useful effects. Transformations can also be effected in the Y and Z fields.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Expressions to translate the XYZ coordinates of a given point can be entered here. The attributes to modify here are: <syntaxhighlight lang=python inline>me.inputPoint.x</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputPoint.y</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputPoint.z</syntaxhighlight>.\t\n\t\t\t\nSimply entering <syntaxhighlight lang=python inline>me.inputPoint.x</syntaxhighlight> into the Position X field means that the X coordinate of each point that comes in is passed straight through with no modification.\t\t\t\n\t\t\t\nChanging this entry to <syntaxhighlight lang=python inline>me.inputPoint.x+5</syntaxhighlight> means that the X coordinate of each point that comes in will be displaced by 5 units. This expression can be expanded to produce many useful effects. Transformations can also be effected in the Y and Z fields.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "Menu : Select between keeping the weight or adding a new weight.",
                "type": "MenuPar",
                "name": "doweight",
                "items": []
            },
            {
                "text": "Float : If you select 'New Weight' from the menu above, enter expressions here to control the values of the point weights here. The attribute to modify is: <syntaxhighlight lang=python inline>me.inputPoint.w</syntaxhighlight>. Values for the weight of the point can range from 0.0001 to infinity.",
                "type": "FloatPar",
                "name": "weight",
                "items": []
            },
            {
                "text": "Menu : Select between keeping the color, adding new color, or using no color.",
                "type": "MenuPar",
                "name": "doclr",
                "items": []
            },
            {
                "text": "RGB : If you select 'Add Color' from the menu above, Cd color attributes will be added/modified in the SOP. Enter expressions below to control the values of the point colors. The attributes to modify are: <syntaxhighlight lang=python inline>me.inputColor[0]</syntaxhighlight> for red, <syntaxhighlight lang=python inline>me.inputColor[1]</syntaxhighlight> for green, <syntaxhighlight lang=python inline>me.inputColor[2]</syntaxhighlight> for blue, and <syntaxhighlight lang=python inline>me.inputColor[3]</syntaxhighlight> for alpha.\nIf you select 'No Color' from the menu above, the Cd color attribute will be removed from the SOP.",
                "type": "RGBPar",
                "name": "diffr",
                "items": []
            },
            {
                "text": "RGB : If you select 'Add Color' from the menu above, Cd color attributes will be added/modified in the SOP. Enter expressions below to control the values of the point colors. The attributes to modify are: <syntaxhighlight lang=python inline>me.inputColor[0]</syntaxhighlight> for red, <syntaxhighlight lang=python inline>me.inputColor[1]</syntaxhighlight> for green, <syntaxhighlight lang=python inline>me.inputColor[2]</syntaxhighlight> for blue, and <syntaxhighlight lang=python inline>me.inputColor[3]</syntaxhighlight> for alpha.\nIf you select 'No Color' from the menu above, the Cd color attribute will be removed from the SOP.",
                "type": "RGBPar",
                "name": "diffg",
                "items": []
            },
            {
                "text": "RGB : If you select 'Add Color' from the menu above, Cd color attributes will be added/modified in the SOP. Enter expressions below to control the values of the point colors. The attributes to modify are: <syntaxhighlight lang=python inline>me.inputColor[0]</syntaxhighlight> for red, <syntaxhighlight lang=python inline>me.inputColor[1]</syntaxhighlight> for green, <syntaxhighlight lang=python inline>me.inputColor[2]</syntaxhighlight> for blue, and <syntaxhighlight lang=python inline>me.inputColor[3]</syntaxhighlight> for alpha.\nIf you select 'No Color' from the menu above, the Cd color attribute will be removed from the SOP.",
                "type": "RGBPar",
                "name": "diffb",
                "items": []
            },
            {
                "text": "Float : Control the alpha attribute in the same manner as the rgb colors above. Alpha is Cd[3] and comes from input via <syntaxhighlight lang=python inline>me.inputColor[3]</syntaxhighlight>",
                "type": "FloatPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Menu : Select between keeping the normals, adding new normals, or using no normals.",
                "type": "MenuPar",
                "name": "donml",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Normal' from the menu above, N normal attributes will be added/modified in the SOP. Enter expressions to change a given point normal here. Point normals are directional vectors used by other SOPs, such as Turbulence, Facet and Copy. See [[Attributes]] article for detailed information. The attributes to modify are: <syntaxhighlight lang=python inline>me.inputNormal[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputNormal[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputNormal[2]</syntaxhighlight>.\nIf you select 'No Normal' from the menu above, the N normal attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "nx",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Normal' from the menu above, N normal attributes will be added/modified in the SOP. Enter expressions to change a given point normal here. Point normals are directional vectors used by other SOPs, such as Turbulence, Facet and Copy. See [[Attributes]] article for detailed information. The attributes to modify are: <syntaxhighlight lang=python inline>me.inputNormal[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputNormal[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputNormal[2]</syntaxhighlight>.\nIf you select 'No Normal' from the menu above, the N normal attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "ny",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Normal' from the menu above, N normal attributes will be added/modified in the SOP. Enter expressions to change a given point normal here. Point normals are directional vectors used by other SOPs, such as Turbulence, Facet and Copy. See [[Attributes]] article for detailed information. The attributes to modify are: <syntaxhighlight lang=python inline>me.inputNormal[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputNormal[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputNormal[2]</syntaxhighlight>.\nIf you select 'No Normal' from the menu above, the N normal attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "nz",
                "items": []
            },
            {
                "text": "Menu : Select between keeping the texture coordinates, adding new texture coordinates, or using no texture coordinates.",
                "type": "MenuPar",
                "name": "douvw",
                "items": []
            },
            {
                "text": "UVW : If you select 'Add Texture' from the menu above, uv texture coordinate attributes will be added/modified in the SOP. Enter expressions here to control the values of the texture coordinates here. The attributes to modify are: <syntaxhighlight lang=python inline>me.inputTexture[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputTexture[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputTexture[2]</syntaxhighlight>.\nIf you select 'No Texture' from the menu above, the uv texture coordinate attribute will be removed from the SOP.",
                "type": "UVWPar",
                "name": "map",
                "items": []
            },
            {
                "text": "Menu : Select between keeping the width attribute or adding a new width. This Width (width) attribute is used exclusively with [[Line MAT]] to control line width when the material is rendered.",
                "type": "MenuPar",
                "name": "dowidth",
                "items": []
            },
            {
                "text": "Float : If you select 'New Width' from the menu above, width attribute will be added/modified in the SOP. Enter expressions here to control the values of the point widths here. The attribute to modify is: <syntaxhighlight lang=python inline>me.inputPoint.width[0]</syntaxhighlight>.",
                "type": "FloatPar",
                "name": "width",
                "items": []
            },
            {
                "text": "Menu : Select between keeping the scale attribute, adding new scale, or using no scale. This scale (pscale) attribute is used with the [[Particle SOP]] and acts as a multiplier for the size of particles. The value of this attribute is multiplied by the size specified in the [[Particle SOP]]'s render attributes to scale each particle. This attribute is used by the [[Point Sprite MAT]] when rendering point sprites.",
                "type": "MenuPar",
                "name": "dopscale",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Scale' from the menu above, pscale attribute will be added/modified in the SOP. Enter expressions here to control the values of the point particle scales here. The attribute to modify is: <syntaxhighlight lang=python inline>me.inputPoint.pscale[0]</syntaxhighlight>.\nIf you select 'No Scale' from the menu above, the pscale attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "pscale",
                "items": []
            },
            {
                "text": "Str : Creates a custom attribute with this name.",
                "type": "StrPar",
                "name": "custom1",
                "items": []
            },
            {
                "text": "Menu : The type of attribute created can be selected from this menu.",
                "type": "MenuPar",
                "name": "custom1type",
                "items": []
            },
            {
                "text": "Float : Set the values of the Custom Attrib using these parameters.",
                "type": "FloatPar",
                "name": "custom1val",
                "items": []
            },
            {
                "text": "Menu : Retains, adds, or removes mass and drag attributes for points.",
                "type": "MenuPar",
                "name": "domass",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Mass/Drag' from the menu above, mass attribute will be added/modified in the SOP. If you select 'No Mass/Drag' from the menu above, the mass attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "mass",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Mass/Drag' from the menu above, drag attribute will be added/modified in the SOP. If you select 'No Mass/Drag' from the menu above, the drag attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "drag",
                "items": []
            },
            {
                "text": "Menu : Tension affects the elasticity of the edges the point is connected to.",
                "type": "MenuPar",
                "name": "dotension",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Tension' from the menu above, tension attribute will be added/modified in the SOP. Enter expressions here to control the values of the tension here. The attribute to modify is: <syntaxhighlight lang=python inline>me.inputPoint.tension[0]</syntaxhighlight>. If you select 'No Tension' from the menu above, the tension attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "tension",
                "items": []
            },
            {
                "text": "Menu : Retains, adds, or removes spring constant attributes for points. The Spring Constant is a well known physical property affecting each point.",
                "type": "MenuPar",
                "name": "dospringk",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Spring K' from the menu above, springk attribute will be added/modified in the SOP. Enter expressions here to control the values of the springk here. The attribute to modify is: <syntaxhighlight lang=python inline>me.inputPoint.springk[0]</syntaxhighlight>. If you select 'No Spring K' from the menu above, the springk attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "springk",
                "items": []
            },
            {
                "text": "Menu : Retains, adds, or removes the velocity of points. Defines the magnitude of the particle's velocity in the X, Y and Z directions.",
                "type": "MenuPar",
                "name": "dovel",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Velocity' from the menu above, v velocity attributes will be added/modified in the SOP. Enter expressions to change a given point velocity here. The attributes to modify here are: <syntaxhighlight lang=python inline>me.inputPoint.v[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputPoint.v[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputPoint.v[2]</syntaxhighlight>. If you select 'No Velocity' from the menu above, the v velocity attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "vx",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Velocity' from the menu above, v velocity attributes will be added/modified in the SOP. Enter expressions to change a given point velocity here. The attributes to modify here are: <syntaxhighlight lang=python inline>me.inputPoint.v[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputPoint.v[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputPoint.v[2]</syntaxhighlight>. If you select 'No Velocity' from the menu above, the v velocity attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "vy",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Velocity' from the menu above, v velocity attributes will be added/modified in the SOP. Enter expressions to change a given point velocity here. The attributes to modify here are: <syntaxhighlight lang=python inline>me.inputPoint.v[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputPoint.v[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputPoint.v[2]</syntaxhighlight>. If you select 'No Velocity' from the menu above, the v velocity attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "vz",
                "items": []
            },
            {
                "text": "Menu : Creates/Removes the \"up\" attribute for points. This attribute defines an up vector which is used to fully define the space around a point (for particle instancing or copying geometry). The up vector can be used in conjunction with the copy template's normals to control the orientation of the copies in the [[Copy SOP]].",
                "type": "MenuPar",
                "name": "doup",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Up Vector' from the menu above, up attributes will be added/modified in the SOP. Enter expressions to change a given point up vector here. The attributes to modify here are: <syntaxhighlight lang=python inline>me.inputPoint.up[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputPoint.up[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputPoint.up[2]</syntaxhighlight>. If you select 'No Up Vector' from the menu above, the up attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "upx",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Up Vector' from the menu above, up attributes will be added/modified in the SOP. Enter expressions to change a given point up vector here. The attributes to modify here are: <syntaxhighlight lang=python inline>me.inputPoint.up[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputPoint.up[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputPoint.up[2]</syntaxhighlight>. If you select 'No Up Vector' from the menu above, the up attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "upy",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Up Vector' from the menu above, up attributes will be added/modified in the SOP. Enter expressions to change a given point up vector here. The attributes to modify here are: <syntaxhighlight lang=python inline>me.inputPoint.up[0]</syntaxhighlight>, <syntaxhighlight lang=python inline>me.inputPoint.up[1]</syntaxhighlight> and <syntaxhighlight lang=python inline>me.inputPoint.up[2]</syntaxhighlight>. If you select 'No Up Vector' from the menu above, the up attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "upz",
                "items": []
            },
            {
                "text": "Menu : Retains, adds, or removes radiusf attributes for points, used to modify the distance roll-off effect. The roll-off is: <code>r /(r+d^2)</code> Where <code>r</code> is radius, and <code>d</code> is distance from attractor point. If no radius is set, no attenuation is performed.",
                "type": "MenuPar",
                "name": "doradius",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Radius' from the menu above, radiusf attribute will be added/modified in the SOP. Enter expressions here to control the values of the distance roll-off here. If you select 'No Radius' from the menu above, the radiusf attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "radiusf",
                "items": []
            },
            {
                "text": "Menu : Retains, adds, or removes scalef attributes for points, a multiplier for total force associated with this attractor point.\t\n\t\t\t\nBoth Radius and Force Scale will default to 1 if not created as point attributes.\t\t\t\n\t\t\t\n'''Radial / Normal / Edge / Directional Force''' - These four parameters introduce a type of force when created and each has a corresponding multiplier associated with it.",
                "type": "MenuPar",
                "name": "doscale",
                "items": []
            },
            {
                "text": "Float : If you select 'Add F Scale' from the menu above, scalef attribute will be added/modified in the SOP. Enter expressions here to control the values of the force multiplier here. If you select 'No F scale' from the menu above, the scalef attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "scalef",
                "items": []
            },
            {
                "text": "Menu : Retains, adds, or removes radialf attributes for points, the force directed towards the attractor point. Positive multipliers are towards while negative are away.",
                "type": "MenuPar",
                "name": "doradialf",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Radial F' from the menu above, radialf attribute will be added/modified in the SOP. Enter expressions here to control the values of the directed force here. If you select 'No Radial F' from the menu above, the radialf attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "radialf",
                "items": []
            },
            {
                "text": "Menu : Retains, adds, or removes normalf attributes for points, the force directed along the point normal direction.",
                "type": "MenuPar",
                "name": "donormalf",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Normal F' from the menu above, normalf attribute will be added/modified in the SOP. Enter expressions here to control the values of the force in the normal direction here. If you select 'No Normal F' from the menu above, the normalf attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "normalf",
                "items": []
            },
            {
                "text": "Menu : Retains, adds, or removes edgef attributes for points, which only works on primitive face types. The force is directed in the direction of the edge leading from that point. If multiple vertices reference the same point, then the direction is the edge direction of the last primitive referencing the point.\t\n\t\t\t\nIf the face open, then the end point has an edge direction equal to that of the preceding point in that primitive.\t\t\t\n\t\t\t\n'''Note:''' When edge forces are added using the Point SOP, the force directions are computed in the Point SOP itself. Thus, any following transformations do not effect these. If you wish for the edge directions to be transformed as well, all transformations must be done before the Point SOP. Only the edge forces function like this.",
                "type": "MenuPar",
                "name": "doedgef",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Edge F' from the menu above, edgef attribute will be added/modified in the SOP. Enter expressions here to control the values of the force in the normal direction here. If you select 'No Edge F' from the menu above, the edgef attribute will be removed from the SOP.",
                "type": "FloatPar",
                "name": "edgef",
                "items": []
            },
            {
                "text": "Menu : Retains, adds, or removes dirf attributes for points, an arbitrary directional force still affected by the distance roll-off function.",
                "type": "MenuPar",
                "name": "dodirf",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Dir. F' from the menu above, dirf attribute will be added/modified in the SOP. Enter expressions here to control the values of the force in the arbitrary direction here. If you select 'No Dir. F' from the menu above, the dirf attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "dirfx",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Dir. F' from the menu above, dirf attribute will be added/modified in the SOP. Enter expressions here to control the values of the force in the arbitrary direction here. If you select 'No Dir. F' from the menu above, the dirf attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "dirfy",
                "items": []
            },
            {
                "text": "XYZ : If you select 'Add Dir. F' from the menu above, dirf attribute will be added/modified in the SOP. Enter expressions here to control the values of the force in the arbitrary direction here. If you select 'No Dir. F' from the menu above, the dirf attribute will be removed from the SOP.",
                "type": "XYZPar",
                "name": "dirfz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "pointSOP_Class",
        "opType": "point",
        "opLicense": "Non-Commercial",
        "opLabel": "Point",
        "long": "The Point SOP allows you to get right into the geometry and manipulate the position, color, texture coordinates, and normals of the points in the Source, and other attributes. The Point SOP also lets you create custom point attributes. It is the complement to the [[Primitive SOP]]. Using a second input allows for combining of two SOPs using their respective expressions (see: [[PointSOP Class]]). If the second input has less points than the first input, the points in the second input will be cycled.\t\t\n\t\t\t\nFor example, you can create point coloring, or flip the normals of incoming geometry. Using expressions in Position X, Y and Z, you can move any given input point to a new place as defined by the expression with any standard attributes. \t\t\n\nThe Width (width) attribute affects the line width in the [[Line MAT]].  The Scale attribute (pscale) affects particle size, and in the [[Line MAT]] it affects the dot size at each point.\n\n'''Tip''': For greater flexibility, use the [[Script SOP]].",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Point SOP allows you to get right down into the geometry and manipulate the position, color, texture coordinates, and normals of the points in the Source, and other attributes.",
        "opCategories": ""
    },
    "polypatchSOP": {
        "label": "polypatchSOP",
        "members": [
            {
                "text": "StrMenu : Subset of input to use. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Select spline type: <span class=\"tipTextSOP\">Cardinal</span> or <span class=\"tipTextSOP\">BSpline</span>.",
                "type": "MenuPar",
                "name": "basis",
                "items": []
            },
            {
                "text": "Menu : This option is used to select how the points of the created surface are connected.",
                "type": "MenuPar",
                "name": "connecttype",
                "items": []
            },
            {
                "text": "Menu : Settings for wrapping in U direction.",
                "type": "MenuPar",
                "name": "closeu",
                "items": []
            },
            {
                "text": "Menu : Settings for wrapping in V direction.",
                "type": "MenuPar",
                "name": "closev",
                "items": []
            },
            {
                "text": "Menu : Settings for clamping first end in U.",
                "type": "MenuPar",
                "name": "firstuclamp",
                "items": []
            },
            {
                "text": "Menu : Settings for clamping last end in U.",
                "type": "MenuPar",
                "name": "lastuclamp",
                "items": []
            },
            {
                "text": "Menu : Settings for clamping first end in V.",
                "type": "MenuPar",
                "name": "firstvclamp",
                "items": []
            },
            {
                "text": "Menu : Settings for clamping last end in V.",
                "type": "MenuPar",
                "name": "lastvclamp",
                "items": []
            },
            {
                "text": "Int : The number of divisions in the output surface. Use more divisions for a smoother surface.",
                "type": "IntPar",
                "name": "divisions",
                "items": []
            },
            {
                "text": "Toggle : Force polygonal rather than mesh output.",
                "type": "TogglePar",
                "name": "polys",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "polypatchSOP_Class",
        "opType": "polypatch",
        "opLicense": "Non-Commercial",
        "opLabel": "Polypatch",
        "long": "The Polypatch SOP creates a smooth polygonal patch from a mesh primitive or a set of faces (polygons, NURBS or Bezier curves).",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Polypatch SOP creates a smooth polygonal patch from a mesh primitive or a set of faces (polygons, NURBS or Bezier curves).",
        "opCategories": ""
    },
    "polyreduceSOP": {
        "label": "polyreduceSOP",
        "members": [
            {
                "text": "StrMenu : The polygons which will be candidates for simplification. Other polygons which share points with these might also be affected.",
                "type": "StrMenuPar",
                "name": "reduce",
                "items": []
            },
            {
                "text": "StrMenu : Which polygons are feature edges.",
                "type": "StrMenuPar",
                "name": "creases",
                "items": []
            },
            {
                "text": "Menu : Select how to reduce the number of polygons from the following methods.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Float : Specify the percentage of polygons to keep when Method set to 'Percentage'.",
                "type": "FloatPar",
                "name": "percentage",
                "items": []
            },
            {
                "text": "Int : Specify the number of polygons to keep when Method set to 'Number'.",
                "type": "IntPar",
                "name": "numpolys",
                "items": []
            },
            {
                "text": "Object : The object to use as a reference.",
                "type": "ObjectPar",
                "name": "obj",
                "items": []
            },
            {
                "text": "Float : The world distance at which the polygons should be left at full detail.",
                "type": "FloatPar",
                "name": "distance",
                "items": []
            },
            {
                "text": "Float : A lower bound to the level of reduction.",
                "type": "FloatPar",
                "name": "minpercent",
                "items": []
            },
            {
                "text": "Float : Without any constraints, the edges of planar surfaces can erode. This controls a bias which penalizes such erosion.",
                "type": "FloatPar",
                "name": "borderweight",
                "items": []
            },
            {
                "text": "Float : The amount of penalty to add to the feature edges being eroded.",
                "type": "FloatPar",
                "name": "creaseweight",
                "items": []
            },
            {
                "text": "Float : This bias penalizes the removal of long edges. It tends to reduce high aspect ratio triangles at the expense of more uniform reduction.",
                "type": "FloatPar",
                "name": "lengthweight",
                "items": []
            },
            {
                "text": "Toggle : When enabled, each reduction is tested to see if it would flip a triangle normal. While encurring a slight cost, the results are almost always worth it.",
                "type": "TogglePar",
                "name": "meshinvert",
                "items": []
            },
            {
                "text": "Toggle : As only triangular polygons will be reduced, this option will automatically triangulate the input polygons.",
                "type": "TogglePar",
                "name": "triangulate",
                "items": []
            },
            {
                "text": "Toggle : This prohibits the removal of any edge that occurs at the boundary of the polygons. This ensures no cracks develop with unreduced areas.",
                "type": "TogglePar",
                "name": "keepedges",
                "items": []
            },
            {
                "text": "Toggle : When it collapses edges, it will use one of the two original points instead of finding the optimal interior point.",
                "type": "TogglePar",
                "name": "originalpoints",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "SOP",
        "opType": "polyreduceSOP",
        "opLabel": "Polyreduce",
        "opClass": "polyreduceSOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The Polyreduce SOP reduces a high detail polygonal model into one consisting of fewer polygons.",
        "long": "The Polyreduce SOP reduces a high detail polygonal model into one consisting of fewer polygons. The second input's polygons represent feature edges. They are matched to the input mesh by point numbers.\t\n\t\t\nThe methods to reduce polygonal models are:\t\t\n\t\t\n* A percentage of their former size\t\t\n* A specfic number of polys (within a few)\t\t\n* According to distance from a camera\t\t\n\t\t\nNote that as it requires (and outputs) a triangular mesh, the polygon count may increase as a result of this operation.\t\t\n\t\t\nA second input for feature edges is provided.",
        "opCategories": ""
    },
    "polysplineSOP": {
        "label": "polysplineSOP",
        "members": [
            {
                "text": "StrMenu : Subset of faces to use. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Spline type to use. There are seven choices:",
                "type": "MenuPar",
                "name": "basis",
                "items": []
            },
            {
                "text": "Menu : Determines if the output spline is open or closed.",
                "type": "MenuPar",
                "name": "closure",
                "items": []
            },
            {
                "text": "Menu : Settings for refining the spline by adding extra divisions.",
                "type": "MenuPar",
                "name": "divide",
                "items": []
            },
            {
                "text": "Float : The length of the segments in the resampled curve.\t\n\t\t\n<!--TDparStart--><span class=\"tipTextSOP\">Division Method Standard</span><!--TDparEnd-->\t\t\nIf <span class=\"tipTextSOP\">Even Length Segments</span> are selected, <span class=\"tipTextSOP\">Segment Length</span> sets the length of output segments. The number of output segments is determined by <span class=\"tipTextSOP\">Output Divisions</span>.\t\t\nIf <span class=\"tipTextSOP\">Output Divisions</span> is zero, the number of output segments is calculated using the <span class=\"tipTextSOP\">Segment Length</span> parameter, and is determined by how many segments of this size will fit into the overall shape.\t\t\nIf <span class=\"tipTextSOP\">Even Length Segments</span> is selected, along with zero <span class=\"tipTextSOP\">Output Divisions</span> and <span class=\"tipTextSOP\">Segment Length</span> of zero, an error message is generated, saying \"Invalid number of divisions or segment size\".",
                "type": "FloatPar",
                "name": "segsize",
                "items": []
            },
            {
                "text": "Int : Number of segments in the resampled curve.\t\n\t\t\nIf <span class=\"tipTextSOP\">Division Method</span> = <span class=\"tipTextSOP\">Standard</span> is selected, this has no effect. If <span class=\"tipTextSOP\">Even Length Segments</span> is selected, this parameter sets the number of edges that is created. The length of the segments is determined by <span class=\"tipTextSOP\">Segment Length</span>. If <span class=\"tipTextSOP\">Segment Length</span> is 0, the length of the output segments is determined by dividing the over all shape into this number of segments.\t\t\n\t\t\nIf the <span class=\"tipTextSOP\">Output Divisions</span> parameter is set to zero, the value of the <span class=\"tipTextSOP\">Segment Length</span> parameter is used to calculate the number of <span class=\"tipTextSOP\">Output Divisions</span>.",
                "type": "IntPar",
                "name": "polydivs",
                "items": []
            },
            {
                "text": "Int : Number of spline divisions before resampling.\t\n\t\t\nIf <span class=\"tipTextSOP\">Division Method</span> = <span class=\"tipTextSOP\">Standard</span> is selected, this is the number of subdivisions for every edge. If <span class=\"tipTextSOP\">Even Length Segments</span> is chosen, it has the subtle effect of determining the accuracy with which the segment lengths can be calculated.",
                "type": "IntPar",
                "name": "edgedivs",
                "items": []
            },
            {
                "text": "Int : Number of times to repeat the first control vertex, determining its multiplicity. This determines the number of times to replicate the first vertex of the Source polygon(s). This is most useful when the Source consists of open polygons; extra vertices at the beginning of the line will force the curve to extend to the beginning of the line. For example a value of two will force a <span class=\"tipTextSOP\">Cardinal</span> curve to extend to its first vertex and a value of three will force a <span class=\"tipTextSOP\">Bspline</span> to start at is first vertex.",
                "type": "IntPar",
                "name": "first",
                "items": []
            },
            {
                "text": "Int : This determines the number of times to repeat the last control vertex, determining its multiplicity. This determines the number of times to replicate the last vertex of the Source polygon(s). This is most useful when the Source consists of open polygons; extra vertices at the end of the line will force the curve to extend to the end of the line.",
                "type": "IntPar",
                "name": "last",
                "items": []
            },
            {
                "text": "Float : The tension exerted by the points from the Source polygons. The greater the tension, the closer the resulting shape will be to the original shape.",
                "type": "FloatPar",
                "name": "tension",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "polysplineSOP_Class",
        "opType": "polyspline",
        "opLicense": "Non-Commercial",
        "opLabel": "Polyspline",
        "long": "The Polyspline SOP fits a spline curve to a polygon or hull and outputs a polygonal approximation of that spline. You can choose either to create divisions between the original points, or to ignore the position of the original points and divide the shape into segments of equal lengths.\t\n\t\t\nPolyspline can optionally resample the output curve, providing control over the length and number of its segments.\t\t\n\t\t\n'''Tip:''' When using this SOP, it is useful to enable Points display in the Viewport options dialog. This way you can see exactly what effect the SOP is having.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Polyspline SOP fits a spline curve to a polygon or hull and outputs a polygonal approximation of that spline.",
        "opCategories": ""
    },
    "polystitchSOP": {
        "label": "polystitchSOP",
        "members": [
            {
                "text": "StrMenu : The polygons to consider for stitching.",
                "type": "StrMenuPar",
                "name": "stitch",
                "items": []
            },
            {
                "text": "StrMenu : A list of point numbers that are to be considered breaks in the boundary edges.",
                "type": "StrMenuPar",
                "name": "corners",
                "items": []
            },
            {
                "text": "Float : The maximum distance two edges can be from each other and still be stitched.",
                "type": "FloatPar",
                "name": "tol3d",
                "items": []
            },
            {
                "text": "Toggle : When several points along one edge are snapped to the same position, consolidate them into a single point. This only consolidates along the boundary, not across the boundary.",
                "type": "TogglePar",
                "name": "consolidate",
                "items": []
            },
            {
                "text": "Toggle : Whenever an edge changes direction at a point more than the specified angle, it will mark that point as a corner.",
                "type": "TogglePar",
                "name": "findcorner",
                "items": []
            },
            {
                "text": "Float : The maximum angle a boundary point can change before it is considered a corner.",
                "type": "FloatPar",
                "name": "angle",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "polystitchSOP_Class",
        "opType": "polystitch",
        "opLicense": "Non-Commercial",
        "opLabel": "Polystitch",
        "long": "The Polystitch SOP attempts to stitch polygonal surfaces together, thereby eliminating cracks that result from evaluating the surfaces at differing levels of detail.\n\t\nFirst, the boundaries of all the polygons to be stitched are found. An edge is a boundary edge if it is shared by no other polygon. The uniqueness of edges is determined by point numbers, and not by spatial positioning. Each boundary is then split at each \"corner\" into a number of pieces. A list of corner points can be manually specified, or any point at which the boundary changes direction by a certain amount can be flagged as a corner.\t\n\t\nFinally, any two boundary pieces that are within the tolerance of each other are stitched together. This is performed by snapping the points of the high detail edge to those of the low detail edge.",
        "opFilter": "True",
        "opFamily": "SOP",
        "short": "The Polystitch SOP attempts to stitch polygonal surfaces together, thereby eliminating cracks that result from evaluating the surfaces at differing levels of detail.",
        "opCategories": ""
    },
    "profileSOP": {
        "label": "profileSOP",
        "members": [
            {
                "text": "StrMenu : This field allows you to specify the particular group of curves on the surface. Other primitives are ignored. You can specify profile curves within the group by providing a profile pattern (e.g. *.3 specifies the fourth profile in all spline surfaces).",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : This menu allows you to extract a stand-alone 3D curve as the world or parametric image of the profile. The non-parametric option will yield a curve whose shape and position in space are identical or very similar to those of the chosen profile. The parametric option will produce a planar, XY face whose vertices and type will be identical to those of the profile in 2D; also, if the profile is a spline it will have the same basis as the extracted curve.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Toggle : If Fitted (this option not checked), the profile will be a spatial NURBS curve whose position and shape in space will be identical to the curve on surface. It may very well be non-planar. If Extracted Parametrically (this option checked), the result will extract the profile's parametric image as a 3D face, which will be a planar face in XY whose type (polygon, Bzier, NURBS) will the same as the profile's, and whose vertices match the profile CVs. This, however, does not guarantee spatial coincidence between profile and extracted curve, and is more of an analytical tool.\t\n\t\t\t\n'''Tip:''' A profile extracted parametrically can be reapplied to the surface identically with the Project SOP by choosing the '''Parametric''' option with no Mapping to Range. Use this method to extract the profile, pull its points or edit it as you would any 3D face, then re-project it on the surface at the same location.",
                "type": "TogglePar",
                "name": "parametric",
                "items": []
            },
            {
                "text": "Toggle : If enabled, it will fit a spline through the extracted points. This parameter is disabled when extracting the profile parametrically. Disable this parameter in order to bypass the fitting process which might be both expensive (in processing speed) and unnecessary when extracting profiles produced by boolean operations (see [[Surfsect SOP]]).",
                "type": "TogglePar",
                "name": "smooth",
                "items": []
            },
            {
                "text": "Int : The number of points per span to be computed on the profile. A span is the line connecting two consecutive CVs on a polygon, or the arc between two breakpoints on a spline curve. The profile tends to become more accurate as the number of divisions is higher.",
                "type": "IntPar",
                "name": "sdivs",
                "items": []
            },
            {
                "text": "Float : This parameter specifies the precision of the fitting process for the extracted 3D data, and is typically less than 0.01.",
                "type": "FloatPar",
                "name": "tolerance",
                "items": []
            },
            {
                "text": "Int : The spline order of the resulting 3D curve. The type of curve (Bzier or NURBS) is inherited from the spatial curve. The order, however, is not inherited because the spline order provides useful control over the quality of the fit. If the profile is a polygon, the spatial curve will be a NURBS curve.",
                "type": "IntPar",
                "name": "order",
                "items": []
            },
            {
                "text": "Toggle : Controls the precision with which sharp corners in the profile curve are interpolated. It should be on when the profile has areas of high changes in curvature.",
                "type": "TogglePar",
                "name": "csharp",
                "items": []
            },
            {
                "text": "Toggle : Specifies whether the parent surface should be removed after the extraction or not.",
                "type": "TogglePar",
                "name": "keepsurf",
                "items": []
            },
            {
                "text": "Toggle : When Keep Surface parameter is On, select whether to leave or delete the original profile.",
                "type": "TogglePar",
                "name": "delprof",
                "items": []
            },
            {
                "text": "Menu : Select how to reposition and scale an existing profile to fit within the specified domain range. It is a good means of bringing an invisible profile into view by setting the mapping range between 0 and 1 in the U and V parametric directions. A profile mapped outside the unit domain becomes invisible but is not removed from the surface. Other ways to change a profile are available through the [[Primitive SOP]].",
                "type": "MenuPar",
                "name": "maptype",
                "items": []
            },
            {
                "text": "Float : Indicates in percentages what part of the U surface domain is the mapping area. A full range of 0-1 will cause the profiles to be mapped to the entire domain in the U parametric direction. The range is not restricted to the 0-1 interval.",
                "type": "FloatPar",
                "name": "urange",
                "items": []
            },
            {
                "text": "Float : Indicates in percentages what part of the V surface domain is the mapping area. A full range of 0-1 will cause the profiles to be mapped to the entire domain in the V parametric direction. The range is not restricted to the 0-1 interval.",
                "type": "FloatPar",
                "name": "vrange",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "profile",
        "opLabel": "Profile",
        "short": "The Profile SOP enables the extraction and manipulation of profiles.",
        "opClass": "profileSOP_Class",
        "opFamily": "SOP",
        "long": "The Profile SOP enables the extraction and manipulation of profiles.\t\t\n\t\t\t\nYou will usually need a [[Trim SOP]], [[Bridge SOP]], or Profile SOP after a [[Project SOP]]. Use a Trim SOP to cut a hole in the projected surface. Use a Bridge SOP to skin the profile curve to another profile curve.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "railsSOP": {
        "label": "railsSOP",
        "members": [
            {
                "text": "StrMenu : You can use a subset of primitives from the Cross-section input by specifying a group here. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "xsectgrp",
                "items": []
            },
            {
                "text": "StrMenu : You can use a subset of primitives from the Rails input by specifying a group here. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "railgrp",
                "items": []
            },
            {
                "text": "Menu : Select how the cross=section is applied along the rails.",
                "type": "MenuPar",
                "name": "cycle",
                "items": []
            },
            {
                "text": "Toggle : Sweeps along rail 1 &amp; 2, 3 &amp; 4, 5 &amp; 6 etc. instead of 1 &amp; 2, 2 &amp; 3, 3 &amp; 4 etc.",
                "type": "TogglePar",
                "name": "pairs",
                "items": []
            },
            {
                "text": "Toggle : Connects the cross-section between the first and last rails.",
                "type": "TogglePar",
                "name": "firstl",
                "items": []
            },
            {
                "text": "Toggle : Stretches the cross-section geometry to the rail geometry.",
                "type": "TogglePar",
                "name": "stretch",
                "items": []
            },
            {
                "text": "Toggle : Specifies two vertices of the cross section polygon to be placed on rail1 and rail2 respectively. Very useful, for instance, to keep the first vertex on rail1 and the seventh vertex on rail2.",
                "type": "TogglePar",
                "name": "usevtx",
                "items": []
            },
            {
                "text": "Int : The vertices at which the cross-section is connected to the rails.",
                "type": "IntPar",
                "name": "vertex",
                "items": []
            },
            {
                "text": "Float : Global scaling of the cross-sections.",
                "type": "FloatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Float : Non-cumulative rotation of the cross sections around the backbone. All cross sections get the same rotation.",
                "type": "FloatPar",
                "name": "roll",
                "items": []
            },
            {
                "text": "Toggle : Option to correct the flipping when no direction vector is used and the two rails happen to cross each other causing the normal to flip upside down.",
                "type": "TogglePar",
                "name": "noflip",
                "items": []
            },
            {
                "text": "Toggle : Uses the direction vector specified in the X, Y and Z coordinates. Otherwise it will use the normals of the geometry.",
                "type": "TogglePar",
                "name": "usedir",
                "items": []
            },
            {
                "text": "XYZ : The direction vector to use.",
                "type": "XYZPar",
                "name": "dirx",
                "items": []
            },
            {
                "text": "XYZ : The direction vector to use.",
                "type": "XYZPar",
                "name": "diry",
                "items": []
            },
            {
                "text": "XYZ : The direction vector to use.",
                "type": "XYZPar",
                "name": "dirz",
                "items": []
            },
            {
                "text": "Toggle : Selecting this option enables the creation of groups. A group is created for each backbone that is incoming. This allows for easy skinning in the [[Skin SOP]].",
                "type": "TogglePar",
                "name": "newg",
                "items": []
            },
            {
                "text": "Str : Specify the name of your output groups in this field. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrPar",
                "name": "railname",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "rails",
        "opLabel": "Rails",
        "short": "The Rails SOP generates surfaces by stretching cross-sections between two rails.",
        "opClass": "railsSOP_Class",
        "opFamily": "SOP",
        "long": "The Rails SOP generates surfaces by stretching cross-sections between two rails. This is similar to the [[Sweep SOP]], but it gives more control over the orientation and scaling of the cross-sections. The first SOP input is the cross-section which will be replicated, and is typically placed in the XY plane. The second input SOP source is the rails along which the cross-section is replicated.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "rasterSOP": {
        "label": "rasterSOP",
        "members": [
            {
                "text": "TOP : The path to the TOP to rasterize into geometry.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Menu : Determines the direction of rasterization. Depending on the image horizontal or vertical might work better.",
                "type": "MenuPar",
                "name": "direction",
                "items": []
            },
            {
                "text": "Menu : Gives the option for a delayed data download from the GPU, which is much faster and does not stall the render.",
                "type": "MenuPar",
                "name": "downloadtype",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "SOP",
        "opType": "rasterSOP",
        "opLabel": "Raster",
        "opClass": "rasterSOP_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Raster SOP converts a field of pixels into a field of colored geometry points suitable for laster devices.",
        "long": "The Raster SOP converts TOP image data to geometry by scanning left to right, top to bottom, outputting a geometry point at each pixel. This output can be used to display image data on laser devices, oscilloscopes or similar devices using the [[Laser CHOP]]. This is different from the [[Trace SOP]] which only outputs contour shapes from an image.",
        "opCategories": ""
    },
    "raySOP": {
        "label": "raySOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Select the method of projection for the Ray SOP.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Toggle : If selected, it will transform the input points as defined below. Leave this off when only interested in updating the source point attributes.",
                "type": "TogglePar",
                "name": "dotrans",
                "items": []
            },
            {
                "text": "Toggle : If selected, this option allows the user to choose between intersecting with the closest intersecting object or the furthest. See example, below.",
                "type": "TogglePar",
                "name": "lookfar",
                "items": []
            },
            {
                "text": "Menu : If selected, updates each point in the source geometry with the normal at the collision surface it intersects with. If the point doesn't intersect at the collision surface, a normal of (0,0,0) is used.",
                "type": "MenuPar",
                "name": "normal",
                "items": []
            },
            {
                "text": "Int : The number of times to bounce the ray off of the collision surface before creating the output position. For example, if bounces is set to 1, then the point will be projected onto surface at the first point it hits. If set to 2, the ray will be re-projected off of that first surface as if it was reflected, or bounced and will then be projected onto the next surface the ray hits. See the second Ray snippet for an example.",
                "type": "IntPar",
                "name": "bounces",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the projected geometry will be saved each time the projected ray bounces off a surface resulting in multiple copies of the input geometry. See the second Ray snippet for an example.",
                "type": "TogglePar",
                "name": "bouncegeo",
                "items": []
            },
            {
                "text": "Toggle : If selected, updates each point intersected with the distance to the collision surface. If the point doesn't intersect at the collision surface a distance of 0 is used. This value is placed in the <code>$DIST</code> point attribute, accessible from the [[Point SOP]].",
                "type": "TogglePar",
                "name": "putdist",
                "items": []
            },
            {
                "text": "Float : A value of zero will leave the input point unaffected. A value of one will land the point on the intersection surface. Negative values and values &gt; 1 are also valid.",
                "type": "FloatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Float : This value further offsets the surface input by offsetting it in the direction of its normal.",
                "type": "FloatPar",
                "name": "lift",
                "items": []
            },
            {
                "text": "Int : This value determines the number of rays sent per point. If greater than one, the remaining rays are perturbed randomly, and averaged.",
                "type": "IntPar",
                "name": "sample",
                "items": []
            },
            {
                "text": "Float : Controls the perturbation of the extra sample rays.",
                "type": "FloatPar",
                "name": "jitter",
                "items": []
            },
            {
                "text": "Int : Allows a different random sequence at higher sampling rates.",
                "type": "IntPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Toggle : If selected, it will create a point group containing all the points which were intersected successfully.",
                "type": "TogglePar",
                "name": "newgrp",
                "items": []
            },
            {
                "text": "Str : Specifies the name of the above point group.",
                "type": "StrPar",
                "name": "hitgrp",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "ray",
        "opLabel": "Ray",
        "short": "The Ray SOP is used to project one surface onto another.",
        "opClass": "raySOP_Class",
        "opFamily": "SOP",
        "long": "The Ray SOP is used to project one surface onto another. Rays are projected from each point of the input geometry in the direction of its normal. This can be used to drape clothes over surfaces, shrink-wrap one object with another, and other similar effects.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "rectangleSOP": {
        "label": "rectangleSOP",
        "members": [
            {
                "text": "Menu : Picks the major plane the rectangle's y-axis orients itself with. Set it to <span class=\"Heading4\">camera</span> if it is to point towards a camera.",
                "type": "MenuPar",
                "name": "orient",
                "items": []
            },
            {
                "text": "Object : Specifies which camera to use if <span class=\"tipTextSOP\">Orientation</span> is set to <span class=\"tipTextSOP\">camera</span>.",
                "type": "ObjectPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "Float : Used when using 'Fill Camera View'. <span class=\"tipTextSOP\">Camera Z</span> is an arbitrary distance you specify from the camera. It will move the rectangle so it is this many units away from the camera, then scale the rectangle so it fills the viewer.",
                "type": "FloatPar",
                "name": "camz",
                "items": []
            },
            {
                "text": "XY : Specify the aspect ratio of the camera with this parameter and the Restangle SOP's aspect ratio will match. This makes it easy to apply a texture on the rectangle which matches the camera's viewport without any further adjustments.",
                "type": "XYPar",
                "name": "cameraaspectx",
                "items": []
            },
            {
                "text": "XY : Specify the aspect ratio of the camera with this parameter and the Restangle SOP's aspect ratio will match. This makes it easy to apply a texture on the rectangle which matches the camera's viewport without any further adjustments.",
                "type": "XYPar",
                "name": "cameraaspecty",
                "items": []
            },
            {
                "text": "Toggle : If a SOP is connected to the node's input, then the rectangle will be sized based on the bounding box of that SOP. Enabling Modify Bounds allows the resulting rectangle to be further modified by scaling it's size or moving it's center.",
                "type": "TogglePar",
                "name": "modifybounds",
                "items": []
            },
            {
                "text": "XY : Adjusts the size of the rectangle in X and Y. If the size of the rectangle is being chosen from a Camera, or from a connected input SOP, then this parameter behaves as a scale. Otherwise it will set the size of the rectangle for all other modes.",
                "type": "XYPar",
                "name": "sizex",
                "items": []
            },
            {
                "text": "XY : Adjusts the size of the rectangle in X and Y. If the size of the rectangle is being chosen from a Camera, or from a connected input SOP, then this parameter behaves as a scale. Otherwise it will set the size of the rectangle for all other modes.",
                "type": "XYPar",
                "name": "sizey",
                "items": []
            },
            {
                "text": "XYZ : These X, Y, and Z Values determine where the center of the Rectangle is located. If the position of the rectangle is being chosen from a Camera, or from a connected input SOP, then this parameter behaves as an offset. Otherwise it will set the center of the rectangle for all other modes.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : These X, Y, and Z Values determine where the center of the Rectangle is located. If the position of the rectangle is being chosen from a Camera, or from a connected input SOP, then this parameter behaves as an offset. Otherwise it will set the center of the rectangle for all other modes.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : These X, Y, and Z Values determine where the center of the Rectangle is located. If the position of the rectangle is being chosen from a Camera, or from a connected input SOP, then this parameter behaves as an offset. Otherwise it will set the center of the rectangle for all other modes.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "Toggle : Invert the direction of anchors.",
                "type": "TogglePar",
                "name": "reverseanchors",
                "items": []
            },
            {
                "text": "Float : Set the point in X about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchoru",
                "items": []
            },
            {
                "text": "Float : Set the point in Y about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorv",
                "items": []
            },
            {
                "text": "Menu : Texture addes (0,1) coordinates to the vertices when set to <span class=\"tipTextSOP\">Face</span>. Creates a rectangle without uv attributes when set to <span class=\"tipTextSOP\">Off</span>.",
                "type": "MenuPar",
                "name": "texture",
                "items": []
            },
            {
                "text": "Toggle : Create a normal (N) attribute for this geometry.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "rectangle",
        "opLabel": "Rectangle",
        "short": "The Rectangle SOP creates a 4-sided polygon. It is a planar surface.",
        "opClass": "rectangleSOP_Class",
        "opFamily": "SOP",
        "long": "The Rectangle SOP creates a 4-sided polygon. It is a planar surface. The rectangle can be explicitly sized, or sized from other sources such as at the camera's view frustum, or the bounding box of a SOP connected to this node's input.",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "opCategories": ""
    },
    "refineSOP": {
        "label": "refineSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Toggle : Enable or disable the First U controls.",
                "type": "TogglePar",
                "name": "firstu",
                "items": []
            },
            {
                "text": "Float : This specifies a starting / ending location to complete the operation. Select this and a parametric U location between 0 and 1.",
                "type": "FloatPar",
                "name": "domainu1",
                "items": []
            },
            {
                "text": "Toggle : Enable or disable the Second U controls.",
                "type": "TogglePar",
                "name": "secondu",
                "items": []
            },
            {
                "text": "Float : This specifies a starting / ending location to complete the operation. Select this and a parametric U location between 0 and 1.",
                "type": "FloatPar",
                "name": "domainu2",
                "items": []
            },
            {
                "text": "Int : If refining or sub-dividing, this option specifies the number of refines to be performed between First U and Second U.",
                "type": "IntPar",
                "name": "divsu",
                "items": []
            },
            {
                "text": "Toggle : Enable or disable the First V controls.",
                "type": "TogglePar",
                "name": "firstv",
                "items": []
            },
            {
                "text": "Float : This specifies a starting / ending location to complete the operation. Select this and a parametric V location between 0 and 1.",
                "type": "FloatPar",
                "name": "domainv1",
                "items": []
            },
            {
                "text": "Toggle : Enable or disable the Second V controls.",
                "type": "TogglePar",
                "name": "secondv",
                "items": []
            },
            {
                "text": "Float : This specifies a starting / ending location to complete the operation. Select this and a parametric V location between 0 and 1.",
                "type": "FloatPar",
                "name": "domainv2",
                "items": []
            },
            {
                "text": "Int : If refining or sub-dividing, this option specifies the number of refines to be performed between First V and Second V.",
                "type": "IntPar",
                "name": "divsv",
                "items": []
            },
            {
                "text": "Int : Number of knots to insert at each location in the U / V basis when refining NURBS.",
                "type": "IntPar",
                "name": "refineu",
                "items": []
            },
            {
                "text": "Int : Number of knots to insert at each location in the U / V basis when refining NURBS.",
                "type": "IntPar",
                "name": "refinev",
                "items": []
            },
            {
                "text": "Menu : Specify how to measure along splines / curves.",
                "type": "MenuPar",
                "name": "space",
                "items": []
            },
            {
                "text": "Float : Only remove knots that do change the curve, polygon, or surface by more than this distance.",
                "type": "FloatPar",
                "name": "tolu",
                "items": []
            },
            {
                "text": "Float : Only remove knots that do change the curve, polygon, or surface by more than this distance.",
                "type": "FloatPar",
                "name": "tolv",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "refine",
        "opLabel": "Refine",
        "short": "The Refine SOP allows you to increase the number of CVs in any NURBS, Bzier, or polygonal surface or face without changing its shape.",
        "opClass": "refineSOP_Class",
        "opFamily": "SOP",
        "long": "The Refine SOP allows you to increase the number of CVs in any NURBS, Bzier, or polygonal surface or face without changing its shape. It is also used to decrease the number of CVs within a given tolerance (i.e. a simple but fast method of data reduction).\t\t\n{{OPSubSection\n|opFamily=SOP\n|sectionName=The Difference Between Refinement and Unrefinement\n|sectionSummary=Refinement and unrefinement work both on faces (polygons, Bzier curves and NURBS curves) and surfaces (primitive meshes, Bzier surfaces and NURBS surfaces). To unrefine a face or a surface you need to specify a parametric interval (not just a single value as in refinement). This allows you to unrefine primitives within arbitrary intervals, either locally or globally. For example, to unrefine the whole primitive choose 0 and 1 as the two parametric boundaries; [0,0.5] will unrefine only the first parametric half of the primitive.\t\t\t\n\t\t\t\nThe interval boundaries are given by the First/Second U/V fields. Since refinement does not need an interval, the Second U/V fields are disabled by default.\t\t\t\n\t\t\t\nThe Tolerance control is only available for unrefinement, and not for refinement. Refinement does not need tolerances because it generates a curve or a surface that is mathematically identical to the original. Unrefinement, however, may tend to smooth out (or \"melt\") the original in a given area. In short, unrefinement is lossy; refinement isn't.\t\n}}",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "revolveSOP": {
        "label": "revolveSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this <code>SOP</code> to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : This option is used to select the type of surface, when using a Mesh Primitive Type.",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "XYZ : Coordinates defining the origin of the revolution.",
                "type": "XYZPar",
                "name": "originx",
                "items": []
            },
            {
                "text": "XYZ : Coordinates defining the origin of the revolution.",
                "type": "XYZPar",
                "name": "originy",
                "items": []
            },
            {
                "text": "XYZ : Coordinates defining the origin of the revolution.",
                "type": "XYZPar",
                "name": "originz",
                "items": []
            },
            {
                "text": "XYZ : X, Y, and Z coordinates of the direction vector defining the direction of the revolve.",
                "type": "XYZPar",
                "name": "dirx",
                "items": []
            },
            {
                "text": "XYZ : X, Y, and Z coordinates of the direction vector defining the direction of the revolve.",
                "type": "XYZPar",
                "name": "diry",
                "items": []
            },
            {
                "text": "XYZ : X, Y, and Z coordinates of the direction vector defining the direction of the revolve.",
                "type": "XYZPar",
                "name": "dirz",
                "items": []
            },
            {
                "text": "Toggle : Changes the output mesh to consist of individual polygons.",
                "type": "TogglePar",
                "name": "polys",
                "items": []
            },
            {
                "text": "Toggle : Applies to splines only. If selected, the results are approximated nonrational curves, otherwise they are perfect rational curves.",
                "type": "TogglePar",
                "name": "imperfect",
                "items": []
            },
            {
                "text": "Menu : Determines how the revolve should be generated.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Float : The start and end angles of the revolve. A revolve will start at the beginning angle, and proceed towards the ending angle. If <span class=\"tipTextSOP\">Beginning</span> = <code>0</code> and <span class=\"tipTextSOP\">End</span> = <code>360</code> it will be fully revolved. Values greater than 360 are also valid.",
                "type": "FloatPar",
                "name": "angle",
                "items": []
            },
            {
                "text": "Int : Density of the resulting mesh surface.",
                "type": "IntPar",
                "name": "divs",
                "items": []
            },
            {
                "text": "Int : If a spline type is selected, it is built at this order.",
                "type": "IntPar",
                "name": "order",
                "items": []
            },
            {
                "text": "Toggle : If selected, it adds faceted end caps.",
                "type": "TogglePar",
                "name": "cap",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "revolve",
        "opLabel": "Revolve",
        "short": "The Revolve SOP revolves faces to create a surface of revolution.",
        "opClass": "revolveSOP_Class",
        "opFamily": "SOP",
        "long": "The Revolve SOP revolves faces to create a surface of revolution. The revolution's direction and origin are represented by guide geometry that resembles a thick line with a cross hair at the centre. The cross hair represents the origin of the revolve as entered in the dialog and the stick represents the direction. Changing any of these parameters will cause the guide to change appropriately.\t\t\n\t\t\t\nIf the guide geometry is too distracting, you can disable it by entering the Viewport options dialog and clicking on the Guide geometry button so that it no longer appears indented. This procedure is global and will disable the guide geometry of other SOPs as well.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "scriptSOP": {
        "label": "scriptSOP",
        "members": [
            {
                "text": "DAT : Specifies the DAT which holds the callbacks. See [[scriptSOP_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Pulse : Clicking the button runs the <code>setupParameters()</code> callback function.",
                "type": "PulsePar",
                "name": "setuppars",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "script",
        "opLabel": "Script",
        "short": "The Script SOP runs a script each time the Script SOP cooks.",
        "opClass": "scriptSOP_Class",
        "opFamily": "SOP",
        "long": "The Script SOP runs a python script each time the Script SOP cooks. It can create, delete and modify points, primitives and their vertices. It can create custom attributes or built-in attributes like <code>Cd</code> (color), <code>uv</code> and <code>N</code> (normals). It can add polygons, bezier curves and meshes among others. It can combine multiple inputs. By default, the Script SOP is created with a docked DAT that contains three Python methods: <code>cook()</code>, <code>onPulse()</code>, and <code>setupParameters()</code>. The <code>cook()</code> method is run each time the Script SOP cooks. The <code>setupParameters()</code> method is run whenever the Setup Parameter button on the Script page is pressed. The <code>onPulse()</code> method is run whenever a custom pulse parameter is pushed.\t\n\t\t\nRefer to Help -> Python Examples, and Help -> [[OP Snippets|Operator Snippets]].\t\n\t\t\nNote: Because the Script SOP can get data from anywhere, it's difficult to determine what it procedurally depends on. So every time that a Script OP runs it will make a list of operators, parameters, nodes etc that it depends upon, and when they change, the Script OP will re-cook.\t\t\n\nSee also: [[Geometry Detail]], [[Point]], [[Point List]], [[Point Class]], [[Primitive]], [[Prims Class]], [[Polygon]], [[Vertex]], [[SOP]], [[SOP Class]], [[SOP to DAT]], [[Point SOP]], [[Point Group]]s, [[Primitive Group]]s, [[Attributes]].\n\nSee also: [[Script CHOP]], [[Script DAT]], [[Script TOP]].",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "opCategories": ""
    },
    "selectSOP": {
        "label": "selectSOP",
        "members": [
            {
                "text": "SOP : The path of the SOP being referenced.",
                "type": "SOPPar",
                "name": "sop",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "select",
        "opLabel": "Select",
        "short": "The Select SOP allows you to reference a SOP from any other location in TouchDesigner.",
        "opClass": "selectSOP_Class",
        "opFamily": "SOP",
        "long": "The Select SOP allows you to reference a SOP from any other location in TouchDesigner. If only one other SOP is referenced, its memory is shared instead of re-created in this SOP.",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "opCategories": ""
    },
    "sequenceblendSOP": {
        "label": "sequenceblendSOP",
        "members": [
            {
                "text": "Float : This value determines the blend transition between consecutive geometry inputs. Values between 0 and 1 will control the metamorphosis between geometry input 1 and 2, values between 1 and 2 will control the metamorphosis between geometry input 2 and 3, and so on.",
                "type": "FloatPar",
                "name": "blend",
                "items": []
            },
            {
                "text": "Toggle : If checked, only point xyz positions are blended.",
                "type": "TogglePar",
                "name": "dopos",
                "items": []
            },
            {
                "text": "Toggle : Point Colors are blended.",
                "type": "TogglePar",
                "name": "doclr",
                "items": []
            },
            {
                "text": "Toggle : Point normals are blended.",
                "type": "TogglePar",
                "name": "donml",
                "items": []
            },
            {
                "text": "Toggle : Point texture coordinates are blended.",
                "type": "TogglePar",
                "name": "douvw",
                "items": []
            },
            {
                "text": "Toggle : When checked, the Up Vector of the geometry inputs will be blended based on the weights of the blend channels.",
                "type": "TogglePar",
                "name": "doup",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "sblend",
        "opLabel": "Sequence Blend",
        "short": "The Sequence Blend SOP allows you do 3D Metamorphosis between shapes and Interpolate point position, colors, point normals, and texture coordinates between shapes.",
        "opClass": "sequenceblendSOP_Class",
        "opFamily": "SOP",
        "long": "The Sequence Blend SOP allows you do 3D Metamorphosis between shapes and Interpolate point position, colors, point normals, and texture coordinates between shapes.\n\t\nSee also [[Blend SOP]] and [[Switch SOP]].",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "skinSOP": {
        "label": "skinSOP",
        "members": [
            {
                "text": "StrMenu : Empty by default, this field provides a way to specify a subset of the first input's faces and surfaces. Do so by selecting one or more primitive groups from this field's pop-up menu.",
                "type": "StrMenuPar",
                "name": "uprims",
                "items": []
            },
            {
                "text": "StrMenu : Empty by default, this field provides a way to specify a subset of V faces. If a second input exists, the primitive groups available for selection are taken from the second input. If only the first input is present, the groups listed in the pop-up menu belong to the first input. This means that two inputs are not always needed for a bilinear skin as long as the first input has both U and V groups in it.",
                "type": "StrMenuPar",
                "name": "vprims",
                "items": []
            },
            {
                "text": "Menu : (Results only viewable for polygons and meshes).",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "Toggle : This parameter determines the precision of a linear skin (case c in the diagram). If enabled, it ensures that the generated surface goes through each cross-section. Here, a cross-section can be a face or a surface boundary, depending on the types being skinned. If disabled, Preserve Shape produces a surface whose CVs coincide with the CVs of the cross-sections (after they have being converted to a common type and an identical number of CVs). The skinning algorithm is faster with shape preservation OFF, but it lacks precision.\t\n\t\t\nSkinning with shape preservation ON may produce unintuitive shapes when the cross-sections have many coincident CVs or are very close to each other. In this case try to jitter the CVs, vary the V Order (see below), or simply disable shape preservation.\t\t\n\t\t\nPreserve shape is deactivated when doing bi-linear skinning.",
                "type": "TogglePar",
                "name": "keepshape",
                "items": []
            },
            {
                "text": "Menu : This menu (menu: Off, On, If primitive does) setting determines whether the surface should be wrapped in the V parametric direction. The options are to open (Off), close (On), or inherit the closure type from the cross-sections. V Wrap is ignored when doing bilinear skinning.",
                "type": "MenuPar",
                "name": "closev",
                "items": []
            },
            {
                "text": "Toggle : Enables or disables the use of the <span class=\"tipTextSOP\">V Order</span> parameter. If the flag is <span class=\"tipTextSOP\">OFF</span>, the skinned surface is built as a cubic (order 4) in V, unless fewer than four cross-sections for an open V or 3 cross-section for a closed V are given. For example, if the input consists of two faces and the V Wrap flag is <span class=\"tipTextSOP\">OFF</span>, the surface will be linear in V (order 2). The status of the V Order flag is irrelevant when the faces or surfaces are all polygons or meshes respectively, and when doing a bilinear skin.\t\n\t\t\nHere, cross-section refers either to a face or a surface boundary, depending on the types being skinned.",
                "type": "TogglePar",
                "name": "force",
                "items": []
            },
            {
                "text": "Int : Specifies the order of the skinned surface when the <span class=\"tipTextSOP\">V Order</span> flag is enabled. A NURB surface of order \"n\" can be constructed with at least n or n-1 cross-sections, depending on whether the surface is open or closed in V respectively. A Bzier surface of the same order can be constructed with at least M*(n-1) + 1 cross-sections if open, or M*(n-1) cross-sections if closed. M is a non-negative, integer multiplier. The V order is ignored when the faces or surfaces are all polygons or meshes respectively, and when building a bilinear skin.",
                "type": "IntPar",
                "name": "orderv",
                "items": []
            },
            {
                "text": "Menu : Can optionally skin subgroups of n primitives or every nth primitive in a cyclical manner.\t\n\t\t\n'''For example'''; assume there are six primitives numbered for 0 - 5, and <span class=\"tipTextSOP\">N</span> = 2. Then,\t\t\n\t\t\n* Groups will generate 0-1 2-3 4-5\t\t\n* Skipping will generate 0-2-6 and 1-3-5.",
                "type": "MenuPar",
                "name": "skinops",
                "items": []
            },
            {
                "text": "Int : Determines the number of primitives to be either grouped or skipped. N2.",
                "type": "IntPar",
                "name": "inc",
                "items": []
            },
            {
                "text": "Toggle : Determines whether the input primitives will be preserved (On) or deleted from the output (Off).",
                "type": "TogglePar",
                "name": "prim",
                "items": []
            },
            {
                "text": "Toggle : If set, this flag instructs the program to convert the skinned surface(s) to polygons if the surface type is Mesh.",
                "type": "TogglePar",
                "name": "polys",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "skin",
        "opLabel": "Skin",
        "short": "The Skin SOP takes any number of faces and builds a skin surface over them.",
        "opClass": "skinSOP_Class",
        "opFamily": "SOP",
        "long": "The Skin SOP takes any number of faces and builds a skin surface over them. If given two or more surfaces, however, the SOP builds four skins, one for each set of boundary curves.\t\n\t\t\nAll face and surface types are valid as long as the input(s) contain only faces or only surfaces. Different face types can be skinned together into one surface. For example, it is possible to skin a cubic open NURBS curve with a polygon and a quintic closed Bzier curve even if the three faces have a different number of control vertices. Similarly, this SOP can skin the boundary curves of surfaces of different types, number of rows, columns, etc.\t\t\n\t\t\nWhen face types are input, the number of input SOPs and the number of faces in each input establish the skinning method. If only one input exists, a \"linear-skinning\" operation is performed by running a skin across the cross-sections. The result is the classic ruled or skinned surface. If a second input exists, a \"bi-linear skinning\" is performed which computes a cross-skin between the faces in the first input (U cross-sections) and the faces in the second input (V cross-sections). The result is a surface whose name derives from the number of cross-sections in each direction: triangular, square, or multiple boundary surface, as well as a special case of swept surfaces and N-rails. When possible, cross-sections are interpolated as isoparms.\t\t\n\t\t\nIf you need more control over tangency in the skin, try using the [[Bridge SOP]].\t\t\n\t\t\n'''Tip:''' If you have problems with the results being skinned in the wrong order, try inserting a Sort SOP ahead of the Skin SOP, and <span class=\"tipTextSOP\">Sort by Normals</span>.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "sortSOP": {
        "label": "sortSOP",
        "members": [
            {
                "text": "Menu : Sort the points in the input geometry, according to the following criteria:",
                "type": "MenuPar",
                "name": "ptsort",
                "items": []
            },
            {
                "text": "Int : The random seed when <span class=\"tipTextSOP\">Point Sort</span> is set to <span class=\"tipTextSOP\">Random</span>.",
                "type": "IntPar",
                "name": "pointseed",
                "items": []
            },
            {
                "text": "Int : Shift point order by the amount specified on the offset line.",
                "type": "IntPar",
                "name": "pointoffset",
                "items": []
            },
            {
                "text": "XYZ : The X, Y and Z coordinates to reference when sorting by <span class=\"tipTextSOP\">Proximity to Point</span>.",
                "type": "XYZPar",
                "name": "pointproxx",
                "items": []
            },
            {
                "text": "XYZ : The X, Y and Z coordinates to reference when sorting by <span class=\"tipTextSOP\">Proximity to Point</span>.",
                "type": "XYZPar",
                "name": "pointproxy",
                "items": []
            },
            {
                "text": "XYZ : The X, Y and Z coordinates to reference when sorting by <span class=\"tipTextSOP\">Proximity to Point</span>.",
                "type": "XYZPar",
                "name": "pointproxz",
                "items": []
            },
            {
                "text": "Object : Sort points along a vector defined by the object's transformation values.",
                "type": "ObjectPar",
                "name": "pointobj",
                "items": []
            },
            {
                "text": "XYZ : Allows you to specify a unique vector along which points can be sorted.",
                "type": "XYZPar",
                "name": "pointdirx",
                "items": []
            },
            {
                "text": "XYZ : Allows you to specify a unique vector along which points can be sorted.",
                "type": "XYZPar",
                "name": "pointdiry",
                "items": []
            },
            {
                "text": "XYZ : Allows you to specify a unique vector along which points can be sorted.",
                "type": "XYZPar",
                "name": "pointdirz",
                "items": []
            },
            {
                "text": "Menu : Sort the primitives according to the following criteria:",
                "type": "MenuPar",
                "name": "primsort",
                "items": []
            },
            {
                "text": "Int : Random seed when sorting by <span class=\"tipTextSOP\">Random</span>.",
                "type": "IntPar",
                "name": "primseed",
                "items": []
            },
            {
                "text": "Int : Shift primitive order by the amount specified on the offset line.",
                "type": "IntPar",
                "name": "primoffset",
                "items": []
            },
            {
                "text": "XYZ : The X, Y and Z coordinates to reference when sorting by <span class=\"tipTextSOP\">Proximity to Point</span>.",
                "type": "XYZPar",
                "name": "primproxx",
                "items": []
            },
            {
                "text": "XYZ : The X, Y and Z coordinates to reference when sorting by <span class=\"tipTextSOP\">Proximity to Point</span>.",
                "type": "XYZPar",
                "name": "primproxy",
                "items": []
            },
            {
                "text": "XYZ : The X, Y and Z coordinates to reference when sorting by <span class=\"tipTextSOP\">Proximity to Point</span>.",
                "type": "XYZPar",
                "name": "primproxz",
                "items": []
            },
            {
                "text": "Object : Sort primitives along a vector defined by the object's translation.",
                "type": "ObjectPar",
                "name": "primobj",
                "items": []
            },
            {
                "text": "XYZ : Allows you to specify a unique vector along which primitives can be sorted.",
                "type": "XYZPar",
                "name": "primdirx",
                "items": []
            },
            {
                "text": "XYZ : Allows you to specify a unique vector along which primitives can be sorted.",
                "type": "XYZPar",
                "name": "primdiry",
                "items": []
            },
            {
                "text": "XYZ : Allows you to specify a unique vector along which primitives can be sorted.",
                "type": "XYZPar",
                "name": "primdirz",
                "items": []
            },
            {
                "text": "Menu : Sort the primitives according to the following criteria:",
                "type": "MenuPar",
                "name": "partsort",
                "items": []
            },
            {
                "text": "Toggle : Reverses the result from the Particle Sort as defined above.",
                "type": "TogglePar",
                "name": "partreverse",
                "items": []
            },
            {
                "text": "Int : Shift particle order by the amount specified on the offset line.",
                "type": "IntPar",
                "name": "partoffset",
                "items": []
            },
            {
                "text": "XYZ : The X, Y and Z coordinates to reference when sorting by <span class=\"tipTextSOP\">Proximity to Point</span>.",
                "type": "XYZPar",
                "name": "partproxx",
                "items": []
            },
            {
                "text": "XYZ : The X, Y and Z coordinates to reference when sorting by <span class=\"tipTextSOP\">Proximity to Point</span>.",
                "type": "XYZPar",
                "name": "partproxy",
                "items": []
            },
            {
                "text": "XYZ : The X, Y and Z coordinates to reference when sorting by <span class=\"tipTextSOP\">Proximity to Point</span>.",
                "type": "XYZPar",
                "name": "partproxz",
                "items": []
            },
            {
                "text": "Object : Sort particles along a vector defined by the object's translation.",
                "type": "ObjectPar",
                "name": "partobj",
                "items": []
            },
            {
                "text": "XYZ : Allows you to specify a unique vector along which particles can be sorted.",
                "type": "XYZPar",
                "name": "partdirx",
                "items": []
            },
            {
                "text": "XYZ : Allows you to specify a unique vector along which particles can be sorted.",
                "type": "XYZPar",
                "name": "partdiry",
                "items": []
            },
            {
                "text": "XYZ : Allows you to specify a unique vector along which particles can be sorted.",
                "type": "XYZPar",
                "name": "partdirz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "sort",
        "opLabel": "Sort",
        "short": "The Sort SOP allows you to sort points and primitives in different ways.",
        "opClass": "sortSOP_Class",
        "opFamily": "SOP",
        "long": "The Sort SOP allows you to sort points and primitives in different ways. Sometimes the primitives are arranged in the desired order, but the point order is not. There are many possible combinations. To sort vertices, use the [[Primitive SOP]].",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "sphereSOP": {
        "label": "sphereSOP",
        "members": [
            {
                "text": "Menu : Select from the following types. For information on the different types, see the [[:Category:Geometry|Geometry]] category articles. Depending on the primitive type chosen, some SOP options may not apply.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : This option is used to select the type of surface, when using a <span class=\"tipTextSOP\">Mesh Primitive Type</span>.",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "Toggle : Available only when an input is connected to the Sphere SOP to set bounds for the sphere. When Orient Bounds = On it will rotate the geometry to match the orientation of the input SOP used for bounds.",
                "type": "TogglePar",
                "name": "orientbounds",
                "items": []
            },
            {
                "text": "Toggle : Available only when an input is connected to the Sphere SOP to set bounds for the sphere. When Modify Bounds = On the transform parameters below will further modify the rotation, position, and radius of the bounds.",
                "type": "TogglePar",
                "name": "modifybounds",
                "items": []
            },
            {
                "text": "XYZ : The radius of the sphere in X, Y and Z.",
                "type": "XYZPar",
                "name": "radx",
                "items": []
            },
            {
                "text": "XYZ : The radius of the sphere in X, Y and Z.",
                "type": "XYZPar",
                "name": "rady",
                "items": []
            },
            {
                "text": "XYZ : The radius of the sphere in X, Y and Z.",
                "type": "XYZPar",
                "name": "radz",
                "items": []
            },
            {
                "text": "XYZ : Offset of sphere center from object center.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Offset of sphere center from object center.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Offset of sphere center from object center.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the Sphere along the X, Y, and Z axes.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the Sphere along the X, Y, and Z axes.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the Sphere along the X, Y, and Z axes.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "Toggle : Invert the direction of anchors.",
                "type": "TogglePar",
                "name": "reverseanchors",
                "items": []
            },
            {
                "text": "Float : Set the point in X about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchoru",
                "items": []
            },
            {
                "text": "Float : Set the point in Y about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorv",
                "items": []
            },
            {
                "text": "Float : Set the point in Z about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorw",
                "items": []
            },
            {
                "text": "Menu : Determines axis for sphere. Poles of sphere align with orientation axis.",
                "type": "MenuPar",
                "name": "orient",
                "items": []
            },
            {
                "text": "Int : This controls the level of polygons used to create the sphere, when using the <span class=\"tipTextSOP\">Polygon Primitive Type</span>.",
                "type": "IntPar",
                "name": "freq",
                "items": []
            },
            {
                "text": "Int : Number of rows in a sphere when using the mesh, imperfect NURBS and imperfect Bzier.",
                "type": "IntPar",
                "name": "rows",
                "items": []
            },
            {
                "text": "Int : Number of columns in a sphere when using the mesh, imperfect NURBS and imperfect Bzier.",
                "type": "IntPar",
                "name": "cols",
                "items": []
            },
            {
                "text": "Int : If a spline curve is selected, it is built at this order for U.",
                "type": "IntPar",
                "name": "orderu",
                "items": []
            },
            {
                "text": "Int : If a spline curve is selected, it is built at this order for V.",
                "type": "IntPar",
                "name": "orderv",
                "items": []
            },
            {
                "text": "Toggle : This option applies only to Bzier and NURBS spheres. If selected, the spheres are approximated nonrational curves, otherwise they are perfect rational curves.",
                "type": "TogglePar",
                "name": "imperfect",
                "items": []
            },
            {
                "text": "Toggle : Applies to Mesh, NURBS and Bzier surfaces only. This option determines whether points at the poles are shared or are individual to the columns.",
                "type": "TogglePar",
                "name": "upole",
                "items": []
            },
            {
                "text": "Menu : Adds UV texture coordinates to the sphere.",
                "type": "MenuPar",
                "name": "texture",
                "items": []
            },
            {
                "text": "Toggle : Creates normals on the geometry.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "sphere",
        "opLabel": "Sphere",
        "short": "The Sphere SOP generates spherical objects of different geometry types.",
        "opClass": "sphereSOP_Class",
        "opFamily": "SOP",
        "long": "The Sphere SOP generates spherical objects of different geometry types. It is capable of creating non-uniform scalable spheres of all geometry types.\t\n\t\t\nIf an input is provided, the sphere's radius is automatically determined as a function of the input's bounding geometry.",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "opCategories": ""
    },
    "sprinkleSOP": {
        "label": "sprinkleSOP",
        "members": [
            {
                "text": "Float : Any number, integer or non-integer, which starts the random number generator. Each number gives completely different point positions.",
                "type": "FloatPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Menu : Describes where points are located.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Int : The total number of points created.",
                "type": "IntPar",
                "name": "numpoints",
                "items": []
            },
            {
                "text": "Toggle : Remove points until remaining are a minimum distance apart.",
                "type": "TogglePar",
                "name": "consolidate",
                "items": []
            },
            {
                "text": "Float : Minimum distance when using Consolidate option.",
                "type": "FloatPar",
                "name": "neardist",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "SOP",
        "opType": "sprinkleSOP",
        "opLabel": "Sprinkle",
        "opClass": "sprinkleSOP_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The Sprinkle SOP is used to add [[Point Class|points]] to either the surface or the volume of a SOP. You can create points on a surface, or within a closed volume based on the Method menu.",
        "long": "The Sprinkle SOP is used to add [[Point Class|points]] to either the surface or the volume of a SOP. You can create points on a surface, or within a closed volume based on the Method menu. The Surface method keeps the distribution of points constant per unit area of surface, whereas Per-Primitive gives each primitive, usually triangles, a constant number per primitive no matter their size.\n\nThe second input is used when you are scattering on a deforming surface. You generally don't want the distribution of points to jump while deforming, so you give the deformed surface as second input and the un-deformed surface as the first input. The Sprinkle SOP will then distribute points on the un-deformed surface, and then put them on their equivalent place on the deformed surface.",
        "opCategories": ""
    },
    "stitchSOP": {
        "label": "stitchSOP",
        "members": [
            {
                "text": "StrMenu : Which primitives to stitch. If blank, it stitches the entire input. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Stitches sub-groups of n primitives or patterns of primitives.",
                "type": "MenuPar",
                "name": "stitchop",
                "items": []
            },
            {
                "text": "Int : The value entered for <span class=\"tipTextSOP\">N</span> determines the pattern of primitives stitched.",
                "type": "IntPar",
                "name": "inc",
                "items": []
            },
            {
                "text": "Toggle : If enabled, it connects the beginning of the first primitive in the left input to the end of the last primitive in the same input. If only one primitive exists, its ends will be stitched together.",
                "type": "TogglePar",
                "name": "loop",
                "items": []
            },
            {
                "text": "Menu : Allows stitching along either the U or V parametric direction.",
                "type": "MenuPar",
                "name": "dir",
                "items": []
            },
            {
                "text": "Float : This parameter minimizes modification to the input sources. A smaller value creates less modification.",
                "type": "FloatPar",
                "name": "tolerance",
                "items": []
            },
            {
                "text": "Float : Determines which primitive remains unaffected. The values go from <code>0 - 1</code>, where <code>0</code> - first, and <code>1</code> - last.",
                "type": "FloatPar",
                "name": "bias",
                "items": []
            },
            {
                "text": "Float : Point on each left / right primitive at which to begin / end the stitch.",
                "type": "FloatPar",
                "name": "leftuv",
                "items": []
            },
            {
                "text": "Float : Point on each left / right primitive at which to begin / end the stitch.",
                "type": "FloatPar",
                "name": "rightuv",
                "items": []
            },
            {
                "text": "Float : The first value represents the width of the left stitch. The second value represents the width of the right stitch.",
                "type": "FloatPar",
                "name": "lrwidth",
                "items": []
            },
            {
                "text": "Toggle : If selected, move a single row from each primitive to coincide.",
                "type": "TogglePar",
                "name": "dostitch",
                "items": []
            },
            {
                "text": "Toggle : If selected, modifies neighbouring rows on each primitive to create identical slopes at the given rows.",
                "type": "TogglePar",
                "name": "dotangent",
                "items": []
            },
            {
                "text": "Toggle : If selected, creates sharp corners at the ends of the stitch when the stitch partially spans a primitive.",
                "type": "TogglePar",
                "name": "sharp",
                "items": []
            },
            {
                "text": "Toggle : When the tangent option is on, this option allows some flexibility as to which side of each slope is modified.",
                "type": "TogglePar",
                "name": "fixed",
                "items": []
            },
            {
                "text": "Float : Use this parameter to control the direction and position of the tangential slopes.",
                "type": "FloatPar",
                "name": "lrscale",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "stitch",
        "opLabel": "Stitch",
        "short": "The Stitch SOP is used to stretch two curves or surfaces to cover a smooth area.",
        "opClass": "stitchSOP_Class",
        "opFamily": "SOP",
        "long": "The Stitch SOP is used to stretch two curves or surfaces to cover a smooth area. It can also be used to create certain types of upholstered fabrics such as cushions and parachutes.\t\n\t\t\nIf a second input is given, it must contain one surface that the primitives in the first input can stitch to. The left input can contain either faces or surfaces; in either case, each primitive in the first input is stitched to a parametric area of the surface in the second input in such a way that the parametric area allocated to each primitive is the same and the size of all areas added together equals the parametric range specified in the R Width (see below).\t\t\n\t\t\nPlease refer to the [[Align SOP]] for a discussion of \"left\" and \"right\" primitives as well as the option of an auxiliary input.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "superquadSOP": {
        "label": "superquadSOP",
        "members": [
            {
                "text": "Menu : Select from the following types. For information on the different types, see the [http://www.derivativeinc.com/Tools/Touch000/Manual/Guides/GeoTypesGuide/GeometryTypes.pdf Geometry Types Guide]. Depending on the primitive type chosen, some SOP options may not apply.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : This option is used to select the type of surface, when using a <span class=\"tipTextSOP\">Mesh</span> primitive type.",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "Toggle : Available only when an input is connected to the Superquad SOP to set bounds for the superquad. When Modify Bounds = On the transform parameters below will further modify the position and radius of the bounds.",
                "type": "TogglePar",
                "name": "modifybounds",
                "items": []
            },
            {
                "text": "XYZ : Determines overall radius.",
                "type": "XYZPar",
                "name": "radx",
                "items": []
            },
            {
                "text": "XYZ : Determines overall radius.",
                "type": "XYZPar",
                "name": "rady",
                "items": []
            },
            {
                "text": "XYZ : Determines overall radius.",
                "type": "XYZPar",
                "name": "radz",
                "items": []
            },
            {
                "text": "XYZ : Offset of superquad center from object center.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Offset of superquad center from object center.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Offset of superquad center from object center.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "Toggle : Invert the direction of anchors.",
                "type": "TogglePar",
                "name": "reverseanchors",
                "items": []
            },
            {
                "text": "Float : Set the point in X about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchoru",
                "items": []
            },
            {
                "text": "Float : Set the point in Y about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorv",
                "items": []
            },
            {
                "text": "Float : Set the point in Z about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorw",
                "items": []
            },
            {
                "text": "Menu : Determines pole axis for the iso surface.",
                "type": "MenuPar",
                "name": "orient",
                "items": []
            },
            {
                "text": "Int : Number of rows used in the superquad.",
                "type": "IntPar",
                "name": "rows",
                "items": []
            },
            {
                "text": "Int : Number of columns used in the superquad.",
                "type": "IntPar",
                "name": "cols",
                "items": []
            },
            {
                "text": "Float : The <span class=\"tipTextSOP\">XY Exponent</span> determines inflation / contraction in the X and Y axes.",
                "type": "FloatPar",
                "name": "expxy",
                "items": []
            },
            {
                "text": "Float : The <span class=\"tipTextSOP\">Z Exponent</span> determines inflation / contraction in the Z axis. See the [[Metaball SOP]] for a description of exponents.",
                "type": "FloatPar",
                "name": "expz",
                "items": []
            },
            {
                "text": "Toggle : Determines whether points at the poles are shared or are unique to the columns.",
                "type": "TogglePar",
                "name": "upole",
                "items": []
            },
            {
                "text": "Toggle : Makes points unique, causing the superquad to be faceted.",
                "type": "TogglePar",
                "name": "cusp",
                "items": []
            },
            {
                "text": "Float : Input angle in degrees to determine when vertices are shared or not, creating cusping.",
                "type": "FloatPar",
                "name": "angle",
                "items": []
            },
            {
                "text": "Menu : Adds UV texture coordinates to the sphere.",
                "type": "MenuPar",
                "name": "texture",
                "items": []
            },
            {
                "text": "Toggle : Creates normals on the geometry.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "superquad",
        "opLabel": "Superquad",
        "short": "The Superquad SOP generates an isoquadric surface.",
        "opClass": "superquadSOP_Class",
        "opFamily": "SOP",
        "long": "The Superquad SOP generates an isoquadric surface. This produces a spherical shape that is similar to a metaball, with the difference that it doesn't change it's shape in response to what surrounds it. You can change the <span class=\"tipTextSOP\">XY Exponent</span> of an isoquadric surface to define it to be more \"squarish\" or \"starish\" in shape. Also, an isoquadric surface is always defined as a polygonal or mesh type geometry.",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "opCategories": ""
    },
    "sweepSOP": {
        "label": "sweepSOP",
        "members": [
            {
                "text": "StrMenu : You can use only a subset of primitives from the Cross-section inputs by specifying a group here.",
                "type": "StrMenuPar",
                "name": "xgrp",
                "items": []
            },
            {
                "text": "StrMenu : You can use only a subset of primitives from the Backbone inputs by specifying a group here.",
                "type": "StrMenuPar",
                "name": "pathgrp",
                "items": []
            },
            {
                "text": "StrMenu : You can use only a subset of primitives from the Reference inputs by specifying a group here.",
                "type": "StrMenuPar",
                "name": "refgrp",
                "items": []
            },
            {
                "text": "Menu : Determines the Cycle Type based on these menu options.",
                "type": "MenuPar",
                "name": "cycle",
                "items": []
            },
            {
                "text": "Toggle : Attempts to fix buckling twists that may occur when sweeping.",
                "type": "TogglePar",
                "name": "angle",
                "items": []
            },
            {
                "text": "Toggle : Attempts to fix buckling twists that may occur when sweeping by fixing flipped normals.",
                "type": "TogglePar",
                "name": "noflip",
                "items": []
            },
            {
                "text": "Toggle : When selected, any points right on top of one another will be ignored.",
                "type": "TogglePar",
                "name": "skipcoin",
                "items": []
            },
            {
                "text": "Toggle : Reference Points are used in conjunction with the backbone to control the orientation of the elements along the sweep. This is done by drawing a line between the reference point and corresponding backbone point in order to determine an angle vector which determines the orientation of the cross-section profiles. Enable this parameter to allow this behaviour.\t\n\t\t\t\n'''Note:''' In order for this to work, you must supply '''Reference Points''' via the third input, and there must be exactly the same number of '''Reference Points''' as there are points in the '''Backbone'''.",
                "type": "TogglePar",
                "name": "aimatref",
                "items": []
            },
            {
                "text": "Toggle : Use vertex number of the incoming cross-section to place the cross-section on the backbone.",
                "type": "TogglePar",
                "name": "usevtx",
                "items": []
            },
            {
                "text": "Int : Specify a specific vertex to connect to the backbone.",
                "type": "IntPar",
                "name": "vertex",
                "items": []
            },
            {
                "text": "Float : Scales the cross sections globally.",
                "type": "FloatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Float : Cumulative rotation of the cross sections around the backbone. If a value of five is specified, the cross section at the first point of the backbone is rotated five degrees, the next ten degrees, the next fifteen degrees and so on.",
                "type": "FloatPar",
                "name": "twist",
                "items": []
            },
            {
                "text": "Float : Non-cumulative rotation of the cross sections around the backbone. All cross sections get the same rotation.\t\n\t\t\t\n'''Note:''' The '''Scale''', '''Twist '''and '''Roll''' parameters can now be controlled directly by points' attributes of the same names. Thus, combined with the [[CHOP to SOP|Channel SOP]], those parameters can now be controlled dynamically. You can use scale and other attributes coming in to taper.",
                "type": "FloatPar",
                "name": "roll",
                "items": []
            },
            {
                "text": "Toggle : Selecting this option enables the creation of groups. A group is created for each backbone that is incoming. This allows for easy skinning in the [[Skin SOP]].",
                "type": "TogglePar",
                "name": "newg",
                "items": []
            },
            {
                "text": "Str : Specify the name of your output groups in this field.",
                "type": "StrPar",
                "name": "sweepgrp",
                "items": []
            },
            {
                "text": "Menu : Determines the output based on these menu options.",
                "type": "MenuPar",
                "name": "skin",
                "items": []
            },
            {
                "text": "Toggle : Enables an optimized skinning technique which speeds up output from 2 - 4 times in many cases at the expense of accuracy. In order for it to work correctly, the input topologies must remain consistent between cooks and each cross-section must have the same number of vertices.",
                "type": "TogglePar",
                "name": "fast",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "sweep",
        "opLabel": "Sweep",
        "short": "The Sweep SOP sweeps primitives in the Cross-section input along Backbone Source primitive(s), creating ribbon and tube-like shapes.",
        "opClass": "sweepSOP_Class",
        "opFamily": "SOP",
        "long": "The Sweep SOP sweeps primitives in the Cross-section input along Backbone Source primitive(s), creating ribbon and tube-like shapes. The cross-section primitives are placed at each point of the backbone perpendicular to it. The Backbone Source can have one or several primitives. If there is more than one, Sweep will sweep the cross section along each one.\t\t\n\t\t\t\nA backbone is a primitive curve that can be open or closed, but must have at least two points. The cross section input can also have multiple primitives, and can be assigned to the backbone in various ways. The origin of the cross section primitive is placed at a point on the backbone by default, but you can also choose a point number of the cross section to place. In most cases, it is best to build the cross section primitives in the XY plane; Sweep will automatically orient them properly along the backbone. If the backbone primitive(s) have point colors or texture coordinates, they will be maintained and applied to the cross section primitives.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "textSOP": {
        "label": "textSOP",
        "members": [
            {
                "text": "StrMenu : Select the font for the text from this drop down menu. All fonts are provided by the OS, any [http://en.wikipedia.org/wiki/TrueType TrueType] font that is loaded into the OS can be used.",
                "type": "StrMenuPar",
                "name": "font",
                "items": []
            },
            {
                "text": "File : Specify any TrueType or OpenType font file (<code>.ttf, .otf file</code>) to use for the text. When using a font file, the Font menu above is disabled.",
                "type": "FilePar",
                "name": "fontfile",
                "items": []
            },
            {
                "text": "Toggle : Displays the text in '''bold'''.",
                "type": "TogglePar",
                "name": "bold",
                "items": []
            },
            {
                "text": "Toggle : Displays the text in ''Italic''.",
                "type": "TogglePar",
                "name": "italic",
                "items": []
            },
            {
                "text": "Float : Sets the font size in X (horizontal). The font size defines the distance from the baseline to the top of the layout box for the given font. The default size of 1 of the default font is close to the vertical size of capital letters with no descenders.",
                "type": "FloatPar",
                "name": "fontsizex",
                "items": []
            },
            {
                "text": "Float : Sets the font size in Y (vertical).",
                "type": "FloatPar",
                "name": "fontsizey",
                "items": []
            },
            {
                "text": "Toggle : Ignores Y value in Font Size. Sets both X and Y size to <span class=\"tipTextSOP\">Font Size</span> X.",
                "type": "TogglePar",
                "name": "keepfontratio",
                "items": []
            },
            {
                "text": "Toggle : ",
                "type": "TogglePar",
                "name": "scalefontobboxheight",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Int : Controls the quality of the text's shape by adding/removing subdivisions to the geometry.",
                "type": "IntPar",
                "name": "levelofdetail",
                "items": []
            },
            {
                "text": "Menu : Language type hint to help format the glyphs correctly. This should be a abbreviation from the [[Text TOP/SOP Unicode Language Abbreviations]] table.",
                "type": "MenuPar",
                "name": "language",
                "items": []
            },
            {
                "text": "Menu : Use to set whether the language reads Left to Right or Right to Left.",
                "type": "MenuPar",
                "name": "readingdirection",
                "items": []
            },
            {
                "text": "Float : The amount of space to add between letters in X and Y. Kerning is way of adding an arbitrary offset between letters. There already is a default offset associated with each font so the letters are flush against each other. The <span class=\"tipTextSOP\">Kerning</span> parameter this adds to that and allows for a Y offset.",
                "type": "FloatPar",
                "name": "kerning",
                "items": []
            },
            {
                "text": "Float : Determines the amount of space between lines of text.",
                "type": "FloatPar",
                "name": "linespacing",
                "items": []
            },
            {
                "text": "Menu : Sets the horizontal alignment.",
                "type": "MenuPar",
                "name": "alignx",
                "items": []
            },
            {
                "text": "Toggle : When checked text is automatically line wrapped once it takes up the space set in <span class=\"tipTextTOP\">Word Wrap Size</span> parameter below.",
                "type": "TogglePar",
                "name": "wordwrap",
                "items": []
            },
            {
                "text": "Float : Determines the amount of 3D space used before the line wraps.",
                "type": "FloatPar",
                "name": "wordwrapsize",
                "items": []
            },
            {
                "text": "Str : The string of text to create as geometry.  If newlines or tabs are desired, the recommended way is to change this parameter to expression mode, and specify a Python string that includes \\n or \\t to signify newlines and tabs. E.g <code>'First Line\\nSecond Line'</code>.",
                "type": "StrPar",
                "name": "text",
                "items": []
            },
            {
                "text": "Toggle : '''Note, it's recommended to use a Python expressionin the Text parameter instead of enabling legacy parsing, as this parsing can easily run into issues with more complex strings.''' When enabled and if the Text parameter is in Constant Mode, \\t and \\n character sequences will be turned into tab and newline characters respectively. Otherwise the \\t and \\n sequences will be left as literal \\ and t and \\ and n.",
                "type": "TogglePar",
                "name": "legacyparsing",
                "items": []
            },
            {
                "text": "Menu : Sets the overall transform order for the transformations. The transform order determines the order in which transformations take place. Depending on the order, you can achieve different results using the exact same values. Choose the appropriate order from the menu.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : Sets the order of the rotations within the overall transform order.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the geometry in the three axes.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the geometry in the three axes.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the geometry in the three axes.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the geometry in the three axes.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the geometry in the three axes.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the geometry in the three axes.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the geometry in the three axes.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the geometry in the three axes.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the geometry in the three axes.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations (not the same as the pivot point in the pivot channels). The pivot point parameters allow you to define the point about which geometry scales and rotates. Altering the pivot point produces different results depending on the transformation performed on the object.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of an object is located at: <code>-1, -1, 0</code> and you wanted to scale the object by <code>0.5</code> (reduce its size by 50%) the object would scale toward the pivot point and appear to slide down and to the left.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations (not the same as the pivot point in the pivot channels). The pivot point parameters allow you to define the point about which geometry scales and rotates. Altering the pivot point produces different results depending on the transformation performed on the object.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of an object is located at: <code>-1, -1, 0</code> and you wanted to scale the object by <code>0.5</code> (reduce its size by 50%) the object would scale toward the pivot point and appear to slide down and to the left.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations (not the same as the pivot point in the pivot channels). The pivot point parameters allow you to define the point about which geometry scales and rotates. Altering the pivot point produces different results depending on the transformation performed on the object.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of an object is located at: <code>-1, -1, 0</code> and you wanted to scale the object by <code>0.5</code> (reduce its size by 50%) the object would scale toward the pivot point and appear to slide down and to the left.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "text",
        "opLabel": "Text",
        "short": "The Text SOP creates text geometry from any [http://en.wikipedia.org/wiki/TrueType TrueType] or [http://en.wikipedia.org/wiki/OpenType OpenType] font that is installed on the system, or any TrueType/OpenType font file on disk.",
        "opClass": "textSOP_Class",
        "opFamily": "SOP",
        "long": "The Text SOP creates text geometry from any [http://en.wikipedia.org/wiki/TrueType TrueType] or [http://en.wikipedia.org/wiki/OpenType OpenType] font that is installed on the system, or any TrueType/OpenType font file on disk. [[Unicode]] is supported.\t\n\nSee also: [[Text TOP]], [[Unicode]].",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "opCategories": ""
    },
    "textureSOP": {
        "label": "textureSOP",
        "members": [
            {
                "text": "StrMenu : If there are input primitive groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Does not work with point or vertex groups. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Int : If the geometry has multiple textures layers applied to it, this parameter determines which layer of UV coordinates this Texture SOP will effect.",
                "type": "IntPar",
                "name": "texlayer",
                "items": []
            },
            {
                "text": "Menu : The <span class=\"tipTextSOP\">Face</span>, <span class=\"tipTextSOP\">Uniform Spline</span>, and <span class=\"tipTextSOP\">Arc-Length Spline</span> texturing methods accept spline curves as well as polygons.\t\n\t\t\t\nWhen using one of the spline-based methods, specifying a paste hierarchy in the <span class=\"tipTextSOP\">Group</span> field will propagate the computation of texture coordinates to all of its nodes. Projection methods will typically yield smoother texture continuity between pasted surfaces than any of the spline methods. Sometimes it helps ensuring that pasted features are Chord-length parameterized with the [[Basis SOP]].",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : Axis to project along, or projection method from splines. X, Y, or Z axes.",
                "type": "MenuPar",
                "name": "axis",
                "items": []
            },
            {
                "text": "Object : This is used when the <span class=\"tipTextSOP\">Perspective From Camera</span> Texture Type is selected. The menu is used to select which light or camera to project the perspective coordinates from.",
                "type": "ObjectPar",
                "name": "camera",
                "items": []
            },
            {
                "text": "Menu : Select to apply texture coordinates to their Natural Location, Point textures, or Vertex textures.\t\n\t\t\t\nWhen <span class=\"tipTextSOP\">Natural location</span> is selected, the UV's will be applied to the verticies when using <span class=\"tipTextSOP\">Polar</span>, <span class=\"tipTextSOP\">Cylindrical</span>, <span class=\"tipTextSOP\">Rows and Columns</span>, and <span class=\"tipTextSOP\">Face</span> texture types.  <span class=\"tipTextSOP\">Orthographic</span>, <span class=\"tipTextSOP\">Uniform Spline</span>, <span class=\"tipTextSOP\">Average Spline</span> and <span class=\"tipTextSOP\">Arc Length Spline</span> will always generate point UV's when you choose <span class=\"tipTextSOP\">Natural</span>.\t\t\t\n\t\t\t\nNatural Location will also create vertex uvs when creating new texture layers, if a vertex uv already exists for layer 0.\t\t\t\n\t\t\t\nIIf the primitive is open in both directions like a grid or a surface (so that the ends do not touch), then the advantage of vertex UV's does not apply since there are no matched seams on the single surface to worry about.\t\t\t\n\t\t\t\nUsing vertex UVs gives you unique points at the closed seam whereas point UVs are shared at seams and are, by default given a value of 0 for either U or V depending on the closed direction of the surface. If you want to make a closed surface open, simply insert a [[Carve SOP]] in the chain and place a single carve in the surface of the direction that the surface is closed.",
                "type": "MenuPar",
                "name": "coord",
                "items": []
            },
            {
                "text": "UVW : Scales the texture coordinates a specific amount.",
                "type": "UVWPar",
                "name": "s",
                "items": []
            },
            {
                "text": "UVW : Offsets the texture coordinates a specific amount.",
                "type": "UVWPar",
                "name": "offset",
                "items": []
            },
            {
                "text": "Float : Rotates the texture coordinates the specified value.\t\n\t\t\t\n'''Tip:''' Before applying a spline-based texture projection with the Texture SOP, remap the U and/or V bases of the spline surface (using a [[Basis SOP]]) between 0 and 1 to ensure a complete mapping of the texture. If a single texture map must be shared by several surfaces, the surface bases should be concatenated prior to being remapped.",
                "type": "FloatPar",
                "name": "angle",
                "items": []
            },
            {
                "text": "Toggle : Attempts to correct texture continuity at face seams.",
                "type": "TogglePar",
                "name": "fixseams",
                "items": []
            },
            {
                "text": "Menu : Sets the overall transform order for the transformations. The transform order determines the order in which transformations take place. Depending on the order, you can achieve different results using the exact same values. Choose the appropriate order from the menu.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : Sets the order of the rotations within the overall transform order.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the texture coordinates in the three axes.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the texture coordinates in the three axes.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the texture coordinates in the three axes.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the texture coordinates in the three axes.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the texture coordinates in the three axes.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the texture coordinates in the three axes.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the texture coordinates in the three axes.",
                "type": "XYZPar",
                "name": "scaletwox",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the texture coordinates in the three axes.",
                "type": "XYZPar",
                "name": "scaletwoy",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the texture coordinates in the three axes.",
                "type": "XYZPar",
                "name": "scaletwoz",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations (not the same as the pivot point in the pivot channels). The pivot point parameters allow you to define the point about which the texture coordinates scale and rotate. Altering the pivot point produces different results depending on the transformation performed.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of the texture coordinates is located at: <code>-1, -1, 0</code> and you wanted to scale by <code>0.5</code> (reduce its size by 50%) the texture would scale toward the pivot point and appear to slide down and to the left.\t\t\t\n\t\t\t\n[[Image:TouchGeometry91.gif]]\t\t\t\n\t\t\t\nIn the example above, rotations performed on a texture coordinates with different pivot points produce very different results.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations (not the same as the pivot point in the pivot channels). The pivot point parameters allow you to define the point about which the texture coordinates scale and rotate. Altering the pivot point produces different results depending on the transformation performed.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of the texture coordinates is located at: <code>-1, -1, 0</code> and you wanted to scale by <code>0.5</code> (reduce its size by 50%) the texture would scale toward the pivot point and appear to slide down and to the left.\t\t\t\n\t\t\t\n[[Image:TouchGeometry91.gif]]\t\t\t\n\t\t\t\nIn the example above, rotations performed on a texture coordinates with different pivot points produce very different results.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations (not the same as the pivot point in the pivot channels). The pivot point parameters allow you to define the point about which the texture coordinates scale and rotate. Altering the pivot point produces different results depending on the transformation performed.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of the texture coordinates is located at: <code>-1, -1, 0</code> and you wanted to scale by <code>0.5</code> (reduce its size by 50%) the texture would scale toward the pivot point and appear to slide down and to the left.\t\t\t\n\t\t\t\n[[Image:TouchGeometry91.gif]]\t\t\t\n\t\t\t\nIn the example above, rotations performed on a texture coordinates with different pivot points produce very different results.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "texture",
        "opLabel": "Texture",
        "short": "The Texture SOP assigns texture UV and W coordinates to the Source geometry for use in texture and bump mapping.",
        "opClass": "textureSOP_Class",
        "opFamily": "SOP",
        "long": "The Texture SOP assigns texture UV and W coordinates to the Source geometry for use in texture and bump mapping. It generates multi-layers of texture coordinates.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "torusSOP": {
        "label": "torusSOP",
        "members": [
            {
                "text": "Menu : Select from the following types. For information on the different types, see the [[:Category:Geometry|Geometry]] category articles.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : This option is used to select the type of surface, when using a <span class=\"tipTextSOP\">Mesh</span> primitive type.",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "Menu : The axis along which the torus is constructed.",
                "type": "MenuPar",
                "name": "orient",
                "items": []
            },
            {
                "text": "Toggle : Enabled only when an input is connected to the Torus SOP to set bounds for the torus. Turn Modify Bounds = On to enable the transform parameters below to further modify the position and radius of the bounds.",
                "type": "TogglePar",
                "name": "modifybounds",
                "items": []
            },
            {
                "text": "XY : The first value (radx) defines the radius of the torus, the second value (rady) determines the radius of the inner ring.\t\n\t\t\t\n[[Image:TouchGeometry256.gif]]",
                "type": "XYPar",
                "name": "radx",
                "items": []
            },
            {
                "text": "XY : The first value (radx) defines the radius of the torus, the second value (rady) determines the radius of the inner ring.\t\n\t\t\t\n[[Image:TouchGeometry256.gif]]",
                "type": "XYPar",
                "name": "rady",
                "items": []
            },
            {
                "text": "XYZ : Offset of torus center from object origin.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Offset of torus center from object origin.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Offset of torus center from object origin.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "Toggle : Invert the direction of anchors.",
                "type": "TogglePar",
                "name": "reverseanchors",
                "items": []
            },
            {
                "text": "Float : Set the point in X about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchoru",
                "items": []
            },
            {
                "text": "Float : Set the point in Y about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorv",
                "items": []
            },
            {
                "text": "Float : Set the point in Z about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorw",
                "items": []
            },
            {
                "text": "Int : The rows define the number of divisions along the torus.",
                "type": "IntPar",
                "name": "rows",
                "items": []
            },
            {
                "text": "Int : The columns determine the number of divisions along the torus' cross-section.",
                "type": "IntPar",
                "name": "cols",
                "items": []
            },
            {
                "text": "Float : Rotates the torus along the minor radius.  For example, if using 4 rows set this value to 45 to create flat top + bottom surfaces.",
                "type": "FloatPar",
                "name": "angleoffset",
                "items": []
            },
            {
                "text": "Toggle : This option applies only to Bezier and NURBS types. If selected, the tube is an approximated nonrational curve, otherwise it is a perfect rational curve.",
                "type": "TogglePar",
                "name": "imperfect",
                "items": []
            },
            {
                "text": "Int : If a spline curve is selected, it is built at this order for U and V.",
                "type": "IntPar",
                "name": "orderu",
                "items": []
            },
            {
                "text": "Int : If a spline curve is selected, it is built at this order for U and V.",
                "type": "IntPar",
                "name": "orderv",
                "items": []
            },
            {
                "text": "Float : The start and end sweep angles of the torus, if <span class=\"tipTextSOP\">U Wrap</span> is not enabled.",
                "type": "FloatPar",
                "name": "angleu",
                "items": []
            },
            {
                "text": "Float : These are the start and end angles of the cross-section circle that is swept to make the torus, if <span class=\"tipTextSOP\">V Wrap</span> is not enabled.",
                "type": "FloatPar",
                "name": "anglev",
                "items": []
            },
            {
                "text": "Toggle : If <span class=\"tipTextSOP\">U Wrap</span> is checked, it creates a 360 cross-section.",
                "type": "TogglePar",
                "name": "closeu",
                "items": []
            },
            {
                "text": "Toggle : Checking <span class=\"tipTextSOP\">V Wrap</span> creates a torus along V by closing the primitive.",
                "type": "TogglePar",
                "name": "closev",
                "items": []
            },
            {
                "text": "Toggle : If <span class=\"tipTextSOP\">U End Caps</span> is checked, it puts faceted end-caps on the ends of the torus if it is less than 360.\t\n\t\t\t\nFor more capping options, turn this parameter off, and append a Cap SOP.",
                "type": "TogglePar",
                "name": "capu",
                "items": []
            },
            {
                "text": "Toggle : If <span class=\"tipTextSOP\">V End Caps</span> is checked, it applies a face between the top and bottom of the torus - if the torus is open.\t\n\t\t\t\nFor more capping options, turn this parameter off, and append a Cap SOP.",
                "type": "TogglePar",
                "name": "capv",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "torus",
        "opLabel": "Torus",
        "short": "The Torus SOP generates complete or specific sections of torus shapes (like a doughnut).",
        "opClass": "torusSOP_Class",
        "opFamily": "SOP",
        "long": "The Torus SOP generates complete or specific sections of torus shapes (like a doughnut).",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "opCategories": ""
    },
    "traceSOP": {
        "label": "traceSOP",
        "members": [
            {
                "text": "TOP : Specify the TOP image to trace.",
                "type": "TOPPar",
                "name": "top",
                "items": []
            },
            {
                "text": "Float : Brightness level value adjusts where trace outline in image occurs.",
                "type": "FloatPar",
                "name": "thresh",
                "items": []
            },
            {
                "text": "Toggle : This option allows the generation of point texture coordinates (UVs). This may occasionally be necessary when the <span class=\"tipTextSOP\">Convert to Poly</span> option is enabled.",
                "type": "TogglePar",
                "name": "addtexture",
                "items": []
            },
            {
                "text": "Toggle : When enabled, this option eliminates extraneous data along the edges of the original image so it isn't traced. This is useful for when \"dirty\" edges exist in the original image that you don't want traced.",
                "type": "TogglePar",
                "name": "delborder",
                "items": []
            },
            {
                "text": "Toggle : Creates normals on the geometry.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            },
            {
                "text": "Int : The number of pixels the removal border should be.",
                "type": "IntPar",
                "name": "bordwidth",
                "items": []
            },
            {
                "text": "Toggle : Determines level of refinement (number of points) for generating trace outlines.",
                "type": "TogglePar",
                "name": "doresample",
                "items": []
            },
            {
                "text": "Float : Value controlling trace outline refinement when <span class=\"tipTextSOP\">Resample Shapes</span> is checked.",
                "type": "FloatPar",
                "name": "step",
                "items": []
            },
            {
                "text": "Toggle : When this option is checked, the geometry is filtered to remove sharp corners.",
                "type": "TogglePar",
                "name": "dosmooth",
                "items": []
            },
            {
                "text": "Float : Value controlling corner smoothing when <code>Smooth Shapes</code> is checked.",
                "type": "FloatPar",
                "name": "corner",
                "items": []
            },
            {
                "text": "Toggle : If selected, the geometry at this point is converted to two-dimensional Bzier curves. Flat edges are preserved in polygons.",
                "type": "TogglePar",
                "name": "fitcurve",
                "items": []
            },
            {
                "text": "Float : Value controlling accuracy of the above curve fitting process. For best results, the input should retain as many points as possible, i.e. do not select <span class=\"tipTextSOP\">Smooth Shapes</span> or <span class=\"tipTextSOP\">Resample Shapes</span>.",
                "type": "FloatPar",
                "name": "error",
                "items": []
            },
            {
                "text": "Toggle : This option will convert the above curves back into polygons.",
                "type": "TogglePar",
                "name": "convpoly",
                "items": []
            },
            {
                "text": "Float : This value controls the accuracy of the conversion back into polygons.",
                "type": "FloatPar",
                "name": "lod",
                "items": []
            },
            {
                "text": "Toggle : This will bridge all holes in the output so that they may be rendered properly. Bzier curves and polygons can be holed, but polygonal holing sometimes produces better results. You may want to use the <span class=\"tipTextSOP\">Convert to Poly</span> option before holing.",
                "type": "TogglePar",
                "name": "hole",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "trace",
        "opLabel": "Trace",
        "short": "The Trace SOP reads an image file and automatically traces it, generating a set of faces around areas exceeding a certain brightness threshold.",
        "opClass": "traceSOP_Class",
        "opFamily": "SOP",
        "long": "The Trace SOP reads an image file and automatically traces it, generating a set of faces around areas exceeding a certain brightness threshold. You can control this threshold and the resolution of the resulting faces.",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "opCategories": ""
    },
    "trailSOP": {
        "label": "trailSOP",
        "members": [
            {
                "text": "Menu : How to construct the trail geometry.",
                "type": "MenuPar",
                "name": "result",
                "items": []
            },
            {
                "text": "Int : This sets the length of the trail by establishing the maximum number of frames for the Trail SOP to use, i.e. a <span class=\"tipTextSOP\">Trail Length</span> of <code>25</code>will connect the geometry from the previous twenty-five frames.",
                "type": "IntPar",
                "name": "length",
                "items": []
            },
            {
                "text": "Int : This will skip the given number of frames to build a trail with fewer points in it, but the same length. This will lower the resolution of the trail by reducing the number of points in the trail. This is better for ghosting when using <span class=\"tipTextSOP\">Preserve Original</span>. If you set the Increment to <code>2</code> or more, you will see the same length trail, but fewer copies of the geometry.",
                "type": "IntPar",
                "name": "inc",
                "items": []
            },
            {
                "text": "Int : The number of frames to keep cached in available memory.",
                "type": "IntPar",
                "name": "cache",
                "items": []
            },
            {
                "text": "Toggle : This option specifies that the Trail SOP will only evaluate, or cook, within the current frame range (<code>$FSTART</code>, <code>$FEND</code>). If this option is not enabled, the SOP can evaluate prior to the start frame.",
                "type": "TogglePar",
                "name": "evalframe",
                "items": []
            },
            {
                "text": "Menu : This option is used to select the type of surface, when using a <span class=\"tipTextSOP\">Mesh Primitive Type</span>.",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "Toggle : When selected, closes the rows in the output selection.",
                "type": "TogglePar",
                "name": "close",
                "items": []
            },
            {
                "text": "Float : Scales the velocity by a specific value when <span class=\"tipTextSOP\">Compute Velocity</span> is selected.",
                "type": "FloatPar",
                "name": "velscale",
                "items": []
            },
            {
                "text": "Toggle : While on, clears any cached geometries, resetting the trail to mirror the input.",
                "type": "TogglePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Pulse : Reset the geometry for a single frame.",
                "type": "PulsePar",
                "name": "resetpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "trail",
        "opLabel": "Trail",
        "short": "The Trail SOP takes an input SOP and makes a trail of each point of the input SOP over the past several frames, and connects the trails in different ways.",
        "opClass": "trailSOP_Class",
        "opFamily": "SOP",
        "long": "The Trail SOP takes an input SOP and makes a trail of each point of the input SOP over the past several frames, and connects the trails in different ways. It will generate trails of any input geometry, whether it is a cube translating, a deforming surface, or particles. This is useful for multi-frame ghosting effects and temporal modelling.\t\n\t\t\nWhen using a [[Particle SOP]] or [[Spring SOP]] as input, it is important to keep the trail increment to integer values. Otherwise, the trail will not work well.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "transformSOP": {
        "label": "transformSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this SOP to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Sets the overall transform order for the transformations. The transform order determines the order in which transformations take place. Depending on the order, you can achieve different results using the exact same values. Choose the appropriate order from the menu.",
                "type": "MenuPar",
                "name": "xord",
                "items": []
            },
            {
                "text": "Menu : Sets the order of the rotations within the overall transform order.",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : These three fields move the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : These three fields rotate the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "sx",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "sy",
                "items": []
            },
            {
                "text": "XYZ : These three fields scale the Source geometry in the three axes.",
                "type": "XYZPar",
                "name": "sz",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations (not the same as the pivot point in the pivot channels). The pivot point parameters allow you to define the point about which geometry scales and rotates. Altering the pivot point produces different results depending on the transformation performed on the object.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of an object is located at: <code>-1, -1, 0</code> and you wanted to scale the object by <code>0.5</code> (reduce its size by 50%) the object would scale toward the pivot point and appear to slide down and to the left.\t\t\t\n\t\t\t\n[[Image:TouchGeometry91.gif]]\t\t\t\n\t\t\t\nIn the example above, rotations performed on an object with different pivot points produce very different results.",
                "type": "XYZPar",
                "name": "px",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations (not the same as the pivot point in the pivot channels). The pivot point parameters allow you to define the point about which geometry scales and rotates. Altering the pivot point produces different results depending on the transformation performed on the object.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of an object is located at: <code>-1, -1, 0</code> and you wanted to scale the object by <code>0.5</code> (reduce its size by 50%) the object would scale toward the pivot point and appear to slide down and to the left.\t\t\t\n\t\t\t\n[[Image:TouchGeometry91.gif]]\t\t\t\n\t\t\t\nIn the example above, rotations performed on an object with different pivot points produce very different results.",
                "type": "XYZPar",
                "name": "py",
                "items": []
            },
            {
                "text": "XYZ : The pivot point for the transformations (not the same as the pivot point in the pivot channels). The pivot point parameters allow you to define the point about which geometry scales and rotates. Altering the pivot point produces different results depending on the transformation performed on the object.\t\n\t\t\t\nFor example, during a scaling operation, if the pivot point of an object is located at: <code>-1, -1, 0</code> and you wanted to scale the object by <code>0.5</code> (reduce its size by 50%) the object would scale toward the pivot point and appear to slide down and to the left.\t\t\t\n\t\t\t\n[[Image:TouchGeometry91.gif]]\t\t\t\n\t\t\t\nIn the example above, rotations performed on an object with different pivot points produce very different results.",
                "type": "XYZPar",
                "name": "pz",
                "items": []
            },
            {
                "text": "Float : <span class=\"tipTextSOP\">Uniform Scale</span> allows you to shrink or enlarge geometry along all three axes simultaneously.",
                "type": "FloatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "Toggle : When selected, vector type attributes (i.e. normals, velocity) maintain the same length under transforms. i.e. When geometry is scaled, the normals remain constant in length.",
                "type": "TogglePar",
                "name": "vlength",
                "items": []
            },
            {
                "text": "Object : Allows you to orient your object by naming the object you would like it to <span class=\"tipTextSOP\">Look At</span>, or point to. Once you have designated this object to look at, it will continue to face that object, even if you move it. This is useful if, for instance, you want a camera to follow another object's movements. The <span class=\"tipTextSOP\">Look At</span> parameter points the object in question at the other object's origin.\t\n\t\t\t\n'''Tip:''' To designate a centre of interest for the camera that doesn't appear in your scene, create a Null object and disable its display flag. Then Parent the Camera to the newly created Null object, and tell the camera to look at this object using the <span class=\"tipTextSOP\">Look At</span> parameter. You can direct the attention of the camera by moving the Null object with the Select state. If you want to see both the camera and the Null object, enable the Null object's display flag, and use the Select state in an additional Viewport by clicking one of the icons in the top-right corner of the TouchDesigner window.",
                "type": "ObjectPar",
                "name": "lookat",
                "items": []
            },
            {
                "text": "XYZ : When orienting an object, the <span class=\"tipTextSOP\">Up Vector</span> is used to determine where the positive Y axis points.",
                "type": "XYZPar",
                "name": "upvectorx",
                "items": []
            },
            {
                "text": "XYZ : When orienting an object, the <span class=\"tipTextSOP\">Up Vector</span> is used to determine where the positive Y axis points.",
                "type": "XYZPar",
                "name": "upvectory",
                "items": []
            },
            {
                "text": "XYZ : When orienting an object, the <span class=\"tipTextSOP\">Up Vector</span> is used to determine where the positive Y axis points.",
                "type": "XYZPar",
                "name": "upvectorz",
                "items": []
            },
            {
                "text": "Menu : Sets the center of the geometry after the Transform page has been applied.",
                "type": "MenuPar",
                "name": "posttx",
                "items": []
            },
            {
                "text": "Menu : Determines which part of the input geometry to align to the Origin or Reference Input as selected in Post Translate parameter above.",
                "type": "MenuPar",
                "name": "fromx",
                "items": []
            },
            {
                "text": "Menu : When using Reference Input this determines which part of the Reference Input to align the geometry to.",
                "type": "MenuPar",
                "name": "tox",
                "items": []
            },
            {
                "text": "Menu : Sets the center of the geometry after the Transform page has been applied.",
                "type": "MenuPar",
                "name": "postty",
                "items": []
            },
            {
                "text": "Menu : Determines which part of the input geometry to align to the Origin or Reference Input as selected in Post Translate parameter above.",
                "type": "MenuPar",
                "name": "fromy",
                "items": []
            },
            {
                "text": "Menu : When using Reference Input this determines which part of the Reference Input to align the geometry to.",
                "type": "MenuPar",
                "name": "toy",
                "items": []
            },
            {
                "text": "Menu : Sets the center of the geometry after the Transform page has been applied.",
                "type": "MenuPar",
                "name": "posttz",
                "items": []
            },
            {
                "text": "Menu : Determines which part of the input geometry to align to the Origin or Reference Input as selected in Post Translate parameter above.",
                "type": "MenuPar",
                "name": "fromz",
                "items": []
            },
            {
                "text": "Menu : When using Reference Input this determines which part of the Reference Input to align the geometry to.",
                "type": "MenuPar",
                "name": "toz",
                "items": []
            },
            {
                "text": "Menu : Sets the scale of the geometry after the Transform page has been applied.",
                "type": "MenuPar",
                "name": "postscale",
                "items": []
            },
            {
                "text": "Menu : Sets the scale of the geometry after the Transform page has been applied to scale.",
                "type": "MenuPar",
                "name": "postscalex",
                "items": []
            },
            {
                "text": "Menu : Sets the scale of the geometry after the Transform page has been applied to scale.",
                "type": "MenuPar",
                "name": "postscaley",
                "items": []
            },
            {
                "text": "Menu : Sets the scale of the geometry after the Transform page has been applied to scale.",
                "type": "MenuPar",
                "name": "postscalez",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "transform",
        "opLabel": "Transform",
        "short": "The Transform SOP translates, rotates and scales the input geometry in \"object space\" or local to the SOP.",
        "opClass": "transformSOP_Class",
        "opFamily": "SOP",
        "long": "The Transform SOP translates, rotates and scales the input geometry in \"object space\" or local to the SOP. The Model Editor and the Transform SOP both work in \"object space\", and change the X Y Z positions of the points. In contrast, animating the transformation channels of an object in the Geometry Viewer Pane moves/scales the entire object in \"world space\" and does not affect the XYZ point positions of the geometry.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "trimSOP": {
        "label": "trimSOP",
        "members": [
            {
                "text": "StrMenu : This field allows you to specify the group that you would like to trim. You can select the group from the pop-up menu, or specify a points and primitives range.\t\n\t\t\nYou can specify profile curves within the group by providing a profile pattern (e.g. <code>*.3</code> specifies the fourth profile in all spline surfaces).",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : The types of trimming operations available.",
                "type": "MenuPar",
                "name": "optype",
                "items": []
            },
            {
                "text": "Toggle : When this option is off, the trim loops in the group (or all the loops on the surfaces if no group has been specified) will be considered together to form a region. It will report the first region that is found. That is, if more than one closed loop could be formed by joining the lines, there is no guarantee that the region is trimmed. Also, if there is a closed loop in the group of loops, then just that loop is used.\t\n\t\t\nIf the loops on the surface don't form a closed loop, then the SOP will attempt to form a region by using the boundary of the region. If all the loops make a total of two intersections with the boundary, then it will attempt to form the loop by forming it around the boundary.\t\t\n\t\t\n'''For example:''' Use the [[Carve SOP]] to extract four profiles: two in U, and two in V. Pipe that into a Trim SOP and turn this option off. The four profiles will define a region to be trimmed. Notice that the profile end-points do not coincide, and the profiles are not parametrically continuous, nor are they created in the proper order. Despite all this, the Trim SOP is able to figure out the hole.",
                "type": "TogglePar",
                "name": "individual",
                "items": []
            },
            {
                "text": "Toggle : This option allows you to specify that an outer trim loop be built. It is useful where you have more than one profile curve on the surface and are performing several successive trim operations involving both the <span class=\"tipTextSOP\">Keep Inside</span> and <span class=\"tipTextSOP\">Keep Outside</span> options (see example, below).\t\n\t\t\n'''Tip:''' An outer trim loop must be generated the first time you punch a hole in the surface, but not if you just keep the contents of that hole and throw away the rest. By default, the outer loop (which goes all around the domain boundary) is built for you automatically. Sometimes, however, you first do a '''Keep Inside''', then a '''Keep Outside''' with an area that's not inside the preserved regions, so you may want the outer curve at that point. That is when this parameter is useful.",
                "type": "TogglePar",
                "name": "bigloop",
                "items": []
            },
            {
                "text": "Float : How close two trim curves must be to each other or to the edge of the patch in order to be considered an intersection.",
                "type": "FloatPar",
                "name": "trimtol",
                "items": []
            },
            {
                "text": "Int : You can specify the altitude of the trim. The <code>$ALTITUDE</code> variable is the surface's current altitude. This marks the transition for the surface from trimmed in to trimmed out.",
                "type": "IntPar",
                "name": "altitude",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "trim",
        "opLabel": "Trim",
        "short": "The Trim SOP cuts out parts of a spline surface, or uncuts previously cut pieces.",
        "opClass": "trimSOP_Class",
        "opFamily": "SOP",
        "long": "The Trim SOP cuts out parts of a spline surface, or uncuts previously cut pieces. When a portion of the surface is trimmed, it is not actually removed from the surface; instead, that part is made invisible. This means that you can still modify the surface (modify the position of its points, for instance) that is not displayed in order to affect the part that is displayed.\t\n\t\t\nThe surface can be trimmed by specifying open or closed profiles as inside or outside regions. The profiles need not be contained within the domain (UV space) of the surface; they can also be nested.\t\t\n\t\t\nOpen profiles are treated as follows: if both ends of the profile are inside the surface, the ends are connected to one another; if the profile's ends are outside the domain of the surface they are projected onto, that part of the surface appears to be cut away.\t\t\n\t\t\nYou will usually need a Trim SOP, [[Bridge SOP]], or [[Profile SOP]] after a [[Project SOP]].\t\t\n\t\t\n* Use a Trim SOP to cut a hole in the projected surface.\t\t\n* Use a [[Bridge SOP]] to skin the profile curve to another profile curve.\t\t\n* Use a [[Profile SOP]] to extract the curve on surface or remap it's position.\t\t\n{{OPSubSection\n|opFamily=SOP\n|sectionName=Selection Method - Winding Rule\n|sectionSummary=The selection method employed for clarifying overlapping trim loops is the winding rule, which executes overlapping commands instead of having them cancel each other out.\t\t\n\t\t\n'''Tip:''' Since only surfaces containing profile curves can be trimmed, you will always need a Project or [[Carve SOP]] in the chain above the Trim SOP.\n}}",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "tristripSOP": {
        "label": "tristripSOP",
        "members": [
            {
                "text": "StrMenu : Specify a group of primitive to convert to tristrips. If no group is specified, then the entire geometry will be converted.",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Toggle : When checked on, the length (number of triangles) of the tristrips can be constrained to a maximum using the Maximum Strip Length parameter below.",
                "type": "TogglePar",
                "name": "constrainstriplength",
                "items": []
            },
            {
                "text": "Int : Set the maximum number of triangles in each tristrip.",
                "type": "IntPar",
                "name": "maxstriplength",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "tristrip",
        "opLabel": "Tristrip",
        "short": "The Tristrip SOP convert geometry into triangle strips.",
        "opClass": "tristripSOP_Class",
        "opFamily": "SOP",
        "long": "The Tristrip SOP convert geometry into triangle strips. Triangle strips are faster to render than regular triangles or quads.",
        "opLicense": "Non-Commercial",
        "opFilter": "True",
        "opCategories": ""
    },
    "tubeSOP": {
        "label": "tubeSOP",
        "members": [
            {
                "text": "Menu : Select from the following types. For information on the different types, see the [[:Category:Geometry|Geometry]] category articles.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Menu : This option is used to select the type of surface, when using a Mesh Primitive Type.",
                "type": "MenuPar",
                "name": "surftype",
                "items": []
            },
            {
                "text": "Menu : Primary axis of tube (long axis).",
                "type": "MenuPar",
                "name": "orient",
                "items": []
            },
            {
                "text": "Toggle : Available only when an input is connected to the Tube SOP to set bounds for the tube. When Orient Bounds = On it will rotate the geometry to match the orientation of the input SOP used for bounds.",
                "type": "TogglePar",
                "name": "orientbounds",
                "items": []
            },
            {
                "text": "Toggle : Enabled only when an input is connected to the Tube SOP to set bounds for the tube. Turn Modify Bounds = On to enable the transform parameters below to further modify the position, scale, radius and height of the bounds.",
                "type": "TogglePar",
                "name": "modifybounds",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rord",
                "items": []
            },
            {
                "text": "XYZ : Location of the tube center from the object origin.",
                "type": "XYZPar",
                "name": "tx",
                "items": []
            },
            {
                "text": "XYZ : Location of the tube center from the object origin.",
                "type": "XYZPar",
                "name": "ty",
                "items": []
            },
            {
                "text": "XYZ : Location of the tube center from the object origin.",
                "type": "XYZPar",
                "name": "tz",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "rx",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "ry",
                "items": []
            },
            {
                "text": "XYZ : ",
                "type": "XYZPar",
                "name": "rz",
                "items": []
            },
            {
                "text": "Float : The first field is the radius of the top of the tube and the second field represents the radius of the bottom of the tube.",
                "type": "FloatPar",
                "name": "rad",
                "items": []
            },
            {
                "text": "Float : The height of the tube.",
                "type": "FloatPar",
                "name": "height",
                "items": []
            },
            {
                "text": "Toggle : Invert the direction of anchors.",
                "type": "TogglePar",
                "name": "reverseanchors",
                "items": []
            },
            {
                "text": "Float : Set the point in X about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchoru",
                "items": []
            },
            {
                "text": "Float : Set the point in Y about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorv",
                "items": []
            },
            {
                "text": "Float : Set the point in Z about which the geometry is positioned, scaled and rotated.",
                "type": "FloatPar",
                "name": "anchorw",
                "items": []
            },
            {
                "text": "Toggle : This option applies only to Bezier and NURBS types. If selected, the tube is an approximated nonrational curve, otherwise it is a perfect rational curve.",
                "type": "TogglePar",
                "name": "imperfect",
                "items": []
            },
            {
                "text": "Int : Number of rows in tube.",
                "type": "IntPar",
                "name": "rows",
                "items": []
            },
            {
                "text": "Int : Number of columns in tube.",
                "type": "IntPar",
                "name": "cols",
                "items": []
            },
            {
                "text": "Int : If a spline surface is selected, it is built at this order for U.",
                "type": "IntPar",
                "name": "orderu",
                "items": []
            },
            {
                "text": "Int : If a spline surface is selected, it is built at this order for V.",
                "type": "IntPar",
                "name": "orderv",
                "items": []
            },
            {
                "text": "Toggle : If selected, it adds faceted end caps to the ends of the tube.",
                "type": "TogglePar",
                "name": "cap",
                "items": []
            },
            {
                "text": "Menu : Adds UV texture coordinates to the sphere.",
                "type": "MenuPar",
                "name": "texture",
                "items": []
            },
            {
                "text": "Toggle : Checking this option On will compute surface normals.",
                "type": "TogglePar",
                "name": "normals",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opType": "tube",
        "opLabel": "Tube",
        "short": "The Tube SOP generates open or closed tubes, cones, or pyramids along the X, Y or Z axes.",
        "opClass": "tubeSOP_Class",
        "opFamily": "SOP",
        "long": "The Tube SOP generates open or closed tubes, cones, or pyramids along the X, Y or Z axes. It outputs as meshes, polygons or simply a tube [[Primitive]].",
        "opLicense": "Non-Commercial",
        "opFilter": "False",
        "opCategories": ""
    },
    "vertexSOP": {
        "label": "vertexSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this <code>SOP</code> to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Menu : Select between keeping the color, adding new color, or using no color for vertex color attributes from incoming geometry.",
                "type": "MenuPar",
                "name": "doclr",
                "items": []
            },
            {
                "text": "RGB : If you select 'Add Color' from the menu above, Cd color vertex attributes will be added/modified in the SOP. Enter expressions below to control the values of the point colors. The attributes to modify are: <code>me.inputColor[0]</code> for red, <code>me.inputColor[1]</code> for green, <code>me.inputColor[2]</code> for blue, and <code>me.inputColor[3]</code> for alpha. If you select 'No Color' from the menu above, the Cd color vertex attribute will be removed from the SOP.",
                "type": "RGBPar",
                "name": "diffr",
                "items": []
            },
            {
                "text": "RGB : If you select 'Add Color' from the menu above, Cd color vertex attributes will be added/modified in the SOP. Enter expressions below to control the values of the point colors. The attributes to modify are: <code>me.inputColor[0]</code> for red, <code>me.inputColor[1]</code> for green, <code>me.inputColor[2]</code> for blue, and <code>me.inputColor[3]</code> for alpha. If you select 'No Color' from the menu above, the Cd color vertex attribute will be removed from the SOP.",
                "type": "RGBPar",
                "name": "diffg",
                "items": []
            },
            {
                "text": "RGB : If you select 'Add Color' from the menu above, Cd color vertex attributes will be added/modified in the SOP. Enter expressions below to control the values of the point colors. The attributes to modify are: <code>me.inputColor[0]</code> for red, <code>me.inputColor[1]</code> for green, <code>me.inputColor[2]</code> for blue, and <code>me.inputColor[3]</code> for alpha. If you select 'No Color' from the menu above, the Cd color vertex attribute will be removed from the SOP.",
                "type": "RGBPar",
                "name": "diffb",
                "items": []
            },
            {
                "text": "Float : Control the alpha attribute in the same manner as the rgb colors above. Alpha is Cd[3] and comes from input via <code>me.inputColor[3]</code>",
                "type": "FloatPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Menu : Select between keeping the texture coordinates, adding new texture coordinates, or using no texture coordinates for the vertex texture attributes from incoming geometry.",
                "type": "MenuPar",
                "name": "douvw",
                "items": []
            },
            {
                "text": "UVW : If you select 'Add Texture' from the menu above, uv texture coordinate vertex attributes will be added/modified in the SOP. Enter expressions here to control the values of the vertex texture coordinates here. The attributes to modify are: <code>me.inputTexture[0]</code>, <code>me.inputTexture[1]</code> and <code>me.inputTexture[2]</code>. If you select 'No Texture' from the menu above, the uv texture coordinates vertex attribute will be removed from the SOP.",
                "type": "UVWPar",
                "name": "map",
                "items": []
            },
            {
                "text": "Menu : Select between keeping the crease, adding new crease, or using no crease for creaseweight attribute from incoming geometry.\t\n\t\t\nThe <code>Crease Weight</code> attribute can be used to set individual edge crease weights for sub-division surfaces (see [[Subdivide SOP]] ). This vertex attribute defines the weight for the edge which goes from that vertex to the next vertex in the polygon. For example, with a triangle (which has vertices 0, 1, 2), the attribute for vertex 1 defines the crease weight for the edge (1, 2). The attribute for vertex 2 defines the crease weight for edge (2, 0). The crease weight should be greater than 0. The larger the value for crease weights, the sharper the edge will be when sub-divided.\t\t\n\t\t\nCrease attributes can be visualized by passing them into a [[Subdivide SOP]].",
                "type": "MenuPar",
                "name": "docrease",
                "items": []
            },
            {
                "text": "Float : If you select 'Add Crease' from the menu above, enter expressions here to control the values of the creaseweights here. The attribute to modify is: me.inputVertex.creaseWeight[0]. Values for the weight of the vertex can range from 0.0001 to infinity.",
                "type": "FloatPar",
                "name": "crease",
                "items": []
            },
            {
                "text": "Str : Creates a custom attribute with this name.",
                "type": "StrPar",
                "name": "custom1",
                "items": []
            },
            {
                "text": "Menu : The type of attribute created can be selected from this menu.",
                "type": "MenuPar",
                "name": "custom1type",
                "items": []
            },
            {
                "text": "Float : Set the values of the Custom Attrib using these parameters.",
                "type": "FloatPar",
                "name": "custom1val",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Vertex SOP allows you to edit/create attributes on a per-vertex (rather than per-point) basis.",
        "opClass": "vertexSOP_Class",
        "opFilter": "True",
        "long": "The Vertex SOP allows you to edit/create attributes on a per-vertex (rather than per-point) basis. It is similar to the [[Point SOP]] in this respect. It supports two inputs, and will inherit the first input source by default.  If the second input have less primitives than the first input, it will cycle through the primitives and match the vertices.  If the primitive in the first input has more vertices than the matching primitive in the second input, the extra vertices are ignored.\t\n\t\t\nThere are currently three vertex attributes supported:\t\t\n\t\t\n* Diffuse Color\t\t\n* Alpha\t\t\n* Texture Coordinates\t\t\n\t\t\nWhen the attribute is defined, it can only occur on either points or vertices, but not both. Thus, if the input geometry has a point attribute for diffuse color, the attribute will automatically be \"elevated\" to be a vertex attribute (if diffuse colors are added in the Vertex SOP).\t\t\n\t\t\nThe SOP processes every vertex of every primitive. For each vertex processed, there are variables which allow you to know the:\t\t\n\t\t\n* Vertex number of the primitive being processed\t\t\n* The number of vertices in the primitive being processed\t\t\n* The point which is referenced by the vertex\t\t\n* The primitive which contains the vertex\t\t\n* The total number of points\t\t\n* The total number of primitives \t\t\n\t\t\nThere are also local variables to find out the values of some point attributes (i.e. position, normal - if they exist), in addition to vertex attributes.  To access the attributes of the second input source, append a 2 to the variable.",
        "opLicense": "Non-Commercial",
        "opFamily": "SOP",
        "opType": "vertex",
        "opLabel": "Vertex",
        "opCategories": ""
    },
    "wireframeSOP": {
        "label": "wireframeSOP",
        "members": [
            {
                "text": "StrMenu : If there are input groups, specifying a group name in this field will cause this <span>SOP</span> to act only upon the group specified. Accepts patterns, as described in [[Pattern Matching]].",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "Float : Radius of the individual wires used in the construction of the geometry.",
                "type": "FloatPar",
                "name": "radius",
                "items": []
            },
            {
                "text": "Toggle : When selected, rounds the corners by placing spheres at the point locations with the same radius as the wires.",
                "type": "TogglePar",
                "name": "corners",
                "items": []
            },
            {
                "text": "Toggle : When selected, places end-caps on all wire geometry.",
                "type": "TogglePar",
                "name": "caps",
                "items": []
            },
            {
                "text": "Toggle : Removes the polygons from the output geometry, leaving only the converted line structures.",
                "type": "TogglePar",
                "name": "remove",
                "items": []
            },
            {
                "text": "Toggle : Faster wire calculation at the expense of accuracy.",
                "type": "TogglePar",
                "name": "fast",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Wireframe SOP converts edges to tubes and points to spheres, creating the look of a wire frame structure in renderings.",
        "opClass": "wireframeSOP_Class",
        "opFilter": "True",
        "long": "The Wireframe SOP converts edges to tubes and points to spheres, creating the look of a wire frame structure in renderings. This is ideal for modelling tube structures and pipes.",
        "opLicense": "Non-Commercial",
        "opFamily": "SOP",
        "opType": "wire",
        "opLabel": "Wireframe",
        "opCategories": ""
    },
    "artnetDAT": {
        "label": "artnetDAT",
        "members": [
            {
                "text": "DAT : Runs this script when polling the network for devices. See [[artnetDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "StrMenu : Select which columns are included in the table.  Click the drop menu to the right to see all that are available.",
                "type": "StrMenuPar",
                "name": "columns",
                "items": []
            },
            {
                "text": "Pulse : Poll the network for devices.",
                "type": "PulsePar",
                "name": "poll",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Art-Net",
        "long": "The Art-Net DAT polls and lists all devices on the network.\t\n\n'''Tip''': If you are having trouble inspecting the Art-Net packets that are or aren\u2019t being read by a device, use the [https://www.wireshark.org/ Wireshark] utility to capture a network stream for comparison.\n\nSee [[Art-Net]], [[DMX In CHOP]], [[DMX Out CHOP]].",
        "opType": "artnet",
        "opClass": "artnetDAT_Class",
        "opFilter": "False",
        "short": "The Art-Net DAT polls and lists all devices on the network.",
        "opCategories": ""
    },
    "chopexecuteDAT": {
        "label": "chopexecuteDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT will respond to the CHOP that is referenced.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : ([[Operator Language|Tscript]] only) Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to ''Specified Operator''.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "CHOP : The CHOP whose channel change will trigger the DAT to execute its script.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "StrMenu : Which channel will trigger change.",
                "type": "StrMenuPar",
                "name": "channel",
                "items": []
            },
            {
                "text": "Toggle : The onOffToOn() method executes when the channel specified switches from off to on, called at the first \"on\" frame.",
                "type": "TogglePar",
                "name": "offtoon",
                "items": []
            },
            {
                "text": "Toggle : The whileOn() method executes when the channel specified is on. It is called once each frame.",
                "type": "TogglePar",
                "name": "whileon",
                "items": []
            },
            {
                "text": "Toggle : The onOnToOff() method executes when the channel specified switches from on to off, called at the first \"off\" frame.",
                "type": "TogglePar",
                "name": "ontooff",
                "items": []
            },
            {
                "text": "Toggle : The whileOff() method executes when the channel specified is off. It is called once each frame.",
                "type": "TogglePar",
                "name": "whileoff",
                "items": []
            },
            {
                "text": "Toggle : The onValueChange() method executes when the channel specified changes value in any way. It is called once each frame.",
                "type": "TogglePar",
                "name": "valuechange",
                "items": []
            },
            {
                "text": "Menu : Enabled when using the <span class=\"tipTextDAT\">While On</span> or <span class=\"tipTextDAT\">While Off</span> options above.  Determines if the DAT executes <span class=\"tipTextDAT\">For Every Sample</span> or <span class=\"tipTextDAT\">Once Per Frame</span>.",
                "type": "MenuPar",
                "name": "freq",
                "items": []
            },
            {
                "text": "Pulse : Clicking this opens a text editor to edit text in the DAT.",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> and <code>.dat</code> files.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : When On, loads the file from disk into the DAT when the projects starts.  A filename must be specified.  Turning on the option will load the file from disk immediately.  If the file does not exist, it will be created the first time the DAT is updated.  The file is monitored so that any changes made to the file will update the DAT, and any changes made to the DAT will be written to the file right away.  If the file is removed, the DAT will retain its current contents.",
                "type": "TogglePar",
                "name": "syncfile",
                "items": []
            },
            {
                "text": "Toggle : When On, reloads the file from disk into the DAT when the projects starts.",
                "type": "TogglePar",
                "name": "loadonstart",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "loadonstartpulse",
                "items": []
            },
            {
                "text": "Toggle : When On, writes the contents of the DAT out to the file on disk when the project is saved.",
                "type": "TogglePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Pulse : Instantly write the file to disk.",
                "type": "PulsePar",
                "name": "writepulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "CHOP Execute",
        "long": "The CHOP Execute DAT will run its script when the channel values of a specified CHOP change. You can specify which channels to look at, and trigger based on their values changing in various ways.  The script gets called for every sample that changes, so when rendering one frame, it may get called 2 or more times per channel, depending on how many frames forward TouchDesigner has stepped (see [[Time Slicing]]).\t\t\n\t\t\t\nCHOP Execute DATs are created with [[chopexecuteDAT_Class|default python method placeholders]]. For each monitored condition in the parameters, there is a matching python method in the DAT. When a condition is turned on in the parameters, each time that condition is satisfied the corresponding python method will be executed.",
        "opType": "chopexec",
        "opClass": "chopexecuteDAT_Class",
        "opFilter": "False",
        "short": "The CHOP Execute DAT will run its script when the channel values of a specified CHOP change.",
        "opCategories": ""
    },
    "choptoDAT": {
        "label": "choptoDAT",
        "members": [
            {
                "text": "CHOP : The CHOP to be used to retrieve values. A row is created for each channel's value.",
                "type": "CHOPPar",
                "name": "chop",
                "items": []
            },
            {
                "text": "Toggle : When checked on, an extra column will be created in every row for the channel's name.",
                "type": "TogglePar",
                "name": "names",
                "items": []
            },
            {
                "text": "Toggle : When on and the CHOP is time sliced, only the latest sample of the CHOP will be used to create the DAT output. This prevents the table size from fluctuating as frames are dropped.",
                "type": "TogglePar",
                "name": "latestsample",
                "items": []
            },
            {
                "text": "Menu : Create a row per channel or column per channel.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "CHOP to",
        "long": "The CHOP to DAT allows you to get CHOP channel values into a DAT in table format.",
        "opType": "chopto",
        "opClass": "choptoDAT_Class",
        "opFilter": "False",
        "short": "The CHOP to DAT allows you to get CHOP channel values into a DAT in table format.",
        "opCategories": ""
    },
    "clipDAT": {
        "label": "clipDAT",
        "members": [
            {
                "text": "Pulse : Clicking this opens a text editor to add/edit/delete text from the DAT.",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The path and name of the file to load. Accepts .txt and .dat files. The file can be read in from disk or from the web. Use http:// when specifying a URL.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Pulse : When set to 1, reloads the file into the DAT.",
                "type": "PulsePar",
                "name": "reload",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "CHOP : Points to the [[Clip CHOP]] which will trigger the script when run in a [[Clip Blender CHOP]].",
                "type": "CHOPPar",
                "name": "clip",
                "items": []
            },
            {
                "text": "OP : The path that the script will be executed from if the Execute From parameter is set to ''Specified Component''.",
                "type": "OPPar",
                "name": "component",
                "items": []
            },
            {
                "text": "Int : Executes the script once, the first time the specified index of the clip is played in a clipblender. Even if the clip is looping in a clipblender, the script will only be executed once.",
                "type": "IntPar",
                "name": "framefirst",
                "items": []
            },
            {
                "text": "Int : Executes the script everytime the specified index of the clip is played in a clipblender. When a clip is looping, the script will run each time through the loop.",
                "type": "IntPar",
                "name": "frameloop",
                "items": []
            },
            {
                "text": "Toggle : Executes the script when a clipblender exits the specified clip.",
                "type": "TogglePar",
                "name": "exit",
                "items": []
            },
            {
                "text": "Toggle : Print debug information to the textport.",
                "type": "TogglePar",
                "name": "printstate",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Pro",
        "opLabel": "Clip",
        "long": "The Clip DAT contains information about motion clips that are manipulated by a [[Clip CHOP]] and [[Clip Blender CHOP]].\t\t\nThe Clip DAT can hold any command or script text, which can be triggered based on the settings on the <span class=\"tipTextDAT\">Execute</span> parameter page (This is where the Clip DAT and the Text DAT are different). The Clip DAT's script is triggered by specified clips being played through a [[Clip Blender CHOP]].",
        "opType": "clip",
        "opClass": "clipDAT_Class",
        "opFilter": "False",
        "short": "The Clip DAT contains information about motion clips that are manipulated by a [[Clip CHOP]] and [[Clip Blender CHOP]].",
        "opCategories": ""
    },
    "convertDAT": {
        "label": "convertDAT",
        "members": [
            {
                "text": "Menu : Convert text format.",
                "type": "MenuPar",
                "name": "how",
                "items": []
            },
            {
                "text": "Toggle : When enabled, do not convert blank lines into empty rows.",
                "type": "TogglePar",
                "name": "removeblank",
                "items": []
            },
            {
                "text": "Str : A list of individual characters to use to split the string into cells. The delimiters are used independently. That is, if <code>$%</code> is used in this parameter, the cells will be split at <code>$</code> OR <code>%</code>, not only at <code>$%</code>. A [[Substitute DAT]] can be used to collapse a more complex delimiter into a single character to be use for the conversion.",
                "type": "StrPar",
                "name": "delimiters",
                "items": []
            },
            {
                "text": "Str : Insert this string between each cell when converting from a table to text.",
                "type": "StrPar",
                "name": "spacers",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Convert",
        "long": "The Convert DAT changes the text format from simple text to table form and vice-versa.",
        "opType": "convert",
        "opClass": "convertDAT_Class",
        "opFilter": "True",
        "short": "The Convert DAT changes the text format from simple text to table form and vice-versa.",
        "opCategories": ""
    },
    "cplusplusDAT": {
        "label": "cplusplusDAT",
        "members": [
            {
                "text": "filepath dll load : The path to the plugin you want to load.",
                "type": "filepath dll loadPar",
                "name": "plugin",
                "items": []
            },
            {
                "text": "joinpair toggle : When this parameter is On 1, it will delete the instance of the class created by the plugin, and create a new one.",
                "type": "joinpair togglePar",
                "name": "reinit",
                "items": []
            },
            {
                "text": "nolabel button : Instantly reinitialize the class.",
                "type": "nolabel buttonPar",
                "name": "reinitpulse",
                "items": []
            },
            {
                "text": "toggle : When this parameter goes above 1, it will delete the instance of the class created by the plugin and unload the plugin. If multiple DATs have loaded the same plugin they will all need to unload it to release the file.",
                "type": "togglePar",
                "name": "unloadplugin",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opType": "cplusplusDAT",
        "opLabel": "CPlusPlus",
        "opClass": "cplusplusDAT_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The CPlusPlus DAT allows you to make custom DAT operators by writing your own plugin using C++.",
        "long": "The CPlusPlus DAT allows you to make custom DAT operators by writing your own plugin using C++.\n \nUsing the CPlusPlus DAT, you can create either a Table or Text DAT output depending what type you specify at the time of creation.\nSee [[Write a CPlusPlus Plugin]] and the other articles in the [[:Category:C++|C++ category]] for more detailed information on how to make .dll for use with this DAT. Note that regardless of the type of DAT node (i.e. Table or Text), all the names for searching the cells and assigned texts have to be a encoded as a valid UTF-8.\n\nExample for CPlusPlus DAT as a Visual Studio project in Windows are available in <code>C:/Program Files/Derivative/TouchDesigner/Samples/CPlusPlus/DAT</code> or your custom TouchDesigner installation folder. (NOTE: On macOS it is here: <code>TouchDesigner.app/Contents/Resources/tfs/Samples/CPlusPlus/DAT</code>\n\n'''Custom Parameters''' - Custom Parameters can be automatically created by the C++ DAT <code>.dll</code>. This custom parameter page can be removed, edited, or appended to from within the <code>setupParameters()</code> function in CPlusPlusDATExample.cpp. The defined custom parameters can be enabled or disabled depending on whether they are valid for a specific task or not.)",
        "opCategories": ""
    },
    "datexecuteDAT": {
        "label": "datexecuteDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT will respond to the CHOP that is referenced.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : ([[Operator Language|Tscript]] only) Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to ''Specified Operator''.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "DAT : The DAT which is monitored and will trigger the script to execute when its contents change.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "Toggle : The onTableChange() method is called if the table changes in any way since the last cook.",
                "type": "TogglePar",
                "name": "tablechange",
                "items": []
            },
            {
                "text": "Toggle : The onRowChange() method is called once for every row that changed (since its last cook).",
                "type": "TogglePar",
                "name": "rowchange",
                "items": []
            },
            {
                "text": "Toggle : The onColChange() method is called once for every column that changed (since its last cook).",
                "type": "TogglePar",
                "name": "colchange",
                "items": []
            },
            {
                "text": "Toggle : The onCellChange() method is called for every cell that changed since the last cook.",
                "type": "TogglePar",
                "name": "cellchange",
                "items": []
            },
            {
                "text": "Toggle : The onSizeChange() method is called for every table size change since the last cook.",
                "type": "TogglePar",
                "name": "sizechange",
                "items": []
            },
            {
                "text": "Menu : Determines if the methods are executed at the start of the frame or end of the frame.",
                "type": "MenuPar",
                "name": "execute",
                "items": []
            },
            {
                "text": "Pulse : Clicking this opens a text editor to edit text in the DAT.",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> and <code>.dat</code> files.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : When On, loads the file from disk into the DAT when the projects starts.  A filename must be specified.  Turning on the option will load the file from disk immediately.  If the file does not exist, it will be created the first time the DAT is updated.  The file is monitored so that any changes made to the file will update the DAT, and any changes made to the DAT will be written to the file right away.  If the file is removed, the DAT will retain its current contents.",
                "type": "TogglePar",
                "name": "syncfile",
                "items": []
            },
            {
                "text": "Toggle : When On, reloads the file from disk into the DAT when the projects starts.",
                "type": "TogglePar",
                "name": "loadonstart",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "loadonstartpulse",
                "items": []
            },
            {
                "text": "Toggle : When On, writes the contents of the DAT out to the file on disk when the project is saved.",
                "type": "TogglePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Pulse : Instantly write the file to disk.",
                "type": "PulsePar",
                "name": "writepulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "DAT Execute",
        "long": "The DAT Execute DAT monitors another DAT's contents and runs a script when those contents change. The other DAT is usually a table.\t\t\n\t\t\t\nDAT Execute DATs are created with [[datexecuteDAT_Class#Callbacks|default python method placeholders]]. For each monitored condition in the parameters, there is a matching python method in the DAT. When a condition is turned on in the parameters, each time that condition is satisfied the corresponding python method will be executed.",
        "opType": "datexec",
        "opClass": "datexecuteDAT_Class",
        "opFilter": "False",
        "short": "The DAT Execute DAT monitors another DAT's contents and runs a script when those contents change. The other DAT is usually a table.",
        "opCategories": ""
    },
    "errorDAT": {
        "label": "errorDAT",
        "members": [
            {
                "text": "Toggle : Inhibits and allows message to be added to log.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : Filter pattern for the output. Can be a combination or one of: <code>message</code>, <code>warning</code> or <code>abort</code>",
                "type": "StrPar",
                "name": "severity",
                "items": []
            },
            {
                "text": "Str : Filter pattern for the output where the source operator family is specified. Can be a combination or one of the operator families.",
                "type": "StrPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Str : Filter pattern for the output where the logging of errors can be limited to specific locations in the project.",
                "type": "StrPar",
                "name": "source",
                "items": []
            },
            {
                "text": "Str : Filter pattern for the output applied to the error message.",
                "type": "StrPar",
                "name": "message",
                "items": []
            },
            {
                "text": "Pulse : Traverse through all nodes and captures all current errors.",
                "type": "PulsePar",
                "name": "logcurrent",
                "items": []
            },
            {
                "text": "DAT : The DAT's script will execute once for each message coming in. See [[errorDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to <span class=\"tipTextDAT\">Specified Operator</span>.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading.",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Error",
        "long": "The Error DAT lists the most recent TouchDesigner errors in its FIFO (first in/first out) table. \t\t\n\t\t\t\nYou can filter our messages using pattern matching on some of the columns like Severity, Type and path of the node containing the error. One column contains the absolute frame (<code>absTime.frame</code>) in which the error occurred.",
        "opType": "error",
        "opClass": "errorDAT_Class",
        "opFilter": "False",
        "short": "The Error DAT lists the most recent TouchDesigner errors in its FIFO (first in/first out) table.",
        "opCategories": ""
    },
    "etherdreamDAT": {
        "label": "etherdreamDAT",
        "members": [
            {
                "text": "DAT : Runs this script when polling for devices. See [[etherdreamDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "StrMenu : Select which columns are included in the table. Click the drop menu to the right to see all that are available.",
                "type": "StrMenuPar",
                "name": "columns",
                "items": []
            },
            {
                "text": "Pulse : Poll for devices.",
                "type": "PulsePar",
                "name": "poll",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "EtherDream",
        "long": "The EtherDream DAT polls and lists all EtherDream devices connected.",
        "opType": "etherdream",
        "opClass": "etherdreamDAT_Class",
        "opFilter": "False",
        "short": "The EtherDream DAT polls and lists all EtherDream devices connected.",
        "opCategories": ""
    },
    "evaluateDAT": {
        "label": "evaluateDAT",
        "members": [
            {
                "text": "DAT : An alternative DAT table to be used in place of an input table.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "DAT : An alternative DAT table to be used in place of a formula table.",
                "type": "DATPar",
                "name": "datexpr",
                "items": []
            },
            {
                "text": "StrMenu : Determines what format will be used for output from the DAT.",
                "type": "StrMenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Str : Expression used to evaluate each cell if an Expression input or DAT is not supplied.",
                "type": "StrPar",
                "name": "expr",
                "items": []
            },
            {
                "text": "Menu : If the Output Table Size parameter is Strings, Expressions, or Commands, and there is a second input, you can choose the output table size to be either Input DAT or the Formula DAT.  If the Formula DAT is chosen and its table size is greater than the input data table, then the last cell in each row or column will be used when evaluating the remaining formulas.",
                "type": "MenuPar",
                "name": "outputsize",
                "items": []
            },
            {
                "text": "Toggle : If the Output parameter is set to Strings or Expressions, the DAT will monitor any nodes used by the data, as well as check for time dependencies, and cook accordingly. This toggle is on by default. If you only want the DAT to cook based on input changes, you can turn this off to avoid unnecessary updates.",
                "type": "TogglePar",
                "name": "dependency",
                "items": []
            },
            {
                "text": "Toggle : Will convert things like \\n to newlines, \\t to tabs etc. Note that \\n, \\t will be converted to spaces if the input DAT is a table.",
                "type": "TogglePar",
                "name": "backslash",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Evaluate",
        "long": "The Evaluate DAT changes the cells of the incoming DAT using string-editing and math expressions. \t\t\n\t\t\t\nIn its simplest form, without an input DAT attached, you can put any python expression in the Expression parameter of an Evaluate DAT. To evaluate the expression every frame you may need to put the parameter into Expression [[Parameter Mode]].\t\t\t\n\t\t\t\nWith a DAT attached, it outputs a table with the same number of rows and columns as the input. \t\t\t\n\t\t\t\nThe Scope page can be used to restrict which rows and columns of cells are affected.\t\t\t\n\t\t\t\n* When the <span class=\"tipTextDAT\">Output</span> menu is set to Expressions, it causes the input cells to be evaluated as Pythong expressions. <code>me.inputCell.val</code> is the value of the input cell. \t\t\t\n\t\t\t\n* The optional second input DAT is an array of expressions which are matched to the cells of the input, then evaluated and output. If there are fewer rows in the second DAT than the first, the expressions in the last row of the second input are repeated. If there are fewer columns in the second DAT than the first, the last column is repeated.\t\t\t\n\t\t\t\n* '''Expressions are optimized by storing a compiled internal version, which runs much faster.'''  Use this where possible.  If you are reusing expressions by repeating them in a table, having an input table with the few expressions you will cycle through separate from the data will also improve performance.\t\t\t\n\t\t\t\nIf the second DAT is one cell, like the Expression parameter, it applies its expression to all the input cells. A one-cell second DAT with <code>me.inputCell.val+1</code> adds 1 to all the first input's cells.\t\t\t\n\t\t\t\nIf the second DAT is\n{{{!}} class=\"wikitable\"\n{{!}}<syntaxhighlight lang=python inline>me.inputCell.val</syntaxhighlight> {{!}}{{!}} <syntaxhighlight lang=python inline>me.inputCell.val</syntaxhighlight>\n{{!}}-\n{{!}}<syntaxhighlight lang=python inline>me.inputCell.val</syntaxhighlight> {{!}}{{!}} <syntaxhighlight lang=python inline>math.sin(math.radians(float(me.inputCell.val)))</syntaxhighlight>\n{{!}}}\nthen the first row and first column are left intact and the rest of the cells get their <code>sin()</code> computed.\t\t\t\n\t\t\t\n[[File:EvaluateDAT_ex.png]]\t\t\t\n\t\t\t\nThe Evaluate DAT maintains the format of the first input DAT (table or text) unless the Output Table Size parameter is used.\t\t\t\n\t\t\t\nSee also the [[Substitute DAT]], [[Expression CHOP]].",
        "opType": "eval",
        "opClass": "evaluateDAT_Class",
        "opFilter": "False",
        "short": "The Evaluate DAT changes the cells of the incoming DAT using string-editing and math expressions.",
        "opCategories": ""
    },
    "examineDAT": {
        "label": "examineDAT",
        "members": [
            {
                "text": "OP : Path to the operator to examine.",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Menu : Specifies what part of the operator to examine.",
                "type": "MenuPar",
                "name": "source",
                "items": []
            },
            {
                "text": "Str : If the object to be examined is a dictionary you can specify which element to examine here.",
                "type": "StrPar",
                "name": "subkey",
                "items": []
            },
            {
                "text": "Str : When source is set to Expression, enter your expression in this parameter.",
                "type": "StrPar",
                "name": "expression",
                "items": []
            },
            {
                "text": "Str : Clamp the maximum depth level.",
                "type": "StrPar",
                "name": "level",
                "items": []
            },
            {
                "text": "Str : Filter Key results.",
                "type": "StrPar",
                "name": "key",
                "items": []
            },
            {
                "text": "Str : Filter Type results.",
                "type": "StrPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Str : Filter Value results.",
                "type": "StrPar",
                "name": "value",
                "items": []
            },
            {
                "text": "Toggle : When true, complex object structures (example OP) are further expanded.",
                "type": "TogglePar",
                "name": "expandclasses",
                "items": []
            },
            {
                "text": "Int : Specify the maximum depth in which to expand a python object.",
                "type": "IntPar",
                "name": "maxlevels",
                "items": []
            },
            {
                "text": "Menu : Determines whether the output is raw text or in table format.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "Toggle : Turn this on to display the column names when '''Format''' is set to Table.",
                "type": "TogglePar",
                "name": "outputheaders",
                "items": []
            },
            {
                "text": "Toggle : Turn this on to output the '''Level''' column of the results.",
                "type": "TogglePar",
                "name": "outputlevel",
                "items": []
            },
            {
                "text": "Toggle : Turn this on to output the '''Key''' column of the results.",
                "type": "TogglePar",
                "name": "outputkey",
                "items": []
            },
            {
                "text": "Toggle : Turn this on to output the '''Type''' column of the results.",
                "type": "TogglePar",
                "name": "outputtype",
                "items": []
            },
            {
                "text": "Toggle : Turn this on to output the '''Value''' column of the results.",
                "type": "TogglePar",
                "name": "outputvalue",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Examine",
        "long": "The Examine DAT lets you inspect an operator's python storage, locals, globals, expressions, and extensions.",
        "opType": "examine",
        "opClass": "examineDAT_Class",
        "opFilter": "False",
        "short": "The Examine DAT lets you inspect an operator's python storage, locals, globals, expressions, and extensions.",
        "opCategories": ""
    },
    "executeDAT": {
        "label": "executeDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT will respond to the events selected below.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : ([[Operator Language|Tscript]] only) Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : This component is also the path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to ''Specified Operator''.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The onStart() method is executed when TouchDesigner starts.\tThis method is never called in TouchEngine because components are loaded after TouchEngine has started.",
                "type": "TogglePar",
                "name": "start",
                "items": []
            },
            {
                "text": "Toggle : The create() method is executed when the node is created. This can be triggered on start, by loading a component from disk, by copying & pasting, or any other way a node can be created.",
                "type": "TogglePar",
                "name": "create",
                "items": []
            },
            {
                "text": "Toggle : The onExit() method is executed when the TouchDesigner process quits.",
                "type": "TogglePar",
                "name": "exit",
                "items": []
            },
            {
                "text": "Toggle : The onFrameStart() method is executed at the start of every frame.",
                "type": "TogglePar",
                "name": "framestart",
                "items": []
            },
            {
                "text": "Toggle : The onFrameEnd() method is executed at the end of every frame.",
                "type": "TogglePar",
                "name": "frameend",
                "items": []
            },
            {
                "text": "Toggle : The onPlayStateChange() method is executed each time the play state changes, ie. pause or play is used on the timeline.",
                "type": "TogglePar",
                "name": "playstatechange",
                "items": []
            },
            {
                "text": "Toggle : The onDeviceChange() method is executed each time devices are connected or disconnected from the computer. For example, plugging in MIDI devices, cameras, joysticks, etc.<!--TDitemEnd-->\t\n\t\t\t\n'''NOTE:''' When using multiple Execute DATs with Start and Create functions, they are triggered in numbered-alphanumeric order of the DAT's names.",
                "type": "TogglePar",
                "name": "devicechange",
                "items": []
            },
            {
                "text": "Pulse : Clicking this opens a text editor to edit text in the DAT.<!--TDparEnd-->\t\n\t\t\t\n'''TIP:''' To direct all \"standard output\" of python to a Text DAT, put this in the <code>start()</code> method: <code>sys.stdout = op('text1')</code>\t\n\nTo safely to this and restore standard output:\n<syntaxhighlight lang=python>prev = sys.stdout\nsys.stdout = op('text1')\nsys.stdout = prev</syntaxhighlight>",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> and <code>.dat</code> files.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : When On, loads the file from disk into the DAT when the projects starts.  A filename must be specified.  Turning on the option will load the file from disk immediately.  If the file does not exist, it will be created the first time the DAT is updated.  The file is monitored so that any changes made to the file will update the DAT, and any changes made to the DAT will be written to the file right away.  If the file is removed, the DAT will retain its current contents.",
                "type": "TogglePar",
                "name": "syncfile",
                "items": []
            },
            {
                "text": "Toggle : When On, reloads the file from disk into the DAT when the projects starts.",
                "type": "TogglePar",
                "name": "loadonstart",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "loadonstartpulse",
                "items": []
            },
            {
                "text": "Toggle : When On, writes the contents of the DAT out to the file on disk when the project is saved.",
                "type": "TogglePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Pulse : Instantly write the file to disk.",
                "type": "PulsePar",
                "name": "writepulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Execute",
        "long": "The Execute DAT lets you edit scripts and run them based on conditions. It can be executed at the start or end of every frame, or at the start or end of the TouchDesigner process. \n\t\t\t\nExecute DATs are created with [[executeDAT_Class|default python method placeholders]].  For each monitored condition in the parameters, there is a matching python method in the DAT.  When a condition is turned on in the parameters, each time that condition is satisfied the corresponding python method will be executed.\t\n\nText can also can be passed into the Text DAT through the node's input, however this text will not be editable. Text can be created in the DAT via the [[Node Viewer]] or an external text editor.  \t\n\nSee also [[OP Execute DAT]].",
        "opType": "execute",
        "opClass": "executeDAT_Class",
        "opFilter": "False",
        "short": "The Execute DAT lets you edit scripts and run them based on conditions.",
        "opCategories": ""
    },
    "fifoDAT": {
        "label": "fifoDAT",
        "members": [
            {
                "text": "DAT : The Callbacks DAT will execute once for each row added to the FIFO DAT.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when <span class=\"tipTextDAT\">Execute</span> is set to <span class=\"tipTextDAT\">Specified Operator</span>. This operator is also the path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to <span class=\"tipTextDAT\">Specified Operator</span>.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <syntaxhighlight lang=python inline>op('opname').par.clear.pulse()</syntaxhighlight>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Keeps first row in table.",
                "type": "TogglePar",
                "name": "firstrow",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "FIFO",
        "long": "The FIFO DAT maintains a user-set maximum number of rows in a table. You add rows using the <code>appendRow()</code> method found in [[DAT Class]]. When its capacity is reached, the first row is removed. After the maximum number of rows is reached, the oldest row is discarded when a new row is added.\t\t\n\t\t\t\nExample:\n<syntaxhighlight lang=python>op('fifo1').appendRow(['a','b','c'])</syntaxhighlight>",
        "opType": "fifo",
        "opClass": "fifoDAT_Class",
        "opFilter": "False",
        "short": "The FIFO DAT maintains a user-set maximum number of rows in a table.",
        "opCategories": ""
    },
    "fileinDAT": {
        "label": "fileinDAT",
        "members": [
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> files for regular text and <code>.dat</code> files for text in table format.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : Converts the contents of the DAT from regular text to table-formatted text (tab-delimited text, each <tab> is a new column in the table).",
                "type": "TogglePar",
                "name": "converttable",
                "items": []
            },
            {
                "text": "Toggle : Reload the file when this parameter is set to On.",
                "type": "TogglePar",
                "name": "refresh",
                "items": []
            },
            {
                "text": "Pulse : Instantly reload the file from disk.",
                "type": "PulsePar",
                "name": "refreshpulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "File In",
        "long": "The File In DAT reads in <code>.txt</code> text files and <code>.dat</code> table files. It will attempt to read any other file as raw text. The file can be located on disk or on the web. Use <code>http://</code> when specifying a URL.\n    \nSee also [[Table DAT]], [[Text DAT]].",
        "opType": "filein",
        "opClass": "fileinDAT_Class",
        "opFilter": "False",
        "short": "The File In DAT reads in <code>.txt</code> text files and <code>.dat</code> table files.",
        "opCategories": ""
    },
    "fileoutDAT": {
        "label": "fileoutDAT",
        "members": [
            {
                "text": "File : The filesystem path and name of the file to be written.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Int : Using <code>me.par.n</code> (or $N in [[Tscript]]) in the filename (in the File parameter) in conjuction with the N parameter here gives a method of incrementing file names. The N parameter must manually be incremented each time. Exporting a [[Count CHOP]] which increments each time you want to save out a new file is an easy way to do this.",
                "type": "IntPar",
                "name": "n",
                "items": []
            },
            {
                "text": "Pulse : Press this button to write the file once.",
                "type": "PulsePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Toggle : Appends the text into the file instead of overwriting the file contents completely.",
                "type": "TogglePar",
                "name": "append",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "File Out",
        "long": "The File Out DAT allows you to write out DAT contents to a <code>.dat</code> file or a <code>.txt</code> file. A <code>.dat</code> file is one of the [[File Types]] of TouchDesigner that is used to hold the arrays of the [[Table DAT]].\t\n\t\t\nWhen the File Out DAT has 0 inputs, it can be triggered to send text by using the <code>send</code> command.\t\t\n\t\t\nIf 'Append' is off, a new file is written every time, if 'Append' is on, the file is appended to, and the file handle remains open.",
        "opType": "fileout",
        "opClass": "fileoutDAT_Class",
        "opFilter": "True",
        "short": "The File Out DAT allows you to write out DAT contents to a <code>.dat</code> file or a <code>.txt</code> file.",
        "opCategories": ""
    },
    "folderDAT": {
        "label": "folderDAT",
        "members": [
            {
                "text": "Toggle : When off, the DAT outputs a single-row table with only the headings, useful when dormant or when sending the DAT to a [[Replicator COMP]].",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Folder : The folder in the filesystem whose contents will be displayed in the DAT list.",
                "type": "FolderPar",
                "name": "rootfolder",
                "items": []
            },
            {
                "text": "Toggle : When on, it monitors the specified folder(s) of the filesystem.",
                "type": "TogglePar",
                "name": "refresh",
                "items": []
            },
            {
                "text": "Pulse : The pulse button reads the folder contents once.",
                "type": "PulsePar",
                "name": "refreshpulse",
                "items": []
            },
            {
                "text": "Toggle : When on, the update happens asynchronously from the main thread so it doesn't make TouchDesigner drop frames or pause. As a result, the Folder DAT way not update its data within the next frame after the change on disk.",
                "type": "TogglePar",
                "name": "async",
                "items": []
            },
            {
                "text": "Menu : Select whether to include the filename extension or not.",
                "type": "MenuPar",
                "name": "nameformat",
                "items": []
            },
            {
                "text": "Menu : The format used to display the item's dates in the table.",
                "type": "MenuPar",
                "name": "dateformat",
                "items": []
            },
            {
                "text": "Menu : The types of contents to display.",
                "type": "MenuPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Str : Use [[Pattern Matching]] to specify which folders are included.  Matches the folder path.  Delimiters used are spaces and commas.  To match spaces, enclose the entire search term in double quotes.",
                "type": "StrPar",
                "name": "folders",
                "items": []
            },
            {
                "text": "Str : Use [[Pattern Matching]] to specify which names are included.  Delimiters used are spaces and commas.  To match spaces, enclose the entire search term in double quotes.",
                "type": "StrPar",
                "name": "names",
                "items": []
            },
            {
                "text": "Toggle : Includes all file extensions.",
                "type": "TogglePar",
                "name": "allextensions",
                "items": []
            },
            {
                "text": "Toggle : Includes image contents that are supported by TouchDesigner. See supported [[File Types]].",
                "type": "TogglePar",
                "name": "imageextensions",
                "items": []
            },
            {
                "text": "Toggle : Includes movie contents that are supported by TouchDesigner. See supported [[File Types]].",
                "type": "TogglePar",
                "name": "movieextensions",
                "items": []
            },
            {
                "text": "Toggle : Includes audio contents that are supported by TouchDesigner. See supported [[File Types]].",
                "type": "TogglePar",
                "name": "audioextensions",
                "items": []
            },
            {
                "text": "Str : Use [[Pattern Matching]] to specify which extensions are included. Extensions listed here should not include the period. E.g *txt, not *.txt.",
                "type": "StrPar",
                "name": "extensions",
                "items": []
            },
            {
                "text": "Toggle : Includes the subfolders from the root folder specified.",
                "type": "TogglePar",
                "name": "subfolders",
                "items": []
            },
            {
                "text": "Int : Set a minmum depth for the subfolders the Folder DAT should recursively search through.",
                "type": "IntPar",
                "name": "mindepth",
                "items": []
            },
            {
                "text": "Toggle : Turns on the Maximum Depth parameter to limit searching through subfolders. Turning this toggle off will search through all subtrees.",
                "type": "TogglePar",
                "name": "limitdepth",
                "items": []
            },
            {
                "text": "Int : Set the maximum depth for the subfolders the Folder DAT should recursively search through.",
                "type": "IntPar",
                "name": "maxdepth",
                "items": []
            },
            {
                "text": "Toggle : The name of the folder or file. In the case of a file this includes the extension. ie. <code>myfile.txt</code>",
                "type": "TogglePar",
                "name": "namecol",
                "items": []
            },
            {
                "text": "Toggle : The name of the folder or file. In the case of a file this form does not includes the extension. ie. <code>myfile</code>",
                "type": "TogglePar",
                "name": "basenamecol",
                "items": []
            },
            {
                "text": "Toggle : The file extension of the file, blank for folders. ie. <code>txt</code>",
                "type": "TogglePar",
                "name": "extensioncol",
                "items": []
            },
            {
                "text": "Toggle : The type of file as reported by the operating system.",
                "type": "TogglePar",
                "name": "typecol",
                "items": []
            },
            {
                "text": "Toggle : The size of the file in Bytes. Folders do not report any size.",
                "type": "TogglePar",
                "name": "sizecol",
                "items": []
            },
            {
                "text": "Toggle : How many folders deep the item is found from the Root Folder. Items on the Root Folder level have a depth of 0.",
                "type": "TogglePar",
                "name": "depthcol",
                "items": []
            },
            {
                "text": "Toggle : The path of the folder, or in the case of a file, the path of the folder the file is found in.",
                "type": "TogglePar",
                "name": "foldercol",
                "items": []
            },
            {
                "text": "Toggle : The full path to the folder or file.",
                "type": "TogglePar",
                "name": "pathcol",
                "items": []
            },
            {
                "text": "Toggle : The relative path to the folder or file from the Root Folder.",
                "type": "TogglePar",
                "name": "relpathcol",
                "items": []
            },
            {
                "text": "Toggle : The date of creation.",
                "type": "TogglePar",
                "name": "datecreatedcol",
                "items": []
            },
            {
                "text": "Toggle : The date of most recent modification.",
                "type": "TogglePar",
                "name": "datemodifiedcol",
                "items": []
            },
            {
                "text": "Toggle : The date of most recent access or opening.",
                "type": "TogglePar",
                "name": "dateaccessedcol",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Folder",
        "long": "The Folder DAT lists the files and subfolders found in a file system folder and monitors any changes.\t\t\n\t\t\t\nFor each item found, a row is created in the table with optional columns for the following information: \t\t\t\n* Name\t\t\t\n* Base Name\t\t\t\n* Extension\t\t\t\n* Type\t\t\t\n* Size\t\t\t\n* Depth\t\t\t\n* Folder\t\t\t\n* Path\t\t\t\n* Relative Path\t\t\t\n* Date Created\t\t\t\n* Date Modified\t\t\t\n* Date Accessed",
        "opType": "folder",
        "opClass": "folderDAT_Class",
        "opFilter": "False",
        "short": "The Folder DAT lists the files and subfolders found in a file system folder and monitors any changes.",
        "opCategories": ""
    },
    "inDAT": {
        "label": "inDAT",
        "members": [
            {
                "text": "Str : Creates a pop-up label when the cursor rolls over this Component input.",
                "type": "StrPar",
                "name": "label",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "In",
        "long": "The In DAT is used to create a DAT input in a Component. Component inputs are positioned alphanumerically on the left side of the Component. Disconnecting an input to an In DAT will still keep the contents instanced to the original input.",
        "opType": "in",
        "opClass": "inDAT_Class",
        "opFilter": "True",
        "short": "The In DAT is used to create a DAT input in a Component.",
        "opCategories": ""
    },
    "indicesDAT": {
        "label": "indicesDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Indices",
        "long": "The Indices DAT creates a series of numbers in a table, ranging between the start and end values.  These values are suitable for display along a graph horizontal or vertical axis.  They are carefully picked to make them all round, nicely spaced, etc.",
        "opType": "indices",
        "opClass": "indicesDAT_Class",
        "opFilter": "False",
        "short": "The Indices DAT creates a series of numbers in a table, ranging between the start and end values."
    },
    "infoDAT": {
        "label": "infoDAT",
        "members": [
            {
                "text": "OP : The [[Network Path|path]] to the operator that the Info DAT is getting information from. You can drag & drop any node onto this path, or type the path directly into the field.",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Toggle : If this option is off, the Info DAT will update automatically when the information changes. If on, the data may or may not be out-of-date, and the Info DAT may require a forced cook to update its contents. This parameter can by useful to prevent unnecessary cooking.",
                "type": "TogglePar",
                "name": "passive",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Info",
        "long": "The Info DAT gives you string information about a node. Only some nodes contain additional string information which can be accessed by the Info DAT.",
        "opType": "info",
        "opClass": "infoDAT_Class",
        "opFilter": "False",
        "short": "The Info DAT gives you string information about a node.",
        "opCategories": ""
    },
    "insertDAT": {
        "label": "insertDAT",
        "members": [
            {
                "text": "Menu : Specify what to insert.",
                "type": "MenuPar",
                "name": "insert",
                "items": []
            },
            {
                "text": "Menu : Specify where to insert.",
                "type": "MenuPar",
                "name": "at",
                "items": []
            },
            {
                "text": "Int : Index to insert the row or column.  You can use local variables <code>$NR</code> and <code>$NC</code> to append at the end of the table.",
                "type": "IntPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Str : Entries for each cell separated by spaces. Put entries that have spaces in quotes, for example <code>Name Species \"Home Planet\"</code> will put <code>Name</code> in the first cell, <code>Species</code> in the second, and <code>Home Planet</code> in the third. Extra entries will be ignored.",
                "type": "StrPar",
                "name": "contents",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Insert",
        "long": "The Insert DAT allows you to insert a row or column into an existing table.  \t\t\n\t\t\t\nYou can add strings that will be put in the new cells, space separated. If you want a cell to include spaces, in the Contents parameter put the cell contents in quotes:  <code>cell1 'cell 2' cell3</code>. Or a list in the parameter expression: <code>['cell1', 'cell 2']</code>\t\t\t\n\t\t\t\nIf the input DAT is not a table, it will be converted to a table.",
        "opType": "insert",
        "opClass": "insertDAT_Class",
        "opFilter": "True",
        "short": "The Insert DAT allows you to insert a row or column into an exiting table.",
        "opCategories": ""
    },
    "jsonDAT": {
        "label": "jsonDAT",
        "members": [
            {
                "text": "Str : A filter string following JSONPath syntax that will be used to filter the input JSON.",
                "type": "StrPar",
                "name": "filter",
                "items": []
            },
            {
                "text": "Menu : Select the output of the JSON DAT.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            },
            {
                "text": "Str : The custom expression to output",
                "type": "StrPar",
                "name": "expression",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the output of the DAT will formatted with indents and newlines.",
                "type": "TogglePar",
                "name": "formatoutput",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the most recent result will be held if the results become empty, in effect only new non-empty results will update the output.",
                "type": "TogglePar",
                "name": "holdlast",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opType": "jsonDAT",
        "opLabel": "JSON",
        "opClass": "jsonDAT_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The JSON DAT converts and filters JSON text using [[JSONPath]] syntax and outputs the filtered results. It eliminates having to code scripts to parse and manipulate JSON, and keeps the data flow procedural.",
        "long": "The JSON DAT converts and filters JSON text using [[JSONPath]] syntax and outputs the filtered results. It eliminates having to code scripts to parse and manipulate JSON, and keeps the data flow procedural.\n    \nIt expects JSON text as input and converts the input to a Python object in the <code>DAT.source</code> member.\n\nIt then filters the JSON down using the [[JSONPath|JSONPath Filter parameter]], and it outputs the resulting data from the DAT as JSON text. \n\nIt also puts the filtered results as <code>DAT.results</code> (a Python list of results) and <code>DAT.result</code> (the first result).\n\nYou can test expressions on <code>DAT.source</code>, <code>DAT.result</code> and <code>DAT.results</code> by setting the Output menu to Expression and using expressions like <code>me.result['city']</code>, which outputs the evaluated expression from the DAT. You can then use that expression as <code>op('json1').result['city']</code> in an expression elsewhere.  <code>DAT.expr</code> is also a member of the JSON DAT, for example, <code>op('json1').expr</code> returns the evaluated expression parameter.\n\n'''Output tables''': The JSON DAT can output a table by setting the Output Format menu to Table. It will do its best to take the result of the JSON Filter and form rows and columns of values and headings in a DAT table. Any cell than can't be expressed as a simple string, integer, float or boolean will be left as the JSON string of the remainder. A cell or range of cells can be further reduced with a [[Select DAT]] and then passed to another JSON DAT which can convert the JSON strings to a table.\n\n'''See also:''' [[JSONPath]], [[OP Snippets]], and the [[TDJSON]] functions for converting and manipulating JSON data.",
        "opCategories": ""
    },
    "keyboardinDAT": {
        "label": "keyboardinDAT",
        "members": [
            {
                "text": "Toggle : Inhibits and allows message to be added to log.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : When on, key events are only detected while in perform mode.",
                "type": "TogglePar",
                "name": "perform",
                "items": []
            },
            {
                "text": "Str : List of keys to allow through the filter. Just put the characters in the list, space-separated. Eg. '1 2 g h' for the 1, 2, g and h keys. Only these keys will be added to the log and generate an event. If blank, no filtering will be done. List of accepted keys: [[Keyboard UI]]",
                "type": "StrPar",
                "name": "keys",
                "items": []
            },
            {
                "text": "Str : List of shortcuts to watch for. See \"Shortcuts\" in the notes for defining shortcuts.",
                "type": "StrPar",
                "name": "shortcuts",
                "items": []
            },
            {
                "text": "PanelCOMP : Optional list of references to panels to detect events from. Events will only be fired when any of the listed panels has focus.",
                "type": "PanelCOMPPar",
                "name": "panels",
                "items": []
            },
            {
                "text": "Toggle : When on, the states of the left and right modifier keys (see Notes) will be added to the table. Switching the state of this parameter will reset the table's contents.",
                "type": "TogglePar",
                "name": "lrmodifiers",
                "items": []
            },
            {
                "text": "DAT : Path to a DAT containing callbacks for each keyboard event received. See keyboardinDAT_Class for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when <span class=\"tipTextDAT\">Execute</span> is set to <span class=\"tipTextDAT\">Specified Operator</span>. This operator is also the path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to <span class=\"tipTextDAT\">Specified Operator</span>.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading.  To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Keyboard In",
        "long": "The Keyboard In DAT lists the most recent key events in its FIFO (first in/first out) table. There is one row for every key press down and every key-up, including Shift, Ctrl and Alt, with distinction between left and right side. For convenience, with each key press, a column indicates if the  Shift, Ctrl and Alt were being held down at the time.\t\t\n\t\t\t\nYou get key presses even of the cursor is outside the TouchDesigner windows, whether they are control panels, Perform Mode or the network editor window. Exceptions: while entering text in the editor window.\t\t\t\n\t\t\t\nYou can set a filter to watch only certain keys. Custom shortcuts can be defined and handled by a [[keyboardinDAT_Class|python callback in the attached script]].",
        "opType": "keyboardin",
        "opClass": "keyboardinDAT_Class",
        "opFilter": "False",
        "short": "The Keyboard In DAT lists the most recent key events in its FIFO (first in/first out) table.",
        "opCategories": ""
    },
    "lookupDAT": {
        "label": "lookupDAT",
        "members": [
            {
                "text": "dropmenu : Select how the index values are interpreted: as values/indices contained in a column or contained in a row.",
                "type": "dropmenuPar",
                "name": "index",
                "items": []
            },
            {
                "text": "dropmenu : When 'Row Values' or 'Col Values' is selected in the Index Parameter, this parameter lets you select how the lookup row or column where the index value searches will be specified.",
                "type": "dropmenuPar",
                "name": "valueloction",
                "items": []
            },
            {
                "text": "string : Specify the name of the lookup row or column.",
                "type": "stringPar",
                "name": "valuename",
                "items": []
            },
            {
                "text": "integer : Specify the index of the lookup row or column.",
                "type": "integerPar",
                "name": "valueindex",
                "items": []
            },
            {
                "text": "toggle : Include the first row or column.",
                "type": "togglePar",
                "name": "includeheader",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opType": "lookupDAT",
        "opLabel": "Lookup",
        "opClass": "lookupDAT_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "short": "The Lookup DAT  outputs values from a lookup Table. The first input is an index into the second input.",
        "long": "The Lookup DAT  outputs values from a lookup Table. The first input is an index into the second input. \n    \nThe Lookup DAT allows you to select rows from its second input by referencing data either via row/column indices or row/column names. The advantage of the Lookup DAT is such that the order the data is selected is independent from the order in the Lookup Table, rather the Index Table dictates the order therefore allowing for reordering of data and selecting rows/columns multiple times.",
        "opCategories": ""
    },
    "mergeDAT": {
        "label": "mergeDAT",
        "members": [
            {
                "text": "DAT : Specifies the path to DATs to be merged. Can be used in conjunction with the operator's wired inputs.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "Menu : Sets how tables are merged together.",
                "type": "MenuPar",
                "name": "how",
                "items": []
            },
            {
                "text": "Toggle : Specifies if you are appending columns and rows by name.",
                "type": "TogglePar",
                "name": "byname",
                "items": []
            },
            {
                "text": "Str : Allows you to separate the cell data with a string when concatenating. The default is a space.",
                "type": "StrPar",
                "name": "spacer",
                "items": []
            },
            {
                "text": "Toggle : If the subsequent tables have rows or columns that are not found in the first table, these will be added to the output.",
                "type": "TogglePar",
                "name": "unmatched",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Merge",
        "long": "The Merged DAT is a multi-input DAT which merges the text or tables from the input DATs together.",
        "opType": "merge",
        "opClass": "mergeDAT_Class",
        "opFilter": "True",
        "short": "The Merged DAT is a multi-input DAT which merges the text or tables from the input DATs together.",
        "opCategories": ""
    },
    "midieventDAT": {
        "label": "midieventDAT",
        "members": [
            {
                "text": "Toggle : Logs MIDI events when turned on.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Toggle : Does not log sense messages when this is turned on.",
                "type": "TogglePar",
                "name": "skipsense",
                "items": []
            },
            {
                "text": "Toggle : Does not report timing messages when this is turned on.",
                "type": "TogglePar",
                "name": "skiptiming",
                "items": []
            },
            {
                "text": "Toggle : Turning this on enables the message filtering parameters below.",
                "type": "TogglePar",
                "name": "filter",
                "items": []
            },
            {
                "text": "Str : Filter by the MIDI message content. Example \"Control Change\"",
                "type": "StrPar",
                "name": "message",
                "items": []
            },
            {
                "text": "Str : Filter by the MIDI message channel.\tChannels range from 1 to 16.",
                "type": "StrPar",
                "name": "channel",
                "items": []
            },
            {
                "text": "Str : Filter by the MIDI message index. Indices range from 1 to 128.",
                "type": "StrPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Str : Filter by the MIDI message value. Values range from 0 to 127.",
                "type": "StrPar",
                "name": "value",
                "items": []
            },
            {
                "text": "Str : Filter by the message direction, \"input\" or \"output\".",
                "type": "StrPar",
                "name": "dir",
                "items": []
            },
            {
                "text": "DAT : Runs this script once for each row added to the table (ie. MIDI event recieved). See [[midieventDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when <span class=\"tipTextDAT\">Execute</span> is set to <span class=\"tipTextDAT\">Specified Operator</span>. This operator is also the path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to <span class=\"tipTextDAT\">Specified Operator</span>.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "MIDI Event",
        "long": "The MIDI Event DAT logs all [[MIDI]] messages coming into or out of TouchDesigner from all MIDI In/Out operators. Note: no messages will be logged if there are no active MIDI In or Out operators set to receive them. It outputs columns in a table format: message, type, channel, index, value.\t\t\n\t\t\t\nThe table is FIFO \"first-in first-out\" and limited to parameter-set number of lines. An optional script may be run for each packet received.\t\t\t\n\t\t\t\nSee also the [[MIDI In DAT]], [[MIDI In Map CHOP]], [[MIDI In CHOP]], [[MIDI Out CHOP]], Tscript <code>midi()</code> Command.",
        "opType": "midievent",
        "opClass": "midieventDAT_Class",
        "opFilter": "False",
        "short": "The MIDI Event DAT logs all MIDI messages coming into TouchDesigner from all MIDI devices.",
        "opCategories": ""
    },
    "midiinDAT": {
        "label": "midiinDAT",
        "members": [
            {
                "text": "Toggle : Logs MIDI events when turned on.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "DAT : Path to the MIDI device [[Table DAT]]",
                "type": "DATPar",
                "name": "device",
                "items": []
            },
            {
                "text": "Str : Path to the MIDI device [[Table DAT]]",
                "type": "StrPar",
                "name": "id",
                "items": []
            },
            {
                "text": "Toggle : Does not log sense messages when this is turned on.",
                "type": "TogglePar",
                "name": "skipsense",
                "items": []
            },
            {
                "text": "Toggle : Does not report timing messages when this is turned on.",
                "type": "TogglePar",
                "name": "skiptiming",
                "items": []
            },
            {
                "text": "Toggle : Turning this on enables the message filtering parameters below.",
                "type": "TogglePar",
                "name": "filter",
                "items": []
            },
            {
                "text": "Str : Filter by the MIDI message content. Example \"Control Change\"",
                "type": "StrPar",
                "name": "message",
                "items": []
            },
            {
                "text": "Str : Filter by the MIDI message channel.\tChannels range from 1 to 16.",
                "type": "StrPar",
                "name": "channel",
                "items": []
            },
            {
                "text": "Str : Filter by the MIDI message index. Indices range from 1 to 128.",
                "type": "StrPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Str : Filter by the MIDI message value. Values range from 0 to 127.",
                "type": "StrPar",
                "name": "value",
                "items": []
            },
            {
                "text": "DAT : Runs this script once for each row added to the table (ie. each MIDI event received). See [[midiinDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when <span class=\"tipTextDAT\">Execute from</span> is set to <span class=\"tipTextDAT\">Specified Operator</span>. This operator is also the path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to <span class=\"tipTextDAT\">Specified Operator</span>.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "MIDI In",
        "long": "The MIDI In DAT logs all [[MIDI]] messages coming into TouchDesigner from a specified MIDI device. It outputs columns in a table format - message, type, channel, index, value. \t\t\n\t\t\t\nHowever general setup is simpler. Once you have MIDI set up via the Dialogs -> MIDI Device Mapper, TouchDesigner is ready to receive MIDI via Select CHOPs that point to <code>/local/maps/map1</code> for device 1, etc.\t\t\t\n\t\t\t\nSee also the [[MIDI Event DAT]], [[MIDI In Map CHOP]], [[MIDI In CHOP]], [[MIDI Out CHOP]], Tscript <code>midi()</code> Command, [[MIDI Device Mapper Dialog]].",
        "opType": "midiin",
        "opClass": "midiinDAT_Class",
        "opFilter": "False",
        "short": "The MIDI In DAT logs all MIDI messages coming into TouchDesigner from a specified MIDI device.",
        "opCategories": ""
    },
    "monitorsDAT": {
        "label": "monitorsDAT",
        "members": [
            {
                "text": "DAT : Runs this script once for each change to the table (ie. monitor state change). See [[monitorsDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Toggle : While on, an additional \"bounds\" row will be added to the table. The dimensions correspond to a bounding box around all the detected monitors. In this row, \"primary\" refers to the index in the table of the primary monitor.",
                "type": "TogglePar",
                "name": "bounds",
                "items": []
            },
            {
                "text": "Menu : Specify which monitors to report information about.",
                "type": "MenuPar",
                "name": "monitors",
                "items": []
            },
            {
                "text": "Menu : Specify if the numbers are reported in Native Pixel units or DPI Scaled units.",
                "type": "MenuPar",
                "name": "units",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Monitors",
        "long": "The Monitors DAT is a table of data about all currently detected monitors with information on the resolution, screen positioning, monitor name and description, GPU, and a flag indicating whether it is a primary monitor or not.\t\t\n\t\t\t\nYou can also set it to display the overall bounds of all the detected monitors.\t\t\t\n\t\t\t\nIt runs a callback script when a change in the monitors has been detected. These changes can be that a monitor was plugged in, a monitor was unplugged, the resolution of a monitor has changed, or the primary monitor has changed.\t\t\t\n\t\t\t\nThe Monitor DAT returns top/bottom values in lower-left origin coordinates, (0,0) is the lower-left corner of the monitor.",
        "opType": "monitors",
        "opClass": "monitorsDAT_Class",
        "opFilter": "False",
        "short": "The Monitors DAT is a table of data about all currently detected monitors with information on the resolution, screen positioning, monitor name and description, GPU, and a flag indicating whether it is a primary monitor or not.",
        "opCategories": ""
    },
    "mqttclientDAT": {
        "label": "mqttclientDAT",
        "members": [
            {
                "text": "Toggle : Enable the connection.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The address of the broker to connect to. The address should take the form <code><protocol>://<host>:<port></code>.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Toggle : Allows naming the client with parameter <code>User Client ID</code>, otherwise automatically and uniquely generated for each connection.",
                "type": "TogglePar",
                "name": "specifyid",
                "items": []
            },
            {
                "text": "Str : Client name when <code>Specify ID</code> enabled.",
                "type": "StrPar",
                "name": "usercid",
                "items": []
            },
            {
                "text": "Int : Specifies in seconds, the maximum time to expect without communication. If no data is sent during this time, a lightweight ping message is sent to the server instead. Can be set to 0 to avoid pings.",
                "type": "IntPar",
                "name": "keepalive",
                "items": []
            },
            {
                "text": "Int : Controls how many messages can be in-flight simultaneously.",
                "type": "IntPar",
                "name": "maxinflight",
                "items": []
            },
            {
                "text": "Toggle : If <code>Specify ID</code> is selected, the server will preserve any state information associated with the connection of that ID, such as subscriptions, delivery attempts, etc.",
                "type": "TogglePar",
                "name": "cleansession",
                "items": []
            },
            {
                "text": "Toggle : Enables TLS (transport layer security) certificate verification against the server (ie. broker).",
                "type": "TogglePar",
                "name": "verifycert",
                "items": []
            },
            {
                "text": "String : Specify the username for authentication if the server requires it. MQTT servers that support the MQTT v3.1 protocol provide authentication and authorization via username and password.",
                "type": "StringPar",
                "name": "username",
                "items": []
            },
            {
                "text": "String : Specify the password for authentication if the server requires it. MQTT servers that support the MQTT v3.1 protocol provide authentication and authorization via username and password.",
                "type": "StringPar",
                "name": "password",
                "items": []
            },
            {
                "text": "Pulse : Will attempt to reconnect to the MQTT broker.",
                "type": "PulsePar",
                "name": "reconnect",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT contains functions that are called when connections are made, lost or published data arrives. See [[mqttclientDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when <span class=\"tipTextDAT\">Execute From</span> is set to <span class=\"tipTextDAT\">Specified Operator</span>. This operator is also the path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to <span class=\"tipTextDAT\">Specified Operator</span>.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "MQTT Client",
        "long": "The MQTT Client DAT receives and sends data from/to [[MQTT]] devices via MQTT servers (broker). TouchDesigner can act as a client and another computer needs to act as a MQTT Server.  Once a client establishes a connection with a server, it can do two things: \t\t\n# Send a message to the server to express interest in any data that has a specific \"topic\" string. This is called \"subscribing\". Then the MQTT Client DAT will receive all messages that the server gets with that topic. \t\t\t\n# Inform the server that it will send messages to the server with a certain topic string, and then send messages with that topic. The messages then get forward to any client that has expressed interest in that topic.\t\t\t\n\t\t\t\nSee also [[MQTT]], [[TCP/IP DAT]].",
        "opType": "mqttclient",
        "opClass": "mqttclientDAT_Class",
        "opFilter": "False",
        "short": "The MQTT Client DAT receives and sends data from/to [[MQTT]] devices via MQTT servers (broker).",
        "opCategories": ""
    },
    "multitouchinDAT": {
        "label": "multitouchinDAT",
        "members": [
            {
                "text": "Toggle : Registers event when Active is On.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Sets how the output is displayed in the table.",
                "type": "MenuPar",
                "name": "outputtype",
                "items": []
            },
            {
                "text": "PanelCOMP : The [[Panel Component]] to capture the touch events from.",
                "type": "PanelCOMPPar",
                "name": "panel",
                "items": []
            },
            {
                "text": "Toggle : Reorder the touch ids so only the ones within the specified panel are counted.",
                "type": "TogglePar",
                "name": "relativeid",
                "items": []
            },
            {
                "text": "Toggle : Output position and normalized coordinates relative to lower left corner of the specified panel.",
                "type": "TogglePar",
                "name": "relativepos",
                "items": []
            },
            {
                "text": "Toggle : When on, the mouse add a touch event when clicked. This event always shares ID 1 with the first touch. Using mouse and multitouch at the same time may result in unexpected behaviours.",
                "type": "TogglePar",
                "name": "mouse",
                "items": []
            },
            {
                "text": "Float : A new message will not be added if a finger has moved less than this number of units. The units are determined by the input device, not necessarily the resolution of the screen that it is associated with.",
                "type": "FloatPar",
                "name": "posthresh",
                "items": []
            },
            {
                "text": "Float : Some touch devices have a width and height of a press, representing pressure of amount of finger contact. This is a minimum threshold below which no events are recognized.",
                "type": "FloatPar",
                "name": "contactthresh",
                "items": []
            },
            {
                "text": "Int : The minimum number of rows always displayed in the table.",
                "type": "IntPar",
                "name": "minrows",
                "items": []
            },
            {
                "text": "Float : The maximum time allowed between clicks to be registered as a 'double-click'.",
                "type": "FloatPar",
                "name": "doubleclickthresh",
                "items": []
            },
            {
                "text": "DAT : Path to a DAT containing callbacks.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to ''Specified Operator''.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a script command, here is an example: <code>opparm -c /serial1 clear</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Multi Touch In",
        "long": "The Multi Touch In DAT is used for receiving messages and events from the Windows 7+ standard multi-touch API. It captures all the messages, where each new message changes the table it outputs. When a messages is added to the DAT, any script can be called pointing to the new message. The Multi Touch In DAT is most frequently sent to the [[Render Pick DAT]].\t\t\n\t\t\t\nIt can output either of two table formats: (1) Raw Events as a FIFO (first in - first out) list, or (2) ID Table, which is the events processed into a more usable one-row-per-finger table.\t\t\t\n\t\t\t\nThe Raw Events format creates a FIFO-type DAT (see also [[FIFO DAT]]) which, for each multi-touch event, has a row added to the bottom of the table while at the same time a row at the top is deleted.\t\t\t\n\t\t\t\nNote: To operate panel gadgets with multi-touch screens that send events through the Windows 7, 8 or 10 event stream, multi-touch works without requiring DATs. You need to use the DAT when using multiple fingers on one panel, like in a container displaying a 3D render whose objects you want to pick.\t\t\t\n\t\t\t\nThe ID table format includes the columns:\t\t\t\n* <code>id</code> - every finger press increases the id by 1\t\t\t\n* <code>sn</code> - an ongoing count of each finger press.\t\t\t\n* <code>select</code> - when 1, this row represents a finger is down.\t\t\t\n* <code>downf</code> - the absolute frame number when the finger press occurred.\t\t\t\n* <code>upf</code> - the absolute frame number that the finger press ended\t\t\t\n* <code>x</code>, <code>y</code> - the position, in pixels in the horizontal and vertical directions. <code>NOTE</code>: The <code>x</code> and <code>y</code> values are expressed in screen pixels, not panel width/height pixels. For example, the top-right corner of a panel will be different if the panel is scaled within another panel, window or network viewer. It is better to use <code>u</code> and <code>v</code>, and scale them by the panel Width and Height.\t\t\t\n* <code>u</code>, <code>v</code> - the position, 0 to 1 in the horizontal and vertical directions\t\t\t\n* <code>downu</code>, <code>downv</code> - the position, 0 to 1 in the horizontal and vertical directions when the touch first occured (ie. initial touch down location).\t\t\t\n<code>contactx</code>, <code>contacty</code> - the width of the contact area.\t\t\t\n<code>contactu</code>, <code>contactv</code> - the height of the contact area.\t\t\t\n** <code>monitor</code> - monitor number, starting with 0\t\t\t\n* <code>clicktime</code> - like <code>downf</code>, in seconds\t\t\t\n* <code>elapsedtime</code> - the number of seconds that finger has been down.\t\t\t\n* <code>changedtime</code> - the time since the finger press that the most recent u or v value changed.\t\t\t\n* <code>dclick</code> - double-tap occurred\t\t\t\n* <code>aux</code> - user supplied data via the [[PanelCOMP_Class]] method <code>interactTouch()</code>.  When the event is triggered by the mouse via the Include Mouse option, <code>aux</code> will include the mouse buttons used (<code>1</code> for left, <code>2</code> for middle, <code>4</code> for right, can be tested bitwise).\t\t\n\t\t\t\nYou can use the attached callback DAT (named <code>mtouchin1_callbacks</code>) to react to multi-touch events. This is suitable for 2D interfaces that do not require a [[Render Pick DAT]].\t\t\t\n\t\t\t\nSee the [[Palette:multiTouch]] example in the [[Palette]] under Tools.\t\t\t\n\t\t\t\nSee also the [[MultiTouch]] page.",
        "opType": "mtouchin",
        "opClass": "multitouchinDAT_Class",
        "opFilter": "False",
        "short": "The Multi Touch In DAT is used for receiving messages and events from the Windows 7+ standard multi-touch API.",
        "opCategories": ""
    },
    "ndiDAT": {
        "label": "ndiDAT",
        "members": [
            {
                "text": "datref : Script callbacks for events relating to NDI sources and streams.",
                "type": "datrefPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "string : By default NDI searches using mDNS, which is usually limited to locate networks. To find sources available on machines not reachable by mDNS, this parameter can be filled with a space-separated list of one or more IP address.",
                "type": "stringPar",
                "name": "extraips",
                "items": []
            },
            {
                "text": "float : Persistence affects how long an entry in the DAT stays present even after the source has disappeared. This allows for a source to disappear for a bit and then reappear without being removed from the list.",
                "type": "floatPar",
                "name": "persistence",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opType": "ndiDAT",
        "opLabel": "NDI",
        "opClass": "ndiDAT_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The NDI DAT lists in a table and monitors all NDI sources and streams found on the network. Callbacks are provided to trigger actions when sources are added/removed/changed and when streams start/stop.",
        "long": "The NDI DAT lists in a table and monitors all NDI sources and streams found on the network. Callbacks are provided to trigger actions when sources are added/removed/changed and when streams start/stop.\n    \nSee [[NDI]], [[NDI In TOP]] and [[NDI Out TOP]].",
        "opCategories": ""
    },
    "nullDAT": {
        "label": "nullDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Null",
        "long": "The Null DAT has no effect on the data. It is an instance of the DAT connected to its input. The Null DAT is often used when making reference to a DAT network, allowing new DATs to be added to the network (upstream) without the need to update the reference.",
        "opType": "null",
        "opClass": "nullDAT_Class",
        "opFilter": "True",
        "short": "The Null DAT has no effect on the data. It is an instance of the DAT connected to its input.",
        "opCategories": ""
    },
    "opexecuteDAT": {
        "label": "opexecuteDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT will respond to the OP that is referenced.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : ([[Operator Language|Tscript]] only) Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to ''Specified Operator''.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "OP : Specify which operators to monitor to trigger the scripts.",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Toggle : The <code>onPreCook()</code> method is triggered before the operator is cooked.",
                "type": "TogglePar",
                "name": "precook",
                "items": []
            },
            {
                "text": "Toggle : The <code>onPostCook()</code> method is triggered after the operator is cooked.",
                "type": "TogglePar",
                "name": "postcook",
                "items": []
            },
            {
                "text": "Toggle : The <code>onDestroy()</code> method is triggered when the operator is deleted.",
                "type": "TogglePar",
                "name": "opdelete",
                "items": []
            },
            {
                "text": "Toggle : The <code>onFlagChange()</code> method is triggered when one of the operator's [[Flags]] changes state. This includes all the flags in the Common Flags list of an [[OP_Class#Common_Flags|OP_Class]], plus all the python accessible flags listed in [[COMP_Class#Common_Flags|COMP_Class]], [[SOP_Class#Common_Flags|SOP_Class]], [[CHOP_Class#Common_Flags|CHOP_Class]].",
                "type": "TogglePar",
                "name": "flagchange",
                "items": []
            },
            {
                "text": "Toggle : The <code>onWireChange()</code> method is triggered when the operator's inputs are rewired (connected, disconnected, swapped).",
                "type": "TogglePar",
                "name": "wirechange",
                "items": []
            },
            {
                "text": "Toggle : The <code>onNameChange()</code> method is triggered when the name of the operator is changed.",
                "type": "TogglePar",
                "name": "namechange",
                "items": []
            },
            {
                "text": "Toggle : The <code>onPathChange()</code> method is triggered when the path of the operator is changed.",
                "type": "TogglePar",
                "name": "pathchange",
                "items": []
            },
            {
                "text": "Toggle : The <code>onUIChange()</code> method is triggered when operator is resized or moved in the network editor.",
                "type": "TogglePar",
                "name": "uichange",
                "items": []
            },
            {
                "text": "Toggle : The onNumChildrenChange() method is triggered if the number of children an operator has changes. Only works with [[Component]] type operators.",
                "type": "TogglePar",
                "name": "numchildrenchange",
                "items": []
            },
            {
                "text": "Toggle : The <code>onChildRename()</code> method is triggered if a child of the operator is renamed.",
                "type": "TogglePar",
                "name": "childrename",
                "items": []
            },
            {
                "text": "Toggle : The <code>onCurrentChildChange()</code> method is triggered if a child of the operator is made current in a network. Only works with Component type operators.",
                "type": "TogglePar",
                "name": "currentchildchange",
                "items": []
            },
            {
                "text": "Toggle : The <code>onExtensionChange()</code> method is triggered when an extension of the operator is changed.",
                "type": "TogglePar",
                "name": "extensionchange",
                "items": []
            },
            {
                "text": "Pulse : Clicking this opens a text editor to edit text in the DAT.",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> and <code>.dat</code> files.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : When On, loads the file from disk into the DAT when the projects starts.  A filename must be specified.  Turning on the option will load the file from disk immediately.  If the file does not exist, it will be created the first time the DAT is updated.  The file is monitored so that any changes made to the file will update the DAT, and any changes made to the DAT will be written to the file right away.  If the file is removed, the DAT will retain its current contents.",
                "type": "TogglePar",
                "name": "syncfile",
                "items": []
            },
            {
                "text": "Toggle : When On, reloads the file from disk into the DAT when the projects starts.",
                "type": "TogglePar",
                "name": "loadonstart",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "loadonstartpulse",
                "items": []
            },
            {
                "text": "Toggle : When On, writes the contents of the DAT out to the file on disk when the project is saved.",
                "type": "TogglePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Pulse : Instantly write the file to disk.",
                "type": "PulsePar",
                "name": "writepulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "OP Execute",
        "long": "The OP Execute DAT runs a script when the state of an [[Operator|operator]] changes. \t\t\n\t\t\t\nOP Execute DATs are created with default python method placeholders. For each monitored condition in the parameters, there is a [[opexecuteDAT_Class|matching python method]] in the DAT. When a condition is turned on in the parameters, each time that condition is satisfied the corresponding python method will be executed.",
        "opType": "opexec",
        "opClass": "opexecuteDAT_Class",
        "opFilter": "False",
        "short": "The OP Execute DAT runs a script when the state of an [[Operator|operator]] changes.",
        "opCategories": ""
    },
    "opfindDAT": {
        "label": "opfindDAT",
        "members": [
            {
                "text": "Menu : Determines when to cook the DAT.",
                "type": "MenuPar",
                "name": "activecook",
                "items": []
            },
            {
                "text": "Pulse : Manually force the OP Find DAT to update.",
                "type": "PulsePar",
                "name": "cookpulse",
                "items": []
            },
            {
                "text": "COMP : The path to the component where the search starts from.",
                "type": "COMPPar",
                "name": "component",
                "items": []
            },
            {
                "text": "Toggle : Include the component the search starts from in the search itself.",
                "type": "TogglePar",
                "name": "includecomponent",
                "items": []
            },
            {
                "text": "Toggle : Any components wired to the starting component are included in the search.",
                "type": "TogglePar",
                "name": "includewired",
                "items": []
            },
            {
                "text": "Int : Set a minmum depth for the sub-components the OP Find DAT should recursively search through.",
                "type": "IntPar",
                "name": "mindepth",
                "items": []
            },
            {
                "text": "Toggle : Turns on the Maximum Depth parameter to limit searching through sub-components. Turning this toggle off will search through all sub-networks.",
                "type": "TogglePar",
                "name": "limitmaxdepth",
                "items": []
            },
            {
                "text": "Int : Set the maximum depth for the sub-components the OP Find DAT should recursively search through.",
                "type": "IntPar",
                "name": "maxdepth",
                "items": []
            },
            {
                "text": "Toggle : Limit the total number of operators iterated in the search.",
                "type": "TogglePar",
                "name": "limitmaxops",
                "items": []
            },
            {
                "text": "Int : Number of operators the search is limited to.",
                "type": "IntPar",
                "name": "maxops",
                "items": []
            },
            {
                "text": "Toggle : Include Object COMPs, like Geo COMP, in the search.",
                "type": "TogglePar",
                "name": "objects",
                "items": []
            },
            {
                "text": "Toggle : Include Panel COMPs, like Container COMP, in the search.",
                "type": "TogglePar",
                "name": "panels",
                "items": []
            },
            {
                "text": "Toggle : Include other type COMPs, like Base COMP, in the search.",
                "type": "TogglePar",
                "name": "other",
                "items": []
            },
            {
                "text": "Toggle : Include DAT family operators in the search.",
                "type": "TogglePar",
                "name": "tops",
                "items": []
            },
            {
                "text": "Toggle : Include CHOP family operators in the search.",
                "type": "TogglePar",
                "name": "chops",
                "items": []
            },
            {
                "text": "Toggle : Include SOP family operators in the search.",
                "type": "TogglePar",
                "name": "sops",
                "items": []
            },
            {
                "text": "Toggle : Include MAT family operators in the search.",
                "type": "TogglePar",
                "name": "mats",
                "items": []
            },
            {
                "text": "Toggle : Include DAT family operators in the search.",
                "type": "TogglePar",
                "name": "dats",
                "items": []
            },
            {
                "text": "Toggle : Use case sensitivity in all pattern matching below.",
                "type": "TogglePar",
                "name": "casesensitive",
                "items": []
            },
            {
                "text": "Menu : Combine 'All', 'Any' or 'Custom' of the filters below to get a match. 'Custom' allows for specifying a subselection of filters with 'or' and 'and' keywords.",
                "type": "MenuPar",
                "name": "combinefilters",
                "items": []
            },
            {
                "text": "Str : Specify which filters to combine in the search.",
                "type": "StrPar",
                "name": "customcombine",
                "items": []
            },
            {
                "text": "Str : Use the operator's names like 'wave1', 'wave2', etc.",
                "type": "StrPar",
                "name": "namefilter",
                "items": []
            },
            {
                "text": "Str : Use names like <code>waveCHOP</code> and <code>panelexecuteDAT</code>. Look at the column Type to see the syntax.",
                "type": "StrPar",
                "name": "typefilter",
                "items": []
            },
            {
                "text": "Str : Only match operators that include the here specified Parent Shortcut.",
                "type": "StrPar",
                "name": "parentshortcutfilter",
                "items": []
            },
            {
                "text": "Str : Only match operators that include the here specified OP Shortcut.",
                "type": "StrPar",
                "name": "opshortcutfilter",
                "items": []
            },
            {
                "text": "Str : Specify a path that the operator should be located in.",
                "type": "StrPar",
                "name": "pathfilter",
                "items": []
            },
            {
                "text": "Str : Specify a relative parent path that operators should be located in. This is a filter option on the <code>parentPath</code> column of this DAT that can be enabled by toggling the <code>Parent Path</code> parameter on this DAT's <code>Columns</code> page.",
                "type": "StrPar",
                "name": "parentfilter",
                "items": []
            },
            {
                "text": "Str : Specify a relative path that should be excluded from the search.",
                "type": "StrPar",
                "name": "excludefilter",
                "items": []
            },
            {
                "text": "Str : ",
                "type": "StrPar",
                "name": "wirepathfilter",
                "items": []
            },
            {
                "text": "Str : Only match operators that include the here specified comment string.",
                "type": "StrPar",
                "name": "commentfilter",
                "items": []
            },
            {
                "text": "Str : Only match operators that match the here specified tags. Multiple tags can be searched for as a space seperated list.",
                "type": "StrPar",
                "name": "tagsfilter",
                "items": []
            },
            {
                "text": "Str : Only include operators that - in the case of being from the DAT family - match specified string in their content.",
                "type": "StrPar",
                "name": "textfilter",
                "items": []
            },
            {
                "text": "Str : Only match operators with specified parameter name.  Parameters must match ALL of name, value and expression to be included.",
                "type": "StrPar",
                "name": "parnamefilter",
                "items": []
            },
            {
                "text": "Str : Only include operators that match specified parameter value. Parameters must match ALL of name, value and expression to be included.",
                "type": "StrPar",
                "name": "parvaluefilter",
                "items": []
            },
            {
                "text": "Str : Only include operators that match specified parameter expression string. Parameters must match ALL of name, value and expression to be included.",
                "type": "StrPar",
                "name": "parexpressionfilter",
                "items": []
            },
            {
                "text": "Toggle : Only match with parameters that are non-default values.",
                "type": "TogglePar",
                "name": "parnondefaultonly",
                "items": []
            },
            {
                "text": "Toggle : Use only when expecting column headers to be named with legacy titles.",
                "type": "TogglePar",
                "name": "legacycols",
                "items": []
            },
            {
                "text": "Toggle : An integer that uniquely defines the node in this process. It's the same number for the duration of the process, but may be different when you run the process again.",
                "type": "TogglePar",
                "name": "idcol",
                "items": []
            },
            {
                "text": "Toggle : Inlcude the name of the operator in the result table.",
                "type": "TogglePar",
                "name": "namecol",
                "items": []
            },
            {
                "text": "Toggle : Include the operator type in the result table. For example <code>rampTOP</code>.",
                "type": "TogglePar",
                "name": "typecol",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's Parent Shortcut in the result table.",
                "type": "TogglePar",
                "name": "parentshortcutcol",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's OP Shortcut in the result table.",
                "type": "TogglePar",
                "name": "opshortcutcol",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's path in the result table.",
                "type": "TogglePar",
                "name": "pathcol",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's, relative to the search root, path in the result table.",
                "type": "TogglePar",
                "name": "relpathcol",
                "items": []
            },
            {
                "text": "Toggle : Include the parent path.",
                "type": "TogglePar",
                "name": "parentpath",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's wire path in the result table.",
                "type": "TogglePar",
                "name": "wirepathcol",
                "items": []
            },
            {
                "text": "Toggle : Include a column showing the relative depth to the root path of the found operator.",
                "type": "TogglePar",
                "name": "depthcol",
                "items": []
            },
            {
                "text": "Toggle : Include cook-time of found operators.",
                "type": "TogglePar",
                "name": "cooktimescol",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's tags.",
                "type": "TogglePar",
                "name": "tagscol",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's name, id, isCOMP, node position, node size and dock id in the result table.",
                "type": "TogglePar",
                "name": "genprop",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's CPU cooktime in the result table.",
                "type": "TogglePar",
                "name": "cputime",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's GPU cooktime in the result table.",
                "type": "TogglePar",
                "name": "gputime",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's CPU memory in the result table.",
                "type": "TogglePar",
                "name": "cpumem",
                "items": []
            },
            {
                "text": "Toggle : Include the operator's GPU memory in the result table.",
                "type": "TogglePar",
                "name": "gpumem",
                "items": []
            },
            {
                "text": "Toggle : Include the children of the operator in the result table.",
                "type": "TogglePar",
                "name": "children",
                "items": []
            },
            {
                "text": "DAT : Path to a DAT containing callbacks for each event received. See [[opfindDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Toggle : For boolean logic values, the value will be '1' or '0'. When this parameter is Off, they will be 'True\" or 'False'.",
                "type": "TogglePar",
                "name": "convertbool",
                "items": []
            },
            {
                "text": "Toggle : For 'None' values, the value will be converted to Empty.",
                "type": "TogglePar",
                "name": "convertnone",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "OP Find",
        "long": "The OP Find DAT traverses the component hierarchy starting at one component and looking at all nodes within that component, and outputs a table with one row per node that matches criteria the user chooses. For example, the criteria could be all Ramp TOPs, or all nodes whose name starts with \u201c<code>wave</code>\u201d, or all nodes with the Clone parameter set to \u201c<code>master1</code>\u201d, or all Geometry components with a tag called \u201c<code>emitter</code>\u201d.\t\t\n\t\t\t\nThe criteria can limited to include only nodes of certain families, or certain operator types. It can filter on matching its path, certain parameters containing certain values (both constant and expressions), comments, tags, or the content of a DAT containing certain strings.\t\t\t\n\t\t\t\nYou can also cause the DAT to only look to some depth of the hierarchy from the specified component, such as 2 levels down, or limitless.\t\t\t\n\t\t\t\nCriteria can be case-sensitive or not, but case-sensitive On or Off applies to all criteria in the OP Find DAT.\t\t\t\n\t\t\t\nFurthermore you can exclude some nodes using more specialized criteria by returning a True of False in a callback contained in the attached callback DAT.\t\t\t\n\t\t\t\nWith the Combine Filters Menu (Any or All, Default is All), you can do an \"or\" or \"and\" on the pattern matching criterea.  \t\t\t\n\t\t\t\nIt also takes an optional DAT containing a list of operators (eg, another OP Find DAT) which can be used to chain filters.\t\t\t\n\t\t\t\n=== Output Columns ===\t\t\t\nThere is a variety of columns that you can select from including <code>name</code>, <code>id</code>, <code>paths</code>, <code>type</code> and <code>tags</code>.  (<code>id</code> is a member of the operator, which is an integer unique to the node, and doesn't change during the running of the TouchDesigner process.)\t\t\t\n\t\t\t\nYou can also output custom columns by defining the column names in the callback DAT, and filling in the column cells via another function in the callback DAT. For example, you can output a custom column which is the <code>tx</code> parameter value of the node.\t\t\t\n\t\t\t\nYou can control when the OP Find DAT cooks. Normally it cooks whenever any of the nodes in the specified hierarchy changes. Using the Active Cook menu parameter, you can also force-cook it every frame, or turn off cooking entirely.  You can also click the Pulse parameter on Active Cook in order to force-cook it once, or do the equivalent using the node.cookpulse.pulse() python call.\t\t\t\n\t\t\t\nInstead of being give the path to a component to start at, the OP Find DAT can take an input DAT containing a pre-generated list of paths to nodes to start from, and merge the results of each input line together in the output. To use this, the input DAT should contain the node \u201cid\u201d as the first column, which can be generated with another OP Find DAT with the Column called \u201cID\u201d turned on.\t\t\t\n\t\t\t\nFor example, say you first list all components that are panels, then you separate into groups based on type or Clone parameter. The first OP Find DAT pre-filters a huge hierarchy to a small fraction of the nodes, the subsequent OP Find DATs are operating on simpler sets to eliminate a lot of checking and cooking.\t\t\t\n\t\t\t\nRefer to Help -> [[OP Snippets|Operator Snippets]].\t\t\t\n\t\t\t\nSee also: [[Script DAT]]",
        "opType": "opfind",
        "opClass": "opfindDAT_Class",
        "opFilter": "False",
        "short": "The OP Find DAT traverses the component hierarchy starting at one component and looking at all nodes within that component, and outputs a table with one row per node that matches criteria the user chooses."
    },
    "oscinDAT": {
        "label": "oscinDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT receives information sent to the network port. While Off, no updating occurs. Data sent to the port is lost.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Select which protocol to use, refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : For multi-cast protocol, this is the multi-cast address to listen for. For UDT protocol this is the IP address of the server.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The port which OSC-In will accept packets on.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to receive on, useful when the system has mulitple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Toggle : Use the same connection as other networking DATs using the same network protocol.",
                "type": "TogglePar",
                "name": "shared",
                "items": []
            },
            {
                "text": "Str : To reduce which message are generated, you can use message address name patterns to include or exclude messages. For example, <code>^*accel*</code> will exclude accelerometer messages coming in from an iOS or iPhone app like mrmr. See [[Pattern Matching]] for the syntax of the possible address name patterns.",
                "type": "StrPar",
                "name": "addscope",
                "items": []
            },
            {
                "text": "Toggle : Includes the argument list type tag in each message. It includes the parameter type keywords (in case the parsing application needs to identify parameter types).",
                "type": "TogglePar",
                "name": "typetag",
                "items": []
            },
            {
                "text": "Toggle : When On, each message contained within a bundle is given its own row.",
                "type": "TogglePar",
                "name": "splitbundle",
                "items": []
            },
            {
                "text": "Toggle : When On, OSC address and arguments are given individual columns, otherwise they are included in the message column.",
                "type": "TogglePar",
                "name": "splitmessage",
                "items": []
            },
            {
                "text": "Toggle : When On, each bundle timestamp value is included in a column.",
                "type": "TogglePar",
                "name": "bundletimestamp",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute once for each message received. See [[oscinDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when <span class=\"tipTextDAT\">Execute from</span> is set to <span class=\"tipTextDAT\">Specified Operator</span>. This operator is also the path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to <span class=\"tipTextDAT\">Specified Operator</span>.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "OSC In",
        "long": "The OSC In DAT receives and parses full Open Sound Control packets using UDP by default.  Each packet is parsed and appended as a row in the DAT's table. The table is FIFO \"fisrt-in first-out\" and limited to parameter-set number of lines. An optional script may be run for each packet received. Each packet/row represents either one OSC message, or an entire OSC bundle.  Each argument is translated into readable ASCII text. \t\t\n\t\t\t\nSee also [[OSC]], [[OSC Out DAT]], [[Peer Class]], [[OSC_In_CHOP|OSC In CHOP]], [[OSC Out CHOP]], [[iOS and OSC]], [[Network Protocols]].\t\t\t\n\t\t\t\nThe supported argument tag types are:\t\t\t\n\t\t\t\n*i int32 \t\t\t\n*f float32 \t\t\t\n*s OSC-string \t\t\t\n*b OSC-blob \t\t\t\n*h 64 bit big-endian two's complement integer \t\t\t\n*t OSC-timetag \t\t\t\n*d 64 bit (\"double\") IEEE 754 floating point number \t\t\t\n*S alternate type represented as an OSC-string\t\t\t\n*c ASCII character\t\t\t\n*r 32 bit RGBA color \t\t\t\n*m 4 byte MIDI message\t\t\t\n*T True\t\t\t\n*F False\t\t\t\n*N Nil\t\t\t\n*I Infinitum\t\t\t\n*[ Beginning of an array\t\t\t\n*] End of an array\t\t\t\n\t\t\t\n\t\t\t\nIn the case of multi-vectored arguments (example \"blob\", \"midi\", \"rgb\", etc), the list of values is enclosed in double quotes.  In the case of unknown argument types, a quoted list of decimal values representing the bytes of that argument are included instead.\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opType": "oscin",
        "opClass": "oscinDAT_Class",
        "opFilter": "False",
        "short": "The OSC In DAT receives and parses full Open Sound Control packets using UDP by default.",
        "opCategories": ""
    },
    "oscoutDAT": {
        "label": "oscoutDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT receives/sends information from/to the network port. While Off, no updating occurs. Data sent to the port is lost.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Selects the network protocol to use. Refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : The network address of the target computer when using UDP. For multi-cast this is the multi-cast address to send to. This address is a standard WWW address, such as 'foo' or 'foo.bar.com'. You can put an IP address (e.g. 100.123.45.78). If you put \"localhost\", it means the other end of the pipe is on the same computer.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The network port to send to.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Str : Specify an IP address to send from, useful when the system has mulitple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Toggle : Use the same connection as other networking DATs using the same network protocol.",
                "type": "TogglePar",
                "name": "shared",
                "items": []
            },
            {
                "text": "Toggle : To reduce which channels are generated, you can use channel name patterns to include or exclude channels. For example, <code>^*accel*</code> will exclude accelerometer channels coming in from an iOS or iPhone app like mrmr. See [[Pattern Matching]] for the syntax of the possible channel name patterns.",
                "type": "TogglePar",
                "name": "addscope",
                "items": []
            },
            {
                "text": "Toggle : Includes the argument list type tag in each message. It includes the parameter type keywords (in case the parsing application needs to identify parmameter types).",
                "type": "TogglePar",
                "name": "typetag",
                "items": []
            },
            {
                "text": "Toggle : When On, each message contained within a bundle is given its own row.",
                "type": "TogglePar",
                "name": "splitbundle",
                "items": []
            },
            {
                "text": "Toggle : When On, OSC address and arguments are given individual columns, otherwise they are included in the message column.",
                "type": "TogglePar",
                "name": "splitmessage",
                "items": []
            },
            {
                "text": "Toggle : When On, each bundle timestamp value is included in a column.",
                "type": "TogglePar",
                "name": "bundletimestamp",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute once for each message received.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when <span class=\"tipTextDAT\">Execute from</span> is set to <span class=\"tipTextDAT\">Specified Operator</span>. This operator is also the path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to <span class=\"tipTextDAT\">Specified Operator</span>.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "OSC Out",
        "long": "The OSC Out DAT is used for sending information over a OSC connection between remotely located computers. Use the [[OscoutDAT_Class|<code>.sendOSC()</code>]] python method to output the OSC messages.\n    \nOSC bundles allows you to send a group of messages in a single command rather than as separate, individual messages. The OSC Out DAT <code>sendOSC()</code> function will accept a list of messages and send as a bundle when you set the kwarg <code>asBundle=True</code>.\nBundles were created as a performance optimization for real-time control of synthesizers with a large number of parameters. (thx Jesse Gilbert)\n\t\t\t\nSee also [[OSC]], [[OSC In DAT]], [[OSC In CHOP]], [[OSC Out CHOP]], [[iOS and OSC]], [[Network Protocols]], [[Sync]].\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opType": "oscout",
        "opClass": "oscoutDAT_Class",
        "opFilter": "False",
        "short": "The OSC Out DAT is used for sending information over a OSC connection between remotely located computers.",
        "opCategories": ""
    },
    "outDAT": {
        "label": "outDAT",
        "members": [
            {
                "text": "Str : Creates a pop-up label when the cursor rolls over this Component output.",
                "type": "StrPar",
                "name": "label",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Out",
        "long": "The Out DAT is used to create a DAT output in a Component. Component outputs are positioned alphanumerically on the right side of the Component.",
        "opType": "out",
        "opClass": "outDAT_Class",
        "opFilter": "True",
        "short": "The Out DAT is used to create a DAT output in a Component.",
        "opCategories": ""
    },
    "panelexecuteDAT": {
        "label": "panelexecuteDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT will respond to the Panel that is referenced.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : ([[Operator Language|Tscript]] only) Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The path that the script will be executed from if the <span class=\"tipTextDAT\">Execute From</span> parameter is set to ''Specified Operator''.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "COMP : Select which [[Panel Component|Panel COMPs]] to monitor for changes.",
                "type": "COMPPar",
                "name": "panels",
                "items": []
            },
            {
                "text": "StrMenu : The [[Panel Value]](s) that is monitored to trigger the execution of the script.<!--TDparEnd-->\t\n\t\t\t\nScripts will execute based on a combination of the five trigger events listed below. The script is executed once per trigger (except for <span class=\"tipTextDAT\">While On</span>/<span class=\"tipTextDAT\">While Off</span> cases). Each event will only cause one trigger to go off (i.e. if both <span class=\"tipTextDAT\">Off to On</span> and <span class=\"tipTextDAT\">On Value Change</span> are checked, one event will be fired with <span class=\"tipTextDAT\">Off to On</span> as the trigger). Logic for the 'on' state is ''greater than zero''.",
                "type": "StrMenuPar",
                "name": "panelvalue",
                "items": []
            },
            {
                "text": "Toggle : The onOffToOn() method executes when the panel value specified switches from off to on, called at the first \"on\" frame.",
                "type": "TogglePar",
                "name": "offtoon",
                "items": []
            },
            {
                "text": "Toggle : The whileOn() method executes when the panel value specified is on. It is called once each frame.",
                "type": "TogglePar",
                "name": "whileon",
                "items": []
            },
            {
                "text": "Toggle : The onOnToOff() method executes when the panel value specified switches from on to off, called at the first \"off\" frame.",
                "type": "TogglePar",
                "name": "ontooff",
                "items": []
            },
            {
                "text": "Toggle : The whileOff() method executes when the panel value specified is off. It is called once each frame.",
                "type": "TogglePar",
                "name": "whileoff",
                "items": []
            },
            {
                "text": "Toggle : The onValueChange() method executes when the panel value specified changes value in any way. It is called once each frame.",
                "type": "TogglePar",
                "name": "valuechange",
                "items": []
            },
            {
                "text": "Pulse : Clicking this opens a text editor to edit text in the DAT.",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> and <code>.dat</code> files.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : When On, loads the file from disk into the DAT when the projects starts.  A filename must be specified.  Turning on the option will load the file from disk immediately.  If the file does not exist, it will be created the first time the DAT is updated.  The file is monitored so that any changes made to the file will update the DAT, and any changes made to the DAT will be written to the file right away.  If the file is removed, the DAT will retain its current contents.",
                "type": "TogglePar",
                "name": "syncfile",
                "items": []
            },
            {
                "text": "Toggle : When On, reloads the file from disk into the DAT when the projects starts.",
                "type": "TogglePar",
                "name": "loadonstart",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "loadonstartpulse",
                "items": []
            },
            {
                "text": "Toggle : When On, writes the contents of the DAT out to the file on disk when the project is saved.",
                "type": "TogglePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Pulse : Instantly write the file to disk.",
                "type": "PulsePar",
                "name": "writepulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Panel Execute",
        "long": "The Panel Execute DAT will run its script when the [[Panel Value]]s of a specified panel component changes. You can specify which panel values to monitor, and trigger scripts based on their values changing in various ways.\t\t\n\t\t\t\nPanel Execute DATs are created with [[panelexecuteDAT_Class|default python method]] placeholders. For each monitored condition in the parameters, there is a matching python method in the DAT. When a condition is turned on in the parameters, each time that condition is satisfied the corresponding python method will be executed.\t\t\t\n\t\t\t\nIn the template Python script, <code>panelValue</code> is passed to each method, and you can query each call by printing <code>panelValue.name</code> and <code>panelValue.val</code>. See [[PanelValue Class]].",
        "opType": "panelexec",
        "opClass": "panelexecuteDAT_Class",
        "opFilter": "False",
        "short": "The Panel Execute DAT will run its script when the [[Panel Value]]s of a specified panel component changes.",
        "opCategories": ""
    },
    "parameterDAT": {
        "label": "parameterDAT",
        "members": [
            {
                "text": "noderef : The operators determine where to obtain the channels. Specify or more operator names or paths. Examples: <code>wave1</code>, <code>slider*</code>, <code>constant[1-9] constant[10-19:2]</code>, <code>../base1</code>. Or select the operators using the menu.",
                "type": "noderefPar",
                "name": "ops",
                "items": []
            },
            {
                "text": "string : The list of parameters names (which can include wildcards) you want to get from the OP(s). One or more parameter, or * for all parameters. You can also specify a \"NOT\" selection with an <code>^</code>. Or select the parameter using the menu. See [[Pattern Matching]].",
                "type": "stringPar",
                "name": "parameters",
                "items": []
            },
            {
                "text": "toggle : Adds the OP name to the beginning of each parameter name in the table",
                "type": "togglePar",
                "name": "includeopname",
                "items": []
            },
            {
                "text": "string : See [[Pattern Matching]].",
                "type": "stringPar",
                "name": "renamefrom",
                "items": []
            },
            {
                "text": "string : See [[Pattern Expansion]].",
                "type": "stringPar",
                "name": "renameto",
                "items": []
            },
            {
                "text": "toggle : Output the operators' custom parameters.",
                "type": "togglePar",
                "name": "custom",
                "items": []
            },
            {
                "text": "toggle : Output the operators' built-in parameters.",
                "type": "togglePar",
                "name": "builtin",
                "items": []
            },
            {
                "text": "toggle : Outputs the column headers.",
                "type": "togglePar",
                "name": "header",
                "items": []
            },
            {
                "text": "toggle : Outputs the parameter name.",
                "type": "togglePar",
                "name": "name",
                "items": []
            },
            {
                "text": "toggle : Outputs the evaluated parameter value.",
                "type": "togglePar",
                "name": "value",
                "items": []
            },
            {
                "text": "toggle : Outputs the evaluated parameter value as a python object.",
                "type": "togglePar",
                "name": "eval",
                "items": []
            },
            {
                "text": "toggle : Outputs the current constant value of the parameter.",
                "type": "togglePar",
                "name": "constant",
                "items": []
            },
            {
                "text": "toggle : Outputs the current python expression of the parameter.",
                "type": "togglePar",
                "name": "expression",
                "items": []
            },
            {
                "text": "toggle : Outputs the export path of the parameter.",
                "type": "togglePar",
                "name": "export",
                "items": []
            },
            {
                "text": "toggle : Outputs the current mode of the parameter (constant, expression, or export).",
                "type": "togglePar",
                "name": "mode",
                "items": []
            },
            {
                "text": "toggle : Outputs what format the parameter is (eg. Float for float parameters, Menu for menu parameters etc.).",
                "type": "togglePar",
                "name": "style",
                "items": []
            },
            {
                "text": "toggle : Outputs the name of the tuplet the parameter is in. For example, tx on the Geometry COMP is a part of the 't' tuplet.",
                "type": "togglePar",
                "name": "tupletname",
                "items": []
            },
            {
                "text": "toggle : Outputs the size of the tuplet. For example, tx on the Geometry COMP would have a tuplet size of 3 since it's a part of the 't' tuplet with 3 parameters.",
                "type": "togglePar",
                "name": "size",
                "items": []
            },
            {
                "text": "toggle : Outputs the path to the node.",
                "type": "togglePar",
                "name": "path",
                "items": []
            },
            {
                "text": "toggle : If the parameter is a menu, then output the selected index of the menu.",
                "type": "togglePar",
                "name": "menuindex",
                "items": []
            },
            {
                "text": "toggle : Outputs the minimum and maximum values of the parameter. These values will clamp the value parameter to be within the range. If clampmin is 0 then the minimum will not clamp and the row/column entry will be 0. If clampmax is 0 then the maximum will not clamp and the row/column entry will be 1.",
                "type": "togglePar",
                "name": "minmax",
                "items": []
            },
            {
                "text": "toggle : Outputs whether or not the parameter has a clamped min or clamped max. If true, then the values are defined by min/max columns.",
                "type": "togglePar",
                "name": "clampminmax",
                "items": []
            },
            {
                "text": "toggle : Outputs the minimum and maximum values of the parameter in the interface (ie. the minimum and maximum values of a slider).",
                "type": "togglePar",
                "name": "normminmax",
                "items": []
            },
            {
                "text": "toggle : Outputs the default value of the parameter",
                "type": "togglePar",
                "name": "default",
                "items": []
            },
            {
                "text": "toggle : Outputs whether the parameter is currently enabled",
                "type": "togglePar",
                "name": "enabled",
                "items": []
            },
            {
                "text": "toggle : Outputs whether the parameter is currently read-only",
                "type": "togglePar",
                "name": "readonly",
                "items": []
            },
            {
                "text": "toggle : Outputs whether the parameter has a section divider/separator (ie. line) above it.",
                "type": "togglePar",
                "name": "section",
                "items": []
            },
            {
                "text": "toggle : Outputs a list of the menu names for any menu parameters.",
                "type": "togglePar",
                "name": "menunames",
                "items": []
            },
            {
                "text": "toggle : Outputs a list of the menu labels for any menu parameters.",
                "type": "togglePar",
                "name": "menulabels",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opType": "parameterDAT",
        "opLabel": "Parameter",
        "opClass": "parameterDAT_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Parameter DAT outputs a table of parameter names and values of an operator, including custom parameters, from any OP type. It outputs pre-evaluated expressions, and the parameter mode.",
        "long": "The Parameter DAT outputs a table of parameter names and values of an operator, including custom parameters, from any OP type. \n    \nIt can output pre-evaluated expressions, the [[Parameter Mode]] plus all attributes that define parameters - their type, label, ranges, menu items, limits, etc. in up to 24 columns of information."
    },
    "parameterexecuteDAT": {
        "label": "parameterexecuteDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT will respond to the Parameter that is referenced.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : ([[Operator Language|Tscript]] only) Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : This operator is also the path that the script will be executed from if the Execute From parameter is set to ''Specified Operator''.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "OP : Specify which operator(s) the triggering parameter belongs to.",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Str : Specify which parameter(s) to monitor for triggering the script.",
                "type": "StrPar",
                "name": "pars",
                "items": []
            },
            {
                "text": "Toggle : The onValueChange() method executes when the parameter value specified changes value in any way. It is called once each frame.",
                "type": "TogglePar",
                "name": "valuechange",
                "items": []
            },
            {
                "text": "Toggle : The onValuesChanged() method executes at end of frame with complete list of individual parameter changes. The changes are a list of named tuples, where each tuple is (Par, previous value)",
                "type": "TogglePar",
                "name": "valueschanged",
                "items": []
            },
            {
                "text": "Toggle : The onPulse() method executes when a 'pulse' type parameter is pulsed by clicking on it or via the [[Par Class|Par]].pulse() method.",
                "type": "TogglePar",
                "name": "onpulse",
                "items": []
            },
            {
                "text": "Toggle : The onExpressionChange() method executes whenever the specified parameter's expression changes. For example, changing the expression from <code>me.time.frame</code> to <code>me.time.seconds</code> will trigger the script.",
                "type": "TogglePar",
                "name": "expressionchange",
                "items": []
            },
            {
                "text": "Toggle : The onExportChange() method executes if the export path to the specified parameter changes. For example, if the parameter is being exported to from /chopname/chan1 and that is changed so /chopname2/chan2 is now exporting to it, then the script will be triggered.",
                "type": "TogglePar",
                "name": "exportchange",
                "items": []
            },
            {
                "text": "Toggle : The onEnableChange() method executes if the specified parameter goes from being disabled to enabled.",
                "type": "TogglePar",
                "name": "enablechange",
                "items": []
            },
            {
                "text": "Toggle : The onModeChange() method executes if the specified [[Parameter Mode|parameter's mode]] changes between the available constant, expression, export or bind mode.",
                "type": "TogglePar",
                "name": "modechange",
                "items": []
            },
            {
                "text": "Toggle : Monitor [[Custom Parameters]].",
                "type": "TogglePar",
                "name": "custom",
                "items": []
            },
            {
                "text": "Toggle : Monitor Built-In parameters.",
                "type": "TogglePar",
                "name": "builtin",
                "items": []
            },
            {
                "text": "Pulse : Clicking this opens a text editor to edit text in the DAT.",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> and <code>.dat</code> files.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : When On, loads the file from disk into the DAT when the projects starts.  A filename must be specified.  Turning on the option will load the file from disk immediately.  If the file does not exist, it will be created the first time the DAT is updated.  The file is monitored so that any changes made to the file will update the DAT, and any changes made to the DAT will be written to the file right away.  If the file is removed, the DAT will retain its current contents.",
                "type": "TogglePar",
                "name": "syncfile",
                "items": []
            },
            {
                "text": "Toggle : When On, reloads the file from disk into the DAT when the projects starts.",
                "type": "TogglePar",
                "name": "loadonstart",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "loadonstartpulse",
                "items": []
            },
            {
                "text": "Toggle : When On, writes the contents of the DAT out to the file on disk when the project is saved.",
                "type": "TogglePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Pulse : Instantly write the file to disk.",
                "type": "PulsePar",
                "name": "writepulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Parameter Execute",
        "long": "The Parameter Execute DAT runs a script when a [[parameter]] of any operator changes state. There are 4 ways a parameter can trigger the script: if its value, expression, export, or enable state changes.  \t\t\n\t\t\t\nParameter Execute DATs are created with [[parameterexecuteDAT_Class#Callbacks|default python method placeholders]]. Unlike other execute DATs, the Parameter Execute DAT does not cook the node that it is watching, to avoid issues with recursive updates.",
        "opType": "parexec",
        "opClass": "parameterexecuteDAT_Class",
        "opFilter": "False",
        "short": "The Parameter Execute DAT runs a  script when a [[parameter]] of any operator changes state.",
        "opCategories": ""
    },
    "pargroupexecuteDAT": {
        "label": "pargroupexecuteDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT will respond to the Parameter that is referenced.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "OP : Specify which operator(s) the triggering parameter belongs to.",
                "type": "OPPar",
                "name": "op",
                "items": []
            },
            {
                "text": "Str : Specify which parameter(s) to monitor for triggering the script.",
                "type": "StrPar",
                "name": "pars",
                "items": []
            },
            {
                "text": "Menu : This controls the format of the 'curr' and 'prev' arguments to the callbacks.",
                "type": "MenuPar",
                "name": "callbackmode",
                "items": []
            },
            {
                "text": "Toggle : The onValueChange() method executes when the parameter value specified changes value in any way. It is called once each frame.",
                "type": "TogglePar",
                "name": "valuechange",
                "items": []
            },
            {
                "text": "Toggle : The onPulse() method executes when a 'pulse' type parameter is pulsed by clicking on it or via the [[Par Class|Par]].pulse() method.",
                "type": "TogglePar",
                "name": "onpulse",
                "items": []
            },
            {
                "text": "Toggle : The onExpressionChange() method executes whenever the specified parameter's expression changes. For example, changing the expression from <code>me.time.frame</code> to <code>me.time.seconds</code> will trigger the script.",
                "type": "TogglePar",
                "name": "expressionchange",
                "items": []
            },
            {
                "text": "Toggle : The onExportChange() method executes if the export path to the specified parameter changes. For example, if the parameter is being exported to from /chopname/chan1 and that is changed so /chopname2/chan2 is now exporting to it, then the script will be triggered.",
                "type": "TogglePar",
                "name": "exportchange",
                "items": []
            },
            {
                "text": "Toggle : The onEnableChange() method executes if the specified parameter goes from being disabled to enabled.",
                "type": "TogglePar",
                "name": "enablechange",
                "items": []
            },
            {
                "text": "Toggle : The onModeChange() method executes if the specified [[Parameter Mode|parameter's mode]] changes between the available constant, expression, export or bind mode.",
                "type": "TogglePar",
                "name": "modechange",
                "items": []
            },
            {
                "text": "Toggle : Monitor [[Custom Parameters]].",
                "type": "TogglePar",
                "name": "custom",
                "items": []
            },
            {
                "text": "Toggle : Monitor Built-In parameters.",
                "type": "TogglePar",
                "name": "builtin",
                "items": []
            },
            {
                "text": "Pulse : Clicking this opens a text editor to edit text in the DAT.",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> and <code>.dat</code> files.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : When On, loads the file from disk into the DAT when the projects starts.  A filename must be specified.  Turning on the option will load the file from disk immediately.  If the file does not exist, it will be created the first time the DAT is updated.  The file is monitored so that any changes made to the file will update the DAT, and any changes made to the DAT will be written to the file right away.  If the file is removed, the DAT will retain its current contents.",
                "type": "TogglePar",
                "name": "syncfile",
                "items": []
            },
            {
                "text": "Toggle : When On, reloads the file from disk into the DAT when the projects starts.",
                "type": "TogglePar",
                "name": "loadonstart",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "loadonstartpulse",
                "items": []
            },
            {
                "text": "Toggle : When On, writes the contents of the DAT out to the file on disk when the project is saved.",
                "type": "TogglePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Pulse : Instantly write the file to disk.",
                "type": "PulsePar",
                "name": "writepulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opType": "pargroupexecuteDAT",
        "opLabel": "ParGroup Execute",
        "opClass": "pargroupexecuteDAT_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "",
        "long": ""
    },
    "performDAT": {
        "label": "performDAT",
        "members": [
            {
                "text": "Toggle : Turns logging on/off. The DAT will continuously log while Active is On.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Pulse : Use resetpulse button to grab a single frame snapshot.",
                "type": "PulsePar",
                "name": "activepulse",
                "items": []
            },
            {
                "text": "Menu : Offers two options for when to trigger a refresh of the logs.",
                "type": "MenuPar",
                "name": "triggermode",
                "items": []
            },
            {
                "text": "Float : This is the amount of time, in milliseconds, that a frame must exceed to cause the DAT to log and output the frame's timing. For example to see what happens when a frame takes more that 33 ms to cook, put this parameter to 33.",
                "type": "FloatPar",
                "name": "triggerthreshold",
                "items": []
            },
            {
                "text": "Toggle : Logs the cook time of operators.",
                "type": "TogglePar",
                "name": "logcook",
                "items": []
            },
            {
                "text": "Toggle : Logs time spent exporting CHOP channels.",
                "type": "TogglePar",
                "name": "logexport",
                "items": []
            },
            {
                "text": "Toggle : Logs time to draw 3D geometry and SOP viewers.",
                "type": "TogglePar",
                "name": "logviewport",
                "items": []
            },
            {
                "text": "Toggle : Logs time taken to read video and audio from movie files.",
                "type": "TogglePar",
                "name": "logmovie",
                "items": []
            },
            {
                "text": "Toggle : Logs time to draw channels in CHOP viewers.",
                "type": "TogglePar",
                "name": "logdrawchannels",
                "items": []
            },
            {
                "text": "Toggle : Logs time to draw objects in 3D viewers.",
                "type": "TogglePar",
                "name": "logobjectview",
                "items": []
            },
            {
                "text": "Toggle : Logs time taken by custom panels build with [[Panel Component]]s.",
                "type": "TogglePar",
                "name": "logcustompanel",
                "items": []
            },
            {
                "text": "Toggle : Logs time spent on MIDI.",
                "type": "TogglePar",
                "name": "logmidi",
                "items": []
            },
            {
                "text": "Toggle : Logs various graphics system calls, such as time spent waiting for the graphics card, calls to the graphic driver, converting TOP data to CHOPs, etc.",
                "type": "TogglePar",
                "name": "loggraphics",
                "items": []
            },
            {
                "text": "Toggle : Logs total frame time in milliseconds (ms).",
                "type": "TogglePar",
                "name": "logframelength",
                "items": []
            },
            {
                "text": "Toggle : Logs miscellaneous times that do not fit into other categories.",
                "type": "TogglePar",
                "name": "logmisc",
                "items": []
            },
            {
                "text": "Toggle : Logs time spent running scripts.",
                "type": "TogglePar",
                "name": "logscript",
                "items": []
            },
            {
                "text": "Toggle : Logs time spend by Render or Renderpass TOPs.",
                "type": "TogglePar",
                "name": "logrender",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Perform",
        "long": "The Perform DAT logs various performance times in a [[Table DAT]] format. These benchmarks are similar to those reported by the [[Performance Monitor Dialog|Performance Monitor]].",
        "opType": "perform",
        "opClass": "performDAT_Class",
        "opFilter": "False",
        "short": "The Perform DAT logs various performance times in a [[Table DAT]] format.",
        "opCategories": ""
    },
    "renderpickDAT": {
        "label": "renderpickDAT",
        "members": [
            {
                "text": "Menu : Decides when to update values based on pick interactions.",
                "type": "MenuPar",
                "name": "strategy",
                "items": []
            },
            {
                "text": "Toggle : This parameter is only enabled when the Strategy is set to Hold Last Picked. When this is on, starting a new pick on empty space will clear the values. When off, the last values will be held if the pick starts on empty space.",
                "type": "TogglePar",
                "name": "clearprev",
                "items": []
            },
            {
                "text": "Menu : Determines when the values are updated.",
                "type": "MenuPar",
                "name": "responsetime",
                "items": []
            },
            {
                "text": "Int : Controls the radius of the search area for the pick. If nothing is found at the pick's center it will keep searching for geometry in the search area defined by the Pick Radius.",
                "type": "IntPar",
                "name": "pickradius",
                "items": []
            },
            {
                "text": "Int : Used to reduce the searching within the search area. The search area is sampled at locations that correspond to 'spokes' outwards from the center pick point.",
                "type": "IntPar",
                "name": "pickradstep",
                "items": []
            },
            {
                "text": "Int : Used to reduce the searching within the search area. The search area is sampled at locations that correspond to 'rings' outwards from the center pick point.",
                "type": "IntPar",
                "name": "pickcirstep",
                "items": []
            },
            {
                "text": "TOP : Specifies which scene to pick on, and which camera to pick from. By default the first camera listed in the [[Render TOP]] will be used for picking. Another camera can be specified with the 'Custom Pick Camera(s)' parameter, and multiple different cameras can be selected using the <code>camera</code> input column.",
                "type": "TOPPar",
                "name": "rendertop",
                "items": []
            },
            {
                "text": "Object : Picking can be done from the viewport of custom camera(s) by specifying one or more [[Camera COMP]] here. If this parameter is blank the cameras from the Render TOP are used. To pick from the viewpoint of multiple different cameras, a <code>camera</code> column must be specified in the input DAT.",
                "type": "ObjectPar",
                "name": "custompickcameras",
                "items": []
            },
            {
                "text": "Toggle : [[Multi-Camera Rendering]] is a faster way to render multiple passes at the same time, and is thus a speed improvement for doing many picks at the same time. This feature may not work correctly for some older [[GLSL MAT]]s made in 088 though, so this parameter allows forcing off this speed improvement if necessary. Generally it should be left on though.",
                "type": "TogglePar",
                "name": "allowmulticamera",
                "items": []
            },
            {
                "text": "Toggle : When turned on only geometry whose [[Flag|Pickable Flag]] is on can be selected by the Render Pick DAT. The Pickable Flag is found on all [[Object]] components.",
                "type": "TogglePar",
                "name": "usepickableflags",
                "items": []
            },
            {
                "text": "Toggle : Includes the non-pickable objects in the picking algorithm such that non-pickable objects may occlude pickable objects.  For example, if there is only one pickable object in the scene with lots of additional non-pickable geometry is present, turning this parameter on will prevent the pickable object from being selected if it is behind a non-pickage object (occluded by the non-pickage object).",
                "type": "TogglePar",
                "name": "includenonpickable",
                "items": []
            },
            {
                "text": "Toggle : Appends input table to the Render Pick DATs columns.",
                "type": "TogglePar",
                "name": "mergeinputdat",
                "items": []
            },
            {
                "text": "Toggle : Enables Callback DAT for each pick event.",
                "type": "TogglePar",
                "name": "activatecallbacks",
                "items": []
            },
            {
                "text": "DAT : Path to a DAT containing callbacks for pick event received.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Returns the position of the point picked on the geometry. Columns ''tx, ty, tz''.",
                "type": "MenuPar",
                "name": "position",
                "items": []
            },
            {
                "text": "Menu : Returns the normals of the point picked on the geometry. Columns ''nx, ny, nz''.",
                "type": "MenuPar",
                "name": "normal",
                "items": []
            },
            {
                "text": "Object : Object used when fetching position or normals '''Relative to Object'''.",
                "type": "ObjectPar",
                "name": "referenceobj",
                "items": []
            },
            {
                "text": "Toggle : Returns the point color of the point picked on the geometry. Columns ''cr, cg, cb, ca''.",
                "type": "TogglePar",
                "name": "color",
                "items": []
            },
            {
                "text": "Toggle : Returns the texture coordinates of the point picked on the geometry. Columns ''mapu, mapv, mapw''.",
                "type": "TogglePar",
                "name": "uv",
                "items": []
            },
            {
                "text": "Toggle : Returns the depth of the point picked on the geometry. This value a non-linear ratio of the point's position between the near and far planes of the [[Depth Buffer]]. Column is ''depth''.",
                "type": "TogglePar",
                "name": "depth",
                "items": []
            },
            {
                "text": "Toggle : Returns the Instance ID of the object. This will always be 0 if instancing is off. Column is ''instance''.",
                "type": "TogglePar",
                "name": "instanceid",
                "items": []
            },
            {
                "text": "Str : Specify which custom attributes to return from the object.",
                "type": "StrPar",
                "name": "customattrib1",
                "items": []
            },
            {
                "text": "Menu : The type of attribute is selected from this menu.",
                "type": "MenuPar",
                "name": "customattrib1type",
                "items": []
            },
            {
                "text": "Str : Specify which custom attributes to return from the object.",
                "type": "StrPar",
                "name": "customattrib2",
                "items": []
            },
            {
                "text": "Menu : The type of attribute is selected from this menu.",
                "type": "MenuPar",
                "name": "customattrib2type",
                "items": []
            },
            {
                "text": "Str : Specify which custom attributes to return from the object.",
                "type": "StrPar",
                "name": "customattrib3",
                "items": []
            },
            {
                "text": "Menu : The type of attribute is selected from this menu.",
                "type": "MenuPar",
                "name": "customattrib3type",
                "items": []
            },
            {
                "text": "Str : Specify which custom attributes to return from the object.",
                "type": "StrPar",
                "name": "customattrib4",
                "items": []
            },
            {
                "text": "Menu : The type of attribute is selected from this menu.",
                "type": "MenuPar",
                "name": "customattrib4type",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Render Pick",
        "long": "The Render Pick DAT lets you get information about the 3D surface at any pixel of any 3D render, allowing you to implement multi-touch on a 3D rendered scene. It samples a rendering (from a [[Render TOP]] or a [[Render Pass TOP]]) and returns 3D information from the geometry at the specified pick locations.\t\t\n\t\t\t\nYou feed it a DAT with minimum three columns: <code>select</code>, <code>u</code> and <code>v</code>. A [[Multi Touch In DAT]] is usually connected to the Render Pick DAT, where the Multi Touch In DAT points to a container that is displaying the output of the Render TOP.\t\t\t\n\t\t\t\n\t\t\t\nYou can pick from multiple cameras simultaneously. You can specify a <code>camera</code> which allows the pick to occur from the point of a view other than the first camera listed in the [[Render TOP]]. The value in the column can either be a path (relative to the Render Pick DAT, or absolute) to a Camera COMP, or it can be an integer index, started at 0. If it's an index it will select the camera to use if there are multiple cameras listed in the [[Render TOP]], or if there are cameras listed in the 'Custom Pick Camera(s)' parameter. This is useful for various [[Multi-Camera Rendering]] setups, and cases such as VR where your picking isn't coming from the point of view of your eye cameras, but instead hand controllers.\t\t\t\n\t\t\t\nThe pick location is a u,v (horizontal, vertical) coordinate placed in the table that you connect to the Render Pick DAT input.  Each row of the input table represents one pick point to be sampled, except for the first row which contains column headings <code>select</code>, <code>u</code> and <code>v</code> (plus any other unused columns you want).  The <code>select</code>, <code>u</code> and <code>v</code> columns are what you would get from a [[Panel CHOP]]. The u and v values goes 0 to 1 left to right and bottom to top, no matter what the aspect ratio of the render is.\t\t\t\n\t\t\t\nWhen Strategy is Always, that u,v location is always sampled and the results are displayed in the corresponding row in the Render Pick DAT output. \t\t\t\n\t\t\t\nThe output table will show the path of the geometry that was picked, its position (in a choice of reference frames), surface normal (excluding bump mapping), distance from camera, texture UV coordinate, color, alpha and instance id. It properly picks surfaces with deforming vertices.\t\t\t\n\t\t\t\nThere are some examples here:\t\t\t\n\t\t\t\n* [[Palette:geoPanel|geoPanel]] in the palette.\t\t\t\n* [[Palette:multiTouch|multiTouch]] in the palette under Techniques.\t\t\t\n* [http://www.derivative.ca/Forum/viewtopic.php?f=22&t=166&p=13447 Render Pick DAT Example].\t\t\t\n\t\t\t\nSee also the single-sample [[Render Pick CHOP]].",
        "opType": "renderpick",
        "opClass": "renderpickDAT_Class",
        "opFilter": "False",
        "short": "The Render Pick DAT lets you get information about the 3D surface at any pixel of any 3D render, allowing you to implement multi-touch on a 3D rendered scene.",
        "opCategories": ""
    },
    "reorderDAT": {
        "label": "reorderDAT",
        "members": [
            {
                "text": "Menu : This parameter allows you to reorder either rows or columns.",
                "type": "MenuPar",
                "name": "reorder",
                "items": []
            },
            {
                "text": "Menu : Specify how to reorder the table.",
                "type": "MenuPar",
                "name": "method",
                "items": []
            },
            {
                "text": "Str : The rows or columns to copy or swap from.",
                "type": "StrPar",
                "name": "before",
                "items": []
            },
            {
                "text": "Str : The rows or columns to copy or swap to.",
                "type": "StrPar",
                "name": "after",
                "items": []
            },
            {
                "text": "Str : The order of input rows and columns to copy.",
                "type": "StrPar",
                "name": "order",
                "items": []
            },
            {
                "text": "Toggle : Only available when Method is 'In Specified Order by Name' or 'In Specified Order by Index'. It will delete any row/column not listed in the Order parameter.",
                "type": "TogglePar",
                "name": "delete",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Reorder",
        "long": "The Reorder DAT allows you to reorder the rows and columns of the input table. You can also use In Specified Order option to get duplicate copies of rows and columns.",
        "opType": "reorder",
        "opClass": "reorderDAT_Class",
        "opFilter": "True",
        "short": "The Reorder DAT allows you to reorder the rows and columns of the input table.",
        "opCategories": ""
    },
    "scriptDAT": {
        "label": "scriptDAT",
        "members": [
            {
                "text": "DAT : Specifies the DAT which holds the callbacks. See [[scriptDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Pulse : Clicking the button runs the <code>setupParameters()</code> callback function.",
                "type": "PulsePar",
                "name": "setuppars",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Script",
        "long": "The Script DAT runs a script each time the DAT cooks and can build/modify the output table based in the optional input tables. The Script DAT is created with a [[Docking|dock]]ed (attached) DAT that contains three Python methods: <code>cook</code>, <code>onPulse</code>, and <code>setupParameters</code>. The <code>cook</code> method is run each time the Script DAT cooks. The <code>setupParameters</code> method is run whenever the Setup Parameter button on the Script page is pressed. The <code>onPulse</code> method is run whenever a custom pulse parameter is pushed.\t\t\n\t\t\t\nRefer to Help -> Python Examples, and Help -> [[OP Snippets|Operator Snippets]].\t\t\t\n\t\t\t\nNote: Because the Script DAT can get data from anywhere, it's difficult to determine what it procedurally depends on. So every time that any Script OP runs it will add to a list of operators, parameters, nodes etc that it depends upon, and when they change, the Script OP will re-cook. The list is reset when a <code>.toe</code> restarts.\t\n\t\t\t\nSee also: [[Script CHOP]], [[Script SOP]], [[Script TOP]]",
        "opType": "script",
        "opClass": "scriptDAT_Class",
        "opFilter": "False",
        "short": "The Script DAT runs a script each time the DAT cooks and can build/modify the output table based in the optional input tables.",
        "opCategories": ""
    },
    "selectDAT": {
        "label": "selectDAT",
        "members": [
            {
                "text": "DAT : The [[Network Path|path]] of the DAT being referenced.",
                "type": "DATPar",
                "name": "dat",
                "items": []
            },
            {
                "text": "Toggle : Forces the first row to be selected even if it is not specified by the Select Rows settings.",
                "type": "TogglePar",
                "name": "firstrow",
                "items": []
            },
            {
                "text": "Toggle : Forces the first column to be selected even if it is not specified by the Select Cols settings.",
                "type": "TogglePar",
                "name": "firstcol",
                "items": []
            },
            {
                "text": "Menu : This parameter allows you to pick different ways of specifying the rows selected.",
                "type": "MenuPar",
                "name": "extractrows",
                "items": []
            },
            {
                "text": "Str : Specify the row name to start the selection range from.",
                "type": "StrPar",
                "name": "rownamestart",
                "items": []
            },
            {
                "text": "Int : Specify the row index to start the selection range from.",
                "type": "IntPar",
                "name": "rowindexstart",
                "items": []
            },
            {
                "text": "Str : Specify the row name to end the selection range.",
                "type": "StrPar",
                "name": "rownameend",
                "items": []
            },
            {
                "text": "Int : Specify the row index to end the selection range.",
                "type": "IntPar",
                "name": "rowindexend",
                "items": []
            },
            {
                "text": "Str : Specify actual row names that you want to select. You can use TouchDesigner's pattern matching (see wiki page [[Pattern Matching]]), for example <code>row[1-4]</code> will select all the rows names <code>row1</code> thru <code>row4</code>. Some characters like <code>'</code> need a <code>\\</code> in front of it.",
                "type": "StrPar",
                "name": "rownames",
                "items": []
            },
            {
                "text": "Str : Specify an expression that will be evaluated.  If the expression evaluates to true, the row will be selected.  \t\n\t\t\t\nExpand the parameter and you will see that it is in [[Parameter Mode|expression mode]].\t\t\t\n  \t\t\t\n[[File:SelectDAT_rowselectexpr.png]]\t\t\t\n\t\t\t\nBy default, the [[Python]] expression is <code>re.match('.*',me.inputCell.val) != None</code>.  <code>'.*'</code> means match any character multiple times, so this expression matches all values.  If you want to match the parent's operator name followed by any numeric number you can use <code>parent().name+'[0-9]*'</code>, where <code>'[0-9]*'</code> matches any numerical string.  <code>'.*'+parent().name+'.*'</code> will match any cell that contains the operator's parent name.  You can check  [https://docs.python.org/3.3/library/re.html Regular Expression Operations] for additional information on how to use the Python Regular Expression module.",
                "type": "StrPar",
                "name": "rowexpr",
                "items": []
            },
            {
                "text": "Int : When selecting rows by values, this parameter selects which column to use when matching cell values to Selected Row Values to determine which rows are selected.",
                "type": "IntPar",
                "name": "fromcol",
                "items": []
            },
            {
                "text": "Menu : This parameter allows you to pick different ways of specifying the columns selected.",
                "type": "MenuPar",
                "name": "extractcols",
                "items": []
            },
            {
                "text": "Str : Specify the column name to start the selection range from.",
                "type": "StrPar",
                "name": "colnamestart",
                "items": []
            },
            {
                "text": "Int : Specify the column index to start the selection range from.",
                "type": "IntPar",
                "name": "colindexstart",
                "items": []
            },
            {
                "text": "Str : Specify the column name to end the selection range.",
                "type": "StrPar",
                "name": "colnameend",
                "items": []
            },
            {
                "text": "Int : Specify the column index to end the selection range.",
                "type": "IntPar",
                "name": "colindexend",
                "items": []
            },
            {
                "text": "Str : Specify actual column names that you want to select. You can use TouchDesigner's pattern matching  (see wiki page [[Pattern Matching]]), for example <code>colvalue[1-4]</code> will select all the columns named <code>colvalue1</code> thru <code>colvalue4</code>.\tMatching some characters like <code>'</code> need a <code>\\</code> in front of it.",
                "type": "StrPar",
                "name": "colnames",
                "items": []
            },
            {
                "text": "Str : Specify an expression that will be evaluated. If the expression evaluates to true, the column will be selected. See Row Select Condition for more details.",
                "type": "StrPar",
                "name": "colexpr",
                "items": []
            },
            {
                "text": "Int : When extracting columns by Specified Names, this parameter selects which row to use when matching cell values to Selected Col Values to determine which columns are selected.",
                "type": "IntPar",
                "name": "fromrow",
                "items": []
            },
            {
                "text": "Menu : Determines what format will be used for output from the DAT.",
                "type": "MenuPar",
                "name": "output",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Select",
        "long": "The Select DAT allows you to fetch a DAT from any other location in the project, and to select any subset of rows and columns if it is a table.",
        "opType": "select",
        "opClass": "selectDAT_Class",
        "opFilter": "True",
        "short": "The Select DAT allows you to fetch a DAT from any other location in the project, and to select any subset of rows and columns if it is a table.",
        "opCategories": ""
    },
    "serialDAT": {
        "label": "serialDAT",
        "members": [
            {
                "text": "Toggle : This check box enables the serial connection.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Interpret the incoming data as binary or ASCII data. If the format is Per Byte, one row is appended for each binary byte received. If the format is Per Line, one row is appended for each null or newline delimited message received.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "StrMenu : Selects the COM port that the serial connection will use.  Default port names 1 through 8 are available in the popup menu, though any name can be manually entered in this field.",
                "type": "StrMenuPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Int : The maximum number of bits of information, including \"control\" bits, that are transmitted per second. Check your input device's default baud rate and set accordingly.",
                "type": "IntPar",
                "name": "baudrate",
                "items": []
            },
            {
                "text": "Menu : This parameter sets the number of data bits sent in each. Data bits are transmitted \"backwards\". Backwards refers to the order of transmission, which is from least significant bit (LSB) to most significant bit (MSB). To interpret the data bits, you must read from right to left.",
                "type": "MenuPar",
                "name": "databits",
                "items": []
            },
            {
                "text": "Menu : This parameter can be set to none, even, or odd. The optional parity bit follows the data bits and is included as a simple means of error checking. Parity bits work by specifying ahead of time whether the parity of the transmission is to be even or odd. If the parity is set to be odd, the transmitter will then set the parity bit in such a way as to make an odd number of 1's among the data bits and the parity bit.",
                "type": "MenuPar",
                "name": "parity",
                "items": []
            },
            {
                "text": "Menu : The last part of transmission packet consists of 1 or 2 Stop bits. The connection will now wait for the next Start bit.",
                "type": "MenuPar",
                "name": "stopbits",
                "items": []
            },
            {
                "text": "Menu : The DTR (data-terminal-ready) flow control. (Windows Only).",
                "type": "MenuPar",
                "name": "dtr",
                "items": []
            },
            {
                "text": "Menu : The RTS (request-to-send) flow control. (Windows Only).",
                "type": "MenuPar",
                "name": "rts",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute once for each message received.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The path that the script will be executed from if the Execute From parameter is set to Specified Operator.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a script command, here is an example: <code>opparm -c /serial1 clear</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "Serial",
        "long": "The Serial DAT is used for serial communication through an external port, using the RS-232 protocol. These ports are usually a 9 pin connector, or a USB port on new machines.  (Using a USB port requires a USB-to-serial adapter and driver.) \t\t\nAll of a computer's available serial ports can be found in the Device Manager in the Windows operating system under Computer \u2013> Manage -> Devices -> Serial\u2026 -> COM ports. Their names begin with 'COM'. Example: COM1, COM2, COM3.\t\t\t\n\t\t\t\nTo send bytes out this connection, see the send methods in the [[serialDAT_Class]], or in Tscript the <code>send</code> Command.\t\t\t\n\t\t\t\nSee also [[Arduino]] and [[Serial CHOP]].",
        "opType": "serial",
        "opClass": "serialDAT_Class",
        "opFilter": "False",
        "short": "The Serial DAT is used for serial communication through an external port, using the RS-232 protocol.",
        "opCategories": ""
    },
    "socketioDAT": {
        "label": "socketioDAT",
        "members": [
            {
                "text": "Toggle : When enabled, the SocketIO DAT is actively listening for events from the server, and can also emit events.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Pulse : Disconnects the connection and then reconnects.",
                "type": "PulsePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Str : The URL of the socket.io server.",
                "type": "StrPar",
                "name": "url",
                "items": []
            },
            {
                "text": "Toggle : Enables TLS (transport layer security) certificate verification.",
                "type": "TogglePar",
                "name": "verifycert",
                "items": []
            },
            {
                "text": "Int : The delay in milliseconds between reconnection attempts.",
                "type": "IntPar",
                "name": "delay",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute once for each message coming in.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when Execute from is set to Specified Operator. This operator is also the path that the script will be executed from if the Execute from parameter is set to Specified Operator.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "SocketIO",
        "opFilter": "False",
        "opType": "socketio",
        "long": "The SocketIO DAT connects to a [[Socket.IO]] server at the specified URL.\n    \nAdditional headers can be specified via the first input of the SocketIO DAT. This input should be in a table format with two columns, structured as name/value pairs.\n    \nThe SocketIO DAT listens to specific events that the server emits. These events are added as listeners via the second input, structured as a single column of event names. Then, when the server emits these events the <code>onReceiveEvent</code> callback will be triggered.\n\nThe SocketIO DAT can also emit events to the server. This is done using the python <code>emit</code> method. Acknowledgement callbacks are not supported.\n\nThe SocketIO DAT is built with [https://github.com/socketio/socket.io-client-cpp socket.io's C++ Client API] v2.0.0. Works with with socket.io v2.x servers; socket.io v3 currently not supported.\n\nThe SocketIO DAT prints socket.io status messages to the TouchDesigner text console. The text console can be enabled by setting the environment variable <code>TOUCH_TEXT_CONSOLE=1</code> (see: https://docs.derivative.ca/Variables#System_Environment_Variables). The text console will open the next time TouchDesigner is launched.\n\nSee also: [[WebSocket DAT]], [[Web Client DAT]]",
        "opClass": "socketioDAT_Class",
        "short": "The SocketIO DAT connects to a [[Socket.IO]] server at the specified URL.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "soptoDAT": {
        "label": "soptoDAT",
        "members": [
            {
                "text": "SOP : Specify the SOP to pull data from.",
                "type": "SOPPar",
                "name": "sop",
                "items": []
            },
            {
                "text": "Menu : Specify whether to pull point data or primitive data.",
                "type": "MenuPar",
                "name": "extract",
                "items": []
            },
            {
                "text": "StrMenu : Point or primitive group to extract. If none specify all data will be extracted.",
                "type": "StrMenuPar",
                "name": "group",
                "items": []
            },
            {
                "text": "StrMenu : Attributes to extract.  \t\n\t\t\t\nPoint specific attributes can include P and Pw for position and weight.  \t\t\t\n\t\t\t\nPrimitive specific attributes include vertices and close. Vertices list the point numbers in a primitive and close reports whether the primitive is a closed polygon. The index column is the point or primitive number and will always be output.",
                "type": "StrMenuPar",
                "name": "attrib",
                "items": []
            },
            {
                "text": "Toggle : Copies the vertex UVs to point UVs.",
                "type": "TogglePar",
                "name": "uvforpts",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opLabel": "SOP to",
        "long": "The SOP to DAT allows you to extract point, vertex and primitive (e.g. polygon) data and attributes from a SOP.\t\t\n\t\t\t\nData is output in columns, with the first column being index. The index refers to the Point or Primitive number.  [[Attribute|Attributes]] are output with column name <code>''attrib''</code> if it is a single value attribute, or with multiple columns named <code>''attrib''(0)</code>, <code>''attrib''(1)</code>, <code>''attrib''(2)</code> etc. if it is a multiple value attribute.\t\t\t\n\t\t\t\nSee also: [[Geometry Detail]], [[Point]], [[Point List]], [[Point Class]], [[Primitive]], [[Prims Class]], [[Polygon]], [[Vertex]], [[SOP]], [[SOP Class]], [[Script SOP]], [[Point Group]]s, [[Primitive Group]]s, [[Attributes]].\n\t\t\n\t\t\t\n'''Example File :''' [[File:SOPtoDATtoSOP.tox]]",
        "opType": "sopto",
        "opClass": "soptoDAT_Class",
        "opFilter": "False",
        "short": "The SOP to DAT allows you to extract point, vertex and primitive (e.g. polygon) data and attributes from a SOP.",
        "opCategories": ""
    },
    "sortDAT": {
        "label": "sortDAT",
        "members": [
            {
                "text": "Menu : Determines how the table will be sorted.",
                "type": "MenuPar",
                "name": "sortmethod",
                "items": []
            },
            {
                "text": "Str : When using <span class=\"tipTextDAT\">Sort</span> ''Specify Row/Column Name'', specify the name in this parameter. If the sort name does not find a match, the output will be unsorted.",
                "type": "StrPar",
                "name": "name",
                "items": []
            },
            {
                "text": "Int : When using <span class=\"tipTextDAT\">Sort</span> ''Specify Row/Column Index'', specify the index in this parameter. If the sort index is -1 or out of bounds, the output will be unsorted.",
                "type": "IntPar",
                "name": "index",
                "items": []
            },
            {
                "text": "Menu : Determines the type of sorting.",
                "type": "MenuPar",
                "name": "order",
                "items": []
            },
            {
                "text": "Float : The random seed when <span class=\"tipTextDAT\">Sort Order</span> is set to <span class=\"tipTextDAT\">Random</span>.",
                "type": "FloatPar",
                "name": "seed",
                "items": []
            },
            {
                "text": "Toggle : Ignores case sensitivity when Sort Order is set to Alphabetical or Alphabetical with Numbers.",
                "type": "TogglePar",
                "name": "ignorecase",
                "items": []
            },
            {
                "text": "Toggle : Does not resort the first row or column (depending if <span class=\"tipTextDAT\">Sort</span> is set to Rows or Columns).",
                "type": "TogglePar",
                "name": "preservefirst",
                "items": []
            },
            {
                "text": "Menu : Remove duplicate rows/column entries in the sorted row/column.",
                "type": "MenuPar",
                "name": "unique",
                "items": []
            },
            {
                "text": "Toggle : Reverses the sort order.",
                "type": "TogglePar",
                "name": "reverse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "Sort",
        "opFilter": "True",
        "long": "The Sort DAT will sort table DAT data by row or column.",
        "opClass": "sortDAT_Class",
        "opType": "sort",
        "short": "The Sort DAT will sort table DAT data by row or column.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "substituteDAT": {
        "label": "substituteDAT",
        "members": [
            {
                "text": "Str : Search term to replace. The following special characters may be used:\t\n* * - match any number of characters\t\t\t\n* ? - match a single character\t\t\t\n* [] - match any character defined within the brackets\t\t\t\nTo match these special characters exactly, put a backslash (<code>\\</code>) before the special character.",
                "type": "StrPar",
                "name": "before",
                "items": []
            },
            {
                "text": "Str : The replacement term. This replaces everything matched in the search term. Spaces are permitted.",
                "type": "StrPar",
                "name": "after",
                "items": []
            },
            {
                "text": "Menu : Specify where to match:",
                "type": "MenuPar",
                "name": "match",
                "items": []
            },
            {
                "text": "Toggle : Respect case sensitivity in search term.",
                "type": "TogglePar",
                "name": "case",
                "items": []
            },
            {
                "text": "Toggle : Expand variables and back quotes in the From string.",
                "type": "TogglePar",
                "name": "expand",
                "items": []
            },
            {
                "text": "Toggle : Expand variables and back quotes in the To string.",
                "type": "TogglePar",
                "name": "expandto",
                "items": []
            },
            {
                "text": "Toggle : Replaces only the first instance of the matching string.",
                "type": "TogglePar",
                "name": "first",
                "items": []
            },
            {
                "text": "Toggle : Forces the first row to be ignored even if it is not specified by the Select Rows settings.",
                "type": "TogglePar",
                "name": "xfirstrow",
                "items": []
            },
            {
                "text": "Toggle : Forces the first column to be ignored even if it is not specified by the Select Cols settings.",
                "type": "TogglePar",
                "name": "xfirstcol",
                "items": []
            },
            {
                "text": "Menu : This parameter allows you to pick different ways of specifying the rows scoped.",
                "type": "MenuPar",
                "name": "extractrows",
                "items": []
            },
            {
                "text": "Str : Specify the row name to start the scope range from.",
                "type": "StrPar",
                "name": "rownamestart",
                "items": []
            },
            {
                "text": "Int : Specify the row index to start the scope range from.",
                "type": "IntPar",
                "name": "rowindexstart",
                "items": []
            },
            {
                "text": "Str : Specify the row name to end the scope range.",
                "type": "StrPar",
                "name": "rownameend",
                "items": []
            },
            {
                "text": "Int : Specify the row index to end the scope range.",
                "type": "IntPar",
                "name": "rowindexend",
                "items": []
            },
            {
                "text": "Str : Specify actual row names that you want to scope. You can use pattern matching, for example row[1-4] will scope all the rows names row1 thru row4.",
                "type": "StrPar",
                "name": "rownames",
                "items": []
            },
            {
                "text": "Str : Specify an expression that will be evaluated.  If the expression evaluates to true, the row will be selected.  \t\n\t\t\t\nExpand the parameter and you will see that it is in [[Parameter Mode|expression mode]].\t\t\t\n  \t\t\t\n[[File:SelectDAT_rowselectexpr.png]]\t\t\t\n\t\t\t\nBy default, the [[Python]] expression is <syntaxhighlight inline=true lang=python>re.match('.*',me.inputCell.val) != None</syntaxhighlight>.  <code>'.*'</code> means match any character multiple times, so this expression matches all values. If you want to match the parent's operator name followed by any numeric number you can use <code>parent().name+'[0-9]*'</code>, where <code>'[0-9]*'</code> matches any numerical string.  <code>'.*'+parent().name+'.*'</code> will match any cell that contains the operator's parent name.  You can check  [https://docs.python.org/3.7/library/re.html Regular Expression Operations] for additional information on how to use the Python Regular Expression module.",
                "type": "StrPar",
                "name": "rowexpr",
                "items": []
            },
            {
                "text": "Int : When selecting rows by values, this parameter selects which column to use when matching cell values to Selected Row Values to determine which rows are scoped.",
                "type": "IntPar",
                "name": "fromcol",
                "items": []
            },
            {
                "text": "Menu : This parameter allows you to pick different ways of specifying the columns scoped.",
                "type": "MenuPar",
                "name": "extractcols",
                "items": []
            },
            {
                "text": "Str : Specify the column name to start the scope range from.",
                "type": "StrPar",
                "name": "colnamestart",
                "items": []
            },
            {
                "text": "Int : Specify the column index to start the scope range from.",
                "type": "IntPar",
                "name": "colindexstart",
                "items": []
            },
            {
                "text": "Str : Specify the column name to end the scope range.",
                "type": "StrPar",
                "name": "colnameend",
                "items": []
            },
            {
                "text": "Int : Specify the column index to end the scope range.",
                "type": "IntPar",
                "name": "colindexend",
                "items": []
            },
            {
                "text": "Str : Specify actual column names that you want to scope. You can use pattern matching, for example colvalue[1-4] will scope all the columns named colvalue1 thru colvalue4.",
                "type": "StrPar",
                "name": "colnames",
                "items": []
            },
            {
                "text": "Str : Specify an expression that will be evaluated. If the expression evaluates to true, the column will be scoped. See Row Select Condition for more details.",
                "type": "StrPar",
                "name": "colexpr",
                "items": []
            },
            {
                "text": "Int : When scoping columns by Specified Names, this parameter selects which row to use when matching cell values to Selected Col Values to determine which columns are scoped.",
                "type": "IntPar",
                "name": "fromrow",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "substituteDAT_Class",
        "opType": "substitute",
        "short": "The Substitute DAT changes the cells of the incoming DAT using pattern matching and substitution strings.",
        "opFilter": "True",
        "opLabel": "Substitute",
        "long": "The Substitute DAT changes the cells of the incoming DAT using pattern matching and substitution strings. It outputs a table with the same number of rows and columns. \t\t\n\t\t\t\nSee examples below. Also you can use the second input to provide a table of strings to substitute, the first column being the \"before\" strings and the second column being the \"after\" strings.\t\n\n'''See also''': the Python <code>.replace()</code>  [https://www.w3schools.com/python/ref_string_replace.asp], which is a method you can apply to any string. You can do that in an [[Evaluate DAT]] or [[Script DAT]].",
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "switchDAT": {
        "label": "switchDAT",
        "members": [
            {
                "text": "Int : Selects which input to pass though to the output. The first input is 0.",
                "type": "IntPar",
                "name": "index",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "Switch",
        "opFilter": "True",
        "long": "The Switch DAT is a multi-input operator which lets you choose which input is output by using the <span class=\"tipTextDAT\">Input</span> parameter.",
        "opClass": "switchDAT_Class",
        "opType": "switch",
        "short": "The Switch DAT is a multi-input operator which lets you choose which input is output by using the <span class=\"tipTextDAT\">Input</span> parameter.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "tableDAT": {
        "label": "tableDAT",
        "members": [
            {
                "text": "Pulse : Clicking this opens a text editor to add/edit/delete text from the DAT.",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> and <code>.dat</code> files.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : When On, loads the file from disk into the DAT when the projects starts.  A filename must be specified.  Turning on the option will load the file from disk immediately.  If the file does not exist, it will be created the first time the DAT is updated.  The file is monitored so that any changes made to the file will update the DAT, and any changes made to the DAT will be written to the file right away.  If the file is removed, the DAT will retain its current contents.",
                "type": "TogglePar",
                "name": "syncfile",
                "items": []
            },
            {
                "text": "Menu : Sets the expected file encoding format, or auto-detects the format.  UTF8, UTF16-LE, UTF16-BE, CP1252",
                "type": "MenuPar",
                "name": "defaultreadencoding",
                "items": []
            },
            {
                "text": "Toggle : When On, reloads the file from disk into the DAT when the projects starts.",
                "type": "TogglePar",
                "name": "loadonstart",
                "items": []
            },
            {
                "text": "Toggle : When On, writes the contents of the DAT out to the file on disk when the project is saved.",
                "type": "TogglePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Toggle : When enabled, do not convert blank lines into empty rows when loading files.",
                "type": "TogglePar",
                "name": "removeblank",
                "items": []
            },
            {
                "text": "Menu : You can create and fill rows and columns of a table. Fill Type menu gives 5 options: Manual, Set Size, Set Size and Contents, Fill by Column, and Fill by Row. When a Fill option is chosen, you can generate multiple rows/columns with specific headings using space-separated names or an expression, plus expressions to fill the cells.",
                "type": "MenuPar",
                "name": "fill",
                "items": []
            },
            {
                "text": "Int : Defines the number of rows in the table, where applicable.",
                "type": "IntPar",
                "name": "rows",
                "items": []
            },
            {
                "text": "Int : Defines the number of columns in the table, where applicable.",
                "type": "IntPar",
                "name": "cols",
                "items": []
            },
            {
                "text": "Str : Expression used to fill each cell if the Fill Type is Fill by Row or Fill by Column.  Can include expressions <code>me.subRow</code> and <code>me.subCol</code>.",
                "type": "StrPar",
                "name": "cellexpr",
                "items": []
            },
            {
                "text": "Toggle : Creates an extra row at the top, or a column at the left for the names of the columns or rows, filled with the Include Names parameter.",
                "type": "TogglePar",
                "name": "includenames",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "Table",
        "opFilter": "False",
        "long": "The Table DAT lets you hand-edit or create a table of rows and columns of cells, each cell containing a text string. A \"table\" is one of the two forms of DATs (the other being simply lines of \"free-form\" text via the [[Text DAT]]). \t\n\t\t\n'''Manually editing cells''' - When a Table DAT has its [[Viewer Active]] on, you can add rows and columns by right-clicking on row 0 or column 0 to add rows/columns, and typing text into any cell of its [[Node Viewer|node viewer]]. Use the Tab key to jump to the next cell, and the up/down arrow keys to navigate to adjacent cells.\n\n'''Procedurally filling cells''' - You can conveniently create and fill rows and columns of a table. On the Fill page, the Fill Type menu gives 5 options: Manual, Set Size, Set Size and Contents, Fill by Column, and Fill by Row. When a Fill option is chosen, you can generate multiple rows/columns with specific headings using space-separated names or an expression, plus expressions to fill the cells. \n\nYou can use <code>me.subRow</code> and <code>me.subCol</code> (for sub-section being filled) in your expressions. See the popup menu on the Cell Expression parameter for suggestions.\n\t\t\nClick the + below the parameters to you generate multiple sets of new cols or rows.\n\n'''Filling cells externally with python ''' - If you are not auto-filling, you can put strings into table cells using something like <code>op('table1')[2,'select'] = 'yes'</code> in a python script elsewhere, or append rows using <code>.appendRow()</code> in python. See also the [[Script DAT]] and its Snippets.\t\n\t\t\n'''Loading from external files''' - The Table DAT can also can load a table from a <code>.csv</code>, <code>.txt</code> or <code>.dat</code> file on disk or on the web. Either drag-drop the file into a network, or use the File parameter.\n\nUse <code>http://</code> when specifying a table on the internet. \n\nIf you drag the Table DAT to a desktop or folder, The DAT text will be converted into tab-delimited tables in a <code>.txt</code> file.\t\n\nSee also [[Script DAT]], [[Text DAT]].",
        "opClass": "tableDAT_Class",
        "opType": "table",
        "short": "The Table DAT lets you hand-edit or create a table of rows and columns of cells, each cell containing a text string.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "tcpipDAT": {
        "label": "tcpipDAT",
        "members": [
            {
                "text": "Menu : Specify if this operator is communicating as a '''client''' or a '''server'''.",
                "type": "MenuPar",
                "name": "mode",
                "items": []
            },
            {
                "text": "Str : If this node is communicating as a client, this should be the IP address of the server.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The network port to listen on or connect to, depending on of the node is the server or client respectively.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : Use the same connection as other networking DATs using the same network protocol.",
                "type": "TogglePar",
                "name": "shared",
                "items": []
            },
            {
                "text": "Menu : Determines how the incoming data is parsed into the table.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "Toggle : This check box enables the connection.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute once for each message received.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The component who's state change will trigger the DAT to execute its script when <span class=\"tipTextDAT\">Execute from</span> is set to <span class=\"tipTextDAT\">On Panel Change</span>. This component is also the path that the script will be executed from if the <span class=\"tipTextDAT\">Execute from</span> parameter is set to <span class=\"tipTextDAT\">Specified Component</span>.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a script command, here is an example: <code>opparm -c /serial1 clear</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "tcpipDAT_Class",
        "opType": "tcpip",
        "short": "The TCP/IP DAT is used for sending and receiving information over a TCP/IP connection between two remotely located computers.",
        "opFilter": "False",
        "opLabel": "TCP/IP",
        "long": "The TCP/IP DAT is used for sending and receiving information over a TCP/IP connection between two remotely located computers. It captures all the messages without any queuing or buffering, and allows you to send it any messages you want.\t\t\n\t\t\t\nSend messages using the [[tcpipDAT_Class]]. Handle received messages using the callback DAT attached to the TCP/IP DAT. See [[Network Protocols]].\t\t\t\n\t\t\t\nThis DAT can be used to intercept all the raw information being sent from a Pipe Out CHOP for example. The [[Pipe In CHOP]] and [[Pipe Out CHOP]] also communicate through a TCP/IP connection, though they use a specific syntax. \t\t\t\n\t\t\t\nSee also [[Peer Class]], [[UDP In DAT]], [[UDP Out DAT]].\t\t\t\n\t\t\t\nFor Tscript. see Tscript <code>send</code> Command.\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "textDAT": {
        "label": "textDAT",
        "members": [
            {
                "text": "Pulse : Clicking this opens a text editor to add/edit/delete text from the DAT.",
                "type": "PulsePar",
                "name": "edit",
                "items": []
            },
            {
                "text": "File : The filesystem path and name of the file to load. Accepts <code>.txt</code> and <code>.dat</code> files.",
                "type": "FilePar",
                "name": "file",
                "items": []
            },
            {
                "text": "Toggle : When On, loads the file from disk into the DAT when the projects starts.  A filename must be specified.  Turning on the option will load the file from disk immediately.  If the file does not exist, it will be created the first time the DAT is updated.  The file is monitored so that any changes made to the file will update the DAT, and any changes made to the DAT will be written to the file right away.  If the file is removed, the DAT will retain its current contents.",
                "type": "TogglePar",
                "name": "syncfile",
                "items": []
            },
            {
                "text": "Toggle : When On, reloads the file from disk into the DAT when the projects starts.",
                "type": "TogglePar",
                "name": "loadonstart",
                "items": []
            },
            {
                "text": "Pulse : Instantly reloads the file.",
                "type": "PulsePar",
                "name": "loadonstartpulse",
                "items": []
            },
            {
                "text": "Toggle : When On, writes the contents of the DAT out to the file on disk when the project is saved.",
                "type": "TogglePar",
                "name": "write",
                "items": []
            },
            {
                "text": "Pulse : Instantly write the file to disk.",
                "type": "PulsePar",
                "name": "writepulse",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "Text",
        "opFilter": "False",
        "long": "The Text DAT lets you edit free-form, multi-line ASCII text. It is used for scripts, GLSL shaders, notes, XML and other purposes. \"Free-form text\" is one of the two forms of DATs (the other being tables of rows and columns of cells, each cell containing a text string as in a [[Table DAT]]). \t\n\t\t\nText can be typed into the DAT when its [[Viewer Active]] is on, or in an external text editor. The Text DAT can get its data from a file on disk or from a file on the web. Use <code>http://</code> when specifying a remote text file. \t\t\n\t\t\nSee also the Execute DATs which are specialized to run their text as a script: [[CHOP Execute DAT]] runs its script when a CHOP channel changes, [[DAT Execute DAT]] when a DAT changes, [[Execute DAT]] when you start or end your TouchDesigner process or want to run a script every frame, [[Panel Execute DAT]] when a control panel changes, [[Parameter Execute DAT]] when a parameter of a node changes, and [[OP Execute DAT]] when anything else about an operator changes, including creation and deletion of nodes in a component's network.\t\t\n\t\t\nUse the [[Web DAT]] to fetch via a URL query.",
        "opClass": "textDAT_Class",
        "opType": "text",
        "short": "The Text DAT lets you edit free-form, multi-line ASCII text.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "touchinDAT": {
        "label": "touchinDAT",
        "members": [
            {
                "text": "Menu : Select which protocol to use, refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : For multi-cast protocol, this is the multi-cast address to listen for. For UDT protocol this is the IP address of the server.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The port receiving the packets.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : Use the same connection as other networking DATs using the same network protocol.",
                "type": "TogglePar",
                "name": "shared",
                "items": []
            },
            {
                "text": "Toggle : While on, the DAT receives information sent to the network port. While Off, no updating occurs. Data sent to the port is lost.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "Touch In",
        "opFilter": "False",
        "long": "The Touch In DAT receives full tables across the network from the [[Touch Out DAT]], as opposed to messages with the other network based DATs.\t\t\n\t\t\t\nSee also [[UDP Out DAT]].",
        "opClass": "touchinDAT_Class",
        "opType": "touchin",
        "short": "The Touch In DAT receives full tables across the network from the [[Touch Out DAT]], as opposed to messages with the other network based DATs.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "touchoutDAT": {
        "label": "touchoutDAT",
        "members": [
            {
                "text": "Menu : Select which protocol to use, refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : For multi-cast protocol, this is the multi-cast address to listen for. For UDT protocol this is the IP address of the server.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The port the packets will be sent over.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : Use the same connection as other networking DATs using the same network protocol.",
                "type": "TogglePar",
                "name": "shared",
                "items": []
            },
            {
                "text": "Toggle : While on, the DAT sends data to the network port. While Off, no updating occurs.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Int : The maximum number of times the same data will be consecutively sent.",
                "type": "IntPar",
                "name": "redendantsends",
                "items": []
            },
            {
                "text": "Pulse : Send the current data regardless of how many times it has been sent.",
                "type": "PulsePar",
                "name": "resend",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "Touch Out",
        "opFilter": "True",
        "long": "The Touch Out DAT sends full DAT tables across the network to the [[Touch In DAT]] in another TouchDesigner process, as opposed to messages with the other network based DATs. It is an extremely powerful mechanism to sync data between TouchDesigner processes.\t\t\n\t\t\t\nSee also [[UDP Out DAT]].",
        "opClass": "touchoutDAT_Class",
        "opType": "touchout",
        "short": "The Touch Out DAT sends full DAT tables across the network to the [[Touch In DAT]] in another TouchDesigner process, as opposed to messages with the other network based DATs.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "transposeDAT": {
        "label": "transposeDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "Transpose",
        "opFilter": "True",
        "long": "The Transpose DAT converts rows into columns. The number of rows becomes the number of columns, and vice versa.",
        "opClass": "transposeDAT_Class",
        "opType": "transpose",
        "short": "The Transpose DAT converts rows into columns.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "tuioinDAT": {
        "label": "tuioinDAT",
        "members": [
            {
                "text": "Menu : Select which protocol to use, refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : For multi-cast protocol, this is the multi-cast address to listen for.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The port which TUIO In will accept packets on.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : Use the same connection as other networking DATs using the same network protocol.",
                "type": "TogglePar",
                "name": "shared",
                "items": []
            },
            {
                "text": "Toggle : While on, the DAT receives information sent to the network port. While Off, no updating occurs. Data sent to the port is lost.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will get callbacks for TUIO events. See [[tuioinDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when Execute from is set to Specified Operator. This operator is also the path that the script will be executed from if the Execute from parameter is set to Specified Operator.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opClass": "tuioinDAT_Class",
        "opType": "tuioin",
        "short": "The TUIO In DAT receives and parses TUIO messages (received over network) into columns in the table.",
        "opFilter": "False",
        "opLabel": "TUIO In",
        "long": "The TUIO In DAT receives and parses TUIO messages (received over network) into columns in the table. TUIO packets OSC bundles, so TUIO data can also be viewed in its more raw form in an [[OSC In DAT]].\tIt currently uses the TUIO 1.1 protocol. The TUIO 2.0 protocol is not yet supported.",
        "opFamily": "DAT",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "udpinDAT": {
        "label": "udpinDAT",
        "members": [
            {
                "text": "Menu : Select which protocol to use, refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : The multi-cast IP address to listen for.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The network port to listen on.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : Use the same connection as other networking DATs using the same network protocol.",
                "type": "TogglePar",
                "name": "shared",
                "items": []
            },
            {
                "text": "Menu : Determines how the incoming data is parsed.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "Toggle : This check box enables the connection.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute once for each message coming in. See [[udpinDAT_Class]] for usage.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when Execute from is set to Specified Operator. This operator is also the path that the script will be executed from if the Execute from parameter is set to Specified Operator.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "UDP In",
        "opFilter": "False",
        "long": "The UDP In DAT is used for receiving information over a UDP connection between two remotely located computers. It captures all the messages without any queuing or buffering, and allows you to send it any messages you want. Once this DAT has received a message it can reply to the sender using the 'send' command. Using the send command before it has received a message will not work because it doesn't know where to send data yet. When in multicast mode it doesn't send out a multicast message, it sends a reply directly to the originator for the last multicast message it got.\t\t\n\t\t\t\nSee also [[Peer Class]], [[UDP Out DAT]], [[Touch In DAT]] and [[TCP/IP DAT]].\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opClass": "udpinDAT_Class",
        "opType": "udpin",
        "short": "The UDP In DAT is used for receiving information over a UDP connection between two remotely located computers.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "udpoutDAT": {
        "label": "udpoutDAT",
        "members": [
            {
                "text": "Toggle : This check box enables the connection.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Selects the network protocol to use. Refer to the [[Network Protocols]] article for more information.",
                "type": "MenuPar",
                "name": "protocol",
                "items": []
            },
            {
                "text": "Str : You can put an IP address (e.g. 100.123.45.78), or a machine name to send to. If you put \"localhost\", it means the other end of the pipe is on the same computer. If you are using multi-cast you should put the multi-cast address you want to send to here.",
                "type": "StrPar",
                "name": "address",
                "items": []
            },
            {
                "text": "Int : The network port to send to.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : Use the same connection as other networking DATs using the same network protocol.",
                "type": "TogglePar",
                "name": "shared",
                "items": []
            },
            {
                "text": "Menu : Determines how the incoming data is parsed.",
                "type": "MenuPar",
                "name": "format",
                "items": []
            },
            {
                "text": "StrMenu : Specify an IP address to send from, useful when the system has mulitple NICs (Network Interface Card) and you want to select which one to use.",
                "type": "StrMenuPar",
                "name": "localaddress",
                "items": []
            },
            {
                "text": "Menu : Choose between automatically or manually selecting local port to use.",
                "type": "MenuPar",
                "name": "localportmode",
                "items": []
            },
            {
                "text": "Int : When the above parameter is set to 'Manual', enter the port number to use here.",
                "type": "IntPar",
                "name": "localport",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute once for each message coming in.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when Execute from is set to Specified Operator. This operator is also the path that the script will be executed from if the Execute from parameter is set to Specified Operator.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "UDP Out",
        "opFilter": "False",
        "long": "The UDP Out DAT is used to send information over a UDP connection to/from a remotely-located computer. Use the <code>sendBytes()</code> or <code>send()</code> methods of the [[udpoutDAT_Class]] to send messages. \t\t\n\t\t\t\nAlthough is it an 'Out' node, it can receive reply messages from the machine(s) it sends to. The messages will appear in the DAT's contents (just like the [[UDP In DAT]]).\t\t\t\n\t\t\t\nSee also [[UDP In DAT]], [[Touch Out DAT]] and [[TCP/IP DAT]].\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opClass": "udpoutDAT_Class",
        "opType": "udpout",
        "short": "The UDP Out DAT is used to send information over a UDP connection to/from a remotely-located computer.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "udtinDAT": {
        "label": "udtinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "UDT In",
        "opFilter": "False",
        "long": "'''NOTE This DAT has been removed from TouchDesigner 2021 Official builds and later.'''\n\nThe UDT In DAT is used for receiving information over a [[UDT]] connection between two remotely located computers. It captures all the messages without any queuing or buffering, and allows you to send it any messages you want. UDT Streaming is a reliable, streaming, connection orientated protocol. A single server can send to multiple clients at the same time.\t\t\n\t\t\t\nHandle received messages using the callback DAT attached to the UDT In DAT. Send replies using the [[udtinDAT_Class]].\t\t\t\n\t\t\t\nSee also [[Peer Class]], [[UDT Out DAT]], [[Network Protocols]]. \n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opClass": "udtinDAT_Class",
        "opType": "udtin",
        "short": "The UDT In DAT is used for receiving information over a [[UDT]] connection between two remotely located computers.",
        "opLicense": "Non-Commercial"
    },
    "udtoutDAT": {
        "label": "udtoutDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "UDT Out",
        "opFilter": "False",
        "long": "'''NOTE This DAT has been removed from TouchDesigner 2021 Official builds and later.'''\n    \nThe UDT Out DAT is used for sending information over a [[UDT]] connection between remotely located computers.  \t\t\n\t\t\t\nSend messages using the [[udtoutDAT_Class]]. Handle received messages using the callback DAT attached to the [[UDT In DAT]]. See [[Network Protocols]]. \t\t\t\n\t\t\t\nAlthough it is an 'Out' node, it can receive reply messages from the machine(s) it sends to. The messages will appear in the DAT's contents (just like the [[UDT In DAT]]).\t\t\t\n\t\t\t\n[[Tscript]] uses the <code>send</code> Command to initiate the data output.\t\t\t\n\t\t\t\nSee also: [[UDT In DAT]]\n\n'''NOTE for Windows OS - If experiencing connection issues make sure Windows Firewall is disabled.'''",
        "opClass": "udtoutDAT_Class",
        "opType": "udtout",
        "short": "The UDT Out DAT is used for sending information over a [[UDT]] connection between remotely located computers.",
        "opLicense": "Non-Commercial"
    },
    "webclientDAT": {
        "label": "webclientDAT",
        "members": [
            {
                "text": "Toggle : Toggles the operator on/off.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Menu : Selects the [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods HTTP request method].",
                "type": "MenuPar",
                "name": "reqmethod",
                "items": []
            },
            {
                "text": "Str : The URL of the server to send the HTTP request",
                "type": "StrPar",
                "name": "url",
                "items": []
            },
            {
                "text": "Str : The contents of the upload file will be sent to the server (chunked, if necessary).",
                "type": "StrPar",
                "name": "uploadfile",
                "items": []
            },
            {
                "text": "Pulse : Sends the request",
                "type": "PulsePar",
                "name": "request",
                "items": []
            },
            {
                "text": "Pulse : Stops the stream of data from the server.",
                "type": "PulsePar",
                "name": "stop",
                "items": []
            },
            {
                "text": "Toggle : Enables streaming. This is only necessary to enable if the server support streaming.",
                "type": "TogglePar",
                "name": "stream",
                "items": []
            },
            {
                "text": "Toggle : Enables TLS (transport layer security) certificate verification.",
                "type": "TogglePar",
                "name": "verifycert",
                "items": []
            },
            {
                "text": "Int : Timeout of the request if no response is received from the web server.",
                "type": "IntPar",
                "name": "timeout",
                "items": []
            },
            {
                "text": "Toggle : Includes the header in the output of the response.",
                "type": "TogglePar",
                "name": "includeheader",
                "items": []
            },
            {
                "text": "Toggle : Enables asynchronous sending/receiving (ie. TouchDesigner doesn't hang while waiting for a response from the web server).",
                "type": "TogglePar",
                "name": "async",
                "items": []
            },
            {
                "text": "Menu : The type of authentication.",
                "type": "MenuPar",
                "name": "authtype",
                "items": []
            },
            {
                "text": "Str : Username used in Basic/Digest authentication.",
                "type": "StrPar",
                "name": "username",
                "items": []
            },
            {
                "text": "Str : Password used in Basic/Digest authentication.",
                "type": "StrPar",
                "name": "pw",
                "items": []
            },
            {
                "text": "Str : OAuth1 App Key retrieved from web server.",
                "type": "StrPar",
                "name": "appkey",
                "items": []
            },
            {
                "text": "Str : OAuth1 App Secret retrieved from web server.",
                "type": "StrPar",
                "name": "appsecret",
                "items": []
            },
            {
                "text": "Str : OAuth1 user token retrieved from web server.",
                "type": "StrPar",
                "name": "oauthtoken",
                "items": []
            },
            {
                "text": "Str : OAuth1 user secret retrieved from web server.",
                "type": "StrPar",
                "name": "oauthsecret",
                "items": []
            },
            {
                "text": "Str : OAuth2 Client ID retrieved from web server.",
                "type": "StrPar",
                "name": "clientid",
                "items": []
            },
            {
                "text": "Str : OAuth2 token retrieved from web server.",
                "type": "StrPar",
                "name": "token",
                "items": []
            },
            {
                "text": "Pulse : Clears the output of the DAT.",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the output of the DAT is table instead of text. The rows will also be clamped to Maximum lines parameter value. This should be enabled when streaming is enabled too ensure that the output does not get too large.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : The maximum number of rows when clamping is enabled.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opType": "webclientDAT",
        "opLabel": "Web Client",
        "opClass": "webclientDAT_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Web Client DAT allows you to send HTTP requests to web servers from TouchDesigner. It supports GET, POST, PUT, DELETE, HEAD, OPTIONS and PATCH http methods.",
        "long": "The Web Client DAT allows you to send HTTP requests to web servers from TouchDesigner. It supports GET, POST, PUT, DELETE, HEAD, OPTIONS and PATCH http methods.\n\nThe Web Client DAT supports various authentication types such as: basic, oauth1, oauth2.\n\nThe Web Client DAT allows for streaming from web servers.\n\nThe Web Client DAT sends HTTP requests to web servers and then outputs the response in the DAT. With streaming enabled it can stream data from a web server. \n    \nWhen streaming is enabled, Clamp Output as Rows should be enabled. This turns the output of the DAT into a FIFO table instead of raw text. Only the last N lines will be displayed, where N is the value of the Maximum Lines parameter. This will prevent the text in the DAT from getting too larger and will keep cook-times down as a result.\n    \nThe Web Client DAT supports sending of GET, POST, PUT, DELETE, HEAD, OPTIONS, and PATCH request methods. The Web Client DAT also supports 4 authentication methods: Basic, Digest, OAuth1, and OAuth2.\n\nThe first input is the extra headers to send in the request. It should be a table with 2 columns, structured as name/value pairs. For example:\n\n{{{!}} border=\"1\"\t\t\t\n{{!}}Content-Type\t\t\t\n{{!}}application/json\t\t\t\n{{!}}-\t\t\t\n{{!}}Connection\t\t\n{{!}}Close\n{{!}}}\t\n\nThe second input is the data/parameters to send in the request. This can be a table with two columns, structured as name/value pairs. It can also just be text, in which case it will be sent as is. If the request method doesn't have a request body (eg. GET, OPTIONS) then it will append the input to the URL as query parameters if a table, otherwise it will be sent as the request data.\n\n{{{!}} border=\"1\"\t\t\t\n{{!}}name\t\t\t\n{{!}}joe\t\t\t\n{{!}}-\t\t\t\n{{!}}month\t\t\t\n{{!}}May\t\t\t\n{{!}}}\n\nThe Web Client DAT is the successor to the [[Web DAT]]. \n\nSee also: [[Web Server DAT]], [[SocketIO DAT]], [[XML DAT]], [[TCP/IP DAT]], [[WebSocket DAT]], [[Web DAT]].",
        "opCategories": ""
    },
    "webDAT": {
        "label": "webDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "long": "'''Note''': Web DAT deprecated build 2019.15230, use [[Web Client DAT]]. \n    \n    The Web DAT fetches pages of data from a web connection. The data should be ASCII-readable. The Web DAT will automatically uncompress any gzip compressed page transfers. XML content is formatted into a readable indented structure, versus one long line normally sent by the server. An Info DAT can be used to obtain properties of the last page retrieved.\t\t\n\t\t\t\nThere are two main methods of retrieving a page from a web site using the Web DAT:\t\t\t\n* Fetch\t\t\t\n* Submit and Fetch\t\t\t\n\t\t\t\nThe Fetch method simply fetches the page from the internet using the simple protocol \"GET\", while the Submit and Fetch method can be used for submitting form data to a server.  By default the latter method uses the \"POST\" protocol.\t\t\t\n\t\t\t\n\t\t\t\nBoth methods allow a DAT table input to specify options while fetching.  This table should consist of rows of name/value pairs.  The first column consists of the names, while the second column consists of the values.  The Fetch method simply concatenates the pairs into the specified URL, while the Update and Fetch method posts the pairs to a webserver, before fetching the resulting page.\t\t\t\n\t\t\t\nFor example, assume a table with the following contents is connected to the Web DAT:\t\t\t\n\n{{{!}} border=\"1\"\t\t\t\n{{!}}name\t\t\t\n{{!}}joe\t\t\t\n{{!}}-\t\t\t\n{{!}}month\t\t\t\n{{!}}May\t\t\t\n{{!}}}\n\t\t\t\nIf the specified URL is:\t\t\t\n''http://www.example.com''\t\t\t\n\t\t\t\nThen the Fetch method will actually fetch:\t\t\t\n''http://www.example.com?name=joe&month=May''\t\t\t\n\t\t\t\nSimilarly, the Submit and Fetch method will post the pairs to the specified webserver, before fetching the page.\t\t\t\n\t\t\t\nNote that spaces and other special characters in the table will be properly encoded. For example, each space in a name or value would be encoded as: %20\t\t\t\n\t\t\t\nThe first input can also be text data, in which case the data is sent to the webserver during a POST as-is, without any formatting or encoding. If the first input is text it will be ignored during a GET operation.\t\t\t\n\t\t\t\nThe 2nd input of the Web DAT can be used for custom HTTP request headers to be specified as part of the request. Like the 1st input this should be a table of name/value pairs for header field name and the value. E.g\t\t\t\n\t\t\t\n{{{!}} border=\"1\"\t\t\t\n{{!}}Content-Type\t\t\t\n{{!}}application/json\t\t\t\n{{!}}-\t\t\t\n{{!}}Date\t\t\t\n{{!}}Tue, 12 Nov 2013 08:12:31 GMT\t\t\t\n{{!}}}\t\t\t\n\t\t\t\nEach row will automatically be merged into a single line of text separated by a colon. If the 2nd column is empty then the entry in the first column will have a semi-color append to it when it's turned into the request header.\t\t\t\n\t\t\t\nSee also [[XML DAT]], [[TCP/IP DAT]], [[WebSocket DAT]].",
        "opLabel": "Web",
        "opLicense": "Non-Commercial",
        "opFamily": "DAT",
        "short": "The Web DAT fetches pages of data from a web connection.",
        "opType": "web",
        "opFilter": "False",
        "opClass": "webDAT_Class"
    },
    "webserverDAT": {
        "label": "webserverDAT",
        "members": [
            {
                "text": "Toggle : Starts and Stops the webserver.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Pulse : When the server is active, pulsing will restart it.",
                "type": "PulsePar",
                "name": "restart",
                "items": []
            },
            {
                "text": "Int : The web server's connection port. Eg. If the port number is 9980, the web server can be connected to locally (via a web browser) at the address \"localhost:9980\".",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Toggle : When enabled, the web server will use transport layer security (TLS) to create secure connections with clients. As a result, the web server will run through HTTPS instead of HTTP.",
                "type": "TogglePar",
                "name": "secure",
                "items": []
            },
            {
                "text": "File : The path to the private key file of the server's TLS certificate.",
                "type": "FilePar",
                "name": "privatekey",
                "items": []
            },
            {
                "text": "File : The path to the certificate file of the server's TLS certificate.",
                "type": "FilePar",
                "name": "certificate",
                "items": []
            },
            {
                "text": "Text : The password for the certificate specified above. The password is only visually hidden and can still be accessed via python. In order to protect it and encrypt it when the project is saved, the Web Server DAT should be put in a private component.",
                "type": "TextPar",
                "name": "password",
                "items": []
            },
            {
                "text": "DAT : A reference to a DAT with python callbacks. The Web Server DAT relies heavily on the Callbacks DAT, and in fact most functionality passes through the callbacks. \n\n<code>onHTTPRequest</code> - Triggered when the web server receives an HTTP request. The request is a dictionary of HTTP headers. Similarly, response is a dictionary of response data such as status and reason. Additional key/value pairs can be added to the response dictionary that will be added as headers in the HTTP response. The response server must be returned from the callback. This response will be sent back to the client.\n\n<code>onWebSocketOpen</code> - Triggered when a WebSocket connection is opened with a client. The client address is passed to the callback.\n\n<code>onWebSocketClose</code> - Triggered when a WebSocket connection is closed. The client address is passed to the callback.\n\n<code>onWebSocketReceiveText</code> - Triggered when the server's WebSocket connection receives text data from a client. The client that sent the text data is passed through to the callback.\n\n<code>onWebSocketReceiveBinary</code> - Triggered when the server's WebSocket connection receives binary data from a client. The client that sent the binary data is passed through to the callback.\n\n<code>onServerStart</code> - Triggered when the server starts.\n\n<code>onServerStop</code> - Triggered when the server stops.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "Web Server",
        "opFilter": "False",
        "long": "The Web Server DAT allows you to connect to TouchDesigner as a web client, through a web browser for example. The Web Server DAT supports HTTP, WebSockets, as well as the sending/receiving of binary data, such as images (uploading/downloading). How client requests are handled is left up to the user via callbacks.\n    \nThe Web Server DAT can be secure, and also supports basic authentication via the authenticateBasic in the [[webserverDAT_Class]]. Currently only Basic authentication (ie. encoded username and password) is supported via a python method. Authentication will be in the HTTP request dictionary under the key 'Authorization'. \n\nUltimately, security is the complete responsibility of the user. It is up to the user to ensure that HTTP requests are properly authenticated, and any data storing usernames/passwords are encrypted or saved privately.\n\nHTTPS is supported via the Secure (TLS) parameter.\n\nThe Web Server DAT is built with [https://github.com/pocoproject/poco POCO] v1.9.1.\n\nSee also: [[Web Client DAT]]",
        "opClass": "webserverDAT_Class",
        "opType": "webserverDAT",
        "short": "The Text DAT lets you edit free-form, multi-line ASCII text.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "webrtcDAT": {
        "label": "webrtcDAT",
        "members": [
            {
                "text": "Toggle : When active, can connect to peers and send media/data. When deactivated, all existing connections will be closed.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Pulse : Resets the peer associated with the DAT. Equivalent to deactivating then reactivating the active parameter.",
                "type": "PulsePar",
                "name": "reset",
                "items": []
            },
            {
                "text": "Toggle : When enabled, custom min/max bit rates can be specified. These max bit rate limits are expressed in kbps and apply to all tracks associated with the WebRTC DAT.",
                "type": "TogglePar",
                "name": "bitratelimits",
                "items": []
            },
            {
                "text": "Int : Minimum bit rate for all tracks associated with the WebRTC DAT.",
                "type": "IntPar",
                "name": "minbitrate",
                "items": []
            },
            {
                "text": "Int : Maximum bit rate for all tracks associated with the WebRTC DAT.",
                "type": "IntPar",
                "name": "maxbitrate",
                "items": []
            },
            {
                "text": "DAT : Reference to a DAT containing WebRTC callbacks.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Str : URL of the STUN server. See [[WebRTC#ICE]] for more details regarding STUN.",
                "type": "StrPar",
                "name": "stun",
                "items": []
            },
            {
                "text": "Str : Username for access to the specified TURN servers.",
                "type": "StrPar",
                "name": "username",
                "items": []
            },
            {
                "text": "Str : Password for access to the specified TURN servers.",
                "type": "StrPar",
                "name": "password",
                "items": []
            },
            {
                "text": "Str : URL of the TURN server. See [[WebRTC#ICE]] for more details regarding TURN.",
                "type": "StrPar",
                "name": "turn0",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opType": "webrtcDAT",
        "opLabel": "WebRTC",
        "opClass": "webrtcDAT_Class",
        "opFilter": "True",
        "opLicense": "Non-Commercial",
        "opCategories": "",
        "short": "",
        "long": "A WebRTC DAT represents a peer on one end of any number of [[WebRTC]] peer-to-peer connections.\n\nEach connection is represented in TouchDesigner by a generated UUID. The UUID must be passed to [[WebrtcDAT Class]] connection-level python methods.\n\nThe WebRTC DAT output is a table formatted with a row per connection, with columns: id (ie. UUID), [https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/connectionState connection_state], [https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/signalingState signaling_state], [https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceConnectionState ice_connection_state], and [https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/iceGatheringState ice_gathering_state]. \n\nThe columns altogether describe the state of a connection and can also be useful for debugging. For example, if ice_connection_state failed then that means there's an issue pairing local and remote ICE candidates for streaming over the network. It could be that NAT traversal failed, and if using a STUN server that might indicate a need for a TURN server (see https://en.wikipedia.org/wiki/STUN#Limitations).\n\nWebRTC video and audio input/output is done via the [[Video Stream In TOP]], [[Video Stream Out TOP]], [[Audio Stream In CHOP]], and [[Audio Stream Out CHOP]].\n\nSee also [[WebRTC]]."
    },
    "websocketDAT": {
        "label": "websocketDAT",
        "members": [
            {
                "text": "Toggle : While on, the DAT receives information sent to the network port. While Off, no updating occurs. Data sent to the port is lost.",
                "type": "TogglePar",
                "name": "active",
                "items": []
            },
            {
                "text": "Str : The network address of the server computer. This address is a standard WWW address, such as <code>foo</code> or <code>foo.bar.com</code>. You can put an IP address (e.g. <code>100.123.45.78</code>). If you put <code>localhost</code>, it means the other end of the connection is on the same computer.",
                "type": "StrPar",
                "name": "netaddress",
                "items": []
            },
            {
                "text": "Int : The port in which the DAT will accept messages.",
                "type": "IntPar",
                "name": "port",
                "items": []
            },
            {
                "text": "Int : Time in milliseconds the WebSocket DAT will wait to connect to the server.",
                "type": "IntPar",
                "name": "timeout",
                "items": []
            },
            {
                "text": "DAT : The Callbacks DAT will execute once for each message coming in.",
                "type": "DATPar",
                "name": "callbacks",
                "items": []
            },
            {
                "text": "Menu : Determines the location the script is run from.",
                "type": "MenuPar",
                "name": "executeloc",
                "items": []
            },
            {
                "text": "OP : The operator whose state change will trigger the DAT to execute its script when Execute from is set to Specified Operator. This operator is also the path that the script will be executed from if the Execute from parameter is set to Specified Operator.",
                "type": "OPPar",
                "name": "fromop",
                "items": []
            },
            {
                "text": "Toggle : The DAT is limited to 100 messages by default but with Clamp Output, this can be set to anything including unlimited.",
                "type": "TogglePar",
                "name": "clamp",
                "items": []
            },
            {
                "text": "Int : Limits the number of messages, older messages are removed from the list first.",
                "type": "IntPar",
                "name": "maxlines",
                "items": []
            },
            {
                "text": "Pulse : Deletes all lines except the heading. To clear with a python script <code>op(''\"opname\"'').par.clear.pulse()</code>",
                "type": "PulsePar",
                "name": "clear",
                "items": []
            },
            {
                "text": "Toggle : Outputs the raw bytes of the message in a separate column.",
                "type": "TogglePar",
                "name": "bytes",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "WebSocket",
        "opFilter": "False",
        "opType": "websocket",
        "long": "The WebSocket DAT receives and parses [http://en.wikipedia.org/wiki/WebSocket WebSocket] messages. WebSockets are fast an efficient two way communication protocol used by web servers and clients. Each message is parsed and appended as a row in the DAT's table. The table is FIFO \"first-in first-out\" and limited to parameter-set number of lines. An optional script may be run for each packet received. Secure (tls) websocket servers are also supported.\t\t\nConnections to different WebSocket sites are supported without requiring manual header setup.\t\t\t\n\nThe WebSocket DAT prints status and error messages to the TouchDesigner text console. The text console can be enabled by setting the environment variable TOUCH_TEXT_CONSOLE=1 (see: https://docs.derivative.ca/Variables#System_Environment_Variables). The text console will open the next time TouchDesigner is launched.\n\nFor SocketIO support see the [[SocketIO DAT]].\n\t\t\t\nSee also: [[TCP/IP DAT]]\n\t\t\t\nExample project: [http://www.derivative.ca/Forum/viewtopic.php?p=30301 chat with WebSockets]",
        "opClass": "websocketDAT_Class",
        "short": "The WebSocket DAT receives and parses [http://en.wikipedia.org/wiki/WebSocket WebSocket] messages.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "xmlDAT": {
        "label": "xmlDAT",
        "members": [
            {
                "text": "Toggle : If enabled, the input should be in SGML/HTML format. This includes form data. If disabled, XML format is assumed.",
                "type": "TogglePar",
                "name": "sgml",
                "items": []
            },
            {
                "text": "Menu : Merge and label can be used to combine two inputs of data. The second input must be XML formatted, and not SGML/HTML. These two parameters control where and how the second input is merged.",
                "type": "MenuPar",
                "name": "merge",
                "items": []
            },
            {
                "text": "Str : Specify the element at which the merge occurs.",
                "type": "StrPar",
                "name": "mlabel",
                "items": []
            },
            {
                "text": "Str : Element labels must match this parameter.",
                "type": "StrPar",
                "name": "label",
                "items": []
            },
            {
                "text": "Str : Element types must match this parameter.",
                "type": "StrPar",
                "name": "type",
                "items": []
            },
            {
                "text": "Str : Element text must match this parameter.",
                "type": "StrPar",
                "name": "text",
                "items": []
            },
            {
                "text": "Str : If an element contains attributes, at least one must have a name matching this parameter.",
                "type": "StrPar",
                "name": "name",
                "items": []
            },
            {
                "text": "Str : If an element contains attributes, at least one must have a value matching this parameter.",
                "type": "StrPar",
                "name": "value",
                "items": []
            },
            {
                "text": "Str : Elements must have a parent whose label matches this parameter.",
                "type": "StrPar",
                "name": "plabel",
                "items": []
            },
            {
                "text": "Str : Elements must have a parent whose type matches this parameter.",
                "type": "StrPar",
                "name": "ptype",
                "items": []
            },
            {
                "text": "Str : Elements must have a parent whose text matches this parameter.",
                "type": "StrPar",
                "name": "ptext",
                "items": []
            },
            {
                "text": "Str : Elements must have a parent with an attribute whose name matches this parameter.",
                "type": "StrPar",
                "name": "pname",
                "items": []
            },
            {
                "text": "Str : Elements must have a parent with an attribute whose value matches this parameter.",
                "type": "StrPar",
                "name": "pvalue",
                "items": []
            },
            {
                "text": "Str : Only output attributes whos name match this parameter.",
                "type": "StrPar",
                "name": "oaname",
                "items": []
            },
            {
                "text": "Str : Only output attributes whose value match this parameter.",
                "type": "StrPar",
                "name": "oavalue",
                "items": []
            },
            {
                "text": "Str : Only output children whose label match this parameter.",
                "type": "StrPar",
                "name": "oclabel",
                "items": []
            },
            {
                "text": "Menu : This controls how the selected elements are presented.",
                "type": "MenuPar",
                "name": "show",
                "items": []
            },
            {
                "text": "Toggle : This determines whether or not the element label is prefixed when outputting tables or attributes or children.",
                "type": "TogglePar",
                "name": "lprefix",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "DAT",
        "opLabel": "XML",
        "opFilter": "True",
        "opType": "xml",
        "long": "The XML DAT can be used to parse arbitrary XML and SGML/HTML formatted data. Once formatted, selected sections of the text can be output for further processing.\t\t\n\t\t\t\nOne approach to parsing with the XML DAT is to read the XML with a Text DAT or a Web DAT, and pass that to a default XML DAT. Then you start to refine your selection by changing the match-all pattern (the \"*\"), to strings that reduce the elements that are in the output.\t\t\t\n\t\t\t\n===<div class=\"subSectionLineDAT\">XML and HTML Background</div>===\t\t\t\n\t\t\t\nXML and HTML data consists of a tree like structure consisting of elements. Each element can be either tagged or contain arbitrary text. Elements may be nested. Tagged elements begin with an opening section and usually are terminated with a closing section.\t\t\t\n\t\t\t\nExample:\t\t\t\n  <nowiki><greeting a=\"1\" b=\"2\" c=\"3\"> Hello there. </greeting></nowiki>\t\t\t\n\t\t\t\nIn the example above are two elements. The first is a '''tag''' element named ''greeting'' with attributes ''a, b'' and ''c''. The second element is a '''text''' element consisting of \"''Hello there.''\"\t\t\t\n\t\t\t\n===<div class=\"subSectionLineDAT\">XML DAT Operation</div>===\t\t\t\n\t\t\t\nThe XML DAT begins by parsing its input, creating an internal tree of elements.\t\t\t\n\t\t\t\nThe '''Element Scope''' parameters are then used to filter out unwanted elements. The remaining elements are then used to create the output. The format of the output is determined by the '''Format''' parameters. The '''Output''' parameters can then be used to futher limit the information displayed for each scoped element.\t\t\t\n\t\t\t\nEach parsed element contains a number of details:\t\t\t\n\t\t\t\n'''Label''' - Each element is given an arbitrary label named n0, n1, n2 etc. All elements are children of the reserved element labelled 'root'.\t\t\t\n\t\t\t\n'''Type''' - Elements are mainly of type 'tag' or 'text', though tag types can be further classified into 'doctype', 'declaration', 'comment' or 'entity'.\t\t\t\n\t\t\t\n'''Text''' - The text of an element refers to the tag attribute of an element, or the arbitrary text contents. In the above example, the first element would be of type 'tag' and contain text of 'greeting'. The second element would be of type 'text' and contain text of 'Hello there.'\t\t\t\n\t\t\t\n'''Level''' - This describes how deeply nested an element is. For example the single root element always has a level of 0.\t\t\t\n\t\t\t\n'''Parent''' - Each element contains one parent. The root element does not have a parent.\t\t\t\n\t\t\t\n'''Children''' - Each element can have an arbitrary number of children elements.\t\t\t\n\t\t\t\n'''Attributes''' - Each tagged element can have an arbitrary number of attributes. Each attribute consists of a name and a value. In the above example, the greeting tag would contain 3 attributes (with names a, b and c and values 1, 2, and 3 respectively).",
        "opClass": "xmlDAT_Class",
        "short": "The XML DAT can be used to parse arbitrary XML and SGML/HTML formatted data.",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "constantMAT": {
        "label": "constantMAT",
        "members": [
            {
                "text": "Toggle : The projection map texture color from a [[Light COMP]] will be applied to the object as well. This allows for applying a projection map without affecting the projection map's color with any lighting.",
                "type": "TogglePar",
                "name": "applyprojmaps",
                "items": []
            },
            {
                "text": "RGB : The color of the light reflected from the material.",
                "type": "RGBPar",
                "name": "colorr",
                "items": []
            },
            {
                "text": "RGB : The color of the light reflected from the material.",
                "type": "RGBPar",
                "name": "colorg",
                "items": []
            },
            {
                "text": "RGB : The color of the light reflected from the material.",
                "type": "RGBPar",
                "name": "colorb",
                "items": []
            },
            {
                "text": "Float : The opacity of the material. This parameter is multiplied by point alpha of the object.",
                "type": "FloatPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Toggle : Multiplies the color by alpha after all other operations have taken place.",
                "type": "TogglePar",
                "name": "postmultalpha",
                "items": []
            },
            {
                "text": "TOP : Provides a TOP texture to use as a color map.",
                "type": "TOPPar",
                "name": "colormap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapcoordinterp",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Constant MAT renders a constant color on a material.",
        "opLicense": "Non-Commercial",
        "opFamily": "MAT",
        "opFilter": "False",
        "opLabel": "Constant",
        "opClass": "constantMAT_Class",
        "opType": "constant",
        "long": "The Constant MAT renders a constant color on a material.",
        "opCategories": ""
    },
    "depthMAT": {
        "label": "depthMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Depth Only MAT can be used to prevent objects from being drawn by making an invisible barrier in Z.",
        "opLicense": "Non-Commercial",
        "opFamily": "MAT",
        "opFilter": "False",
        "opLabel": "Depth",
        "opClass": "depthMAT_Class",
        "opType": "depth",
        "long": "The Depth Only MAT can be used to prevent objects from being drawn by making an invisible barrier in Z.",
        "opCategories": ""
    },
    "glslMAT": {
        "label": "glslMAT",
        "members": [
            {
                "text": "Menu : Pick what version of GLSL to compile the shader with.",
                "type": "MenuPar",
                "name": "glslversion",
                "items": []
            },
            {
                "text": "DAT : Use this DAT to place preprocessor directives at the start of your shader, such as #extension. This is required since these need to be the first lines in the shader, and TouchDesigner will be adding code to the start of your shader to declare uniforms/functions which would appear before #extension directives located in the main shader.",
                "type": "DATPar",
                "name": "predat",
                "items": []
            },
            {
                "text": "DAT : Path to the DAT that holds the vertex shader code.",
                "type": "DATPar",
                "name": "vdat",
                "items": []
            },
            {
                "text": "DAT : Path to the DAT that holds the pixel shader code.",
                "type": "DATPar",
                "name": "pdat",
                "items": []
            },
            {
                "text": "Pulse : This will read all the declared (and used) uniforms in the compiled GLSL shader, and fill in the various name fields for the uniform parameters.",
                "type": "PulsePar",
                "name": "loaduniformnames",
                "items": []
            },
            {
                "text": "Pulse : This will clear all of the name fields for the uniform parameters.",
                "type": "PulsePar",
                "name": "clearuniformnames",
                "items": []
            },
            {
                "text": "DAT : Path to the DAT that holds the geometry shader code.",
                "type": "DATPar",
                "name": "gdat",
                "items": []
            },
            {
                "text": "Menu : The type of geometry that will be inputed into the Geometry Shader.",
                "type": "MenuPar",
                "name": "inprim",
                "items": []
            },
            {
                "text": "Menu : The type of geometry that the Geometry Shader will output.",
                "type": "MenuPar",
                "name": "outprim",
                "items": []
            },
            {
                "text": "Int : The maximum number of vertices the Geometry Shader will output.",
                "type": "IntPar",
                "name": "numout",
                "items": []
            },
            {
                "text": "Toggle : Enables support for two-sided coloring. When this is enabled the Vertex and/or Geometry shader can write to gl_FrontColor, gl_BackColor, gl_FrontSecondaryColor and gl_BackSecondaryColor and the correct color will be placed into gl_Color and gl_SecondaryColor in the Pixel shader depending on if the primitive's front face or back face is facing the camera. When this is disabled the values placed into gl_FrontColor and gl_FrontSecondaryColor are passed to gl_Color and gl_SecondaryColor regardless of which side of the primitive is facing the camera.",
                "type": "TogglePar",
                "name": "twocolor",
                "items": []
            },
            {
                "text": "MAT : This Material will inherit all of the Textures and Uniforms from the GLSL Material referenced in this parameter.",
                "type": "MATPar",
                "name": "inherit",
                "items": []
            },
            {
                "text": "Menu : Allows lighting space switch from the current default World Space to legacy Camera Space which was used for TouchDesigner 088.",
                "type": "MenuPar",
                "name": "lightingspace",
                "items": []
            },
            {
                "text": "Str : This is the sampler name that the GLSL program will use to sample from this TOP. The samplers need to be declared at the same dimentions as the TOP (sampler2D for a 2D TOP, sampler3D for 3D TOP).",
                "type": "StrPar",
                "name": "sampler0",
                "items": []
            },
            {
                "text": "TOP : This is the TOP that will be referenced by the above sampler name above it.\t\n\t\t\t\t\n'''Exposed by the + Button, texture sampling parameters''':\t\t\t\t\n\t\t\t\t\nRefer to the [[Texture Sampling Parameters]] article for more information on the parameters exposed by pressing the + button. The ''parameter'' prefix for each of the parameters is ''top[digit]''.",
                "type": "TOPPar",
                "name": "top0",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0extendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0filter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "top0anisotropy",
                "items": []
            },
            {
                "text": "Str : The name of the uniform.",
                "type": "StrPar",
                "name": "uniname0",
                "items": []
            },
            {
                "text": "XYZ : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZPar",
                "name": "value0x",
                "items": []
            },
            {
                "text": "XYZ : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZPar",
                "name": "value0y",
                "items": []
            },
            {
                "text": "XYZ : The value to assign to the uniform. If the uniform is a float the first entry of the four is used, if the uniform is a vec2 the first two entries are used, etc.",
                "type": "XYZPar",
                "name": "value0z",
                "items": []
            },
            {
                "text": "Str : The name of the uniform.",
                "type": "StrPar",
                "name": "chopuniname0",
                "items": []
            },
            {
                "text": "Menu : The type of the uniform. You can send up to 4 channels into the GLSL shader in a single uniform. For a CHOP with a single channel declare your uniform as a float, for one with two channels declare your uniform as a vec2, etc. The data is interleaved in the uniform. I.e., the .x component is the 1st channel, .y is the 2nd channel, etc.",
                "type": "MenuPar",
                "name": "chopunitype0",
                "items": []
            },
            {
                "text": "CHOP : The CHOP whose channels will be sent to the GLSL shader.",
                "type": "CHOPPar",
                "name": "chop0",
                "items": []
            },
            {
                "text": "Menu : GPUs can send array data into a GLSL shader using Uniform Arrays or Texture Buffers. A Uniform Array uses very limited memory to store its data, and can be access like any other regular uniform value (but in an array). Texture Buffers use texture memory and texture fetches to access the data, which allows them to store many more values.\t\t\n\t\t\t\t\nIn both cases the index is the 0-based index (an integer) into the array/buffer that you want to get a value for.",
                "type": "MenuPar",
                "name": "choparraytype0",
                "items": []
            },
            {
                "text": "StrMenu : You can select which channels from the CHOP will be used to fill the array. Up to the first 4 channels scoped will be used (depending on the type of the uniform array).",
                "type": "StrMenuPar",
                "name": "chanscope0",
                "items": []
            },
            {
                "text": "Str : The name of the uniform. The uniform should be declared as a mat4.",
                "type": "StrPar",
                "name": "matuniname0",
                "items": []
            },
            {
                "text": "OP : The value to assign the matrix. For valid ways to specify this, see the [[Matrix Parameters]] article.",
                "type": "OPPar",
                "name": "matvalue0",
                "items": []
            },
            {
                "text": "Str : The name of the uniform. The uniform should be declared as a mat4.",
                "type": "StrPar",
                "name": "unimatrixname0",
                "items": []
            },
            {
                "text": "OBJ : Transform from this COMPs world transform.",
                "type": "OBJPar",
                "name": "fromcomp0",
                "items": []
            },
            {
                "text": "OBJ : Transform to this COMPs world transform.",
                "type": "OBJPar",
                "name": "tocomp0",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The GLSL MAT allows you to write or import custom materials into TouchDesigner.",
        "opLicense": "Non-Commercial",
        "opFamily": "MAT",
        "opFilter": "False\t\t\ttexe",
        "opLabel": "GLSL",
        "opClass": "glslMAT_Class",
        "opType": "glsl",
        "long": "The GLSL MAT allows you to write or import custom materials into TouchDesigner. When there are compile errors in a GLSL [[shader]], a blue/red checkerboard ''error'' shader will be displayed.\t\t\t\n\t\t\t\t\nFor more information on writing a shader, see [[Write a GLSL Material]], and the [[:Category:GLSL|GLSL Category]].",
        "opCategories": ""
    },
    "inMAT": {
        "label": "inMAT",
        "members": [
            {
                "text": "Str : Creates a pop-up label when the cursor rolls over this Component input.",
                "type": "StrPar",
                "name": "label",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The In MAT is used to create a  MAT input in a Component.",
        "opLicense": "Non-Commercial",
        "opFamily": "MAT",
        "opFilter": "True",
        "opLabel": "In",
        "opClass": "inMAT_Class",
        "opType": "in",
        "long": "The In MAT is used to create a  MAT input in a Component. Component inputs are positioned alphanumerically on the left side of the Component.",
        "opCategories": ""
    },
    "lineMAT": {
        "label": "lineMAT",
        "members": [
            {
                "text": "dropmenu : Depth Interpolation Model depthmodel \u2013 a menu to select how the width of line items changes by their distance from the camera.",
                "type": "dropmenuPar",
                "name": "depthinterpolationmodel",
                "items": []
            },
            {
                "text": "float : When the Depth Interpolation Model is Inverse Distance, this determines how fast the widths/sizes decrease with distance. If it is set to 1 (default), the width goes down at the rate of 1/r. If it set to 2, it goes down by 1/(r*r), meaning that for lines/dots at a distance r that have a width of w, that line/dot at a distance twice as far away (2r) are 1/4 the width/size as they are at distance r.",
                "type": "floatPar",
                "name": "inversedistanceexponent",
                "items": []
            },
            {
                "text": "float : Specifies a near plane with a certain distance from the camera.",
                "type": "floatPar",
                "name": "distancenear",
                "items": []
            },
            {
                "text": "float : Specifies a far plane with a certain distance from the camera.",
                "type": "floatPar",
                "name": "distancefar",
                "items": []
            },
            {
                "text": "float : Specifies a fixed width value when the distance from camera is less than or equal to Distance Near. See the Summary of this operator for an explantion of the treatment of line width.",
                "type": "floatPar",
                "name": "widthnear",
                "items": []
            },
            {
                "text": "float : Specifies a fixed width value when the distance from the camera is equal or bigger than the Distance Far. Note when the Near-Far Range option is selected as the Depth Model, any point in between Distance Near and Distance Far will be calculated based on sine curve.",
                "type": "floatPar",
                "name": "widthfar",
                "items": []
            },
            {
                "text": "toggle : With this off (default), looking at a rendered image of a certain resolution, a line of with w will always be the same # of pixels wide as you change the field-of-view or ortho width. With this parameter on, a line of width w will be half the number of pixels wide if you double the field-of-view or double the ortho width. Relevant if you are animating camera zoom, for instance.",
                "type": "togglePar",
                "name": "widthaffectedbyfov/orthowidth",
                "items": []
            },
            {
                "text": "float : Moves the S Curve\u2019s bias backward or forward for width interpolation (only S Curve depth model).",
                "type": "floatPar",
                "name": "widthbias",
                "items": []
            },
            {
                "text": "float : Controls the steepness of the S Curve for width interpolation (only S Curve depth model). The higher the value of the steepness, you will notice more dramatic changes (higher slope) in the curve width. Also, with lower values of steepness, the curve transforms into a more linear form.",
                "type": "floatPar",
                "name": "widthsteepness",
                "items": []
            },
            {
                "text": "float : Control the amount of curvature in the curve for width interpolation (only S Curve depth model).",
                "type": "floatPar",
                "name": "widthlinearize",
                "items": []
            },
            {
                "text": "float : Moves the S Curve\u2019s bias backward or forward for color interpolation.",
                "type": "floatPar",
                "name": "colorbias",
                "items": []
            },
            {
                "text": "float : Controls the steepness of the S Curve for color interpolation.",
                "type": "floatPar",
                "name": "colorsteepness",
                "items": []
            },
            {
                "text": "float : Control the amount of curvature in the curve for color interpolation.",
                "type": "floatPar",
                "name": "colorlinearize",
                "items": []
            },
            {
                "text": "toggle : The resulting RGB value is reduced by multiplying RGB by alpha on edges or where transparent. This is the normal treatment in TouchDeisgner of RGB when alpha < 1.",
                "type": "togglePar",
                "name": "postmultalpha",
                "items": []
            },
            {
                "text": "dropmenu : If a line is being drawn on a polygon or its edge (the polygon being in another Geometry COMP + shader), and you need to lift it off the surface to be fully visible, this specifies whether to displace the line points toward the camera or along the line's normal (which can be the direction of the polygon's normal).",
                "type": "dropmenuPar",
                "name": "liftdirection",
                "items": []
            },
            {
                "text": "float : For lines that are drawn on top of filled polygons or along their edges, they may be cut off because they are rendered in the same place. To make it look good, you want to lift the line toward the camera or along its normal away from the surface. This parameter scales how far you lift the line off the surface to make it look good without separating them too far.",
                "type": "floatPar",
                "name": "liftscale",
                "items": []
            },
            {
                "text": "int : When drawing Points in Circle (Polygon) mode, or drawing end-caps, or elbows between edges, this determines how many points you would draw in a full-circle arc to simulate a circular shape. The lower the number, the faster it renders.",
                "type": "intPar",
                "name": "numptsincircle",
                "items": []
            },
            {
                "text": "toggle : A toggle to draw the Line polygons.",
                "type": "togglePar",
                "name": "drawlines",
                "items": []
            },
            {
                "text": "dropmenu : A menu to select the joint type where two lines segments meet.",
                "type": "dropmenuPar",
                "name": "linejointtype",
                "items": []
            },
            {
                "text": "integer : Specifies a threshold value in degrees for the Miter joint which alters the joint shape to Bevel joint if the angle between each two lines segments is bigger than this value.",
                "type": "integerPar",
                "name": "miterthreshold",
                "items": []
            },
            {
                "text": "dropmenu : A menu to Specify the end cap type at the Line start. You can control the size of each end cap type in the Cap page.",
                "type": "dropmenuPar",
                "name": "linestartcaptype",
                "items": []
            },
            {
                "text": "dropmenu : A menu to Specify the end cap type at the Line end.",
                "type": "dropmenuPar",
                "name": "lineendcaptype",
                "items": []
            },
            {
                "text": "float : ",
                "type": "floatPar",
                "name": "lineendtaperstrength",
                "items": []
            },
            {
                "text": "rgb : Specifies the color value for the Line at the Distance Near plane and any location closer to camera.",
                "type": "rgbPar",
                "name": "linenearcolor",
                "items": []
            },
            {
                "text": "float : Specifies the alpha value for the Line at the Distance Near plane and any location closer to camera.",
                "type": "floatPar",
                "name": "linenearalpha",
                "items": []
            },
            {
                "text": "toggle : A toggle to use the far color and interpolate the values between near and far color.",
                "type": "togglePar",
                "name": "specifylinefarcolor",
                "items": []
            },
            {
                "text": "rgb : Specifies the color value for the Line at the Distance Far plane and beyond (farther from camera).",
                "type": "rgbPar",
                "name": "linefarcolor",
                "items": []
            },
            {
                "text": "float : Specifies the alpha value for the Line at the Distance Far plane and beyond (farther from camera).",
                "type": "floatPar",
                "name": "linefaralpha",
                "items": []
            },
            {
                "text": "toggle : A toggle to draw the Points.",
                "type": "togglePar",
                "name": "drawpoints",
                "items": []
            },
            {
                "text": "dropmenu : A menu to select the Point type.",
                "type": "dropmenuPar",
                "name": "pointtype",
                "items": []
            },
            {
                "text": "float : Specifies a scale coefficient to the size of the Point. By default, the point radius size equals to the width at the point\u2019s location from the camera.",
                "type": "floatPar",
                "name": "pointsizemultiplier",
                "items": []
            },
            {
                "text": "rgb : Specifies the color value for the Point at the Distance Near plane and any location closer to camera.",
                "type": "rgbPar",
                "name": "pointnearcolor",
                "items": []
            },
            {
                "text": "float : Specifies the alpha value for the Point at the Distance Near plane and any location closer to camera.",
                "type": "floatPar",
                "name": "pointnearalpha",
                "items": []
            },
            {
                "text": "toggle : A toggle to use the far color and interpolate the values between near and far color.",
                "type": "togglePar",
                "name": "specifypointfarcolor",
                "items": []
            },
            {
                "text": "rgb : Specifies the color value for the Point at the Distance Far plane and beyond (farther from camera).",
                "type": "rgbPar",
                "name": "pointfarcolor",
                "items": []
            },
            {
                "text": "float : Specifies the alpha value for the Point at the Distance Far plane and beyond (farther from camera).",
                "type": "floatPar",
                "name": "pointfaralpha",
                "items": []
            },
            {
                "text": "dropmenu : A menu to select the the dirction to lift points.  See parameter Lift Direction.",
                "type": "dropmenuPar",
                "name": "pointliftdirection",
                "items": []
            },
            {
                "text": "float : see parameter Lift Scale.",
                "type": "floatPar",
                "name": "pointliftscale",
                "items": []
            },
            {
                "text": "toggle : A toggle to draw the Vectors at each point.",
                "type": "togglePar",
                "name": "drawvectors",
                "items": []
            },
            {
                "text": "dropmenu : When drawing a vector at each point, this determines where to get the XYZ of the vector. By default it gets it from an attribute of the SOP, the point normal by default. But when instancing is used, you can get it from an instance attribute from an Instance OP. The vector can be represented in world space or in the reference frame of the Geometry COMP.",
                "type": "dropmenuPar",
                "name": "attributetype",
                "items": []
            },
            {
                "text": "string : Specify the geometry [[Attribute]] to use to render the Vector. Some standard attribute are: N, P, Cd, uv, however it is possible to specify a custom attribute. Note that this value is case sensitive, ensure that the it matches with the name of the attribute for that point/vector.",
                "type": "stringPar",
                "name": "attribute",
                "items": []
            },
            {
                "text": "int : When instancing is used, you can get the XYZ vector from an instance attribute. This is the index of the X value in the Instance OP.",
                "type": "intPar",
                "name": "cusattribidx",
                "items": []
            },
            {
                "text": "float : A scale value which applies on the length of the Vector.",
                "type": "floatPar",
                "name": "scale",
                "items": []
            },
            {
                "text": "dropmenu : A menu to Specify the end cap type at the Vector start. You can control the size of each end cap type in the Cap page.",
                "type": "dropmenuPar",
                "name": "vectorstartcaptype",
                "items": []
            },
            {
                "text": "dropmenu : A menu to Specify the end cap type at the Vector end. You can control the size of each end cap type in the Cap page.",
                "type": "dropmenuPar",
                "name": "vectorendcaptype",
                "items": []
            },
            {
                "text": "float : : A coefficient to scale the width of end part of the Vector.",
                "type": "floatPar",
                "name": "vectortaperstrength",
                "items": []
            },
            {
                "text": "rgb : Specifies the color value for the Vector at the Distance Near plane and any location closer to camera.",
                "type": "rgbPar",
                "name": "vectornearcolor",
                "items": []
            },
            {
                "text": "float : Specifies the alpha value for the Vector at the Distance Near plane and any location closer to camera.",
                "type": "floatPar",
                "name": "vectornearalpha",
                "items": []
            },
            {
                "text": "toggle : A toggle to use the far color and interpolate the values between near and far color.",
                "type": "togglePar",
                "name": "specifyvectorfarcolor",
                "items": []
            },
            {
                "text": "rgb : Specifies the color value for the Vector at the Distance Far plane and beyond (farther from camera).",
                "type": "rgbPar",
                "name": "vectorfarcolor",
                "items": []
            },
            {
                "text": "float : Specifies the alpha value for the Vector at the Distance Far plane and beyond (farther from camera).",
                "type": "floatPar",
                "name": "vectorfaralpha",
                "items": []
            },
            {
                "text": "float : Specifies a scale to the width of Round end caps.",
                "type": "floatPar",
                "name": "roundwidth",
                "items": []
            },
            {
                "text": "float : Specifies a scale to the height of Round end caps.",
                "type": "floatPar",
                "name": "roundheight",
                "items": []
            },
            {
                "text": "float : Specifies a scale to the width of Square end caps.",
                "type": "floatPar",
                "name": "squarewidth",
                "items": []
            },
            {
                "text": "float : Specifies a scale to the height of Square end caps.",
                "type": "floatPar",
                "name": "squareheight",
                "items": []
            },
            {
                "text": "float : Specifies a scale to the width of Triangle end caps.",
                "type": "floatPar",
                "name": "trianglewidth",
                "items": []
            },
            {
                "text": "float : Specifies a scale to the height of Triangle end caps.",
                "type": "floatPar",
                "name": "triangleheight",
                "items": []
            },
            {
                "text": "float : Specifies a scale to the width of Arrow end caps.",
                "type": "floatPar",
                "name": "arrowwidth",
                "items": []
            },
            {
                "text": "float : Specifies a scale to the height (from the base of arrow to the head) of Arrow end caps.",
                "type": "floatPar",
                "name": "arrowheight",
                "items": []
            },
            {
                "text": "float : Specifies a scale to the tail length of Arrow end caps (the longer the tail the sharper it will look like).",
                "type": "floatPar",
                "name": "arrowtaillength",
                "items": []
            },
            {
                "text": "float : Normally end caps are the same width as the line. This parameter lets you make the cap wider/narrower than the line.",
                "type": "floatPar",
                "name": "endcapwidthmultiplier",
                "items": []
            },
            {
                "text": "float : Normally the end caps extend farther than the end of the line by half of the width (making the end cap a half-circle, and similarly for square, triangular and arrow endcape). This parameter lets you push the end cap out farther or closer.",
                "type": "floatPar",
                "name": "endcapheightmultiplier",
                "items": []
            },
            {
                "text": "float : By default (0), the start cap goes beyond the start point of the line so that the center of a circular startcap is right at the start point. Setting this to 1 makes the tip of the end cap positioned exactly at the start point.",
                "type": "floatPar",
                "name": "startcappullback",
                "items": []
            },
            {
                "text": "float : By default (0), the end cap goes beyond the end point of the line so that the center of a circular endcap is right at the end point. Setting this to 1 makes the tip of the end cap positioned exactly at the end point.",
                "type": "floatPar",
                "name": "endcappullback",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFamily": "MAT",
        "opType": "lineMAT",
        "opLabel": "Line",
        "opClass": "lineMAT_Class",
        "opFilter": "False",
        "opLicense": "Non-Commercial",
        "short": "The Line MAT renders 3D line segments, dots and vectors. The line width and color can be varied based on distance to the camera, using two models: a 1/z dropoff (z = distance from camera), or a near-far distance rolloff model, where you set the width and color at the near and far distances, and you vary three rolloff controls.",
        "long": "The Line MAT renders 3D line segments, dots and vectors. The line width and color can be varied based on distance to the camera, using two models: a 1/z dropoff (z = distance from camera), or a near-far distance rolloff model, where you set the width and color at the near and far distances, and you vary three rolloff controls.\n    \nFor lines it renders different types of end caps and hinge/joints (round, box, arrow).\nThe light model is flat-shaded (no affect from scene lighting). It draws edges (like polygon edges), points and vectors from points. There are different parameters to control the desired shape, as explained in the Parameter sections.\nIt renders several primitive types: polygons, meshes, NURBS, quads, etc. It also manages closed polygons / open polygons.\n\nYou can render a dot at each point. You can render a vector at each point which uses any attribute, like Normal (N). The points or vectors can have their own colors and alpha.\n\nLine Width is a resolution-independent quantity. A line width of 1 will draw a line that is 1/1000 the width of the image. This is true when used with orthographic cameras and perspective cameras. \n\nTo make the width of a line and its points vary per-point of a SOP, the width can be set by adding a point attribute <code>width</code> on the SOP being rendered. A value of 2 scales the width at that point by 2 times its normal width. New point attributes can be created with the [[Point SOP]] Custom page. To affect per-point width and not affect the line width, use the point attribute <code>pscale</code>.\n\nWhen you are animating Ortho Width or Field of View, you may want line widths to adjust more realistically. When the parameter \"Width Affected by FOV/Ortho Width\" is on, the behavior is different: For Ortho cameras, the drawn line width increases when Ortho Width drops below 1, (as if you are zooming into it), and decreases when Ortho Width increases above 1. For Perspective cameras, the drawn line width increases when Field of View drops below 90 degrees, and decreases when Field of View increases above 90 degrees. Note that when the parameter \"Width Affected by FOV/Ortho Width\" is on, lines are still resolution-independent.\n\nIntro article here from Interactive Immersive HQ: [https://interactiveimmersive.io/blog/3d/new-superpowers-touchdesigners-line-mat/ new-superpowers-touchdesigners-line-mat/]",
        "opCategories": ""
    },
    "MAT": {
        "label": "NotSet",
        "members": [
            {
                "text": "Toggle : This toggle enables and disables blending. However see the wiki article [[Transparency]].",
                "type": "TogglePar",
                "name": "blending",
                "items": []
            },
            {
                "text": "Menu : This value is multiplied by the color value of the pixel that is being written to the Color-Buffer (also know as the Source Color).",
                "type": "MenuPar",
                "name": "srcblend",
                "items": []
            },
            {
                "text": "Menu : This value is multiplied by the color value of the pixel currently in the Color-Buffer (also known as the Destination Color).",
                "type": "MenuPar",
                "name": "destblend",
                "items": []
            },
            {
                "text": "Toggle : This toggle enables and disables separate blending options for the alpha values.",
                "type": "TogglePar",
                "name": "separatealphafunc",
                "items": []
            },
            {
                "text": "Menu : This value is multiplied by the alpha value of the pixel that is being written to the Color-Buffer (also know as the Source Alpha).",
                "type": "MenuPar",
                "name": "srcblenda",
                "items": []
            },
            {
                "text": "Menu : This value is multiplied by the alpha value of the pixel currently in the Color-Buffer (also known as the Destination Alpha).",
                "type": "MenuPar",
                "name": "destblenda",
                "items": []
            },
            {
                "text": "Toggle : Enables and disables the Depth-Test. If the depth-test is disabled, depths values aren't written to the Depth-Buffer.",
                "type": "TogglePar",
                "name": "depthtest",
                "items": []
            },
            {
                "text": "Menu : The depth value of the pixel being drawn is compared to the depth value currently in the depth-buffer using this function. If the test passes then the pixel is drawn to the Frame-Buffer. If the test fails the pixel is discarded and no changes are made to the Frame-Buffer.",
                "type": "MenuPar",
                "name": "depthfunc",
                "items": []
            },
            {
                "text": "Toggle : If Write Depth Values is on, pixels that pass the depth-test will write their depth value to the Depth-Buffer. If this isn't on then no changes will be made to the Depth-Buffer, regardless of if the pixels drawn pass or fail the depth-test.",
                "type": "TogglePar",
                "name": "depthwriting",
                "items": []
            },
            {
                "text": "Toggle : This enables or disables the pixel alpha test.",
                "type": "TogglePar",
                "name": "alphatest",
                "items": []
            },
            {
                "text": "Menu : This menu works in conjunction with the Alpha Threshold parameter below in determining which pixels to keep based on their alpha value.",
                "type": "MenuPar",
                "name": "alphafunc",
                "items": []
            },
            {
                "text": "Float : This value is what the pixel's alpha is compared to to determine if the pixel should be drawn. Pixels with alpha greater than the Alpha Threshold will be drawn. Pixels with alpha less than or equal to the Alpha Threshold will not be drawn.",
                "type": "FloatPar",
                "name": "alphathreshold",
                "items": []
            },
            {
                "text": "Menu : Enables and disables wire-frame rendering with the option of OpenGL Tesselated or Topology based wireframes.",
                "type": "MenuPar",
                "name": "wireframe",
                "items": []
            },
            {
                "text": "Float : This value is the width that the wires will be. This value is in pixels.",
                "type": "FloatPar",
                "name": "wirewidth",
                "items": []
            },
            {
                "text": "Menu : Selects which faces to render.",
                "type": "MenuPar",
                "name": "cullface",
                "items": []
            },
            {
                "text": "Toggle : Turns on the polygon offset feature.",
                "type": "TogglePar",
                "name": "polygonoffset",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "polygonoffsetfactor",
                "items": []
            },
            {
                "text": "Float : ",
                "type": "FloatPar",
                "name": "polygonoffsetunits",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": []
    },
    "nullMAT": {
        "label": "nullMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Null MAT has no effect on the data. It is an instance of the MAT connected to its input.",
        "opLicense": "Non-Commercial",
        "opFamily": "MAT",
        "opFilter": "True",
        "opLabel": "Null",
        "opClass": "nullMAT_Class",
        "opType": "null",
        "long": "The Null MAT has no effect on the data. It is an instance of the MAT connected to its input. It doesn't do much but comes in handy when building networks.",
        "opCategories": ""
    },
    "outMAT": {
        "label": "outMAT",
        "members": [
            {
                "text": "Str : Creates a pop-up label when the cursor rolls over this Component output.",
                "type": "StrPar",
                "name": "label",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The Out MAT is used to create a  MAT output in a Component.",
        "opLicense": "Non-Commercial",
        "opFamily": "MAT",
        "opFilter": "False",
        "opLabel": "Out",
        "opClass": "outMAT_Class",
        "opType": "out",
        "long": "The Out MAT is used to create a  MAT output in a Component. Component outputs are positioned alphanumerically on the right side of the Component.",
        "opCategories": ""
    },
    "pbrMAT": {
        "label": "pbrMAT",
        "members": [
            {
                "text": "RGB : Base color of the texture, used to calculate diffuse and specular contributions.",
                "type": "RGBPar",
                "name": "basecolorr",
                "items": []
            },
            {
                "text": "RGB : Base color of the texture, used to calculate diffuse and specular contributions.",
                "type": "RGBPar",
                "name": "basecolorg",
                "items": []
            },
            {
                "text": "RGB : Base color of the texture, used to calculate diffuse and specular contributions.",
                "type": "RGBPar",
                "name": "basecolorb",
                "items": []
            },
            {
                "text": "Float : The amount of contribution the Specular Level Map adds to the material.",
                "type": "FloatPar",
                "name": "specularlevel",
                "items": []
            },
            {
                "text": "Float : The amount of contribution the Metallic Map adds to the material.",
                "type": "FloatPar",
                "name": "metallic",
                "items": []
            },
            {
                "text": "Float : The amount of contribution the Roughness Map adds to the material. Used to calculate specular D, R, and F (blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf page 3).",
                "type": "FloatPar",
                "name": "roughness",
                "items": []
            },
            {
                "text": "Float : The amount of contribution the Ambient Occlusion Map adds to the material. Ambient Occlusion affects the contribution from the Environement Light COMP.",
                "type": "FloatPar",
                "name": "ambientocclusion",
                "items": []
            },
            {
                "text": "Float : The sampling quality of the Environment Light with the material.",
                "type": "FloatPar",
                "name": "envlightquality",
                "items": []
            },
            {
                "text": "RGB : This is the color that the material will emit even if there is no light.",
                "type": "RGBPar",
                "name": "emitr",
                "items": []
            },
            {
                "text": "RGB : This is the color that the material will emit even if there is no light.",
                "type": "RGBPar",
                "name": "emitg",
                "items": []
            },
            {
                "text": "RGB : This is the color that the material will emit even if there is no light.",
                "type": "RGBPar",
                "name": "emitb",
                "items": []
            },
            {
                "text": "RGB : Adds to the final color. Where there are point colors, finalcolor += Point Color * Constant Color. This behaves like there is ambient illumination of 1 1 1. It is not affected by textures or transparency.",
                "type": "RGBPar",
                "name": "constantr",
                "items": []
            },
            {
                "text": "RGB : Adds to the final color. Where there are point colors, finalcolor += Point Color * Constant Color. This behaves like there is ambient illumination of 1 1 1. It is not affected by textures or transparency.",
                "type": "RGBPar",
                "name": "constantg",
                "items": []
            },
            {
                "text": "RGB : Adds to the final color. Where there are point colors, finalcolor += Point Color * Constant Color. This behaves like there is ambient illumination of 1 1 1. It is not affected by textures or transparency.",
                "type": "RGBPar",
                "name": "constantb",
                "items": []
            },
            {
                "text": "Menu : Controls how the polygon's normal is used to light the front face of the polygon. For more information refer to the [[Two-Sided Lighting]] article.",
                "type": "MenuPar",
                "name": "frontfacelit",
                "items": []
            },
            {
                "text": "Menu : Back Face's</span> <code>backfacelit</code> - Controls how the polygon's normal is used to light the back face of the polygon. For more information refer to the [[Two-Sided Lighting]] article.",
                "type": "MenuPar",
                "name": "backfacelit",
                "items": []
            },
            {
                "text": "Pulse : This button will bring up a dialog that will create a [[GLSL MAT]] and [[Text DAT]]s with shader code that this PBR MAT is currently using. Since shaders are dependent on the number and type of lights, it will list some possible different shader choices, based on what lighting configurations have been used in the current system. '''If no shaders are listed in the dialog''', it means no shader has been rendered in the current session of TouchDesigner. Turn on the viewer for the Phong MAT, or setup a render in a Render TOP. That will create/compile some shaders and will cause the list to be populated. For example if you want to see a shader that does shadow mapping, setup a render that does shadow mapping and you will see that come up in the list.",
                "type": "PulsePar",
                "name": "outputshader",
                "items": []
            },
            {
                "text": "TOP : Reference a [[Substance TOP]] containing an .sbsar file. Referencing the TOP will automatically unpack all enabled textures without having to manually fill in any of the below texture maps. Manually filling in any of the texture map parameters will override the texture automatically pulled from the .sbsar package.",
                "type": "TOPPar",
                "name": "substance",
                "items": []
            },
            {
                "text": "TOP : Clicking on the arrows to the right of the map field will open the [[Texture Sampling Parameters]] for Color Map.  The other Map parameters below will have their own Texture Sampling Parameters as well.",
                "type": "TOPPar",
                "name": "basecolormap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "basecolormapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "basecolormapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "basecolormapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "basecolormapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "basecolormapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "basecolormapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "basecolormapcoordinterp",
                "items": []
            },
            {
                "text": "TOP : Specifies a specular level map.",
                "type": "TOPPar",
                "name": "specularlevelmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specularlevelmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specularlevelmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specularlevelmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specularlevelmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specularlevelmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specularlevelmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specularlevelmapcoordinterp",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specularlevelmapchannelsource",
                "items": []
            },
            {
                "text": "TOP : Specifies a metallic texture map. This is equivalent to the Metallic map in Substance Designer.",
                "type": "TOPPar",
                "name": "metallicmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "metalnessmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "metalnessmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "metalnessmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "metalnessmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "metalnessmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "metallicmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "metallicmapcoordinterp",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "metallicmapchannelsource",
                "items": []
            },
            {
                "text": "TOP : Specifies a roughness texture map. This is equivalent to the Roughness map in Substance Designer.",
                "type": "TOPPar",
                "name": "roughnessmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "roughnessmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "roughnessmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "roughnessmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "roughnessmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "roughnessmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "roughnessmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "roughnessmapcoordinterp",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "roughnessmapchannelsource",
                "items": []
            },
            {
                "text": "TOP : Specifies a ambient occlusion texture map. This is equivalent to the Ambient Occlusion map in Substance Designer. Ambient Occlusion affects the contribution from the Environement Light COMP.",
                "type": "TOPPar",
                "name": "ambientocclusionmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "ambientocclusionmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "ambientocclusionmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "ambientocclusionmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "ambientocclusionmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "ambientocclusionmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "ambientocclusionmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "ambientocclusionmapcoordinterp",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "ambientocclusionmapchannelsource",
                "items": []
            },
            {
                "text": "TOP : Uses a [[Normal Map TOP|Normal Map]] from TOPs to create a 'bump map' effect. Bump-mapping simulates bumps or wrinkles in a surface to give it a 3D depth effect. Your geometry must have tangent attributes created for this feature to work (T[4]). Create these using the [[Attribute Create SOP]].",
                "type": "TOPPar",
                "name": "normalmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapcoordinterp",
                "items": []
            },
            {
                "text": "Float : A multiplier for the 'bump effect' created by the Normal Map parameter.",
                "type": "FloatPar",
                "name": "bumpscale",
                "items": []
            },
            {
                "text": "Toggle : Enables height mapping.",
                "type": "TogglePar",
                "name": "heightmapenable",
                "items": []
            },
            {
                "text": "TOP : Specifies a height texture map. This is equivalent to the Height map in Substance Designer. The height map is used in conjunction with the normal map to perform parallax mapping.",
                "type": "TOPPar",
                "name": "heightmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapcoordinterp",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapchannelsource",
                "items": []
            },
            {
                "text": "Float : Scale value applied to the height map. Can be used to increase or exaggerate the effect.",
                "type": "FloatPar",
                "name": "parallaxscale",
                "items": []
            },
            {
                "text": "Toggle : Enables parallax occlusion, an enhancement of the parallax mapping technique used with the height map. Parallax occlusion improves the quality of the texture offsetting in parallax mapping so that the higher parts of the height map appear to occlude the lower parts, giving a better illusion of height.",
                "type": "TogglePar",
                "name": "parallaxocclusion",
                "items": []
            },
            {
                "text": "Toggle : When Enable Height Map above is On, setting Displace Vertices to On will enable true displacement mapping where the vertices of the geometry are displaced based on the Height Map texture and the parameters below.",
                "type": "TogglePar",
                "name": "displaceverts",
                "items": []
            },
            {
                "text": "Float : A multiplier for the displacement amount.",
                "type": "FloatPar",
                "name": "displacescale",
                "items": []
            },
            {
                "text": "Float : Sets the middle point of displacement map as the start position for the displacement effect.",
                "type": "FloatPar",
                "name": "displacemid",
                "items": []
            },
            {
                "text": "TOP : Specifies a TOP texture that is multiplied with the Emit color parameter of the material. The object must have texture coordinates. The alpha of this map is ignored.",
                "type": "TOPPar",
                "name": "emitmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapcoordinterp",
                "items": []
            },
            {
                "text": "TOP : This map multiplies the alpha of the object. It uses the red channel of the map, other channels are ignored.",
                "type": "TOPPar",
                "name": "alphamap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapcoordinterp",
                "items": []
            },
            {
                "text": "Toggle : Turning this off will make the alpha change depending on orientation of each polygon's normal compared to the camera. Normals that are pointing at the camera will results in the polygon having an alpha of Alpha Front. Normals that are perpendicular to the camera (facing sideways/up/down) will have Alpha Side for their alpha.",
                "type": "TogglePar",
                "name": "alphamode",
                "items": []
            },
            {
                "text": "Float : The opacity of the material. This parameter is multiplied by point alpha of the object (as will as any other alpha source).",
                "type": "FloatPar",
                "name": "alphafront",
                "items": []
            },
            {
                "text": "Float : This is used for non-uniform alpha. It is the alpha value polygons that are facing away from the camera will get.",
                "type": "FloatPar",
                "name": "alphaside",
                "items": []
            },
            {
                "text": "Float : Controls how the alpha changes from Alpha Front to Alpha Side.",
                "type": "FloatPar",
                "name": "rolloff",
                "items": []
            },
            {
                "text": "Toggle : At the end of all of the calculations, the color (RGB) is multiplied by the calculated alpha. You can stop this from happening by turning off this checkbox.",
                "type": "TogglePar",
                "name": "postmultalpha",
                "items": []
            },
            {
                "text": "Toggle : Enables this rim light.",
                "type": "TogglePar",
                "name": "rim1enable",
                "items": []
            },
            {
                "text": "TOP : This map will multiple the calculated rim light color.",
                "type": "TOPPar",
                "name": "rim1map",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapcoordinterp",
                "items": []
            },
            {
                "text": "RGB : The color of the rim light.",
                "type": "RGBPar",
                "name": "rim1colorr",
                "items": []
            },
            {
                "text": "RGB : The color of the rim light.",
                "type": "RGBPar",
                "name": "rim1colorg",
                "items": []
            },
            {
                "text": "RGB : The color of the rim light.",
                "type": "RGBPar",
                "name": "rim1colorb",
                "items": []
            },
            {
                "text": "Float : The center of the rim lights location, situated somewhere on a 360 degree circle.",
                "type": "FloatPar",
                "name": "rim1center",
                "items": []
            },
            {
                "text": "Float : How far from the center the rim light extends.",
                "type": "FloatPar",
                "name": "rim1width",
                "items": []
            },
            {
                "text": "Float : Controls the brightness of the rim light.",
                "type": "FloatPar",
                "name": "rim1strength",
                "items": []
            },
            {
                "text": "TOP : You can specify a horizontal ramp (it will sample the texture at v = 0.5), which controls the the rim lights strength.",
                "type": "TOPPar",
                "name": "rim1strengthramp",
                "items": []
            },
            {
                "text": "Float : This parameter will control how much being in a shadow will change the color of the lighting. At 1 the object will take on the <span class=\"tipTextMAT\">Shadow Color</span> parameter, at 0 it will behave as if it's not in a shadow, even if it is.",
                "type": "FloatPar",
                "name": "shadowstrength",
                "items": []
            },
            {
                "text": "RGB : The color that will be used in shadowed areas.",
                "type": "RGBPar",
                "name": "shadowcolorr",
                "items": []
            },
            {
                "text": "RGB : The color that will be used in shadowed areas.",
                "type": "RGBPar",
                "name": "shadowcolorg",
                "items": []
            },
            {
                "text": "RGB : The color that will be used in shadowed areas.",
                "type": "RGBPar",
                "name": "shadowcolorb",
                "items": []
            },
            {
                "text": "Toggle : The Phong MAT calculates the current brightness of color of the objects, after taking into account lights, rim lights, emission etc. It then uses this brightness (between 0-1) and fades in the <span class=\"tipTextMAT\">Darkness Emit Color</span>. The darker the area, the more of the darkness emit color that will be applied.",
                "type": "TogglePar",
                "name": "darknessemit",
                "items": []
            },
            {
                "text": "RGB : The color that is used for areas that are in darkness.",
                "type": "RGBPar",
                "name": "darknessemitcolorr",
                "items": []
            },
            {
                "text": "RGB : The color that is used for areas that are in darkness.",
                "type": "RGBPar",
                "name": "darknessemitcolorg",
                "items": []
            },
            {
                "text": "RGB : The color that is used for areas that are in darkness.",
                "type": "RGBPar",
                "name": "darknessemitcolorb",
                "items": []
            },
            {
                "text": "TOP : This map multiplies the <span class=\"tipTextMAT\">Darkness Emit Color</span>. This maps alpha is not used.",
                "type": "TOPPar",
                "name": "darknessemitmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapcoordinterp",
                "items": []
            },
            {
                "text": "Toggle : This cause the camera space depth of the pixel to be written to the alpha channel of the output TOP. This value can be useful for post-processing effects, but ofcourse you will not have the result of all the alpha calculations if you turn this on (although they'll get used to multiply the output color, assuming <span class=\"tipTextMAT\">Post-Mult Color by Alpha</span> is enabled.",
                "type": "TogglePar",
                "name": "writecameradepthtoalpha",
                "items": []
            },
            {
                "text": "Toggle : Normally the color attribute (Cd[4]) coming from the SOP is used in the lighting calculation, you can turn off using the color attribute by un-checking this parameter.",
                "type": "TogglePar",
                "name": "applypointcolor",
                "items": []
            },
            {
                "text": "StrMenu : When provider per-instance textures in the [[Geometry COMP]], this parameter selects which map the instance texture will be applied as.",
                "type": "StrMenuPar",
                "name": "instancetexture",
                "items": []
            },
            {
                "text": "StrMenu : Allows sending things like normals or emit color to different Render TOP color buffers in a single pass.",
                "type": "StrMenuPar",
                "name": "colorbuffer1rgb",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "short": "The PBR MAT creates a material using a Physically Based Rendering (PBR) lighting model.",
        "opLicense": "Non-Commercial",
        "opFamily": "MAT",
        "opFilter": "False",
        "opLabel": "PBR",
        "opClass": "pbrMAT_Class",
        "opType": "pbr",
        "long": "The PBR MAT creates a material using a Physically Based Rendering (PBR) lighting model. It has support for textures, reflections, bumps, cone lights, rim lights, alpha maps and more. \t\t\t\n\t\t\t\t\nIt also supports most [https://substance3d.adobe.com/community-assets Adobe Substance 3D Designer] PBR materials loaded in the [[Substance TOP]]. \t\t\t\t\n\t\t\t\t\nYou can output its [[:Category:GLSL|GLSL shader]] into two [[DAT]]s for further adaptation in a [[GLSL MAT]] by using the Output Shader parameter.\t\t\t\t\n\t\t\t\t\nThis OP creates physically based materials from texture maps you assign to it and works with any content pipeline whether you use Maya, Houdini, Unreal, Photoshop etc.\n\nYou can get more PBR materials from PBR texture libraries such as [http://quixel.se/ Quixel] and [http://www.poliigon.com/ Poliigon] and [https://gametextures.com/freebies Game Textures].\nSee also: [[Substance TOP]].",
        "opCategories": ""
    },
    "phongMAT": {
        "label": "phongMAT",
        "members": [
            {
                "text": "Toggle : Uses the Diffuse parameter for Ambient when checked.",
                "type": "TogglePar",
                "name": "ambdiff",
                "items": []
            },
            {
                "text": "RGB : The color of the diffuse light reflected from the material.",
                "type": "RGBPar",
                "name": "diffr",
                "items": []
            },
            {
                "text": "RGB : The color of the diffuse light reflected from the material.",
                "type": "RGBPar",
                "name": "diffg",
                "items": []
            },
            {
                "text": "RGB : The color of the diffuse light reflected from the material.",
                "type": "RGBPar",
                "name": "diffb",
                "items": []
            },
            {
                "text": "RGB : The color of the ambient light reflected from the material.",
                "type": "RGBPar",
                "name": "ambr",
                "items": []
            },
            {
                "text": "RGB : The color of the ambient light reflected from the material.",
                "type": "RGBPar",
                "name": "ambg",
                "items": []
            },
            {
                "text": "RGB : The color of the ambient light reflected from the material.",
                "type": "RGBPar",
                "name": "ambb",
                "items": []
            },
            {
                "text": "RGB : The color of the specular light reflected from the material. This changes the color of the highlights on shiney objects.",
                "type": "RGBPar",
                "name": "specr",
                "items": []
            },
            {
                "text": "RGB : The color of the specular light reflected from the material. This changes the color of the highlights on shiney objects.",
                "type": "RGBPar",
                "name": "specg",
                "items": []
            },
            {
                "text": "RGB : The color of the specular light reflected from the material. This changes the color of the highlights on shiney objects.",
                "type": "RGBPar",
                "name": "specb",
                "items": []
            },
            {
                "text": "RGB : This is the color that the material will emit even if there is no light.",
                "type": "RGBPar",
                "name": "emitr",
                "items": []
            },
            {
                "text": "RGB : This is the color that the material will emit even if there is no light.",
                "type": "RGBPar",
                "name": "emitg",
                "items": []
            },
            {
                "text": "RGB : This is the color that the material will emit even if there is no light.",
                "type": "RGBPar",
                "name": "emitb",
                "items": []
            },
            {
                "text": "RGB : Adds to the final color. Where there are point colors, finalcolor += Point Color * Constant Color. This behaves like there is ambient illumination of 1 1 1. It is not affected by textures or transparency.",
                "type": "RGBPar",
                "name": "constantr",
                "items": []
            },
            {
                "text": "RGB : Adds to the final color. Where there are point colors, finalcolor += Point Color * Constant Color. This behaves like there is ambient illumination of 1 1 1. It is not affected by textures or transparency.",
                "type": "RGBPar",
                "name": "constantg",
                "items": []
            },
            {
                "text": "RGB : Adds to the final color. Where there are point colors, finalcolor += Point Color * Constant Color. This behaves like there is ambient illumination of 1 1 1. It is not affected by textures or transparency.",
                "type": "RGBPar",
                "name": "constantb",
                "items": []
            },
            {
                "text": "Float : Controls the specular highlights (glossyness) of an object. Higher settings are more glossy, like plastic or shiny metal. Lower settings give more of a matte finish.",
                "type": "FloatPar",
                "name": "shininess",
                "items": []
            },
            {
                "text": "TOP : Specifies a TOP texture that is multiplied by the results of all of the lighting calculations. The alpha of this map is used as a part of calculating the objects alpha.  Clicking on the arrows to the right of the map field will open the [[Texture Sampling Parameters]] for Color Map.  The other Map parameters below will have their own Texture Sampling Parameters as well.",
                "type": "TOPPar",
                "name": "colormap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapcoordinterp",
                "items": []
            },
            {
                "text": "TOP : Uses a [[Normal Map TOP|Normal Map]] from TOPs to create a 'bump map' effect. Bump-mapping simulates bumps or wrinkles in a surface to give it a 3D depth effect. '''Your geometry must have tangent attributes created for this feature to work (T[4]). Create these using the [[Attribute Create SOP]].'''",
                "type": "TOPPar",
                "name": "normalmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "normalmapcoordinterp",
                "items": []
            },
            {
                "text": "Float : A multiplier for the 'bump effect' created by the Normal Map parameter.",
                "type": "FloatPar",
                "name": "bumpscale",
                "items": []
            },
            {
                "text": "Toggle : Enables height mapping.",
                "type": "TogglePar",
                "name": "heightmapenable",
                "items": []
            },
            {
                "text": "TOP : Specifies a height texture map. The height map is used in conjunction with the normal map to perform parallax mapping.",
                "type": "TOPPar",
                "name": "heightmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapcoordinterp",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "heightmapchannelsource",
                "items": []
            },
            {
                "text": "Float : Scale value applied to the height map. Can be used to increase or exaggerate the effect.",
                "type": "FloatPar",
                "name": "parallaxscale",
                "items": []
            },
            {
                "text": "Toggle : Enables parallax occlusion, an enhancement of the parallax mapping technique used with the height map. Parallax occlusion improves the quality of the texture offsetting in parallax mapping so that the higher parts of the height map appear to occlude the lower parts, giving a better illusion of height.",
                "type": "TogglePar",
                "name": "parallaxocclusion",
                "items": []
            },
            {
                "text": "Toggle : When Enable Height Map above is On, setting Displace Vertices to On will enable true displacement mapping where the vertices of the geometry are displaced based on the Height Map texture and the parameters below.",
                "type": "TogglePar",
                "name": "displaceverts",
                "items": []
            },
            {
                "text": "Float : A multiplier for the displacement amount.",
                "type": "FloatPar",
                "name": "displacescale",
                "items": []
            },
            {
                "text": "Float : Sets the middle point of displacement map as the start position for the displacement effect.",
                "type": "FloatPar",
                "name": "displacemid",
                "items": []
            },
            {
                "text": "TOP : Specifies a TOP that multiples the Diffuse Color. The object must have texture coordinates. The alpha of this map is ignored.",
                "type": "TOPPar",
                "name": "diffusemap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "diffusemapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "diffusemapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "diffusemapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "diffusemapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "diffusemapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "diffusemapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "diffusemapcoordinterp",
                "items": []
            },
            {
                "text": "TOP : Specifies a TOP texture that is multiplied with the Specular color parameter of the material. The object must have texture coordinates. The alpha of this map is ignored.",
                "type": "TOPPar",
                "name": "specmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "specmapcoordinterp",
                "items": []
            },
            {
                "text": "TOP : Specifies a TOP texture that is multiplied with the Emit color parameter of the material. The object must have texture coordinates. The alpha of this map is ignored.",
                "type": "TOPPar",
                "name": "emitmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "emitmapcoordinterp",
                "items": []
            },
            {
                "text": "TOP : Uses a TOP texture to define an environment map for the material. Environment mapping simulates an object reflecting its surroundings. The TOP defined in this parameter is the texture that will be reflected. The Env Map is added to whatever the normal lighting will be, so to make an object purely reflective turn the Diffuse and Specular parameters to 0. This input expects a sphere map. An example of a sphere map can be found [http://debevec.org/Probes/campus_probe.jpg here]. This input will also accept a cube map, created with the [[Cube Map TOP]] or the [[Render TOP]]'s Render Cube Map parameter.",
                "type": "TOPPar",
                "name": "envmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "envmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "envmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "envmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "envmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "envmapanisotropy",
                "items": []
            },
            {
                "text": "RGB : This color is multiplied with the texture specified by the <span class=\"tipTextMAT\">Environment Map</span> parameter above.",
                "type": "RGBPar",
                "name": "envmapcolorr",
                "items": []
            },
            {
                "text": "RGB : This color is multiplied with the texture specified by the <span class=\"tipTextMAT\">Environment Map</span> parameter above.",
                "type": "RGBPar",
                "name": "envmapcolorg",
                "items": []
            },
            {
                "text": "RGB : This color is multiplied with the texture specified by the <span class=\"tipTextMAT\">Environment Map</span> parameter above.",
                "type": "RGBPar",
                "name": "envmapcolorb",
                "items": []
            },
            {
                "text": "XYZ : Rotate the texture specified by the <span class=\"tipTextMAT\">Environment Map</span> parameter above.",
                "type": "XYZPar",
                "name": "envmaprotatex",
                "items": []
            },
            {
                "text": "XYZ : Rotate the texture specified by the <span class=\"tipTextMAT\">Environment Map</span> parameter above.",
                "type": "XYZPar",
                "name": "envmaprotatey",
                "items": []
            },
            {
                "text": "XYZ : Rotate the texture specified by the <span class=\"tipTextMAT\">Environment Map</span> parameter above.",
                "type": "XYZPar",
                "name": "envmaprotatez",
                "items": []
            },
            {
                "text": "Menu : Select between using a sphere map or an equirectangular map as the Environment Map type.",
                "type": "MenuPar",
                "name": "envmaptype2d",
                "items": []
            },
            {
                "text": "Menu : Controls how the polygon's normal is used to light the front face of the polygon. For more information refer to the [[Two-Sided Lighting]] article.",
                "type": "MenuPar",
                "name": "frontfacelit",
                "items": []
            },
            {
                "text": "Menu : Controls how the polygon's normal is used to light the back face of the polygon. For more information refer to the [[Two-Sided Lighting]] article.",
                "type": "MenuPar",
                "name": "backfacelit",
                "items": []
            },
            {
                "text": "Pulse : This button will bring up a dialog that will create a [[GLSL MAT]] and [[Text DAT]]s with shader code that matches whatever effect this Phong MAT is currently creating. Since shaders are dependent on the number and type of lights, it will list some possible different shader choices, based on what lighting configurations have been used in the current system. '''If no shaders are listed in the dialog''', it means no shader has been rendered in the current session of TouchDesigner. Turn on the viewer for the Phong MAT, or setup a render in a Render TOP. That will create/compile some shaders and will cause the list to be populated. For example if you want to see a shader that does shadow mapping, setup a render that does shadow mapping and you will see that come up in the list.",
                "type": "PulsePar",
                "name": "outputshader",
                "items": []
            },
            {
                "text": "TOP : This map multiplies the alpha of the object. It uses the red channel of the map, other channels are ignored.",
                "type": "TOPPar",
                "name": "alphamap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "alphamapcoordinterp",
                "items": []
            },
            {
                "text": "Toggle : Turning this off will make the alpha change depending on orientation of each polygon's normal compared to the camera. Normals that are pointing at the camera will results in the polygon having an alpha of Alpha Front. Normals that are perpendicular to the camera (facing sideways/up/down) will have Alpha Side for their alpha.",
                "type": "TogglePar",
                "name": "alphamode",
                "items": []
            },
            {
                "text": "Float : The opacity of the material. This parameter is multiplied by point alpha of the object (as will as any other alpha source).",
                "type": "FloatPar",
                "name": "alphafront",
                "items": []
            },
            {
                "text": "Float : This is used for non-uniform alpha. It is the alpha value polygons that are facing away from the camera will get.",
                "type": "FloatPar",
                "name": "alphaside",
                "items": []
            },
            {
                "text": "Float : Controls how the alpha changes from Alpha Front to Alpha Side.",
                "type": "FloatPar",
                "name": "rolloff",
                "items": []
            },
            {
                "text": "Toggle : At the end of all of the calculations, the color (RGB) is multiplied by the calculated alpha. You can stop this from happening by turning off this toggle.",
                "type": "TogglePar",
                "name": "postmultalpha",
                "items": []
            },
            {
                "text": "Toggle : When this is enabled, the luminance of the lighting will be multiplied by the alpha, to decrease/increase it.",
                "type": "TogglePar",
                "name": "alphamultlight",
                "items": []
            },
            {
                "text": "Toggle : Enables multi-texturing. This disables the Color Map parameter.",
                "type": "TogglePar",
                "name": "multitexturing",
                "items": []
            },
            {
                "text": "TOP : You can specify up to 4 textures for multi-texturing.",
                "type": "TOPPar",
                "name": "texture1",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture1mapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture1mapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture1mapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture1mapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture1mapanisotropy",
                "items": []
            },
            {
                "text": "Menu : Specifies which texture coordinate to use for the map.",
                "type": "MenuPar",
                "name": "texture1coord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture1coordinterp",
                "items": []
            },
            {
                "text": "TOP : You can specify up to 4 textures for multi-texturing.",
                "type": "TOPPar",
                "name": "texture2",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture2mapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture2mapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture2mapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture2mapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture2mapanisotropy",
                "items": []
            },
            {
                "text": "Menu : Specifies which texture coordinate to use for the map.",
                "type": "MenuPar",
                "name": "texture2coord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture2coordinterp",
                "items": []
            },
            {
                "text": "TOP : You can specify up to 4 textures for multi-texturing.",
                "type": "TOPPar",
                "name": "texture3",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture3mapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture3mapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture3mapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture3mapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture3mapanisotropy",
                "items": []
            },
            {
                "text": "Menu : Specifies which texture coordinate to use for the map.",
                "type": "MenuPar",
                "name": "texture3coord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture3coordinterp",
                "items": []
            },
            {
                "text": "TOP : You can specify up to 4 textures for multi-texturing.",
                "type": "TOPPar",
                "name": "texture4",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture4mapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture4mapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture4mapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture4mapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture4mapanisotropy",
                "items": []
            },
            {
                "text": "Menu : Specifies which texture coordinate to use for the map.",
                "type": "MenuPar",
                "name": "texture4coord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "texture4coordnterp",
                "items": []
            },
            {
                "text": "Str : GLSL code that combines the texture images (look to the start of this section for more details). This parameter can be left blank (which means the maps will just be multiplied together).",
                "type": "StrPar",
                "name": "multitexexpr",
                "items": []
            },
            {
                "text": "Toggle : Enables this rim light.",
                "type": "TogglePar",
                "name": "rim1enable",
                "items": []
            },
            {
                "text": "TOP : This map will multiple the calculated rim light color.",
                "type": "TOPPar",
                "name": "rim1map",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "rim1mapcoordinterp",
                "items": []
            },
            {
                "text": "RGB : The color of the rim light.",
                "type": "RGBPar",
                "name": "rim1colorr",
                "items": []
            },
            {
                "text": "RGB : The color of the rim light.",
                "type": "RGBPar",
                "name": "rim1colorg",
                "items": []
            },
            {
                "text": "RGB : The color of the rim light.",
                "type": "RGBPar",
                "name": "rim1colorb",
                "items": []
            },
            {
                "text": "Float : The center of the rim lights location, situated somewhere on a 360 degree circle.",
                "type": "FloatPar",
                "name": "rim1center",
                "items": []
            },
            {
                "text": "Float : How far from the center the rim light extends.",
                "type": "FloatPar",
                "name": "rim1width",
                "items": []
            },
            {
                "text": "Float : Controls the brightness of the rim light.",
                "type": "FloatPar",
                "name": "rim1strength",
                "items": []
            },
            {
                "text": "TOP : You can specify a horizontal ramp (it will sample the texture at v = 0.5), which controls the the rim lights strength.",
                "type": "TOPPar",
                "name": "rim1strengthramp",
                "items": []
            },
            {
                "text": "Float : This parameter will control how much being in a shadow will change the color of the lighting. At 1 the object will take on the <span class=\"tipTextMAT\">Shadow Color</span> parameter, at 0 it will behave as if it's not in a shadow, even if it is.",
                "type": "FloatPar",
                "name": "shadowstrength",
                "items": []
            },
            {
                "text": "RGB : The color that will be used in shadowed areas.",
                "type": "RGBPar",
                "name": "shadowcolorr",
                "items": []
            },
            {
                "text": "RGB : The color that will be used in shadowed areas.",
                "type": "RGBPar",
                "name": "shadowcolorg",
                "items": []
            },
            {
                "text": "RGB : The color that will be used in shadowed areas.",
                "type": "RGBPar",
                "name": "shadowcolorb",
                "items": []
            },
            {
                "text": "Toggle : The Phong MAT calculates the current brightness of color of the objects, after taking into account lights, rim lights, emission etc. It then uses this brightness (between 0-1) and fades in the <span class=\"tipTextMAT\">Darkness Emit Color</span>. The darker the area, the more of the darkness emit color that will be applied.",
                "type": "TogglePar",
                "name": "darknessemit",
                "items": []
            },
            {
                "text": "RGB : The color that is used for areas that are in darkness.",
                "type": "RGBPar",
                "name": "darknessemitcolorr",
                "items": []
            },
            {
                "text": "RGB : The color that is used for areas that are in darkness.",
                "type": "RGBPar",
                "name": "darknessemitcolorg",
                "items": []
            },
            {
                "text": "RGB : The color that is used for areas that are in darkness.",
                "type": "RGBPar",
                "name": "darknessemitcolorb",
                "items": []
            },
            {
                "text": "TOP : This map multiplies the <span class=\"tipTextMAT\">Darkness Emit Color</span>. This maps alpha is not used.",
                "type": "TOPPar",
                "name": "darknessemitmap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapanisotropy",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapcoord",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "darknessemitmapcoordinterp",
                "items": []
            },
            {
                "text": "RGB : Adds a secondary specular highlight color.",
                "type": "RGBPar",
                "name": "spec2r",
                "items": []
            },
            {
                "text": "RGB : Adds a secondary specular highlight color.",
                "type": "RGBPar",
                "name": "spec2g",
                "items": []
            },
            {
                "text": "RGB : Adds a secondary specular highlight color.",
                "type": "RGBPar",
                "name": "spec2b",
                "items": []
            },
            {
                "text": "Float : Controls the secondary specular highlights (glossyness) of an object. Higher settings are more glossy, like plastic or shiny metal. Lower settings give more of a matte finish.",
                "type": "FloatPar",
                "name": "shininess2",
                "items": []
            },
            {
                "text": "Toggle : This causes the camera space depth of the pixel to be written to the alpha channel of the output TOP. This value can be useful for post-processing effects, but ofcourse you will not have the result of all the alpha calculations if you turn this on (although they'll get used to multiply the output color, assuming <span class=\"tipTextMAT\">Post-Mult Color by Alpha</span> is enabled.",
                "type": "TogglePar",
                "name": "writecameradepthtoalpha",
                "items": []
            },
            {
                "text": "Toggle : Normally the color attribute (Cd[4]) coming from the SOP is used in the lighting calculation, you can turn off using the color attribute by un-checking this parameter.",
                "type": "TogglePar",
                "name": "applypointcolor",
                "items": []
            },
            {
                "text": "StrMenu : When provider per-instance textures in the [[Geometry COMP]], this parameter selects which map the instance texture will be applied as.",
                "type": "StrMenuPar",
                "name": "instancetexture",
                "items": []
            },
            {
                "text": "StrMenu : Allows sending things like normals or diffuse color to different Render TOP color buffers in a single pass.",
                "type": "StrMenuPar",
                "name": "colorbuffer1rgb",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Phong",
        "opFamily": "MAT",
        "long": "The Phong MAT creates a material using the Phong Shading model. It has support for textures, reflections, bumps, cone lights, rim lights, alpha maps and more. You can output its [[:Category:GLSL|GLSL shader]] into two [[DAT]]s for further adaptation in a [[GLSL MAT]] by using the Output Shader parameter.\t\t\t\n\t\t\t\t\nPhong Shading models three types of reflected light:\t\t\t\t\n\t\t\t\t\n* Ambient - Ambient is considered light that does not come from any particular direction and is therefore constant across the surface. In the physical world, ambient light is created from the reflection of light off surfaces in the environment.\t\t\t\t\n* Diffuse - Diffuse models the light reflected by matte surfaces. This light is reflected equally in all directions, therefore the position of the observer does not effect the percieved illumination.\t\t\t\t\n* Specular - Specular models the light reflected by glossy surfaces. This light is reflected mainly in the direction of the reflected ray and is attenuated by the 'shiny-ness' of an object. Since the light reflected from the surface is mainly in the direction of the reflected ray, the position of the observer determines the specular highlight on the surface.\t\t\t\t\n\t\t\t\t\n<blockquote>\t\t\t\t\n'''NOTE:''' We see the color of an object because of the color of light that the material reflects.\t\n</blockquote>\t\t\t\t\n\t\t\t\t\nPhong Shading produces very nice specular highlights, although it is still an approximation and not physically accurate.  Contrasting with the Gouraud shading model that calculates the lighting at each vertex and interpolates the value across the polygon, Phong calculates the lighting at each pixel.\n\nTo see how all of the different parts are summed together by looking at the [[Phong Lighting Equation]] article.",
        "opClass": "phongMAT_Class",
        "short": "The Phong MAT creates a material using the Phong Shading model.",
        "opType": "phong",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "pointspriteMAT": {
        "label": "pointspriteMAT",
        "members": [
            {
                "text": "RGB : The color of the light reflected from the material.",
                "type": "RGBPar",
                "name": "colorr",
                "items": []
            },
            {
                "text": "RGB : The color of the light reflected from the material.",
                "type": "RGBPar",
                "name": "colorg",
                "items": []
            },
            {
                "text": "RGB : The color of the light reflected from the material.",
                "type": "RGBPar",
                "name": "colorb",
                "items": []
            },
            {
                "text": "Float : The opacity of the material. This parameter is multiplied by point alpha of the object.",
                "type": "FloatPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Toggle : Enable/disable multiplying color by alpha.",
                "type": "TogglePar",
                "name": "postmultalpha",
                "items": []
            },
            {
                "text": "TOP : The color map to apply to the sprites. The Color Map will be multiplied by the color of the sprites. The Color Map parameter can also take 3D / 2D Texture Arrays (from the [[Texture 3D TOP]] for example), and the w texture coordinate will select the correct map from the array.\t\t\n\t\t\t\t\nThe final size of the point sprite is controlled by the pscale point attribute (if present) getting multiplied of the result of the next 6 parameters. There are two types of scale this MAT can apply, and they are blended using the Attenuate Point Scale parameter to create one final point scale (which is multiplied by pscale).",
                "type": "TOPPar",
                "name": "colormap",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapextendu",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapextendv",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapextendw",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapfilter",
                "items": []
            },
            {
                "text": "Menu : ",
                "type": "MenuPar",
                "name": "colormapanisotropy",
                "items": []
            },
            {
                "text": "Float : Crop the left side of the sprites.",
                "type": "FloatPar",
                "name": "offsetleft",
                "items": []
            },
            {
                "text": "Float : Crop the right side of the sprites.",
                "type": "FloatPar",
                "name": "offsetright",
                "items": []
            },
            {
                "text": "Float : Crop the bottom side of the sprites.",
                "type": "FloatPar",
                "name": "offsetbottom",
                "items": []
            },
            {
                "text": "Float : Crop the top side of the sprites.",
                "type": "FloatPar",
                "name": "offsettop",
                "items": []
            },
            {
                "text": "Float : A constant value that is applied to all points evenly. When Attenuate Point Scale is 0, the point sprite size will be pscale * this value.",
                "type": "FloatPar",
                "name": "pointscale",
                "items": []
            },
            {
                "text": "Float : This value blends between the Constant Point Scale and the Attenuated Point Scale. 0 means 100% constant point scale and 1 means 100% attenuated point scale.\t\t\n\t\t\t\t\nPoints that are closer than or at the Near distance from the camera will use the Near Point Scale, points between the Near Distance and Far Distance will use a blended scale between the Near Point Scale and the Far Point Scale. Points farther than the Far Point Distance will use the Far Point Scale.",
                "type": "FloatPar",
                "name": "attenpscale",
                "items": []
            },
            {
                "text": "Float : Points that are closer than or at this distance from the camera will use the Near Point Scale Parameter.",
                "type": "FloatPar",
                "name": "attennear",
                "items": []
            },
            {
                "text": "Float : Points that are farther than or at this distance from the camera will use the Far Point Scale Parameter.",
                "type": "FloatPar",
                "name": "attenfar",
                "items": []
            },
            {
                "text": "Float : This point scale is applied at the near distance.",
                "type": "FloatPar",
                "name": "attensizenear",
                "items": []
            },
            {
                "text": "Float : This point scale is applied at the far distance.",
                "type": "FloatPar",
                "name": "attensizefar",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Point Sprite",
        "opFamily": "MAT",
        "long": "The Point Sprite MAT allows you to control some attributes of Point Sprites (creatable using the [[Particle SOP]], [[DAT to SOP]], or [[Convert SOP]]). You can apply color, a color map, change the size of the created point sprite from a square to a rectangle, and scale the size of the point sprite.\t\t\t\n\t\t\t\t\nA point sprite's final size controls the number of pixels wide/high it is, regardless of how far it is from the camera (unless you are using attenuation).",
        "opClass": "pointspriteMAT_Class",
        "short": "The Point Sprite MAT allows you to control some attributes of Point Sprites (creatable using the [[Particle SOP]] or [[DAT to SOP]]).",
        "opType": "pointsprite",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "selectMAT": {
        "label": "selectMAT",
        "members": [
            {
                "text": "MAT : The path to the MAT being selected.",
                "type": "MATPar",
                "name": "selectmat",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Select",
        "opFamily": "MAT",
        "long": "The Select MAT gets another material from any location in the project.",
        "opClass": "selectMAT_Class",
        "short": "The Select MAT gets another material from any location in the project.",
        "opType": "select",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "switchMAT": {
        "label": "switchMAT",
        "members": [
            {
                "text": "Int : Selects which input to use. The first input is 0.",
                "type": "IntPar",
                "name": "index",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "True",
        "opLabel": "Switch",
        "opFamily": "MAT",
        "long": "The Switch MAT allows you to switch between multiple materials.",
        "opClass": "switchMAT_Class",
        "short": "The Switch MAT allows you to switch between multiple materials.",
        "opType": "switch",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    },
    "wireframeMAT": {
        "label": "wireframeMAT",
        "members": [
            {
                "text": "RGB : The color of the light reflected from the material.",
                "type": "RGBPar",
                "name": "colorr",
                "items": []
            },
            {
                "text": "RGB : The color of the light reflected from the material.",
                "type": "RGBPar",
                "name": "colorg",
                "items": []
            },
            {
                "text": "RGB : The color of the light reflected from the material.",
                "type": "RGBPar",
                "name": "colorb",
                "items": []
            },
            {
                "text": "Float : The opacity of the material. This parameter is multiplied by point alpha of the object.",
                "type": "FloatPar",
                "name": "alpha",
                "items": []
            },
            {
                "text": "Menu : Controls what wireframes are rendered.",
                "type": "MenuPar",
                "name": "wireframemode",
                "items": []
            },
            {
                "text": "Float : The width of the lines displayed in wireframe.",
                "type": "FloatPar",
                "name": "linewidth",
                "items": []
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "opFilter": "False",
        "opLabel": "Wireframe",
        "opFamily": "MAT",
        "long": "The Wireframe MAT renders the edges of polygons and curves as lines.",
        "opClass": "wireframeMAT_Class",
        "short": "The Wireframe MAT renders the edges of polygons and curves as lines.",
        "opType": "wireframe",
        "opLicense": "Non-Commercial",
        "opCategories": ""
    }
}