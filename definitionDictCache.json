{
    "abletonlinkCHOP": {
        "label": "abletonlinkCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "AbsTime": {
        "label": "AbsTime",
        "members": [
            {
                "class": "AbsTime",
                "name": "frame",
                "type": "float",
                "set": "0",
                "text": "Absolute total number of frames played since the application started.  Paused only with the power On/Off or with power()\n<syntaxhighlight lang=python>\nExample: absTime.frame\nExample: tdu.rand(absTime.frame + .1) # a unique random number that is consistent across all nodes, changing every frame\n</syntaxhighlight>"
            },
            {
                "class": "AbsTime",
                "name": "seconds",
                "type": "float",
                "set": "0",
                "text": "Absolute total seconds played since the application started. Paused only with the power On/Off or with power()."
            },
            {
                "class": "AbsTime",
                "name": "step",
                "type": "float",
                "set": "0",
                "text": "Number of absolute frames elapsed between start of previous and current frame. When this value is greater than 1, the system is dropping frames."
            },
            {
                "class": "AbsTime",
                "name": "stepSeconds",
                "type": "float",
                "set": "0",
                "text": "Absolute time elapsed between start of previous and current frame."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "This class contains information on the \"[[Absolute Time|absolute time]]\", the time TouchDesigner has been running since the process started.  It can be accessed with the abstime object, found in the automatically imported [[td Module|td module]]. It is paused only with the power on/off button at the top of the UI, or with the power() method in the [[td Module|td module]]. Absolute time is the same for all nodes and is not affected by the pausing any component's timeline. See  [http://en.wikipedia.org/wiki/Absolute_time_and_space absolute time]."
    },
    "Actors": {
        "label": "Actors",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The Actors Class describes the set of all [[Actor COMP|Actor COMPs]] used by the [[Bullet Solver COMP]] and [[Nvidia Flex Solver COMP]]. It can be accessed with a Bullet Solver COMP. It can be accessed much like a Python list.\n<syntaxhighlight lang=python>\nactors = op('bsolver1').actors\t# get the Actors object\nprint(len(actors))\t\t\t\t# number of Actors \nprint(actors[0])\t\t\t\t# first Actor component in the list\nfor a in actors:\n\tprint(a)\t\t\t\t\t# print all Actors\n</syntaxhighlight>"
    },
    "addSOP": {
        "label": "addSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "addTOP": {
        "label": "addTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "alembicSOP": {
        "label": "alembicSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "alignSOP": {
        "label": "alignSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "ambientlightCOMP": {
        "label": "ambientlightCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "analyzeCHOP": {
        "label": "analyzeCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "analyzeTOP": {
        "label": "analyzeTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "angleCHOP": {
        "label": "angleCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "animationCOMP": {
        "label": "animationCOMP",
        "members": [],
        "methods": [
            {
                "text": "Add or set a keyframe in an animation channel.\n*position - The position along the x-axis of the animation channel.\n*channel - (Optional) The channel to modify. Wildcards and patterns are supported. By default all channels are modified.\n*value - (Keyword, Optional) The channel value at the keyframe.  If not specified, and no keyframe exists at that location, one is added such that the shape of the channel is preserved.\n*function - (Keyword, Optional) The keyframe interpolation function.",
                "returns": "None",
                "name": "setKeyframe",
                "call": "setKeyframe(position, channel='*', value=None, function=None)",
                "class": "animationCOMP"
            },
            {
                "text": "Remove a keyframe from an animation channel.\n*position - The position along the x-axis of the animation channel.\n*channel - (Optional) The channel to modify. Wildcards and patterns are supported. By default all channels are modified.\n<syntaxhighlight lang=python>\nn = op('animation1')\nn.deleteKeyframe(50) # remove keyframe on all channels\nn.deleteKeyframe(75, channel='tz') # modify specific keyframe\n</syntaxhighlight>",
                "returns": "None",
                "name": "deleteKeyframe",
                "call": "deleteKeyframe(position, channel='*', value=None, function=None)",
                "class": "animationCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "COMP"
        ]
    },
    "antialiasTOP": {
        "label": "antialiasTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "App": {
        "label": "App",
        "members": [
            {
                "class": "App",
                "name": "architecture",
                "type": "str",
                "set": "0",
                "text": "The architecture of the compile.  Generally 32 or 64 bit."
            },
            {
                "class": "App",
                "name": "binFolder",
                "type": "str",
                "set": "0",
                "text": "Installation folder containing the binaries."
            },
            {
                "class": "App",
                "name": "build",
                "type": "str",
                "set": "0",
                "text": "Application build number."
            },
            {
                "class": "App",
                "name": "compileDate",
                "type": "tuple(year, month, day)",
                "set": "0",
                "text": "The date the application was compiled, expressed as a tuple (year, month, day)."
            },
            {
                "class": "App",
                "name": "configFolder",
                "type": "str",
                "set": "0",
                "text": "Installation folder containing configuration files."
            },
            {
                "class": "App",
                "name": "desktopFolder",
                "type": "str",
                "set": "0",
                "text": "Current user's desktop folder."
            },
            {
                "class": "App",
                "name": "enableOptimizedExprs",
                "type": "bool",
                "set": "1",
                "text": "Get or set if Python expression optimization is enabled. Defaults to True every time TouchDesigner starts."
            },
            {
                "class": "App",
                "name": "experimental",
                "type": "bool",
                "set": "0",
                "text": "Returns true if the App is an experimental build, false otherwise."
            },
            {
                "class": "App",
                "name": "installFolder",
                "type": "str",
                "set": "0",
                "text": "Main installation folder."
            },
            {
                "class": "App",
                "name": "launchTime",
                "type": "float",
                "set": "0",
                "text": "Total time required to launch and begin playing the toe file, measured in seconds."
            },
            {
                "class": "App",
                "name": "logExtensionCompiles",
                "type": "bool",
                "set": "1",
                "text": "Get or set if extra messages for starting and ending compiling extensions is sent to the textport. Additional error stack will be printed if compilation fails.  Defaults to False every time TouchDesigner starts."
            },
            {
                "class": "App",
                "name": "osName",
                "type": "str",
                "set": "0",
                "text": "The operating system name."
            },
            {
                "class": "App",
                "name": "osVersion",
                "type": "str",
                "set": "0",
                "text": "The operating system version."
            },
            {
                "class": "App",
                "name": "power",
                "type": "bool",
                "set": "1",
                "text": "Get or set the overall processing state of the process. When True, processing is enabled.  When False processing is halted. This is identical to pressing the power button on the main interface. This has a greater effect than simply pausing or stopping the playbar.\n<syntaxhighlight lang=python>\napp.power = False #turn off the power button.\n</syntaxhighlight>"
            },
            {
                "class": "App",
                "name": "preferencesFolder",
                "type": "str",
                "set": "0",
                "text": "Folder where the preferences file is located."
            },
            {
                "class": "App",
                "name": "product",
                "type": "str",
                "set": "0",
                "text": "Type of executable the project is running under. Values are 'TouchDesigner', 'TouchPlayer' or 'TouchEngine'."
            },
            {
                "class": "App",
                "name": "recentFiles",
                "type": "list",
                "set": "1",
                "text": "Get or set the list of most recently saved or loaded files."
            },
            {
                "class": "App",
                "name": "samplesFolder",
                "type": "str",
                "set": "0",
                "text": "Installation folder containing configuration files."
            },
            {
                "class": "App",
                "name": "paletteFolder",
                "type": "str",
                "set": "0",
                "text": "Installation folder containing palette files."
            },
            {
                "class": "App",
                "name": "userPaletteFolder",
                "type": "str",
                "set": "0",
                "text": "Folder where custom user palettes are located."
            },
            {
                "class": "App",
                "name": "version",
                "type": "str",
                "set": "0",
                "text": "Application version number."
            },
            {
                "class": "App",
                "name": "windowColorBits",
                "type": "int",
                "set": "0",
                "text": "The number of color bits per color channel the TouchDesigner window is running at. By default this will be 8-bits per channel, but can be increased to 10-bits by settings env var TOUCH_10_BIT_COLOR=1. Only works on displays that support 10-bit color."
            }
        ],
        "methods": [
            {
                "class": "App",
                "name": "addNonCommercialLimit",
                "call": "addNonCommercialLimit(password)",
                "returns": "None",
                "text": "Limits the application to operate at non-commercial license level. Multiple calls can be made, but each can be undone with a  matching removeNonCommercialLimit(password).  If the password is blank the operation cannot be undone. (See also [[Licenses Class|licenses.disablePro]]) member.\n*password - (Keyword, Optional) Password to later remove the restriction.\n<syntaxhighlight lang=python>\napp.addNonCommercialLimit('secret123')  #undoable with password\napp.addNonCommercialLimit()  #permanent during length of session.\n</syntaxhighlight>"
            },
            {
                "class": "App",
                "name": "removeNonCommercialLimit",
                "call": "removeNonCommercialLimit(password)",
                "returns": "bool",
                "text": "Removes the restriction previously added. Returns True if successful.\n*password - (Keyword) Password previously used when restriction added.\n<syntaxhighlight lang=python>\napp.removeNonCommercialLimit('secret123')\n</syntaxhighlight>"
            },
            {
                "class": "App",
                "name": "addResolutionLimit",
                "call": "addResolutionLimit(x,y password)",
                "returns": "None",
                "text": "Limits all textures to the specified amount. Multiple calls can be made, but each can be undone with a  matching removeResolutionLimit(password).  The final resolution limit will be the minimum of all calls. If the password is blank the operation cannot be undone.\n*x - Width of maximum texture resolution, measured in pixels.\n*y - Height of maximum texture resolution, measured in pixels.\n*password - (Keyword, Optional) Password to later remove the restriction.\n<syntaxhighlight lang=python>\napp.addResolutionLimit(600, 480, 'secret123')  #undoable with password\napp.addResolutionLimit()  #permanent during length of session.\n</syntaxhighlight>"
            },
            {
                "class": "App",
                "name": "removeResolutionLimit",
                "call": "removeResolutionLimit(password)",
                "returns": "bool",
                "text": "Removes the restriction previously added. Returns True if successful.\n*password - (Keyword) Password previously used when restriction added.\n<syntaxhighlight lang=python>\napp.removeResolutionLimit('secret123')\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "This class contains specific application details, such as its version and installation folders. It can be accessed with the app object, found in the automatically imported [[td Module|td module]].\n\n'''NOTE:''' See also [[Variables]] and Dialogs -> Variables where more built-in paths and strings are available via expressions in the form <code>var('DESKTOP')</code>, <code>var('MYDOCUMENTS')</code> and <code>var('TOENAME')</code>."
    },
    "ArcBall": {
        "label": "ArcBall",
        "members": [],
        "methods": [
            {
                "class": "tdu.ArcBall",
                "name": "beginPan",
                "call": "beginPan(u, v)",
                "returns": "None",
                "text": "Begin a pan at at the given u and v.\n<syntaxhighlight lang=python>\nm.beginPan(.1, .2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "beginRotate",
                "call": "beginRotate(u, v)",
                "returns": "None",
                "text": "Begin an arcball rotation at the given u and v.\n<syntaxhighlight lang=python>\nm.beginRotate(.1, .2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "beginDolly",
                "call": "beginDolly(u, v)",
                "returns": "None",
                "text": "Begin a dolly at at the given u and v.\n<syntaxhighlight lang=python>\nm.beginDolly(.1, .2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "pan",
                "call": "pan(u, v)",
                "returns": "None",
                "text": "Pan the view by the given x and y.\n<syntaxhighlight lang=python>\nm.pan(.1, .2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "panTo",
                "call": "panTo(u, v, scale=1.0)",
                "returns": "None",
                "text": "Pan from the u,v given in the last call to beginPan() to the given u and v, applying a scale as well to the pan amount.\n*scale - (Keyword, Optional) Scale the operation by this amount.\n<syntaxhighlight lang=python>\nm.panTo(.1, .2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "rotateTo",
                "call": "rotateTo(u, v, scale=1.0)",
                "returns": "None",
                "text": "Rotates the arcball to the given u and v position.\n*scale - (Keyword, Optional) Scale the operation by this amount.\n<syntaxhighlight lang=python>\nm.rotateTo(.1, .2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "dolly",
                "call": "dolly(z)",
                "returns": "None",
                "text": "Dolly the view by the given z value.\n<syntaxhighlight lang=python>\nm.dolly(.3)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "dollyTo",
                "call": "dollyTo(u, v, scale=1.0)",
                "returns": "None",
                "text": "Dolly from the u,v given in the last call to beginDolly() to the given u and v, applying a scale as well to the dolly amount.(Keyword, Optional)\n*scale - Scale the operation by this amount.\n<syntaxhighlight lang=python>\nm.dollyTo(.1, .2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "transform",
                "call": "transform()",
                "returns": "tdu.Matrix",
                "text": "Gets the current transform [[Matrix Class|matrix]] for the arcball.\n<syntaxhighlight lang=python>\nm.transform()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "setTransform",
                "call": "setTransform(matrix)",
                "returns": "None",
                "text": "Sets the current transform matrix for the arcball. Scales in the given matrix will be ignored.\n<syntaxhighlight lang=python>\nm.setTransform(m)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.ArcBall",
                "name": "identity",
                "call": "identity()",
                "returns": "None",
                "text": "Resets all values of the ArcBall to the default state.\n<syntaxhighlight lang=python>\nm.identity()\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "Encapsulates many aspects of 3D viewer interaction. Rotation via arcball, translation and scale.\n<syntaxhighlight lang=python>\na = tdu.ArcBall(forCamera=False)\n</syntaxhighlight>"
    },
    "armSOP": {
        "label": "armSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "artnetDAT": {
        "label": "artnetDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "Attribute": {
        "label": "Attribute",
        "members": [
            {
                "class": "Attribute",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Attribute",
                "name": "name",
                "type": "str",
                "set": "0",
                "text": "The name of this attribute."
            },
            {
                "class": "Attribute",
                "name": "size",
                "type": "int",
                "set": "0",
                "text": "The number of values associated with this attribute. For example, a normal attribute has a size of 3."
            },
            {
                "class": "Attribute",
                "name": "type",
                "type": "type object",
                "set": "0",
                "text": "The type associated with this attribute: float, integer or string."
            },
            {
                "class": "Attribute",
                "name": "default",
                "type": "value",
                "set": "0",
                "text": "The default values associated with this attribute. Dependent on the type of attribute, it may return a float, integer, string, tuple, [[Position Class|Position]], or [[Vector Class|Vector]]."
            }
        ],
        "methods": [
            {
                "class": "Attribute",
                "name": "destroy",
                "call": "destroy()",
                "returns": "None",
                "text": "Destroy the attribute referenced by this object.\n<syntaxhighlight lang=python>\nn = scriptOP.pointAttribs['N'].destroy()\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "An [[Attribute]] describes a general geometric Attribute, associated with a [[Prim Class]], [[Point Class]], or [[Vertex Class]].\nSpecific values for each Prim, Point or Vertex are described with the [[AttributeData Class]].\nLists of attributes for the [[SOP Class|SOP]] are described with the [[Attributes Class]]."
    },
    "attributeCHOP": {
        "label": "attributeCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "attributecreateSOP": {
        "label": "attributecreateSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "AttributeData": {
        "label": "AttributeData",
        "members": [
            {
                "class": "AttributeData",
                "name": "owner",
                "type": "op",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "AttributeData",
                "name": "val",
                "type": "value",
                "set": "0",
                "text": "The set of values contained within this object.  Dependent on the type of attribute, it may return a float, integer, string, tuple, [[Position Class|Position]], or [[Vector Class|Vector]].  For example Normal attribute data is expressed as a [[Vector Class|Vector]], while [[Position Class|Position]] attribute data is expressed as a Position."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "An AttributeData contains specific geometric [[Attribute]] values, associated with a [[Prim Class]], [[Point Class]], or [[Vertex Class]].  Each value of the attribute must be of the same type, and can be one of float, string or integer.  For example, a point or vertex normal attribute data, consists of 3 float values."
    },
    "Attributes": {
        "label": "Attributes",
        "members": [
            {
                "class": "Attributes",
                "name": "owner",
                "type": "",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            }
        ],
        "methods": [
            {
                "class": "Attributes",
                "name": "[]",
                "call": "[name]",
                "returns": "Attribute",
                "text": "[[Attribute Class|Attributes]] can be accessed using the [] subscript operator.\n*name - The name of the attribute.\n<syntaxhighlight lang=python>\nattribs = scriptOP.pointAttribs # get the Attributes object\nnormals = attribs['N']\n</syntaxhighlight>"
            },
            {
                "class": "Attributes",
                "name": "create",
                "call": "create(name, default)",
                "returns": "Attribute",
                "text": "Create a new [[Attribute Class|Attribute]].\n*name - The name of the attribute.\n*default - (Optional) Specify default values for custom attributes.  For standard attributes, default values are implied.\n\nStandard attributes are: N (normal), uv (texture), T (tangent), v (velocity), Cd (diffuse color).\n<syntaxhighlight lang=python>\n# create a Normal attribute with implied defaults.\nn = scriptOP.pointAttribs.create('N')\n\n# set the X component of the first point's Normal attribute.\nscriptOp.points[0].N[0] = 0.3 \n\n# Create a Vertex Attribute called custom1 with defaults set to (0.0, 0.0)\nn = scriptOP.vertexAttribs.create('custom1', (0.0, 0.0) )\n\n# Create a Primitive Attribute called custom2 defaulting to 1\nn = scriptOP.primAttribs.create('custom2', 1 )\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "An Attributes object describes a set of [[Prim Class|Prim]] Class, [[Point Class|Point]] Class, or [[Vertex Class]] [[Attribute|attributes]], contained within a [[SOP Class|SOP]]."
    },
    "attributeSOP": {
        "label": "attributeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "audiobandeqCHOP": {
        "label": "audiobandeqCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "audiobandeqCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "audiobandeqCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiodeviceinCHOP": {
        "label": "audiodeviceinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiodeviceoutCHOP": {
        "label": "audiodeviceoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiodynamicsCHOP": {
        "label": "audiodynamicsCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "audiodynamicsCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "audiodynamicsCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiofileinCHOP": {
        "label": "audiofileinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiofilterCHOP": {
        "label": "audiofilterCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "returns": "int",
                "name": "chanIndex",
                "class": "audiofilterCHOP"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "returns": "int",
                "name": "sampleIndex",
                "class": "audiofilterCHOP"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiomovieCHOP": {
        "label": "audiomovieCHOP",
        "members": [
            {
                "set": "0",
                "text": "True if the movie has audio.",
                "type": "bool",
                "returns": "bool",
                "name": "hasAudio",
                "class": "audiomovieCHOP"
            },
            {
                "set": "0",
                "text": "The current movie playback rate.",
                "type": "float",
                "returns": "float",
                "name": "playbackRate",
                "class": "audiomovieCHOP"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiooscillatorCHOP": {
        "label": "audiooscillatorCHOP",
        "members": [
            {
                "class": "audiooscillatorCHOP",
                "name": "chanIndex",
                "type": "int",
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audioparaeqCHOP": {
        "label": "audioparaeqCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "audioparaeqCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "audioparaeqCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audioplayCHOP": {
        "label": "audioplayCHOP",
        "members": [],
        "methods": [
            {
                "text": "Trigger the playing of audio samples specified in an [[Audio Play CHOP]].\n*index - (Optional) The index of the audio sample to play, or all if not specified.\n*start - (Keyword, Optional) When True, will play from the beginning of the sample. When False, will play from current location.\n*loop - (Keyword, Optional) When True, will loop the audio. When False, will play only once.\n*delaySeconds - (Keyword, Optional) The number of seconds to delay before playing the audio sample.\n*pan - (Keyword, Optional) Pan the audio:(0 = left, 1 = right), else use pan specified in CHOP.\n*volume - (Keyword, Optional) Specify a new volume to play the audio, else use volume specified in CHOP.\n*fadeSeconds - (Keyword, Optional) The number of seconds to fade to the specified volume.",
                "returns": "None",
                "name": "play",
                "call": "play(index, start=True, loop=False,  delaySeconds=0.0, pan=None, rolloff=None, volume=None, fadeSeconds=0.0)",
                "class": "audioplayCHOP"
            },
            {
                "text": "Stop the playing of audio samples specified in an [[Audio Play CHOP]].\n*index - (Optional) The index of the audio sample to play, or all if not specified.",
                "returns": "None",
                "name": "stop",
                "call": "stop(index)",
                "class": "audioplayCHOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiorenderCHOP": {
        "label": "audiorenderCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiospectrumCHOP": {
        "label": "audiospectrumCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiostreaminCHOP": {
        "label": "audiostreaminCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiostreamoutCHOP": {
        "label": "audiostreamoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "audiowebrenderCHOP": {
        "label": "audiowebrenderCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "NoLabelFound": {
        "label": "NotSet",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": []
    },
    "baseCOMP": {
        "label": "baseCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "COMP"
        ]
    },
    "basisSOP": {
        "label": "basisSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "beatCHOP": {
        "label": "beatCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "Bezier": {
        "label": "Bezier",
        "members": [
            {
                "class": "Bezier",
                "name": "anchors",
                "type": "list",
                "set": "0",
                "text": "Returns the list of anchor [[Vertex Class|vertices]]."
            },
            {
                "class": "Bezier",
                "name": "basis",
                "type": "list",
                "set": "0",
                "text": "Return the bezier basis as a list of float values."
            },
            {
                "class": "Bezier",
                "name": "closed",
                "type": "bool",
                "set": "1",
                "text": "Get or set whether the curve is closed or open."
            },
            {
                "class": "Bezier",
                "name": "order",
                "type": "float",
                "set": "0",
                "text": "Return the bezier order. The order is one more than the degree."
            },
            {
                "class": "Bezier",
                "name": "segments",
                "type": "list",
                "set": "0",
                "text": "Returns a list of segments, where each segment is a list of [[Vertex Class|vertices]]."
            },
            {
                "class": "Bezier",
                "name": "tangents",
                "type": "list",
                "set": "0",
                "text": "Returns the tangents as a list of [[Vertex Class|vertex]] pairs."
            }
        ],
        "methods": [
            {
                "class": "Bezier",
                "name": "insertAnchor",
                "call": "insertAnchor(u)",
                "returns": "Vertex",
                "text": "inserts anchor at given position (u from 0..1) and returns anchor vertex."
            },
            {
                "class": "Bezier",
                "name": "updateAnchor",
                "call": "updateAnchor(anchorIndex, targetPosition, tangents=True)",
                "returns": "tdu.Position",
                "text": "Modify the anchor vertex to the new [[Position Class|position]]. If tangents is True, modify neighboring tangent vertices as well. Returns resulting position."
            },
            {
                "class": "Bezier",
                "name": "appendAnchor",
                "call": "appendAnchor(targetPosition, preserveShape=True)",
                "returns": "Vertex",
                "text": "Appends a set of vertices, creating a new segment on the curve, ending with the targetPosition.\nReturns final anchor vertex.\n*preserveShape - (Keyword, Optional) Specifies whether the new tangent will align with the previous segment or not."
            },
            {
                "class": "Bezier",
                "name": "updateTangent",
                "call": "updateTangent(tangentIndex, targetPosition, rotate=True, scale=True, rotateLock=True, scaleLock=True)",
                "returns": "tdu.Position",
                "text": "Modify the vertex vertex to the new [[Position Class|position]], constraining either rotation or scale. Locked controls matching tangent. Returns resulting position."
            },
            {
                "class": "Bezier",
                "name": "deleteAnchor",
                "call": "deleteAnchor(anchorIndex)",
                "returns": "None",
                "text": "Deletes the anchor and its neighbouring tangents."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "A Bezier describes an instance of a single geometry Bezier primitive (containing a set of connected Bezier curves). It is an instance of a [[Prim Class]].\nIt can be created from either a [[modelSOP Class|Model SOP]] or [[scriptSOP Class|Script SOP]].\nEach curve is described by a set of segments, where each segment is a list of [[Vertex Class|vertices]]. The first and last vertex of each segment is an anchor position, while its neighboring vertices describe tangent handles.\n\nThe members and methods below allow modification of the Bezier in a modelling context, however the Bezier can also be modified by direction manipulation of its vertices.  See [[Prim Class]] for more details."
    },
    "blacktraxCHOP": {
        "label": "blacktraxCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "blendCHOP": {
        "label": "blendCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "blendCOMP": {
        "label": "blendCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "blendSOP": {
        "label": "blendSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "blobtrackTOP": {
        "label": "blobtrackTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "blurTOP": {
        "label": "blurTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "Bodies": {
        "label": "Bodies",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The Bodies Class describes the set of all [[Body Class|Bodies]] in an [[Actor COMP|Actor COMP]] (Actor COMPs are used by the [[Bullet Solver COMP]] and [[Nvidia Flex Solver COMP]]). The Bodies object is accessed via its Actor COMP and is used much like a Python list.\n<syntaxhighlight lang=python>\nbodies = op('bsolver1/actor1').bodies\t# get the Bodies object\nprint(len(bodies))\t\t\t\t\t\t# number of Bodies \nprint(bodies[0])\t\t\t\t\t\t# first Body in the list\nfor b in bodies:\n\tprint(b)\t\t\t\t\t\t\t# print all Bodies\n</syntaxhighlight>"
    },
    "Body": {
        "label": "Body",
        "members": [
            {
                "class": "Body",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The index of this Body in its [[Actor COMP]] (owner)."
            },
            {
                "class": "Body",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[Actor COMP]] to which this body belongs."
            },
            {
                "class": "Body",
                "name": "rotate",
                "type": "tdu.Vector",
                "set": "1",
                "text": "Get or set the body's rotation in world space."
            },
            {
                "class": "Body",
                "name": "translate",
                "type": "tdu.Position",
                "set": "1",
                "text": "Get or set the body's translation in world space."
            },
            {
                "class": "Body",
                "name": "angularVelocity",
                "type": "tdu.Vector",
                "set": "1",
                "text": "Get or set the body's angular velocity."
            },
            {
                "class": "Body",
                "name": "linearVelocity",
                "type": "tdu.Vector",
                "set": "1",
                "text": "Get or set the body's linear velocity."
            }
        ],
        "methods": [
            {
                "class": "Body",
                "name": "applyImpulseForce",
                "call": "applyImpulseForce(force, relPos=None)",
                "returns": "None",
                "text": "Applies impulse force to a body in a Bullet simulation.\n* force - The impulse force to apply to the body.\n* relPos (Keyword, Optional) - If specified, applies the force at the relative position, otherwise applied at (0,0,0)."
            },
            {
                "class": "Body",
                "name": "applyTorque",
                "call": "applyTorque(torque)",
                "returns": "None",
                "text": "Applies torque to a body in a Bullet simulation. The torque will only be applied for a single frame.\n*torque - The torque to apply to the body this frame."
            },
            {
                "class": "Body",
                "name": "applyImpulseTorque",
                "call": "applyImpulseTorque(torque)",
                "returns": "None",
                "text": "Applies impulse torque to a body in a Bullet simulation.\n*torque - The impulse torque to apply to the body."
            },
            {
                "class": "Body",
                "name": "applyForce",
                "call": "applyForce(force, relPos=None)",
                "returns": "None",
                "text": "Applies force to a body in a Bullet simulation. The force will only be applied for a single frame.\n*force - The force to apply to the body this frame.\n*relPos (Keyword, Optional) - If specified, applies the force at the relative position, otherwise applied at (0,0,0)."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Body Class describes the contents of a single body within an [[Actor COMP]].\nThe [[Actor COMP]] has a list of all its bodies."
    },
    "boneCOMP": {
        "label": "boneCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "bonegroupSOP": {
        "label": "bonegroupSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "booleanSOP": {
        "label": "booleanSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "Bounds": {
        "label": "Bounds",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "Bounds(min, max, center, size)",
        "inherit": "",
        "parent": ""
    },
    "boxSOP": {
        "label": "boxSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "bridgeSOP": {
        "label": "bridgeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "buttonCOMP": {
        "label": "buttonCOMP",
        "members": [],
        "methods": [
            {
                "text": "Simulate a mouse click of a button panel.\n*val - (Optional) If specified, the button state will retain that value.\n*clickCount - (Keyword, Optional) Sets the number of clicks, for double clicking etc.\n*force - (Keyword, Optional) Set to True to forces the panel click, even if its disabled.\n*left,middle,right - (Keyword, Optional) Set to True to override the default mouse buttons used. When none are set, the left mouse button is pressed, and the other buttons released.",
                "returns": "None",
                "name": "click",
                "call": "click(val, clickCount=1, force=False, left=False, middle=False, right=False)",
                "class": "buttonCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "PanelCOMP",
            "COMP"
        ]
    },
    "cacheselectTOP": {
        "label": "cacheselectTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "cacheSOP": {
        "label": "cacheSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "cacheTOP": {
        "label": "cacheTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "Camera": {
        "label": "Camera",
        "members": [
            {
                "class": "tdu.Camera",
                "name": "dir",
                "type": "tdu.Position",
                "set": "1",
                "text": "Get or set the direction of the camera as a vector that points towards the target. Up is considered to be (0,1,0)."
            },
            {
                "class": "tdu.Camera",
                "name": "pivot",
                "type": "tdu.Position",
                "set": "1",
                "text": "Get or set the 3D point in space where the camera will pivot around or towards."
            },
            {
                "class": "tdu.Camera",
                "name": "position",
                "type": "tdu.Position",
                "set": "1",
                "text": "Get or set the 3D point in space where the camera is located."
            }
        ],
        "methods": [
            {
                "class": "tdu.Camera",
                "name": "blendCamera",
                "call": "blendCamera(targetCamera, blendFactor)",
                "returns": "tdu.Camera()",
                "text": "Returns a camera that is blended with the given camera using the blendFactor. The camera position is blended using linear interpolation, while the rotation is blended using spherical linear interpolation.\n* targetCamera - A second camera that is the blend target.\n* blendfactor - A blend value between 0 and 1.\""
            },
            {
                "class": "tdu.Camera",
                "name": "dolly",
                "call": "dolly()",
                "returns": "None",
                "text": "Move the camera away or towards the pivot point."
            },
            {
                "class": "tdu.Camera",
                "name": "frameBounds",
                "call": "frameBounds()",
                "returns": "OrthoWidth",
                "text": "Set the camera to frame the given bounding box. Returns the width of the framed scene that can be used when setting up orthographic projections."
            },
            {
                "class": "tdu.Camera",
                "name": "look",
                "call": "look()",
                "returns": "None",
                "text": "Pivot the camera around its position."
            },
            {
                "class": "tdu.Camera",
                "name": "move3D",
                "call": "move3D()",
                "returns": "None",
                "text": "Move the camera using data from a 3D mouse."
            },
            {
                "class": "tdu.Camera",
                "name": "pan",
                "call": "pan()",
                "returns": "None",
                "text": "Pan the camera in a 2D plane facing the pivot point."
            },
            {
                "class": "tdu.Camera",
                "name": "setTransform",
                "call": "setTransform()",
                "returns": "None",
                "text": "Set the camera view matrix."
            },
            {
                "class": "tdu.Camera",
                "name": "track",
                "call": "track()",
                "returns": "None",
                "text": "Move the camera up/down in the Y-Axis or left/right."
            },
            {
                "class": "tdu.Camera",
                "name": "transform",
                "call": "transform()",
                "returns": "None",
                "text": "Get the camera view matrix."
            },
            {
                "class": "tdu.Camera",
                "name": "tumble",
                "call": "tumble()",
                "returns": "None",
                "text": "Rotate the camera around the pivot point."
            },
            {
                "class": "tdu.Camera",
                "name": "walk",
                "call": "walk()",
                "returns": "None",
                "text": "Move the camera forward/back along in the ZX plane and rotate around its position."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "Helper class that maintains a 3D position and orientation for a camera and provides multiple methods for manipulating the camera's position and direction. This class is used for the [[Palette:camera|viewportCamera]] palette component.",
        "inherit": "",
        "parent": ""
    },
    "camerablendCOMP": {
        "label": "camerablendCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "cameraCOMP": {
        "label": "cameraCOMP",
        "members": [],
        "methods": [
            {
                "text": "Returns the inverse projection matrix for the camera, given the X and Y aspect. In general these would be set to the width and height of your render.\n*x - The horizontal aspect ratio.\n*y - The vertical aspect ratio.",
                "returns": "tdu.Matrix",
                "name": "projectionInverse",
                "call": "projectionInverse(x, y)",
                "class": "cameraCOMP"
            },
            {
                "text": "Returns the projection matrix for the camera, given the X and Y aspect. In general these would be set to the width and height of your render.\n*x - The horizontal aspect ratio.\n*y - The vertical aspect ratio.",
                "returns": "tdu.Matrix",
                "name": "projection",
                "call": "projection(x, y)",
                "class": "cameraCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "capSOP": {
        "label": "capSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "captureregionSOP": {
        "label": "captureregionSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "captureSOP": {
        "label": "captureSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "carveSOP": {
        "label": "carveSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "Cell": {
        "label": "Cell",
        "members": [
            {
                "class": "Cell",
                "name": "valid",
                "type": "bool",
                "set": "0",
                "text": "True if the referenced cell currently exists, False if it has been deleted."
            },
            {
                "class": "Cell",
                "name": "row",
                "type": "int",
                "set": "0",
                "text": "The numeric row of the cell."
            },
            {
                "class": "Cell",
                "name": "col",
                "type": "int",
                "set": "0",
                "text": "The numeric column of the cell."
            },
            {
                "class": "Cell",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Cell",
                "name": "val",
                "type": "value",
                "set": "1",
                "text": "Get or set the cell contents, which are always stored as a string value."
            }
        ],
        "methods": [
            {
                "class": "Cell",
                "name": "run",
                "call": "run(endFrame=False, fromOP=None, asParameter=False, group=None, delayFrames=0, delayMilliSeconds=0, delayRef=me, arg1, arg2...)",
                "returns": "td.Run",
                "text": "[[Run Class|Run]] the contents of the cell as a script, returning a Run object which can be used to optionally modify its execution.\n*endFrame - (Keyword, Optional) If set to True, the execution will be delayed until the end of the current frame.\n*fromOP - (Keyword, Optional) Specifies an optional [[OP Class|operator]] from which the execution will be run relative to.\n*asParameter - (Keyword, Optional) When fromOP used, run relative to a parameter of fromOP.\n*group - (Keyword, Optional) Can be used to specify a group label string. This label can then be used with the [[Runs Class|td.runs]] object to modify its execution.\n*delayFrames - (Keyword, Optional) Can be used to delay the execution a specific amount of frames.\n*delayMilliSeconds - (Keyword, Optional) Can be used to delay the execution a specific amount of milliseconds.  This value is rounded to the nearest frame.\n*delayRef - (Keyword, Optional) Specifies an optional [[OP Class|operator]] from which the delay time is derived.\n*arg - (Optional) Arguments that will be made available to the script in a local tuple named args."
            },
            {
                "class": "Cell",
                "name": "offset",
                "call": "offset(r, c)",
                "returns": "td.Cell or None",
                "text": "The cell offset to this cell by the specified amount, or None.\n*r - The number of rows from the cell.  Positive values count down, while negative values count up.\n*c - The number of columns from the cell.  Positive values count right, while negative values count left.\n<syntaxhighlight lang=python>\nc = op('table1')['March', 'Sales']\nd = c.offset(-1, 2)  # one row up, two columns right of cell C\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The [[Cell Class]] describes the contents of a single cell from a [[DAT]] operator table.\nThe [[DAT Class]] offers many ways of accessing its individual cells.\n[[DAT]] cells are always internally stored as strings, but may be accessed as numeric values.\n\n'''IMPORTANT''':  <code>op('table1')[1,2]</code> is this python cell object which usually gets converted for you to the string in the cell. More safely use <code>op('table1')[1,2].val</code> which always gives you the string."
    },
    "Channel": {
        "label": "Channel",
        "members": [
            {
                "class": "Channel",
                "name": "valid",
                "type": "bool",
                "set": "0",
                "text": "True if the referenced chanel value currently exists, False if it has been deleted."
            },
            {
                "class": "Channel",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The numeric index of the channel."
            },
            {
                "class": "Channel",
                "name": "name",
                "type": "str",
                "set": "0",
                "text": "The name of the channel."
            },
            {
                "class": "Channel",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Channel",
                "name": "exports",
                "type": "list",
                "set": "0",
                "text": "The (possibly empty) list of [[Par Class|parameters]] this channel currently exports to."
            },
            {
                "class": "Channel",
                "name": "vals",
                "type": "list",
                "set": "1",
                "text": "Get or set the full list of [[Channel Class|Channel]] values. Modifying [[Channel Class|Channel]] values can only be done in Python within a [[scriptCHOP Class|Script CHOP]]."
            }
        ],
        "methods": [
            {
                "class": "Channel",
                "name": "[]",
                "call": "[index]",
                "returns": "float",
                "text": "Sample values may be easily accessed from a Channel using the [] subscript operator.\n*index - Must be an numeric sample index. Wildcards are not supported. \nTo get the third sample from the channel, assuming the channel has 3 or more samples:\n<syntaxhighlight lang=python>\nn = op('pattern1')\nc = n['chan1'][2] # the third sample\nl = len(n['chan2']) # the total number of samples in the channel\n</syntaxhighlight>"
            },
            {
                "class": "Channel",
                "name": "eval",
                "call": "eval(index)",
                "returns": "float",
                "text": "Evaluate the channel at the specified index sample index. If no index is given, the current index based on the current time is used.\n*index - (Optional) The sample index to evaluate at."
            },
            {
                "class": "Channel",
                "name": "evalFrame",
                "call": "evalFrame(frame)",
                "returns": "float",
                "text": "Evaluate the channel at the specified frame. If no frame is given, the current frame is used.\n*frame  - (Optional) The frame to evaluate at."
            },
            {
                "class": "Channel",
                "name": "evalSeconds",
                "call": "evalSeconds(secs)",
                "returns": "float",
                "text": "Evaluate the channel at the specified seconds. If no time is given, the current time is used.\n*secs - (Optional) The time in seconds to evaluate at."
            },
            {
                "class": "Channel",
                "name": "numpyArray",
                "call": "numpyArray()",
                "returns": "numpy.array",
                "text": "Returns this channels data as a NumPy array with a length equal to the track length."
            },
            {
                "class": "Channel",
                "name": "destroy",
                "call": "destroy()",
                "returns": "None",
                "text": "Destroy and remove the actual Channel this object refers to. This operation is only valid when the channel belongs to a [[scriptCHOP Class| Script CHOP]] or [[oscinCHOP Class|OSC In CHOP]] .\nNote: after this call, other existing Channel objects in this CHOP may no longer be valid."
            },
            {
                "class": "Channel",
                "name": "average",
                "call": "average()",
                "returns": "float",
                "text": "Returns the average value of all the channel samples."
            },
            {
                "class": "Channel",
                "name": "min",
                "call": "min()",
                "returns": "float",
                "text": "Returns the minimum value of all the channel samples."
            },
            {
                "class": "Channel",
                "name": "max",
                "call": "max()",
                "returns": "float",
                "text": "Returns the maximum value of all the channel samples."
            },
            {
                "class": "Channel",
                "name": "copyNumpyArray",
                "call": "copyNumpyArray(numpyArray)",
                "returns": "None",
                "text": "Copies the contents of the numpyArray into the Channel sample values.\n* numpyArray - The NumPy Array to copy. Must be shape(n), where n is the sample length of the CHOP. The data type must be float32. Modifying Channel values can only be done in Python within a [[Script CHOP]]."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "A Channel object describes a single [[Channel|channel]] from a [[CHOP]].  The [[CHOP Class]] provides many ways of accessing its individual channels.\nSee [[Working with CHOPs in Python]] for more examples of how to use this class."
    },
    "channelmixTOP": {
        "label": "channelmixTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "CHOP": {
        "label": "CHOP",
        "members": [
            {
                "class": "CHOP",
                "name": "numChans",
                "type": "int",
                "set": "0",
                "text": "The number of channels."
            },
            {
                "class": "CHOP",
                "name": "numSamples",
                "type": "int",
                "set": "1",
                "text": "Get or set the number of samples (or indices) per channel. You can change the number of samples by setting this value, only in a [[scriptCHOP Class|scriptCHOP]]."
            },
            {
                "class": "CHOP",
                "name": "start",
                "type": "float",
                "set": "1",
                "text": "Get or set the start index of the channels. This can be modified only when the CHOP is a [[scriptCHOP Class|scriptCHOP]]."
            },
            {
                "class": "CHOP",
                "name": "end",
                "type": "float",
                "set": "1",
                "text": "Get or set the end index of the channels. This can be modified only when the CHOP is a [[scriptCHOP Class|scriptCHOP]]."
            },
            {
                "class": "CHOP",
                "name": "rate",
                "type": "float",
                "set": "1",
                "text": "Get or set the sample rate of the CHOP. This can be modified only when the CHOP is a [[scriptCHOP Class|scriptCHOP]]."
            },
            {
                "class": "CHOP",
                "name": "isTimeSlice",
                "type": "bool",
                "set": "1",
                "text": "Get or set the last cooked [[Time Slicing|Time Slice]] value. True if the CHOP last cooked as a Time Slice. This can be modified only when the CHOP is a [[scriptCHOP Class|scriptCHOP]]"
            },
            {
                "class": "CHOP",
                "name": "export",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Export Flag]]."
            },
            {
                "class": "CHOP",
                "name": "exportChanges",
                "type": "int",
                "set": "0",
                "text": "Number of times the export mapping information has changed."
            },
            {
                "class": "CHOP",
                "name": "isCHOP",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a CHOP."
            }
        ],
        "methods": [
            {
                "class": "CHOP",
                "name": "[]",
                "call": "[nameOrIndex]",
                "returns": "Channel",
                "text": "[[Channel Class|Channels]] may be easily accessed from a CHOP using the [] subscript operator.\n*nameOrIndex - Must be an exact string name, or it may be a numeric channel index. Wildcards are not supported. Refer to the help on channels to see how to use the returned [[Channel Class|Channel]] object.<syntaxhighlight lang=\"python\">\nn = op('pattern1')\nc = n[4]\nc = n['chan2']\n</syntaxhighlight>and to get the third sample from the channel, assuming the channel has 3 or more samples:<syntaxhighlight lang=\"python\">\nn = op('pattern1')\nc = n['chan2'][2]\n</syntaxhighlight>"
            },
            {
                "class": "CHOP",
                "name": "chan",
                "call": "chan(nameOrIndex1, nameOrIndex2..., caseSensitive=True)",
                "returns": "Channel or None",
                "text": "Returns the first [[Channel Class|Channel]] that matches the given name or index or None if none are found.\nMultiple patterns may be specified which are all added to the search.\n*nameOrIndex - May be a string name, possibly using [[Pattern Matching]], or it may be a numeric channel index.\n*caseSensitive - (Optional) Specifies whether or not case sensitivity is used.\n<syntaxhighlight lang=\"python\">\nn = op('pattern1')\nc = n.chan(4)\nc = n.chan('chan*')\nc = n.chan('chan3zall', caseSensitive=False)\n</syntaxhighlight>"
            },
            {
                "class": "CHOP",
                "name": "chans",
                "call": "chans(nameOrIndex1, nameOrIndex2..., caseSensitive=True)",
                "returns": "list",
                "text": "Returns a (possibly empty) list of [[Channel Class|Channels]] that match that specified names or indices. Multiple names and indices may be provided.\n*nameOrIndex - (Optional) One or more string names, possibly using [[Pattern Matching]], or numeric channel index. No arguments are passed, a list of all channels is returned.\n*caseSensitive - (Optional) Specifies whether or not case sensitivity is used.\n<syntaxhighlight lang=\"python\">\nn = op('pattern1')\nnewlist = n.chans() # get all channels in the CHOP\nnewlist = n.chans('a*', 3,4,5, 'd*')\n</syntaxhighlight>"
            },
            {
                "class": "CHOP",
                "name": "numpyArray",
                "call": "numpyArray()",
                "returns": "numpy.array",
                "text": "Returns all of the channels in this CHOP a 2D NumPy array with a width equal to the channel length (the number of samples) and a height equal to the number of channels. See [[numPy]]."
            },
            {
                "class": "CHOP",
                "name": "convertToKeyframes",
                "call": "convertToKeyframes(tolerance=0.1)",
                "returns": "animationCOMP",
                "text": "Create an [[Animation COMP]] that contains a keyframed approximation of the CHOP's channels.\nThe resultant [[animationCOMP Class|animationCOMP]] is returned.\n*tolerance - (Keyword, Optional) If this is not given, the default value is 0.1. It may be overridden for higher accuracy match between the source channels and the resulting keyframed channels."
            },
            {
                "class": "CHOP",
                "name": "save",
                "call": "save(filepath, createFolders=False)",
                "returns": "filepath",
                "text": "Saves the channel to the file system. Supported file formats are <code>.clip, .bclip, .chan, .bchan</code> and <code>.aiff</code>.\nReturns the file path used.\n*filepath - (Optional) The path and filename to save to.\n*createFolders - (Keyword, Optional) If True, it creates the not existent directories provided by the filepath.\n<syntaxhighlight lang=\"python\">\nn = op('pattern1')\nname = n.save()   #save in native format with default name\nn.save('output.chan')  #ascii readable tab delimited format\nn.save('output.aiff')  #supported audio format\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP"
        ],
        "summary": "A [[CHOP]] describes a reference to a CHOP operator, containing a set of [[Channel|channels]] accessed with the [[Channel Class]]."
    },
    "chopexecuteDAT": {
        "label": "chopexecuteDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "choptoDAT": {
        "label": "choptoDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "choptoSOP": {
        "label": "choptoSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "choptoTOP": {
        "label": "choptoTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "chromakeyTOP": {
        "label": "chromakeyTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "circleSOP": {
        "label": "circleSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "circleTOP": {
        "label": "circleTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "claySOP": {
        "label": "claySOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "clipblenderCHOP": {
        "label": "clipblenderCHOP",
        "members": [
            {
                "set": "0",
                "text": "The clip being executed or blended from.",
                "type": "OP",
                "class": "clipblenderCHOP",
                "name": "clipA"
            },
            {
                "set": "0",
                "text": "The clip being blended into.",
                "type": "OP",
                "returns": "OP",
                "name": "clipB",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "Clip A before the start of a transition, clip B otherwise.",
                "type": "OP",
                "returns": "OP",
                "name": "currentClip",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "The frame index of the current clip output.",
                "type": "float",
                "returns": "float",
                "name": "currentFrame",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "The time value of the current clip output.",
                "type": "float",
                "returns": "float",
                "name": "currentTime",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "The time at which the transition is complete.",
                "type": "float",
                "returns": "float",
                "name": "endBlendTime",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "True if the output is transitioning between clips.",
                "type": "bool",
                "returns": "bool",
                "name": "isBlending",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "True if transitions are delayed until current transition completes.",
                "type": "bool",
                "returns": "bool",
                "name": "isQueued",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "True if there is a pending triggered transition.",
                "type": "bool",
                "returns": "bool",
                "name": "isTriggerWaiting",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "Last value of clip A.",
                "type": "float",
                "returns": "float",
                "name": "lastClipA",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "Last value of clip B.",
                "type": "float",
                "returns": "float",
                "name": "lastClipB",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "The next clip to be sequenced.",
                "type": "OP",
                "returns": "OP",
                "name": "nextClip",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "The time the transition will start.",
                "type": "float",
                "returns": "float",
                "name": "startBlendTime",
                "class": "clipblenderCHOP"
            },
            {
                "set": "0",
                "text": "The clip .",
                "type": "OP",
                "returns": "None",
                "name": "triggerClip",
                "class": "clipblenderCHOP"
            }
        ],
        "methods": [
            {
                "text": "Trigger the next clip in sequence.\n*clipCHOP - (Optional) If specified, the Clip CHOP it is inserted into the queue.\n*waitEnd - When True, wait until the end of the current clip before triggering.",
                "returns": "None",
                "name": "trigger",
                "call": "trigger(clipCHOP, waitEnd=False)",
                "class": "clipblenderCHOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "clipCHOP": {
        "label": "clipCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "clipDAT": {
        "label": "clipDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "clipSOP": {
        "label": "clipSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "clockCHOP": {
        "label": "clockCHOP",
        "members": [
            {
                "set": "0",
                "text": "\"Get a Timecode object representation of the hour, minute, second, and msec components.\"",
                "type": "tdu.Timecode",
                "class": "clockCHOP",
                "name": "timecode"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "Color": {
        "label": "Color",
        "members": [
            {
                "class": "tdu.Color",
                "name": "r",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the red component of the color."
            },
            {
                "class": "tdu.Color",
                "name": "g",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the green component of the color."
            },
            {
                "class": "tdu.Color",
                "name": "b",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the blue component of the color."
            },
            {
                "class": "tdu.Color",
                "name": "a",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the alpha component of the color."
            }
        ],
        "methods": [
            {
                "class": "tdu.Color",
                "name": "[]",
                "call": "[index]",
                "returns": "float",
                "text": "Sample values may be accessed from a Color using the [] subscript operator."
            },
            {
                "class": "tdu.Color",
                "name": "copy",
                "call": "copy()",
                "returns": "Color",
                "text": "Returns a new color that is a copy of the color."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The color class holds a single 4 component color (R, G, B, A).\n<syntaxhighlight lang=python>\nv = tdu.Color() # starts as (0, 0, 0, 1)\nv2 = tdu.Color(0, 0, 1, 1)\nvalues = [0, 1, 0, 1]\nv3 = tdu.Color(values)\ngreen = v3[1] # access individual elements by index. Same as v3.g\n</syntaxhighlight>"
    },
    "Colors": {
        "label": "Colors",
        "members": [],
        "methods": [
            {
                "class": "Colors",
                "name": "resetToDefaults",
                "call": "resetToDefaults()",
                "returns": "None",
                "text": "Set the colors to their default values."
            },
            {
                "class": "Colors",
                "name": "len",
                "call": "len(Colors)",
                "returns": "int",
                "text": "Returns the total color options.\n<syntaxhighlight lang=python>\na = len(ui.colors)\n</syntaxhighlight>"
            },
            {
                "class": "Colors",
                "name": "[]",
                "call": "[<color option name>]",
                "returns": "triplet(r,g,b)",
                "text": "Get or set specific color option, given a string key.\n<syntaxhighlight lang=python>\nn = ui.colors['default.bg']\nui.colors['default.bg'] = (1,0,0)\n</syntaxhighlight>"
            },
            {
                "class": "Colors",
                "name": "iterator",
                "call": "Iterator",
                "returns": "str",
                "text": "Iterate over each color option name.\n<syntaxhighlight lang=python>\nfor n in ui.colors:\n\tprint(n)\n\tui.colors[n] = myColorsList[n]\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Colors Class describes the application colors.  It can be accessed from the global [[UI Class|ui]] object."
    },
    "COMP": {
        "label": "COMP",
        "members": [
            {
                "class": "COMP",
                "name": "extensions",
                "type": "List",
                "set": "0",
                "text": "A list of [[Extensions|extensions]] attached to this component."
            },
            {
                "class": "COMP",
                "name": "extensionsReady",
                "type": "Bool",
                "set": "0",
                "text": "True unless the extensions are currently compiling. Can be used to avoid accessing promoted members prematurely during an extension initialization function."
            },
            {
                "class": "COMP",
                "name": "internalOPs",
                "type": "Dict",
                "set": "0",
                "text": "A dictionary of [[Internal_Operators|internal operator shortcuts]] found in this component. See also [[OP_Class#General|OP.iop]]"
            },
            {
                "class": "COMP",
                "name": "internalPars",
                "type": "Dict",
                "set": "0",
                "text": "A dictionary of [[Internal_Parameters|internal parameters shortcuts]] found in this component. See also [[OP_Class#General|OP.ipar]]"
            },
            {
                "class": "COMP",
                "name": "clones",
                "type": "List",
                "set": "0",
                "text": "A list of all [[COMP Class|components]] cloned to this component."
            },
            {
                "class": "COMP",
                "name": "componentCloneImmune",
                "type": "Bool",
                "set": "1",
                "text": "Get or set [[Immune Flag|component clone Immune flag]]. This works together with the cloneImmune member of the [[OP_Class]]. When componentCloneImmune is True, everything inside the clone is [[immune]]. When componentCloneImmune is False, it uses the [[OP_Class]] cloneImmune member to determine if just the component is immune (its parameters etc, but not the component's network inside)."
            },
            {
                "class": "COMP",
                "name": "vfs",
                "type": "vfs",
                "set": "0",
                "text": "An intermediate [[VFS Class|VFS object]] from which embedded [[VFSFile Class|VFSFile objects]] can be accessed. For more information see [[Virtual File System]]."
            },
            {
                "class": "COMP",
                "name": "dirty",
                "type": "Bool",
                "set": "0",
                "text": "True if the contents of the component need to be saved."
            },
            {
                "class": "COMP",
                "name": "externalTimeStamp",
                "deprecated": "True",
                "type": "Time",
                "set": "0",
                "text": "Time stamp of the external tox file when it was last saved or loaded."
            },
            {
                "class": "COMP",
                "name": "currentChild",
                "type": "OP",
                "set": "0",
                "text": "The child [[OP Class|operator]] that is currently selected. To make an operator current, use its own [[OP Class#Common Flags|OP.current]] method."
            },
            {
                "class": "COMP",
                "name": "selectedChildren",
                "type": "List",
                "set": "0",
                "text": "The list of currently selected [[OP Class|children]]. To change an individual operator's selection state, use its own [[OP Class#Common Flags|OP.selected]] method."
            },
            {
                "class": "COMP",
                "name": "cpuCookTime",
                "type": "float",
                "set": "0",
                "text": "Duration of the last measured cook in CPU time (in milliseconds)."
            },
            {
                "class": "COMP",
                "name": "childrenCPUCookTime",
                "type": "float",
                "set": "0",
                "text": "The total accumulated cook time of all children of this operator during the last frame. Zero if the operator is not a COMP and/or has no children."
            },
            {
                "class": "COMP",
                "name": "childrenCPUCookAbsFrame",
                "type": "int",
                "set": "0",
                "text": "The absolute frame on which childrenCookTime is based."
            },
            {
                "class": "COMP",
                "name": "gpuMemory",
                "type": "int",
                "set": "0",
                "text": "The amount of GPU memory this OP is using, in bytes."
            },
            {
                "class": "COMP",
                "name": "pickable",
                "type": "Bool",
                "set": "1",
                "text": "Get or set [[Pickable Flag|pickable flag]]."
            },
            {
                "class": "COMP",
                "name": "utility",
                "type": "Bool",
                "set": "1",
                "text": "Get or set utility flag."
            },
            {
                "class": "COMP",
                "name": "isCOMP",
                "type": "Bool",
                "set": "0",
                "text": "True if the operator is a component."
            },
            {
                "class": "COMP",
                "name": "isPrivate",
                "type": "Bool",
                "set": "0",
                "text": "True if the the component contents cannot be directly viewed."
            },
            {
                "class": "COMP",
                "name": "isPrivacyActive",
                "type": "Bool",
                "set": "0",
                "text": "True if the component is private, and privacy is active. When inactive the contents can be temporarily viewed."
            },
            {
                "class": "COMP",
                "name": "isPrivacyLicensed",
                "type": "Bool",
                "set": "0",
                "text": "True if the component is private and if the required CodeMeter license is present to run it."
            },
            {
                "class": "COMP",
                "name": "privacyFirmCode",
                "type": "int",
                "set": "0",
                "text": "The CodeMeter firm code needed to use this private component. 0 if this component is not private using a CodeMeter dongle."
            },
            {
                "class": "COMP",
                "name": "privacyProductCode",
                "type": "int",
                "set": "0",
                "text": "The CodeMeter product code needed to use this private component. 0 if this component is not private using a CodeMeter dongle."
            },
            {
                "class": "COMP",
                "name": "privacyDeveloperName",
                "type": "string",
                "set": "0",
                "text": "The name of the developer of this private component."
            },
            {
                "class": "COMP",
                "name": "privacyDeveloperEmail",
                "type": "string",
                "set": "0",
                "text": "The email of the developer of this private component."
            },
            {
                "class": "COMP",
                "name": "inputCOMPs",
                "type": "List",
                "set": "0",
                "text": "List of input [[COMP Class|components]] to this component through its top connector."
            },
            {
                "class": "COMP",
                "name": "inputCOMPConnectors",
                "type": "List",
                "set": "0",
                "text": "List of input [[Connector Class|connectors]] (on the top) associated with this component."
            },
            {
                "class": "COMP",
                "name": "outputCOMPs",
                "type": "List",
                "set": "0",
                "text": "List of output [[COMP Class|components]] from this component through its bottom connector."
            },
            {
                "class": "COMP",
                "name": "outputCOMPConnectors",
                "type": "List",
                "set": "0",
                "text": "List of output [[Connector Class|connectors]] (on the bottom) associated with this component."
            }
        ],
        "methods": [
            {
                "class": "COMP",
                "name": "create",
                "call": "create(opType, name, initialize=True)",
                "returns": "OP",
                "text": "Create a new node of the given type, inside this component. If <code>name</code> is supplied the new node will use that name, or the next numbered name if its already in use.  opType can be a specific type object, example <code>waveCHOP</code>, or it can be a string <code>'waveCHOP'</code>.  If given an actual instance of a node <code>n</code>, these can be accessed via <code>type(n)</code> and <code>n.OPType</code> respectively.\nAn initialization script associated with the operator is run, unless initialize=False.\nThe new node is returned.\n*opType - The python OP type for the type of operator you want to create.\n*name - (Optional) The name for the new operator. If there already is an operator with that name, the next numbered name will be used.\n*initialize - (Keyword, Optional) If set to false, then the initialization script for that node won't be run. Most nodes don't do anything to initialize, but some do. For example the Light COMP initializes a network inside itself of SOPs.\n<syntaxhighlight lang=python>\nn.create(waveCHOP)\nw = n.create(boxSOP, 'box12')\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "collapseSelected",
                "call": "collapseSelected()",
                "returns": "None",
                "text": "Move all selected operators into a new [[Base COMP]]. Equivalent to right-click on the network background and choosing Collapse Selected."
            },
            {
                "class": "COMP",
                "name": "copy",
                "call": "copy(OP, name=None, includeDocked=True)",
                "returns": "OP",
                "text": "Copy the operator into this component. If name is supplied, the new node will use that name. The new node is returned.\n*OP - The operator to copy. This is not a string, it must be an OP.\n*name - (Keyword, Optional) If provided, the new node will have this name. If there already is an operator with that name, the next numbered name will be used.\n*includeDocked - (Keyword, Optional) When true a copy will include any externally docked operators to the source component.\n<syntaxhighlight lang=python>\nw = n.copy( op('wave1') )\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "copyOPs",
                "call": "copyOPs(listOfOPs)",
                "returns": "List",
                "text": "Copy a list of operators into this component.\nThis is preferred over multiple single copies, as connections between the operators are preserved.\nA new list with the created operators is returned.\n*listOfOPs - A list containing one or more OPs to be copied.\n<syntaxhighlight lang=python>\nalist = [op('wave1'), op('wave2')]\nn.copyOPs(alist)\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "findChildren",
                "call": "findChildren(type=None, name=None, path=None, depth=None, maxDepth=None, text=None, comment=None, tags=[], allTags=False, parValue=None, parExpr=None, parName=None, onlyNonDefaults=False, includeUtility=False, key=None)",
                "returns": "List of OPs",
                "text": "Return a list of [[OP Class|operators]] matching the specified criteria.\n*type - (Keyword, Optional) Specify the type of OP.  Example type=boxSOP\n*name - (Keyword, Optional) Specify the name of the OP. [[Pattern Matching]] supported. Example: name='project*'\n*path - (Keyword, Optional) Specify the path of the OP. [[Pattern Matching]] supported. Example: path='*/pics/*'\n*depth - (Keyword, Optional) Specify the relative depth of the OP to the calling OP.  Children have depth 1, their children have depth 2, etc.\n*maxDepth - (Keyword, Optional) Specify the maximum relative depth of the OP from the calling OP.\n*text - (Keyword, Optional) Specify the DAT contents of the OP.  [[Pattern Matching]] supported.  Example: text='*import*'\n*comment - (Keyword, Optional) Specify the OP comment.  [[Pattern Matching]] supported.  Example: comment='*todo*'\n*tags - (Keyword, Optional) Specify a list of tags to search. [[Pattern Matching]] supported.  Example: tags=['*sequencer*', '*interface*']\n*allTags - (Keyword, Optional) When True, only include OPs where all specified tags are matched.\n*parValue - (Keyword, Optional) Specify the value of any parameters in the OP.  [[Pattern Matching]] supported.  Example: parValue='500'\n*parExpr - (Keyword, Optional) Specify the expression of any parameters in the OP.  [[Pattern Matching]] supported.  Example: parExpr='*sin*'\n*parName - (Keyword, Optional) Specify the name of any parameters in the OP.  [[Pattern Matching]] supported.  Example: parName='clone'\n*onlyNonDefaults - (Keyword, Optional) When True, only non default parameters are included.\n*includeUtility - (Keyword, Optional) If specified, controls whether or not [[Network Utilities: Comments, Network Boxes, Annotates|Utility nodes]] (e.g. Comments) are included in the results.\n*key - (Keyword, Optional) Specify a custom search function.\n<syntaxhighlight lang=python>\n#find all OPs whose name begins with circle\nn.findChildren(name='circle*')\n\n#find all wide CHOPs\nn.findChildren(type=CHOP, key = lambda x: x.nodeWidth > 200)\n\n#find all COMPs specifying clones\nn.findChildren(type=COMP, parName='clone', onlyNonDefaults=True)\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "initializeExtensions",
                "call": "initializeExtensions(index=None)",
                "returns": "Extension",
                "text": "Initialize the components [[Extensions|extensions]]. To initialize an individual extension, specify its index.\nReturns the compiled extension.\n*index - (Optional) Index to initialize. 0 = first extension, etc.\n<syntaxhighlight lang=python>\nn.initializeExtensions(0) # initialize first extension.\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "loadTox",
                "call": "loadTox(filepath, unwired=False, pattern=None, password=None)",
                "returns": "OP",
                "text": "Load the component from the given file path into this component.\n*filepath - The path and filename of the <code>.tox</code> to load.\n*unwired - (Keyword, Optional) If True, the component inputs will remain unwired.\n*pattern - (Keyword, Optional) Can be specified to only load operators within the component that match the pattern. Wildcards are not supported.\n*password - (Keyword, Optional) If specified, decrypts the tox with the password."
            },
            {
                "class": "COMP",
                "name": "loadByteArray",
                "call": "loadByteArray(byteArray, unwired=False, pattern=None, password=None)",
                "returns": "OP",
                "text": "Load the component from the given bytearray into this COMP. See .saveByteArray() as a way to generate this byteArray.\n*bytearray - A bytearray containing the component, from a call to saveByteArray().\n*unwired - (Keyword, Optional) If True, the component inputs will remain unwired.\n*pattern - (Keyword, Optional) Can be specified to only load operators within the component that match the pattern. Wildcards are not supported.\n*password - (Keyword, Optional) If specified, decrypts the component with the password.\""
            },
            {
                "class": "COMP",
                "name": "reload",
                "call": "reload(filepath, password=None)",
                "returns": "None",
                "text": "Reloads the component from the given file path. This will replace its children as well as top level parameters and update flags, node width/height, storage, comments and inputs (but keep original node x,y).\n*filepath - The path and filename of the .tox to load.\n*password - (Keyword, Optional) If specified, decrypts the component with the password.\""
            },
            {
                "class": "COMP",
                "name": "resetNetworkView",
                "call": "resetNetworkView(recurse)",
                "returns": "None",
                "text": "Reset the network view such that the network editor will be re-homed upon entering this component.\n*recurse - (Optional) When True, resets network view of all children components as well. Default False.\n<syntaxhighlight lang=python>\nn.resetNetworkView(True) # reset network view of n and all its children.\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "save",
                "call": "save(filepath, createFolders=False, password=None)",
                "returns": "Path",
                "text": "Saves the component to disk. If no path is provided, a default filename is used and the <code>.tox</code> is saved to <code>project.folder</code>.\nReturns the filename used.\n*filepath - (Optional) The path and filename to save the <code>.tox</code> to.\n*createFolders - (Keyword, Optional) If True, it creates the not existent directories provided by the filepath.\n*password - (Keyword, Optional) If specified, encrypts the tox with the password.\n<syntaxhighlight lang=python>\nname = n.save() # save in native tox format with default name\nn.save('output.tox')  # supply name\nn.save('C:/Desktop/myFolder/output.tox', createFolders=True)  # supply name and createFolder flag\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "saveByteArray",
                "call": "saveByteArray(password=None)",
                "returns": "bytearray",
                "text": "Save the component into a bytearray. The bytearray is the same data that is held in a .tox file. <code>loadByteArray()</code> can be used to load the component.\n*password - (Keyword, Optional) If specified, encrypts the tox with the password."
            },
            {
                "class": "COMP",
                "name": "saveExternalTox",
                "call": "saveExternalTox(recurse=False, password=None)",
                "returns": "int",
                "text": "Save out the contents of any COMP referencing an external .tox\nReturns the number of components saved.\n*recurse - (Keyword, Optional) If set to True, child components are included in the operation.\n*password - (Keyword, Optional) If specified, encrypts the tox with the password.\n<syntaxhighlight lang=python>\nroot.saveExternalTox(recurse=True)\nop('geo1').saveExternalTox(recurse=False)\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "appendCustomPage",
                "call": "appendCustomPage(name)",
                "returns": "Page",
                "text": "Add a new [[Page Class|page]] of custom parameters. See [[Page Class]] for more details. See [[Custom Parameters]] for the procedure.\n<syntaxhighlight lang=python>\nn = op('base1')\npage = n.appendCustomPage('Custom1')\npage.appendFloat('X1')\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "destroyCustomPars",
                "call": "destroyCustomPars()",
                "returns": "Total",
                "text": "Remove all custom parameters from COMP."
            },
            {
                "class": "COMP",
                "name": "sortCustomPages",
                "call": "sortCustomPages(page1, page2, page3...)",
                "returns": "None",
                "text": "Reorder custom parameter pages by listing their page names.\n<syntaxhighlight lang=python>\nn = op('base1')\nn.sortCustomPages('Definition','Controls')\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "accessPrivateContents",
                "call": "accessPrivateContents(key)",
                "returns": "Bool",
                "text": "Gain access to a private component.  The component will still be private the next time it is saved or re-opened.\nReturns true when the key is correct, and access is granted. If dongle privacy is being used, no arguments are required.\n*key - (Optional) The existing key phrase. This should resolve to a non-blank string. Not required for dongle privacy.\n<syntaxhighlight lang=python>\nn.accessPrivateContents('secret')\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "addPrivacy",
                "call": "addPrivacy(key, developerName=None)",
                "returns": "None",
                "text": "Add privacy to a component with the given key.\nPrivacy can only be added to components that currently have no privacy. Adding Privacy requires a Pro license.\n*key - The new key phrase. This should resolve to a non-blank string.\n<syntaxhighlight lang=python>\nn.addPrivacy('secret')\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "addPrivacy",
                "call": "addPrivacy(firmCode, productCode, developerName=None, developerEmail=None)",
                "returns": "None",
                "text": "Add privacy to a component with the given CodeMeter firm code and product code.\nPrivacy can only be added to components that currently have no privacy. Adding Privacy requires a Pro license.\n\nThe first bit of the CodeMeter Dongle's Feature Map must be set to enable privacy and add prodcut code as well as to access the private component in edit mode later.\n\nThe private component can be used with any Dongle matching the firm code and product code without the first Feature Map bit set. In this case the component will run in private mode keeping the contents of the component hidden.\n*firmCode - The CodeMeter firm code to use. \n*productCode - The CodeMeter product code to use. \n<syntaxhighlight lang=python>\nn.addPrivacy(10, 4)\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "blockPrivateContents",
                "call": "blockPrivateContents(key)",
                "returns": "None",
                "text": "Block access to a private component that was temporarily accessible.\n<syntaxhighlight lang=python>\nn.blockPrivateContents()\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "removePrivacy",
                "call": "removePrivacy(key)",
                "returns": "Bool",
                "text": "Completely remove privacy from a component.\nReturns true when the key is correct.\n*key - The existing key phrase. This should resolve to a non-blank string.\n<syntaxhighlight lang=python>\nn.removePrivacy('secret')\n</syntaxhighlight>"
            },
            {
                "class": "COMP",
                "name": "setVar",
                "call": "setVar(name, value)",
                "returns": "None",
                "text": "Set a component variable to the specified value.\n*name - The variable name to use.\n*value - The value for this variable."
            },
            {
                "class": "COMP",
                "name": "unsetVar",
                "call": "unsetVar(name)",
                "returns": "None",
                "text": "Unset the specified component variable. This removes the entry from the '<code>local/set_variables</code>' table, if found.\n*name - The name of the variable to unset."
            },
            {
                "class": "COMP",
                "name": "vars",
                "call": "vars(pattern1, pattern2...)",
                "returns": "List",
                "text": "Return a list of all component variables in this COMP. Optional name patterns may be specified.\n*pattern -  (Optional) The name(s) of variables whose values should be returned. [[Pattern Matching]] can be used.\n<syntaxhighlight lang=python>\na = n.vars()\na = n.vars('A*', 'B*')\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP"
        ],
        "summary": "A COMP describes a reference to a [[Component]] operator."
    },
    "compositeCHOP": {
        "label": "compositeCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "",
                "class": "compositeCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "compositeTOP": {
        "label": "compositeTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "Connector": {
        "label": "Connector",
        "members": [
            {
                "class": "Connector",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The numeric index of this connector."
            },
            {
                "class": "Connector",
                "name": "isInput",
                "type": "bool",
                "set": "0",
                "text": "True when the connector is an input."
            },
            {
                "class": "Connector",
                "name": "isOutput",
                "type": "bool",
                "set": "0",
                "text": "True when the connector is an output."
            },
            {
                "class": "Connector",
                "name": "inOP",
                "type": "OP",
                "set": "0",
                "text": "Will return any input operators (e.g. [[inSOP Class|inSOP]], [[inCHOP Class|inCHOP]]) associated with this connector.  This only applies to regular operator connections attached to components."
            },
            {
                "class": "Connector",
                "name": "outOP",
                "type": "OP",
                "set": "0",
                "text": "Will return any output operators (e.g. [[outSOP Class|outSOP]], [[outCHOP Class|outCHOP]]) associated with this connector.  This only applies to regular operator connections attached to components."
            },
            {
                "class": "Connector",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Connector",
                "name": "connections",
                "type": "list",
                "set": "0",
                "text": "The list of [[Connector Class|connector objects]] connected to this object."
            },
            {
                "class": "Connector",
                "name": "description",
                "type": "str",
                "set": "0",
                "text": "A description for this connection. Example: 'Color Image'."
            }
        ],
        "methods": [
            {
                "class": "Connector",
                "name": "connect",
                "call": "connect(target)",
                "returns": "None",
                "text": "Wire this connector to a target location. The target may be an [[OP Class|operator]] or another connector.\nWhen the connector is an input, its connection is replaced with the target.\nWhen the connector is an output, a new connection is appended to the target.\n*target - The OP or connector you want to connect to.\n<syntaxhighlight lang=python>\n# connect noise1 to lag1\nop('noise1').outputConnectors[0].connect(op('lag1'))\n\n# connect choptotop1 to 2nd input of displace1\nop('choptotop1').outputConnectors[0].connect(op('displace1').inputConnectors[1])\n\n# connect geo1 to geo2, two equivalent methods:\nop('geo1').outputCOMPConnectors[0].connect(op('geo2'))\nop('geo2').inputCOMPConnectors[0].connect(op('geo1'))\n</syntaxhighlight>"
            },
            {
                "class": "Connector",
                "name": "disconnect",
                "call": "disconnect()",
                "returns": "None",
                "text": "Disconnect this connector.\n<syntaxhighlight lang=python>\nop('lag1').inputConnectors[0].disconnect()\nop('lag1').outputConnectors[0].disconnect()\n\n# disconnect geo2 from geo1, two equivalent methods\nop('geo1').outputCOMPConnectors[0].disconnect()\nop('geo2').inputCOMPConnectors[0].disconnect()\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Connector class describes the input or output connection point of an [[OP Class#Connection|operator]].  There are two types of connections:  those between Components, and those between regular operators.\nConnections between regular operators can be accessed through the [[OP Class#Connection|OP.inputConnectors]] and [[OP Class#Connection|OP.outputConnectors]] members. These are the connectors on the left and right sides of [[Operator|Operators]].\nConnections between components can be accessed through the [[COMP Class#Connection|COMP.inputCOMPConnectors]] and [[COMP Class|COMP.outputCOMPConnectors]] members. These are the connectors on the top and bottom of [[Component]] operators"
    },
    "constantCHOP": {
        "label": "constantCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "constantMAT": {
        "label": "constantMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "constantTOP": {
        "label": "constantTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "containerCOMP": {
        "label": "containerCOMP",
        "members": [],
        "methods": [
            {
                "text": "Simulate a mouse click on a container panel at a specific location.\n*u - The first coordinate of the click.\n*v - The second coordinate of the click.\n*clickCount - (Keyword, Optional) If set, it sets the number of clicks. For double clicking etc.\n*force - (Keyword, Optional) If set to True, forces the panel click, even when its disabled.\n*left,middle,right - (Keyword, Optional) Overrides the default mouse button used.  When none are set, the left mouse button is pressed, and the other buttons are released.\n*group - (Keyword, Optional) Specifies an optional panel group name.  See the [[Button COMP]] for a description of group labels.\n<syntaxhighlight lang=python>\nop('container1').click(0.4, 0.5) # Update U and V\n</syntaxhighlight>",
                "returns": "None",
                "name": "click",
                "call": "click(u, v, clickCount=1, force=False, left=False, middle=False, right=False, group=None)",
                "class": "containerCOMP"
            },
            {
                "text": "Simulate a mouse click of a sub-panel within a container panel.  This can be used to click radio buttons within a single container.\n*childIndex - indicates the child panel to click.\n*clickCount - (Keyword, Optional) If set, it sets the number of clicks. For double clicking etc.\n*force - (Keyword, Optional) If set to True, forces the panel click, even when its disabled.\n*left,middle,right - (Keyword, Optional) Overrides the default mouse button used.  When none are set, the left mouse button is pressed, and the other buttons are released.\n*group - (Keyword, Optional) Specifies an optional panel group name.  See the [[Button COMP]] for a description of group labels.\n<syntaxhighlight lang=python>\nop('container1').clickChild(2) # Click the third child panel inside a container.\n</syntaxhighlight>",
                "returns": "None",
                "name": "clickChild",
                "call": "clickChild(childIndex, clickCount=1, force=False, left=False, middle=False, right=False, group=None)",
                "class": "containerCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "PanelCOMP",
            "COMP"
        ]
    },
    "convertDAT": {
        "label": "convertDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "convertSOP": {
        "label": "convertSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "convolveTOP": {
        "label": "convolveTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "copyCHOP": {
        "label": "copyCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "copyCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "copyCHOP",
                "name": "sampleIndex"
            },
            {
                "set": "0",
                "text": "The current copy index, beginning at zero.",
                "type": "int",
                "class": "copyCHOP",
                "name": "copyIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "copySOP": {
        "label": "copySOP",
        "members": [
            {
                "set": "0",
                "text": "The current copy index, beginning at zero.",
                "type": "int",
                "class": "copySOP",
                "name": "copyIndex"
            },
            {
                "set": "0",
                "text": "The total number of copies.",
                "type": "int",
                "class": "copySOP",
                "name": "copyTotal"
            },
            {
                "set": "0",
                "text": "The current [[Point Class|point]] being evaluated, of the template.",
                "type": "int",
                "class": "copySOP",
                "name": "inputPoint"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "cornerpinTOP": {
        "label": "cornerpinTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "countCHOP": {
        "label": "countCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "cplusplusCHOP": {
        "label": "cplusplusCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "cplusplusSOP": {
        "label": "cplusplusSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "cplusplusTOP": {
        "label": "cplusplusTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "creepSOP": {
        "label": "creepSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "cropTOP": {
        "label": "cropTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "crossCHOP": {
        "label": "crossCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "crossTOP": {
        "label": "crossTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "cubemapTOP": {
        "label": "cubemapTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "CUDAMemory": {
        "label": "CUDAMemory",
        "members": [
            {
                "class": "CUDAMemory",
                "name": "ptr",
                "type": "memory address",
                "set": "0",
                "text": "Returns the raw memory pointer address for the CUDA memory."
            },
            {
                "class": "CUDAMemory",
                "name": "size",
                "type": "int",
                "set": "0",
                "text": "Returns the size of the CUDA Memory, in bytes."
            },
            {
                "class": "CUDAMemory",
                "name": "shape",
                "type": "CUDAMemoryShape",
                "set": "0",
                "text": "Returns the [[CUDAMemoryShape Class]] describing this CUDA memory. See the help for that class for notes about channel order for different data types."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "Holds a reference to CUDA memory. The CUDA memory will be deallocated when this class is destructed."
    },
    "CUDAMemoryShape": {
        "label": "CUDAMemoryShape",
        "members": [
            {
                "class": "CUDAMemoryShape",
                "name": "width",
                "type": "int",
                "set": "1",
                "text": "Get/Set the width in pixels of the memory."
            },
            {
                "class": "CUDAMemoryShape",
                "name": "height",
                "type": "int",
                "set": "1",
                "text": "Get/Set the height in pixels of the memory."
            },
            {
                "class": "CUDAMemoryShape",
                "name": "numComps",
                "type": "int",
                "set": "1",
                "text": "Get/Set the number of color components per pixel of the memory."
            },
            {
                "class": "CUDAMemoryShape",
                "name": "dataType",
                "type": "numpy data type",
                "set": "1",
                "text": "Get/Set the data type of each color component, as a numpy data type. E.g numpy.uint8, numpy.float32. Note that for uint8 data types, the channel ordering will be BGRA for 4 component textures. It will be RGBA however for other data types."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "Describes the shape of a CUDA memory segment."
    },
    "curveclaySOP": {
        "label": "curveclaySOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "curvesectSOP": {
        "label": "curvesectSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "cycleCHOP": {
        "label": "cycleCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "DAT": {
        "label": "DAT",
        "members": [
            {
                "class": "DAT",
                "name": "export",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Export Flag]]"
            },
            {
                "class": "DAT",
                "name": "module",
                "type": "module",
                "set": "0",
                "text": "Retrieve the contents of the DAT as a module. This allows for functions in the module to be called directly. E.g n.module.function(arg1, arg2)"
            },
            {
                "class": "DAT",
                "name": "numRows",
                "type": "int",
                "set": "0",
                "text": "Number of rows in the DAT table."
            },
            {
                "class": "DAT",
                "name": "numCols",
                "type": "int",
                "set": "0",
                "text": "Number of columns in the DAT table."
            },
            {
                "class": "DAT",
                "name": "text",
                "type": "str",
                "set": "1",
                "text": "Get or set contents. Tables are treated as tab delimited columns, newline delimited rows."
            },
            {
                "class": "DAT",
                "name": "editingFile",
                "type": "str",
                "set": "0",
                "text": "The path to the current file used by external editors."
            },
            {
                "class": "DAT",
                "name": "isTable",
                "type": "bool",
                "set": "0",
                "text": "True if the DAT contains table formatted data."
            },
            {
                "class": "DAT",
                "name": "isText",
                "type": "bool",
                "set": "0",
                "text": "True if the DAT contains text formatted data. (ie, not table formatted)."
            },
            {
                "class": "DAT",
                "name": "isEditable",
                "type": "bool",
                "set": "0",
                "text": "True if the DAT contents can be edited (Text DATs, Table DATs, locked DATs etc)."
            },
            {
                "class": "DAT",
                "name": "isDAT",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a DAT."
            },
            {
                "class": "DAT",
                "name": "locals",
                "type": "dict",
                "set": "0",
                "text": "Local dictionary used during python execution of scripts in this DAT. The dictionary attribute is read only, but not its contents. Its contents may be manipulated directly with scripts, or with an [[Examine DAT]]."
            },
            {
                "class": "DAT",
                "name": "jsonObject",
                "type": "dict",
                "set": "0",
                "text": "Parses the DAT as json and returns a python object."
            }
        ],
        "methods": [
            {
                "class": "DAT",
                "name": "run",
                "call": "run(arg1, arg2..., endFrame=False, fromOP=None, asParameter=False, group=None, delayFrames=0, delayMilliSeconds=0, delayRef=me)",
                "returns": "td.Run",
                "text": "[[Run Class|Run]] the contents of the DAT as a script, returning a Run object which can be used to optionally modify its execution.\n*arg - (Optional) Arguments that will be made available to the script in a local tuple named args.\n*endFrame - (Keyword, Optional) If set to True, the execution will be delayed until the end of the current frame.\n*fromOP - (Keyword, Optional) Specifies an optional [[OP Class|operator]] from which the execution will be run relative to.\n*asParameter - (Keyword, Optional) When fromOP used, run relative to a parameter of fromOP.\n*group - (Keyword, Optional) Can be used to specify a group label string. This label can then be used with the [[Runs Class|td.runs]] object to modify its execution.\n*delayFrames - (Keyword, Optional) Can be used to delay the execution a specific amount of frames.\n*delayMilliSeconds - (Keyword, Optional) Can be used to delay the execution a specific amount of milliseconds.  This value is rounded to the nearest frame.\n*delayRef - (Keyword, Optional) Specifies an optional [[OP Class|operator]] which is controlled by a different [[Time COMP|Time Component]].  If your own local timeline is paused, you can point to another timeline to ensure this script will still execute for example."
            },
            {
                "class": "DAT",
                "name": "save",
                "call": "save(filepath, append=False, createFolders=False)",
                "returns": "str",
                "text": "Saves the content of the DAT to the file system. Returns the file path that it was saved to.\n*filepath - (Optional) The path and filename to save the file to. If this is not given then a default named file will be saved to project.folder\n*append - (Keyword, Optional) If set to True and the format is txt, then the contents are appended to the existing file.\n*createFolders - (Keyword, Optional) If True, it creates the not existent directories provided by the filepath.\n<syntaxhighlight lang=python>\nname = n.save() #save in native format with default name\nn.save('output.txt') #human readable format without channel names\nn.save('C:/Desktop/myFolder/output.txt', createFolders=True)  # supply file path and createFolder flag\n</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "write",
                "call": "write(args)",
                "returns": "str",
                "text": "Append content to this DAT. Can also be used to implement DAT printing functions.\n<syntaxhighlight lang=python>\n# grab DAT\nn = op('text1')\n# append message directly to DAT\nn.write('Hello World')\n# use print method\nprint('Hello World', file=n)\n</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "detectLanguage",
                "call": "detectLanguage(setLanguage=False)",
                "returns": "str",
                "text": "Returns the result of attempting to auto-detect the programming language in the DAT based on the contained text. \n*setLanguage - (Keyword, Optional) If True sets the language parameters on the DAT appropriately"
            },
            {
                "class": "DAT",
                "name": "clear",
                "call": "clear(keepSize=False, keepFirstRow=False, keepFirstCol=False)",
                "returns": "None",
                "text": "Remove all rows and columns from the table.\n*keepSize - (Keyword, Optional) If set to True, size is unchanged, but entries will be set to blank, dependent on other options below.\n*keepFirstRow - (Keyword, Optional) If set to True, the first row of cells are retained.\n*keepFirstCol - (Keyword, Optional) If set to True, the first column of cells are retained.\n<syntaxhighlight lang=python>\nn.clear() #remove all rows and columns\nn.clear(keepSize=True) #set all table cells to blank\nn.clear(keepFirstRow=True) #remove all rows, but keep the first\nn.clear(keepFirstRow=True, keepFirstCol=True) #keep the first row, first column, and set remaining cells to blank\n</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "copy",
                "call": "copy(DAT)",
                "returns": "None",
                "text": "Copy the text or table from the specified [[DAT]] operator.\n*OP - The DAT operator whose contents should be copied into the DAT."
            },
            {
                "class": "DAT",
                "name": "appendRow",
                "call": "appendRow(vals, nameOrIndex, sort=None)",
                "returns": "int",
                "text": "Append a row to the end of the table, or after the specified row name/index.  Returns the integer index of the new row.\n*vals - (Optional) If specified, will fill the row with the given values. It should be a list of items that can be expressed as strings.  Each item will be copied to one [[Cell Class|cell]].\n*nameOrIndex - (Optional) If specified will determine where the new row will be appended. If it's a numeric value it represents the numeric index of the row. If it is a string it represents a row label.\n*sort - (Keyword, Optional) If specified will determine the column to keep sorted after the insertion. If it's a numeric value it represents the numeric index of the column. If it is a string it represents a column label.\n<syntaxhighlight lang=python>\nn.appendRow()\nn.appendRow( [1,2,3], 'January' )  #append with values (1,2,3) after the row labelled 'January'\nn.appendRow( [1,2,3], 5 )  #append row with values (1,2,3) after the row 5.\nn.appendRow( [1,2,3], sort='Month' )  #append row with values (1,2,3) keeping column 'Month' sorted.\n</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "appendRows",
                "call": "appendRows(vals, nameOrIndex, sort=None)",
                "returns": "int",
                "text": "Append rows to the end of the table, or after the specified row name/index. Returns the integer of the last row appended.\n*vals - (Optional) If specified, will fill the rows with the given values. It should be a list of lists of items that can be expressed as strings.  Each item will be copied to one cell.\n*nameOrIndex - (Optional) If specified will determine where the new row will be appended. If it's a numeric value it represents the numeric index of the row. If it is a string it represents a row label.\n*sort - (Keyword, Optional) If specified will determine the column to keep sorted after the insertion. If it's a numeric value it represents the numeric index of the column. If it is a string it represents a column label.\n<syntaxhighlight lang=python>n.appendRows()\nn.appendRows( [[1,2,3],[4,5,6,7]], 'January' )  #after the row labelled 'January append 2 rows: first one with values (1,2,3), then one with values (4,5,6,7)\nn.appendRows( [[1,2,3]], 5 )  # after row 5 append one row with values (1,2,3).\nn.appendRows( [1,2,3] )  # append 3 rows with values 1, 2, 3 respectively.</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "appendCol",
                "call": "appendCol(vals, nameOrIndex, sort=None)",
                "returns": "int",
                "text": "Append a column to the end of the table. See appendRow for similar usage."
            },
            {
                "class": "DAT",
                "name": "appendCols",
                "call": "appendCols(vals, nameOrIndex, sort=None)",
                "returns": "int",
                "text": "Append columns to the end of the table. See appendRows for similar usage."
            },
            {
                "class": "DAT",
                "name": "insertRow",
                "call": "insertRow(vals, nameOrIndex, sort=None)",
                "returns": "int",
                "text": "Insert a row to the beginning of the table or before the specified row name/index.  See DAT.appendRow() for similar usage."
            },
            {
                "class": "DAT",
                "name": "insertCol",
                "call": "insertCol(vals, nameOrIndex, sort=None)",
                "returns": "int",
                "text": "Insert a column to the beginning of the table or before the specified row name/index. See DAT.appendRow() for similar usage."
            },
            {
                "class": "DAT",
                "name": "replaceRow",
                "call": "replaceRow(nameOrIndex, vals, entireRow=True)",
                "returns": "int",
                "text": "Replaces the contents of an existing row.\n*nameOrIndex - Specifies the row that will be replaced. If it's a numeric value it represents the numeric index of the row. If it is a string it represents a row label.\n*vals - (Optional) If specified, will overwrite the row with the given values. It should be a list of lists of items that can be expressed as strings.  Each item will be copied to one cell.\n*entireRow - (Keyword, Optional) If True, overwrites every cell in the specified row. If False, will only overwrite as many cells in the row as there are items in vals.\n<syntaxhighlight lang=python>\nn.replaceRow(0) # will empty all the cells in row 0 (ie. replaced with nothing)\nn.replaceRow('January', ['January', 1,2,3])  # the row 'January' will be replaced with the list of 4 items.\nn.replaceRow(2, [1,2,3], entireRow=False)  # at row 2 the 3 items will replace the first 3 items in the row.</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "replaceCol",
                "call": "replaceCol(nameOrIndex, vals, entireCol=True)",
                "returns": "int",
                "text": "Replaces the contents of an existing column. See DAT.replaceRow for similar usage."
            },
            {
                "class": "DAT",
                "name": "deleteRow",
                "call": "deleteRow(nameOrIndex)",
                "returns": "None",
                "text": "Delete a single row at the specified row name or index.\n*nameOrIndex - May be a string for a row name, or numeric index for rowindex."
            },
            {
                "class": "DAT",
                "name": "deleteRows",
                "call": "deleteRows(vals)",
                "returns": "None",
                "text": "Deletes multiple rows at the row names or indices specified in vals.\n*vals - If specified, will delete each row given. It should be a list of items that can be expressed as strings. If no vals is provided deleteRows does nothing."
            },
            {
                "class": "DAT",
                "name": "deleteCol",
                "call": "deleteCol(nameOrIndex)",
                "returns": "None",
                "text": "Delete a single column at the specified column name or index.\n*nameOrIndex - May be a string for a column name, or numeric index for column index."
            },
            {
                "class": "DAT",
                "name": "deleteCols",
                "call": "deleteCols(vals)",
                "returns": "None",
                "text": "Deletes multiple columns at the column names or indices specified in vals.\n*vals - If specified, will delete each column given. It should be a list of items that can be expressed as strings. If no vals is provided deleteCols does nothing."
            },
            {
                "class": "DAT",
                "name": "setSize",
                "call": "setSize(numrows, numcols)",
                "returns": "None",
                "text": "Set the exact size of the table.\n*numrows - The number of rows the table should have.\n*numcols - The number of columns the table should have."
            },
            {
                "class": "DAT",
                "name": "scroll",
                "call": "scroll(row, col)",
                "returns": "None",
                "text": "Bring current DAT viewers to the specified row and column\n*row - Row to scroll to.\n*col - (Optional) Column to scroll to for tables."
            },
            {
                "class": "DAT",
                "name": "[]",
                "call": "[rowNameOrIndex, colNameOrIndex]",
                "returns": "td.Cell",
                "text": "[[Cell Class|cells]] in a table may be accessed with the <code>[]</code> subscript operator.\nThe NameOrIndex may be an exact string name, or it may be a numeric index value. [[Pattern Matching]] is ''not'' supported.\n*rowNameOrIndex - If a string it specifies a row name, if it's numeric it specifies a row index.\n*colNameOrIndex - If a string it specifies a column name, if it's numeric it specifies a column index.\n<syntaxhighlight lang=python>\nc = n[4, 'June']\nc = n[3, 4]\n</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "cell",
                "call": "cell(rowNameOrIndex, colNameOrIndex, caseSensitive=True)",
                "returns": "td.Cell or None",
                "text": "Find a single [[Cell Class|cell]] in the table, or None if none are found.\n*rowNameOrIndex/colNameOrIndex - If a string it specifies a row/column name. If it's numeric it specifies a row/column index. [[Pattern Matching]] is supported for strings.\n*caseSensitive - (Optional) Specifies whether or not case sensitivity is used.\n<syntaxhighlight lang=python>\nc = n.cell(5, 'June') #Return a cell under row 5, column 'June'.\nc = n.cell('A*', 2) #Find a cell under any row beginning with an A, in column 2.\n</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "cells",
                "call": "cells(rowNameOrIndex, colNameOrIndex, caseSensitive=True)",
                "returns": "list",
                "text": "Returns a (possibly empty) list of [[Cell Class|cells]] that match the given row/column names or indices. See DAT.cell method for similar usage."
            },
            {
                "class": "DAT",
                "name": "findCell",
                "call": "findCell(pattern, rows=None, cols=None, valuePattern=True, rowPattern=True, colPattern=True, caseSensitive=False)",
                "returns": "Cell or None",
                "text": "Returns a cell that matches the given pattern and row/column names or indices or None if no match is found.\n*pattern - The pattern to match a cell.\n*rows (Keyword, Optional) - If specified, looks for cell only in the specified rows. Must be specified as a list.\n*cols (Keyword, Optional) - If specified, looks for cell only in the specified columns. Must be specified as a list.\n*valuePattern, rowPattern, colPattern(Keyword, Optional) - If specified and set to False, disables pattern matching for a cell, rows or columns.\n*caseSensitive(Keyword, Optional) - Cell matching is case sensitive if set to true.\n<syntaxhighlight lang=python>\n# given a table \"table1\":\n# # id # fruit      # color  #\n# # 0  # Strawberry # Red    #\n# # 1  # Banana     # Yellow #\n# # 2  # Cucumber   # Green  #\n# # 3  # Blueberry  # Blue   #\n# # 4  # Clementine # Orange #\n# # 5  # *Fruit     # Green  #\n\n# t is the reference to a table DAT\nt = op('/project1/table1')\n\n# search for any cell with the value 'Red'\n# will return type:Cell cell:(1, 2) owner:/project1/table1 value:Red\nt.findCell('Red')\n\n# search for any cell in the column 'fruit' with a value starting with 'blue'\n# will return type:Cell cell:(4, 1) owner:/project1/table1 value:Blueberry\nt.findCell('blue*',cols=['fruit'])\n\n# search for any cell in the column 'fruit' with a value starting with 'blue'\n# with case-sensitive search enabled\n# will return None\nt.findCell('blue*',cols=['fruit'], caseSensitive=True)\n\n# will return type:Cell cell:(0, 1) owner:/project1/table1 value:fruit\n# as the '*' in the search pattern will be used to pattern match, the \n# first row of the second column is matched\nt.findCell('*Fruit')\n\n# will return type:Cell cell:(6, 1) owner:/project1/table1 value:*Fruit\n# as pattern matching for the search pattern is disabled\n# hence the '*' is not interpreted as a pattern but a string to look for\nt.findCell('*Fruit', valuePattern=False)\n</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "findCells",
                "call": "findCells(pattern, rows=None, cols=None, valuePattern=True, rowPattern=True, colPattern=True)",
                "returns": "list",
                "text": "Returns a (possibly empty) list of cells that match the given patterns and row/column names or indices.\n*pattern - The pattern to match cells.\n*rows (Keyword, Optional) - If specified, looks for cells only in the specified rows.\n*cols (Keyword, Optional) - If specified, looks for cells only in the specified columns.\n*valuePattern, rowPattern, colPattern(Keyword, Optional) - If specified, overrides pattern matching for cells, rows or columns.\n*caseSensitive(Keyword, Optional) - Cell matching is case sensitive if set to true."
            },
            {
                "class": "DAT",
                "name": "row",
                "call": "row(nameOrIndex1, nameOrIndex2..., caseSensitive=True)",
                "returns": "list",
                "text": "Returns a list of [[Cell Class|cells]] from the row matching the name/index, or None if nothing is found.\nSee DAT.col() for similar usage."
            },
            {
                "class": "DAT",
                "name": "rows",
                "call": "rows(nameOrIndex1, nameOrIndex2..., caseSensitive=True)",
                "returns": "list of lists",
                "text": "Returns a (possibly empty) list of rows (each row being a list of cells). If no arguments are given it returns all rows in the table.\nSee DAT.rows() for similar usage.\n<syntaxhighlight lang=python>\nfor r in op('table1').rows():\n\t# do something with row 'r'\n</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "col",
                "call": "col(nameOrIndex1, nameOrIndex2..., caseSensitive=True)",
                "returns": "list",
                "text": "Returns a list of all the [[Cell Class|cells]] in a column, or None if nothing is found.\n*nameOrIndex - If a string it specifies a column name, if it's numeric it specifies a column index. [[Pattern Matching]] is supported.\n*caseSensitive - (Optional) Specifies whether or not case sensitivity is used.\n<syntaxhighlight lang=python>\nr = op('table1').col(3, caseSensitive=False)\nr = op('table1').col('June')\nr = op('table1').col('A*', 'B*') #returns first column beginning with A or B\n</syntaxhighlight>"
            },
            {
                "class": "DAT",
                "name": "cols",
                "call": "cols(nameOrIndex1, nameOrIndex2..., caseSensitive=True)",
                "returns": "list of lists",
                "text": "Returns a (possibly empty) list of columns (each being a list themselves). See DAT.col for similar usage. If no arguments are given then all columns in the table are returned.\n*nameOrIndex - (Optional) If a string it specifies a column name, if it's numeric it specifies a column index. [[Pattern Matching]] is supported.\n*caseSensitive - (Optional) Specifies whether or not case sensitivity is used.\n<syntaxhighlight lang=python>\nfor c in op('table1').cols():\n\t# do something with each column 'c'\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP"
        ],
        "inherit": "OP",
        "summary": "A [[DAT]] describes a reference to a DAT operator."
    },
    "datexecuteDAT": {
        "label": "datexecuteDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "dattoCHOP": {
        "label": "dattoCHOP",
        "members": [
            {
                "set": "0",
                "text": "The current input [[Cell Class|cell]] being evaluated. From the [[Cell Class|cell]] you can get its row, column and value. e.g. me.inputCell.val or use the specific members listed below.",
                "type": "td.Cell",
                "class": "dattoCHOP",
                "name": "inputCell"
            },
            {
                "set": "0",
                "text": "The current input colunn being evaluated.",
                "type": "td.Col",
                "class": "dattoCHOP",
                "name": "inputCol"
            },
            {
                "set": "0",
                "text": "The current input row being evaluated.",
                "type": "td.Row",
                "class": "dattoCHOP",
                "name": "inputRow"
            },
            {
                "set": "0",
                "text": "The current input [[DAT Class|DAT]] being evaluated.",
                "type": "OP",
                "class": "dattoCHOP",
                "name": "inputTable"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "dattoSOP": {
        "label": "dattoSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "debug": {
        "label": "debug",
        "members": [
            {
                "class": "debug",
                "name": "style",
                "type": "types.SimpleNamespace",
                "set": "1",
                "text": "A namespace containing information about how to process <code>debug</code> statements. This data is not meant to be changed directly. Instead, use the setStyle function below."
            }
        ],
        "methods": [
            {
                "class": "debug",
                "name": "debug",
                "call": "debug(*args)",
                "returns": "None",
                "text": "Print all args and extra debug info (default is DAT and line number) to texport. To change behavior, use the [[Palette:debugControl|debugControl]] component or setStyle function (below).<br>'''TIP: Always use <code>debug</code> instead of <code>print</code> when debugging Python scripts.'''"
            },
            {
                "class": "debug",
                "name": "setStyle",
                "call": "setStyle(printStyle=None, showDAT=None, showFunction=None, showLineNo=None, timeStamp=' ', suppress=None, formatOverride=None, functionOverride=None)",
                "returns": "None",
                "text": "Set the style for the built in TD debug function. Any arguments passed as None will leave that feature unchanged.\n    \n:<code>printStyle</code>: \n::<code>'pprint'</code>=convert non-string args to pprint.pformat(arg, indent=4, sort_dicts=False). Makes lists, dicts, etc. easily readable\n::<code>'pprint_sorted'</code>=convert non-string args to pprint.pformat(arg, indent=4). Makes lists, dicts, etc. easily readable. Dict keys will be alphabetized\n::<code>'repr'</code>=convert non-string args to repr(arg)\n::otherwise, convert non-string args to str(arg)\n:<code>showDAT</code>: in debug message, show the DAT where debug was called\n:<code>showFunction</code>: in debug message, show function where debug was called\n:<code>showLineNo</code>: in debug message, show line number where debug was called\n:<code>suppress</code>: if True, suppress (don't print) any debug calls \n:<code>timeStamp</code>: [https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes Python time format code].\n:<code>formatOverride</code>: overrides the default message that debug prints. You can use {0}, {1}, and {2} for DAT, function, and line number\n:<code>functionOverride</code>: overrides the builtin TD debug function. This function will be called with all arguments from any debug calls in your project. Set to False to remove override."
            },
            {
                "class": "debug",
                "name": "debugs",
                "call": "debugs(*args)",
                "returns": "str",
                "text": "Return the string that would be printed by the debug function. To change \n\tbehavior, use the [[Palette:debugControl|debugControl]] component or setStyle function (above). This is a utility function for building custom debug systems."
            },
            {
                "class": "debug",
                "name": "info",
                "call": "info(*args, stackOffset=0)",
                "returns": "list",
                "text": "Return all args and extra debug info as processed by the debug function. To\n\tchange behavior, use the [[Palette:debugControl|debugControl]] component or setStyle function (above). This is a utility function for building custom debug systems."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The <code>debug</code> module provides tools for use with TouchDesigner's builtin <code>debug</code> statement. It also contains utilities for customizing those statements and building customized debug output. It is a member of [[Tdu Module]].\n\nYou can use the [[Palette:debugControl|debugControl]] component in the palette to set up <code>debug</code> behavior without using Python."
    },
    "deformSOP": {
        "label": "deformSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "delayCHOP": {
        "label": "delayCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "delayCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "deleteCHOP": {
        "label": "deleteCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "deleteSOP": {
        "label": "deleteSOP",
        "members": [
            {
                "set": "0",
                "text": "The current [[Point Class|point]] being evaluated. Can only be used in the parameters for this SOP.",
                "type": "int",
                "class": "deleteSOP",
                "name": "inputPoint"
            },
            {
                "set": "0",
                "text": "The current [[Prim Class|primitive]] being evaluated. Can only be used in the parameters for this SOP.",
                "type": "int",
                "class": "deleteSOP",
                "name": "inputPrim"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "Dependency": {
        "label": "Dependency",
        "members": [
            {
                "class": "tdu.Dependency",
                "name": "val",
                "type": "value",
                "set": "1",
                "text": "The value associated with this object. Referencing this value in an expression will cause the operator to become dependent on its value. Setting this value will cause those operators to be recooked as necessary."
            },
            {
                "class": "tdu.Dependency",
                "name": "peekVal",
                "type": "value",
                "set": "0",
                "text": "This returns the same value as .val but does not create a dependency on the value."
            },
            {
                "class": "tdu.Dependency",
                "name": "callbacks",
                "type": "list",
                "set": "1",
                "text": "A modifiable list of functions. When the Dependency object is modified, it calls each function on the list. Each function is called with a single argument which is a dictionary containing the following:\n* 'dependency'- The Dependency that was modified.\n* 'prevVal' - The previous value if available.\n* 'callback' - This callback function."
            },
            {
                "class": "tdu.Dependency",
                "name": "ops",
                "type": "list",
                "set": "0",
                "text": "A list of [[OP Class|operators]] currently dependent on the object."
            },
            {
                "class": "tdu.Dependency",
                "name": "listAttributes",
                "type": "list",
                "set": "0",
                "text": "A list of [[ListAttribute Class|list attributes]] currently dependent on the object."
            }
        ],
        "methods": [
            {
                "class": "tdu.Dependency",
                "name": "modified",
                "call": "modified()",
                "returns": "None",
                "text": "This call is needed when changing not the value itself, but a subcomponent. For example, if Dependency.val is a dictionary, setting any of the members will not notify the dependent operators. A call to modified is necessary."
            },
            {
                "class": "tdu.Dependency",
                "name": "[]",
                "call": "[<index or key>]",
                "returns": "collection value",
                "text": "'''Only when the dependency wraps iterable or mapped data such as a list or dictionary''', you can use [] to access the items in the wrapped data.\n<syntaxhighlight lang=python>\ndep = tdu.Dependency({'fred': 33, 'wilma':39})\nprint(dep['fred']) # prints \"33\". The key to the dictionary works directly on the dependency object.\ndep2 = tdu.Dependency([\"a\", \"d\", \"g\"])\nprint(dep[2]) # prints \"g\". The index to the list works directly on the dependency object.\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "A '''[[Dependency]]''' object is a value that automatically causes any expression referencing it to update when the dependency value has changed.  These objects eliminate the need to manually force cook operators referencing values in [[Extensions]] or [[OP_Class#Storage|Storage]] for example.\nFor information about dependencies in mutable objects (lists, dicts, sets), see '''[[TDStoreTools#Deeply_Dependable_Collections|Deeply Dependable Collections]]'''"
    },
    "depthMAT": {
        "label": "depthMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "depthTOP": {
        "label": "depthTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "differenceTOP": {
        "label": "differenceTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "directxinTOP": {
        "label": "directxinTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "directxoutTOP": {
        "label": "directxoutTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "displaceTOP": {
        "label": "displaceTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "divideSOP": {
        "label": "divideSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "dmxinCHOP": {
        "label": "dmxinCHOP",
        "members": [
            {
                "set": "0",
                "text": "Get a Timecode object for the last ArtTimeCode packet received. See [[Timecode Class]].",
                "type": "tdu.Timecode",
                "class": "dmxinCHOP",
                "name": "timecode"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "dmxoutCHOP": {
        "label": "dmxoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "Dongle": {
        "label": "Dongle",
        "members": [
            {
                "class": "Dongle",
                "name": "serialNumber",
                "type": "str",
                "set": "0",
                "text": "Dongle Serial Number."
            }
        ],
        "methods": [
            {
                "class": "Dongle",
                "name": "applyUpdate",
                "call": "applyUpdate(str)",
                "returns": "None",
                "text": "Takes an update as a string and applies it to the dongle."
            },
            {
                "class": "Dongle",
                "name": "createUpdateContext",
                "call": "createUpdateContext()",
                "returns": "str",
                "text": "Returns a string which is the remote programming update context for the dongle."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "A class to interact with a single dongle connected to the system."
    },
    "DongleList": {
        "label": "DongleList",
        "members": [],
        "methods": [
            {
                "class": "DongleList",
                "name": "refreshDongles",
                "call": "refreshDongles()",
                "returns": "None",
                "text": "Refreshes the list of dongles connected to the system and their product codes."
            },
            {
                "class": "DongleList",
                "name": "encrypt",
                "call": "encrypt(firmCode, productCode, data)",
                "returns": "ByteArray",
                "text": "Encrypts a string or byte array using a CodeMeter dongle with a given firm code and product code installed on it. If successful it returns a byte array with the encrypted data.\n* firmCode - The firm code to use. It must be present on the dongle.\n* productCode - The product code to use. It must be present on the dongle.\n* data - A string or byte array to encrypt. Must be 16 bytes in size at least."
            },
            {
                "class": "DongleList",
                "name": "decrypt",
                "call": "decrypt(firmCode, productCode, data)",
                "returns": "ByteArray",
                "text": "Decrypts a string or byte array using a CodeMeter dongle with a given firm code and product code installed on it. If successful it returns a byte array with the decrypted data.\n* firmCode - The firm code to use. It must be present on the dongle.\n* productCode - The product code to use. It must be present on the dongle.\n* data - A string or byte array to decrypt. Must be 16 bytes in size at least."
            },
            {
                "class": "DongleList",
                "name": "productCodeInstalled",
                "call": "productCodeInstalled()",
                "returns": "bool",
                "text": "Returns True if the provided product code is installed on any of the connected dongles."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "A list of [[Dongle Class|dongles]] connected to the system. The system instance can be found in <code>licenses.dongles</code>.\n<syntaxhighlight lang=python>\ndongles = licenses.dongles\t\t# get the DongleList object\nprint(len(dongles))\t\t\t\t# number of Dongles \nprint(dongles[0])\t\t\t\t# first Dongle in the list\nfor d in dongles:\n\tprint(d)\t\t\t\t\t# print all Dongles\n</syntaxhighlight>"
    },
    "edgeTOP": {
        "label": "edgeTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "embossTOP": {
        "label": "embossTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "envelopeCHOP": {
        "label": "envelopeCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "envelopeCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "environmentlightCOMP": {
        "label": "environmentlightCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "errorDAT": {
        "label": "errorDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "etherdreamCHOP": {
        "label": "etherdreamCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "etherdreamDAT": {
        "label": "etherdreamDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "evaluateDAT": {
        "label": "evaluateDAT",
        "members": [
            {
                "set": "0",
                "text": "The current expression [[Cell Class|cell]] being evaluated.  From the [[Cell Class|cell]] you can get its row, column and value. e.g. me.exprCell.val or use the specific members listed below.  Too see how a [[Cell Class]] such as me.exprCell is automatically converted to a string or number in an expression see [[Cell Class#Casting to a Value|Casting to a Value]].",
                "type": "",
                "class": "evaluateDAT",
                "name": "exprCell"
            },
            {
                "set": "0",
                "text": "The current expression column being evaluated.",
                "type": "",
                "class": "evaluateDAT",
                "name": "exprCol"
            },
            {
                "set": "0",
                "text": "The current expression row being evaluated.",
                "type": "",
                "class": "evaluateDAT",
                "name": "exprRow"
            },
            {
                "set": "0",
                "text": "The input [[DAT Class|DAT]] containing the expressions.",
                "type": "",
                "class": "evaluateDAT",
                "name": "exprTable"
            },
            {
                "set": "0",
                "text": "The current input [[Cell Class|cell]] being evaluated. From the [[Cell Class|cell]] you can get its row, column and value. e.g. me.inputCell.val or use the specific members listed below.  To see how a [[Cell Class]] such as me.inputCell is automatically converted to a string or number in an expression see [[Cell Class#Casting to a Value|Casting to a Value]].",
                "type": "",
                "class": "evaluateDAT",
                "name": "inputCell"
            },
            {
                "set": "0",
                "text": "The current input column being evaluated.",
                "type": "",
                "class": "evaluateDAT",
                "name": "inputCol"
            },
            {
                "set": "0",
                "text": "The current input row being evaluated.",
                "type": "",
                "class": "evaluateDAT",
                "name": "inputRow"
            },
            {
                "set": "0",
                "text": "The input [[DAT Class|DAT]] containing the source values.",
                "type": "",
                "class": "evaluateDAT",
                "name": "inputTable"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "eventCHOP": {
        "label": "eventCHOP",
        "members": [],
        "methods": [
            {
                "text": "Manually release an event created with createEvent(hold=True) method above.\nReturns the number of events released.\n*id - (Optional) Specifies the event to release. If not specified, all events are released.",
                "returns": "int",
                "name": "releaseEvent",
                "call": "releaseEvent(id)",
                "class": "eventCHOP"
            },
            {
                "text": "Manually create an event for this CHOP. You still need an input attached, but it can stay at 0 and you can create events from this method.\nReturns the id of the created particle.\n* hold - (Optional) Specifies whether the event will hold the sustain state.  When True, can be released with the releaseEvent method.\n* samples - (Optional) A list of values to override the Samples Input.\n* index - (Optional) Specifies the input trigger index to assign to this event.\n* attackTime - (Optional) If not specified, read from parameter.\n* attackLevel - (Optional) If not specified, read from parameter.\n* decayTime - (Optional) If not specified, read from parameter.\n* sustainTime - (Optional) If not specified, read from parameter.\n* sustainMin - (Optional) If not specified, read from parameter.\n* sustainMax - (Optional) If not specified, read from parameter.\n* releaseTime - (Optional) If not specified, read from parameter.\n* releaseLevel - (Optional) If not specified, read from parameter.\n* speed - (Optional) If not specified, read from parameter.",
                "returns": "int",
                "name": "createEvent",
                "call": "createEvent(hold=False, samples=[], index=0, attackTime, attackLevel, decayTime, sustainTime, sustainMin, sustainMax, releaseTime, releaseLevel, speed)",
                "class": "eventCHOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "examineDAT": {
        "label": "examineDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "executeDAT": {
        "label": "executeDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "expressionCHOP": {
        "label": "expressionCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "",
                "class": "expressionCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The current value of the input sample being evaluated.  To access channels from other inputs use the [[OP_Class#Connection|operator's inputs]]. Example:  me.inputs[1]['chan4'] will access chan4 of the second input.",
                "type": "",
                "class": "expressionCHOP",
                "name": "inputVal"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "",
                "class": "expressionCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "extendCHOP": {
        "label": "extendCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "extrudeSOP": {
        "label": "extrudeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "facetSOP": {
        "label": "facetSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "fanCHOP": {
        "label": "fanCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "feedbackCHOP": {
        "label": "feedbackCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "feedbackTOP": {
        "label": "feedbackTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "fieldCOMP": {
        "label": "fieldCOMP",
        "members": [],
        "methods": [
            {
                "text": "Set keyboard focus.\n*selectAll - (Keyword, Optional) If True, then all text will be selected.",
                "returns": "None",
                "name": "setKeyboardFocus",
                "call": "setKeyboardFocus(selectAll=False)",
                "class": "fieldCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "PanelCOMP",
            "COMP"
        ]
    },
    "fifoDAT": {
        "label": "fifoDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "fileinCHOP": {
        "label": "fileinCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "fileinCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The current value of the sample being overridden.",
                "type": "float",
                "class": "fileinCHOP",
                "name": "curVal"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "fileinCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "fileinDAT": {
        "label": "fileinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "FileInfo": {
        "label": "FileInfo",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The FileInfo object stores a file path and has a few utility properties to provide additional info. It is derived from str, so will work as a Python string, but can be differentiated from a regular string by using <syntaxhighlight lang=python inline=true>isinstance(tdu.FileInfo)</syntaxhighlight>.\n\nUtility properties include:\n* path: filepath string\n* ext: string after and including \".\"\n* baseName: the basename of the file\n* fileType: the TD filetype (from tdu.fileTypes)\n* absPath: the absolute path to filepath\n* dir: the containing directory of filepath\n* exists: exists in file-system\n* isDir: is a directory in the file-system\n* isFile: is a file in the file-system",
        "inherit": "",
        "parent": ""
    },
    "fileinSOP": {
        "label": "fileinSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "fileoutCHOP": {
        "label": "fileoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "fileoutDAT": {
        "label": "fileoutDAT",
        "members": [
            {
                "set": "0",
                "text": "The number of times data has been written. This can be used to create an incrementing filename.",
                "type": "int",
                "class": "fileoutDAT",
                "name": "writeCount"
            }
        ],
        "methods": [
            {
                "text": "Write one or more sequence of bytes. No terminators are appended.\n*message - Messages can any combination of strings, byte arrays, or individual single-byte numeric values. To serialize non-byte values (example floats or integers) there are several python modules such as pickle or struct.\n<syntaxhighlight lang=python>\nn.sendBytes( 'TYPE', 23, 255, 12, 0x34, b'\\x01\\x00\\x02\\x00\\x03\\x00\\x00\\x00' )\n</syntaxhighlight>",
                "returns": "int",
                "name": "sendBytes",
                "call": "sendBytes(message1, message2...)",
                "class": "fileoutDAT"
            },
            {
                "text": "Used to write strings into the file.\n*message - One or more strings to write into the file.\n*terminator - (Keyword, Optional) Specifies how the message is to be terminated. If no append terminator is specified, a null character will automatically be appended to the message. To send no terminator, use terminator=''.\nThe number of bytes sent is returned.\n<syntaxhighlight lang=python>\nn.send('Hello', 'World',  terminator='\\r\\n') # send two strings with windows style newline termination.\n</syntaxhighlight>",
                "returns": "int",
                "name": "send",
                "call": "send(message1, message2... , terminator=' ')",
                "class": "fileoutDAT"
            }
        ],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "filletSOP": {
        "label": "filletSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "filterCHOP": {
        "label": "filterCHOP",
        "members": [
            {
                "class": "filterCHOP",
                "name": "chanIndex",
                "type": "int",
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "fitSOP": {
        "label": "fitSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "fitTOP": {
        "label": "fitTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "flipTOP": {
        "label": "flipTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "folderDAT": {
        "label": "folderDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "fontSOP": {
        "label": "fontSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "forceSOP": {
        "label": "forceSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "fractalSOP": {
        "label": "fractalSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "functionCHOP": {
        "label": "functionCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "geometryCOMP": {
        "label": "geometryCOMP",
        "members": [],
        "methods": [
            {
                "text": "Calculate the bounding box of the child geometry of this component.\nA named tuple consisting of (min, max, center, size) is returned. Each component in turn is a named 3-tuple (x, y, z).\n*display - (Keyword, Optional) If set to True, only [[SOP Class|SOP operators]] whose[[Display Flag | display flag]] set are included in the calculation.  Furthermore, if the SOP is contained within a child [[geometryCOMP Class|Geometry Component]], that operator must have its display flag set as well.\n*render - (Keyword, Optional) If set to True, only [[SOP Class|SOP operators]] whose[[Render Flag | render flag]] set are included in the calculation.  Furthermore, if the SOP is contained within a child [[geometryCOMP Class|Geometry Component]], that operator must have its render flag set as well.\n*selected - (Keyword, Optional) If set to True, only child [[COMP Class|components]] that are currently selected are included in the calculation.\n*recurse - (Keyword, Optional) If set to True, child components are included in the calculation.\n<syntaxhighlight lang=python>\na=op('/project1/geo1').computeBounds()\nprint(a.min.x)\n</syntaxhighlight>",
                "returns": "tuple(min, max, center, size)",
                "name": "computeBounds",
                "call": "computeBounds(display=True, render=True, selected=False, recurse=True)",
                "class": "geometryCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "gestureCHOP": {
        "label": "gestureCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "glslMAT": {
        "label": "glslMAT",
        "members": [
            {
                "set": "0",
                "text": "The latest compile result.",
                "type": "str",
                "class": "glslMAT",
                "name": "compileResult"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "glslmultiTOP": {
        "label": "glslmultiTOP",
        "members": [
            {
                "set": "0",
                "text": "The latest compile result.",
                "type": "str",
                "class": "glslmultiTOP",
                "name": "compileResult"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "glslTOP": {
        "label": "glslTOP",
        "members": [
            {
                "set": "0",
                "text": "The latest compile result.",
                "type": "str",
                "class": "glslTOP",
                "name": "compileResult"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "gridSOP": {
        "label": "gridSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "Group": {
        "label": "Group",
        "members": [
            {
                "class": "Group",
                "name": "default",
                "type": "tuple",
                "set": "0",
                "text": "The default values associated with this Group. It returns a tuple item of group points."
            },
            {
                "class": "Group",
                "name": "name",
                "type": "str",
                "set": "1",
                "text": "Set/gets the group name."
            },
            {
                "class": "Group",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "Gets the owner of this group."
            }
        ],
        "methods": [
            {
                "class": "Group",
                "name": "add",
                "call": "add(Point or Prim or int)",
                "returns": "None",
                "text": "Adds a point/primitive to this group. The point or primitive to be added can be specified by a point, primitive object or the index of a point or primitive object."
            },
            {
                "class": "Group",
                "name": "discard",
                "call": "discard(Point or Prim or int)",
                "returns": "None",
                "text": "Removes a point/primitive from this group. The point or primitive to be removed can be specified by a point, primitive object or the index of a point or primitive object."
            },
            {
                "class": "Group",
                "name": "destroy",
                "call": "destroy()",
                "returns": "None",
                "text": "Destroys the current point/primitive group."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "An Group describes groups lists of [[Prim Class]] or [[Point Class]]. \n\nA Group can be created with the [[Group SOP]] or using the <syntaxhighlight lang=python inline=True>createPointGroup(str)</syntaxhighlight> or <syntaxhighlight lang=python inline=True>createPrimGroup(str)</syntaxhighlight> methods of the [[ScriptSOP Class]]."
    },
    "groupSOP": {
        "label": "groupSOP",
        "members": [
            {
                "set": "0",
                "text": "The current [[Point Class|point]] being evaluated.",
                "type": "Point",
                "class": "groupSOP",
                "name": "inputPoint"
            },
            {
                "set": "0",
                "text": "The current [[Prim Class|primitive]] being evaluated.",
                "type": "Prim",
                "class": "groupSOP",
                "name": "inputPrim"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "handleCHOP": {
        "label": "handleCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "handleCOMP": {
        "label": "handleCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "heliosdacCHOP": {
        "label": "heliosdacCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "hogCHOP": {
        "label": "hogCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "hokuyoCHOP": {
        "label": "hokuyoCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "holdCHOP": {
        "label": "holdCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "holeSOP": {
        "label": "holeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "hsvadjustTOP": {
        "label": "hsvadjustTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "hsvtorgbTOP": {
        "label": "hsvtorgbTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "inCHOP": {
        "label": "inCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "inDAT": {
        "label": "inDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "indicesDAT": {
        "label": "indicesDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "infoCHOP": {
        "label": "infoCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "infoDAT": {
        "label": "infoDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "inMAT": {
        "label": "inMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "InputPoint": {
        "label": "InputPoint",
        "members": [
            {
                "class": "InputPoint",
                "name": "color",
                "type": "Color",
                "set": "0",
                "text": "The color for this point. This is different from the Cd attribute, since it can come from a Vertex if there is no color on the inputPoint itself."
            },
            {
                "class": "InputPoint",
                "name": "normP",
                "type": "Position",
                "set": "0",
                "text": "The normalized position of this point within the bounding box of the SOP. Will always be in the range [0,1]. Expressed as tdu.Position object."
            },
            {
                "class": "InputPoint",
                "name": "normal",
                "type": "Vector",
                "set": "0",
                "text": "The normal for this point. This is different from the N attribute, since it can come from a Vertex or from the destination point, if there is no normal on the inputPoint itself."
            },
            {
                "class": "InputPoint",
                "name": "sopCenter",
                "type": "Position",
                "set": "0",
                "text": "Get the barycentric coordinate of the geometry the inputPoint is a part of. This is faster than other methods to get the center of a SOP's geometry due to internal optimizations. It is expressed as a tdu.Position."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "A Input Point is a special case of a Point object, only available in the [[Point SOP|Point SOP's]] parameters."
    },
    "insertDAT": {
        "label": "insertDAT",
        "members": [
            {
                "class": "insertDAT",
                "name": "subRow",
                "type": "int",
                "set": "0",
                "text": "Current row index for Insert DAT Table expressions.",
                "deprecated": ""
            },
            {
                "class": "insertDAT",
                "name": "subCol",
                "type": "int",
                "set": "0",
                "text": "Current col index for Insert DAT Table expressions.",
                "deprecated": ""
            },
            {
                "class": "insertDAT",
                "name": "fillName",
                "type": "str",
                "set": "0",
                "text": "Current header name for Insert DAT Table expressions.",
                "deprecated": ""
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "insideTOP": {
        "label": "insideTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "inSOP": {
        "label": "inSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "interpolateCHOP": {
        "label": "interpolateCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "inTOP": {
        "label": "inTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "inversecurveCHOP": {
        "label": "inversecurveCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "inversecurveSOP": {
        "label": "inversecurveSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "inversekinCHOP": {
        "label": "inversekinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "isosurfaceSOP": {
        "label": "isosurfaceSOP",
        "members": [
            {
                "set": "0",
                "text": "The current [[Position Class|position]] of the surface.",
                "type": "",
                "class": "isosurfaceSOP",
                "name": "curPos"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "joinCHOP": {
        "label": "joinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "joinSOP": {
        "label": "joinSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "jointSOP": {
        "label": "jointSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "joystickCHOP": {
        "label": "joystickCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "keyboardinCHOP": {
        "label": "keyboardinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "keyboardinDAT": {
        "label": "keyboardinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "keyframeCHOP": {
        "label": "keyframeCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "kinectCHOP": {
        "label": "kinectCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "kinectSOP": {
        "label": "kinectSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "kinectTOP": {
        "label": "kinectTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "lagCHOP": {
        "label": "lagCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "lagCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "lagCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "latticeSOP": {
        "label": "latticeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "layoutTOP": {
        "label": "layoutTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "leapmotionCHOP": {
        "label": "leapmotionCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "leapmotionTOP": {
        "label": "leapmotionTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "leuzerod4CHOP": {
        "label": "leuzerod4CHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "levelTOP": {
        "label": "levelTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "lfoCHOP": {
        "label": "lfoCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "lfoCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "License": {
        "label": "License",
        "members": [
            {
                "class": "License",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The license index in the list."
            },
            {
                "class": "License",
                "name": "isEnabled",
                "type": "bool",
                "set": "0",
                "text": "True if the license is locally enabled (That is, it has never been disabled)."
            },
            {
                "class": "License",
                "name": "isRemotelyDisabled",
                "type": "bool",
                "set": "0",
                "text": "True if the license has been remotely disabled."
            },
            {
                "class": "License",
                "name": "key",
                "type": "str",
                "set": "0",
                "text": "The key sequence."
            },
            {
                "class": "License",
                "name": "remoteDisableDate",
                "type": "tuple(year, month, date)",
                "set": "0",
                "text": "The date the license was remotely disabled, expressed as a tuple (year, month, day)."
            },
            {
                "class": "License",
                "name": "status",
                "type": "int",
                "set": "0",
                "text": "The numeric status code. Negative values indicate the license is not applicable to the current application. A value of zero indicates it does."
            },
            {
                "class": "License",
                "name": "statusMessage",
                "type": "str",
                "set": "0",
                "text": "A description of the status code."
            },
            {
                "class": "License",
                "name": "systemCode",
                "type": "str",
                "set": "0",
                "text": "The system code associated with this license."
            },
            {
                "class": "License",
                "name": "type",
                "type": "str",
                "set": "0",
                "text": "The license type, e.g. some products being 'Pro', 'Non-Commercial', 'Commercial'. See also app.product in [[App Class]]"
            },
            {
                "class": "License",
                "name": "updateExpiryDate",
                "type": "tuple(year, month, day)",
                "set": "0",
                "text": "The date updates for this license expires, expressed as a tuple (year, month, day)."
            },
            {
                "class": "License",
                "name": "version",
                "type": "int",
                "set": "0",
                "text": "The numeric license version."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The License class describes a single instance of an installed license.  They can be accessed from the [[Licenses Class|licenses]] object."
    },
    "Licenses": {
        "label": "Licenses",
        "members": [
            {
                "class": "Licenses",
                "name": "disablePro",
                "type": "bool",
                "set": "1",
                "text": "When True, the application will run as though no Pro licenses are available.  This can be used to test compatibility with lesser licenses. (See also: [[App Class#Methods|app.addNonCommercialLimit]])"
            },
            {
                "class": "Licenses",
                "name": "dongles",
                "type": "list",
                "set": "0",
                "text": "Get the list of dongles connected to the system."
            },
            {
                "class": "Licenses",
                "name": "machine",
                "type": "str",
                "set": "0",
                "text": "The computer machine name."
            },
            {
                "class": "Licenses",
                "name": "systemCode",
                "type": "str",
                "set": "0",
                "text": "The unique computer system code."
            },
            {
                "class": "Licenses",
                "name": "isPro",
                "type": "bool",
                "set": "0",
                "text": "When True, the application is running with a Pro license. It is recommended to use this and isNonCommerical over the type method."
            },
            {
                "class": "Licenses",
                "name": "isNonCommercial",
                "type": "bool",
                "set": "0",
                "text": "When True, the application is running with a Non-Commercial license. It is recommended to use this and isPro over the type method."
            },
            {
                "class": "Licenses",
                "name": "type",
                "type": "str",
                "set": "0",
                "text": "The highest ranking license type of all installed licenses, some products being 'Pro', 'Non-Commercial', 'Commercial'. See also app.product in [[App Class]]."
            }
        ],
        "methods": [
            {
                "class": "Licenses",
                "name": "install",
                "call": "install(key)",
                "returns": "bool",
                "text": "Install a [[License Class|license]] with the specified key.  Returns True if successful."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Licenses class describes the set of all installed [[License Class|license objects]].  It can be accessed with the licenses object, , found in the automatically imported [[td Module|td module]].\n<syntaxhighlight lang=python>\nprint(len(licenses))\t# number of licenses \nprint(licenses[0])\t\t# first license in the list\nfor l in licenses:\n\tprint(l.type)\t\t# print all installed licenses' types\n</syntaxhighlight>"
    },
    "lightCOMP": {
        "label": "lightCOMP",
        "members": [],
        "methods": [
            {
                "text": "Returns the inverse projection matrix for the light's view, given the X and Y aspect. In general these would be set to the width and height of your render.\n*x - The horizontal aspect ratio.\n*y - The vertical aspect ratio.",
                "returns": "tdu.Matrix",
                "name": "projectionInverse",
                "call": "projectionInverse(x, y)",
                "class": "lightCOMP"
            },
            {
                "text": "Returns the projection [[Matrix Class|matrix]] for the light's view, given the X and Y aspect. In general these would be set to the width and height of your render.\n*x - The horizontal aspect ratio.\n*y - The vertical aspect ratio.\n<syntaxhighlight lang=python>\nnewlist = op('geo1').pars('t?', 'r?', 's?') # translate/rotate/scale parameters\n</syntaxhighlight>",
                "returns": "tdu.Matrix",
                "name": "projection",
                "call": "projection(x, y)",
                "class": "lightCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "limitCHOP": {
        "label": "limitCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "limitCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "limitSOP": {
        "label": "limitSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "lineSOP": {
        "label": "lineSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "linethickSOP": {
        "label": "linethickSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "ListAttribute": {
        "label": "ListAttribute",
        "members": [
            {
                "class": "ListAttribute",
                "name": "bgColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set background color."
            },
            {
                "class": "ListAttribute",
                "name": "bottomBorderInColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set inside bottom color."
            },
            {
                "class": "ListAttribute",
                "name": "bottomBorderOutColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set outside bottom color."
            },
            {
                "class": "ListAttribute",
                "name": "colStretch",
                "type": "bool",
                "set": "1",
                "text": "Get or set column stretchiness. When True, colWidth specifies minimum width."
            },
            {
                "class": "ListAttribute",
                "name": "colWidth",
                "type": "float",
                "set": "1",
                "text": "Get or set column width, expressed in pixels."
            },
            {
                "class": "ListAttribute",
                "name": "draggable",
                "type": "bool",
                "set": "1",
                "text": "Get or set whether or not cell is draggable."
            },
            {
                "class": "ListAttribute",
                "name": "editable",
                "type": "bool",
                "set": "1",
                "text": "Get or set whether or not contents are editable. When True, contents can be edited by clicking on the cell."
            },
            {
                "class": "ListAttribute",
                "name": "focus",
                "type": "bool",
                "set": "0",
                "text": "Returns True if the cell/row/column/table is currently being edited."
            },
            {
                "class": "ListAttribute",
                "name": "fontFile",
                "type": "string",
                "set": "1",
                "text": "Get or set font file. VFS embedded files supported as well."
            },
            {
                "class": "ListAttribute",
                "name": "fontBold",
                "type": "bool",
                "set": "1",
                "text": "Get or set whether or not text is rendered in bold font."
            },
            {
                "class": "ListAttribute",
                "name": "fontFace",
                "type": "str",
                "set": "1",
                "text": "Get or set font face. Example 'verdana'."
            },
            {
                "class": "ListAttribute",
                "name": "fontItalic",
                "type": "bool",
                "set": "1",
                "text": "Get or set whether or not text is rendered italicized."
            },
            {
                "class": "ListAttribute",
                "name": "fontSizeX",
                "type": "float",
                "set": "1",
                "text": "Get or set font horizontal size."
            },
            {
                "class": "ListAttribute",
                "name": "fontSizeY",
                "type": "float",
                "set": "1",
                "text": "Get or set font vertical size. If not specified, uses fontSizeX."
            },
            {
                "class": "ListAttribute",
                "name": "sizeInPoints",
                "type": "bool",
                "set": "1",
                "text": "Get or set text size units. When True size is in points, when False it is in pixels."
            },
            {
                "class": "ListAttribute",
                "name": "help",
                "type": "str",
                "set": "1",
                "text": "Get or set help string when rolling over the cell."
            },
            {
                "class": "ListAttribute",
                "name": "leftBorderInColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set inside left color."
            },
            {
                "class": "ListAttribute",
                "name": "leftBorderOutColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set outside left color."
            },
            {
                "class": "ListAttribute",
                "name": "radio",
                "type": "bool",
                "set": "0",
                "text": "Returns true if the mouse last selected the cell/row/column/table."
            },
            {
                "class": "ListAttribute",
                "name": "rightBorderInColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set inside right color."
            },
            {
                "class": "ListAttribute",
                "name": "rightBorderOutColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set outside right color."
            },
            {
                "class": "ListAttribute",
                "name": "rollover",
                "type": "bool",
                "set": "0",
                "text": "Returns true if the mouse is currently over the cell/row/column/table."
            },
            {
                "class": "ListAttribute",
                "name": "rowHeight",
                "type": "float",
                "set": "1",
                "text": "Get or set row height, expressed in pixels."
            },
            {
                "class": "ListAttribute",
                "name": "rowIndent",
                "type": "float",
                "set": "1",
                "text": "Get or set row indent, expressed in pixels."
            },
            {
                "class": "ListAttribute",
                "name": "rowStretch",
                "type": "bool",
                "set": "1",
                "text": "Get or set row stretchiness. When True, rowWidth specifies minimum width."
            },
            {
                "class": "ListAttribute",
                "name": "select",
                "type": "bool",
                "set": "0",
                "text": "Returns true if the mouse is currently pressed over the cell/row/column/table."
            },
            {
                "class": "ListAttribute",
                "name": "text",
                "type": "str",
                "set": "1",
                "text": "Get or set contents."
            },
            {
                "class": "ListAttribute",
                "name": "textColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set text color.  Color values must be a tuple with four numeric entries corrresponding to red, green, blue, alpha ie:  (0.3, 06, 0.1, 1.0)"
            },
            {
                "class": "ListAttribute",
                "name": "textJustify",
                "type": "JustifyType",
                "set": "1",
                "text": "Get or set text justification. Value is one of: JustifyType.TOPLEFT, JustifyType.TOPCENTER, JustifyType.TOPRIGHT, JustifyType.CENTERLEFT, JustifyType.CENTER, JustifyType.CENTERRIGHT, JustifyType.BOTTOMLEFT, JustifyType.BOTTOMCENTER, JustifyType.BOTTOMRIGHT"
            },
            {
                "class": "ListAttribute",
                "name": "textOffsetX",
                "type": "float",
                "set": "1",
                "text": "Get or set horizontal text offset."
            },
            {
                "class": "ListAttribute",
                "name": "textOffsetY",
                "type": "float",
                "set": "1",
                "text": "Get or set vertical text offset."
            },
            {
                "class": "ListAttribute",
                "name": "top",
                "type": "op",
                "set": "1",
                "text": "Get or set background image [[TOP Class|TOP]]."
            },
            {
                "class": "ListAttribute",
                "name": "topBorderInColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set inside top color."
            },
            {
                "class": "ListAttribute",
                "name": "topBorderOutColor",
                "type": "tuple(r,g,b,a)",
                "set": "1",
                "text": "Get or set outside top color."
            },
            {
                "class": "ListAttribute",
                "name": "wordWrap",
                "type": "bool",
                "set": "1",
                "text": "Get or set word wrapping."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The ListAttribute class describes an attribute defining a cell or set of cells in a [[listCOMP Class|List Component]]."
    },
    "ListAttributes": {
        "label": "ListAttributes",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The ListAttributes class describes a set of [[ListAttribute Class|list attribute objects]] for cells, rows, columns or table. It can be accessed from a [[listCOMP Class|List Component]].\n\nAccess to individual List Attributes depends on what type: row, col, or cell:\n<syntaxhighlight lang=python>\nrowAttribs = op('list1').rowAttribs\t\t# get the ListAttributes object for rows\nprint(len(rowAttribs))\t\t\t\t\t# number of rows \nprint(rowAttribs[0].bgColor)\t\t\t# rows are accessed by row #. \n\t\t\t\t\t\t\t\t\t\t# This prints the background color settings for the first row\n\ncolAttribs = op('list1').colAttribs\t\t# get the ListAttributes object for columns\nprint(len(colAttribs))\t\t\t\t\t# number of columns \nprint(colAttribs[0].bgColor)\t\t\t# cols are accessed by column #. \n\t\t\t\t\t\t\t\t\t\t# This prints the background color settings for the first column\n\ncellAttribs = op('list1').cellAttribs\t# get the ListAttributes object for columns\nprint(len(cellAttribs))\t\t\t\t\t# total number of cells \nprint(colAttribs[0,2].bgColor)\t\t\t# cells are accessed by [row, col]. \n\t\t\t\t\t\t\t\t\t\t# This prints the background color settings for the cell in the first row, third column\n</syntaxhighlight>\n'''Note:''' The attributes above are the settings for List Component's hierarchical layout technique. This means that cell settings\noverride row settings, which override column settings, which override table settings. If you want to know the final value in a\ngiven cell, use <code>listCOMP.displayAttribs[row, col]</code>."
    },
    "listCOMP": {
        "label": "listCOMP",
        "members": [
            {
                "set": "0",
                "text": "The table [[ListAttribute Class|attributes]]. The members of these attributes can be directly written to / updated with new values. Any row/col or cell attributes defined will override these values. Define global per-table attributes here.\n<syntaxhighlight lang=python>\nn.tableAttribs.fontFace = 'Verdana'\nn.tableAttribs.bgColor = (0,0.3,0,1) #dark green background\n</syntaxhighlight>",
                "type": "td.ListAttribute",
                "class": "listCOMP",
                "name": "attribs"
            },
            {
                "set": "0",
                "text": "The set of row [[ListAttributes Class|attributes]]. Accessed by row index.  The members of these attributes can be directly written to / updated with new values and take priority over any attribute members defined a the table level.\n<syntaxhighlight lang=python>\nn.colAttribs[4].colWidth = 100\nn.colAttribs[4].bgColor = (0,0.6,0,1) #highlight entire column in bright green\n</syntaxhighlight>",
                "type": "td.ListAttributes",
                "class": "listCOMP",
                "name": "colAttribs"
            },
            {
                "set": "0",
                "text": "The set of row [[ListAttributes Class|attributes]]. Accessed by row index. The members of these attributes can be directly written to / updated with new values and take priority over any attribute members defined a the table level.\n<syntaxhighlight lang=python>\nn.rowAttribs[3].rowHeight = 50\n</syntaxhighlight>",
                "type": "td.ListAttributes",
                "class": "listCOMP",
                "name": "rowAttribs"
            },
            {
                "set": "0",
                "text": "The set of cell [[ListAttributes Class|attributes]]. Accessed by row and column. The members of these attributes can be directly written to / updated with new values and take priority over any attribute members defined at the row/col or table level.\n<syntaxhighlight lang=python>\nn.cellAttribs[3,4].text = 'Fade'\nn.cellAttribs[3,4].bgColor = (0.5,0,0,1) #highlight this cell red\n</syntaxhighlight>",
                "type": "td.ListAttributes",
                "class": "listCOMP",
                "name": "cellAttribs"
            },
            {
                "set": "0",
                "text": "The set of attributes actually displayed in the cell. They are a combination of the cell/row/col/table attributes described above. Accessed by row and column.  When combining attributes, cell attributes take priority over row and column attributes, which themselves take priority over table attributes.\n<syntaxhighlight lang=python>n.displayAttribs[3,4].bgColor #the resulting background color for this specific cell</syntaxhighlight>",
                "type": "td.ListAttributes",
                "class": "listCOMP",
                "name": "displayAttribs"
            },
            {
                "set": "0",
                "text": "Last column with focus for editing.",
                "type": "int",
                "class": "listCOMP",
                "name": "focusCol"
            },
            {
                "set": "0",
                "text": "Last row with focus for editing.",
                "type": "int",
                "class": "listCOMP",
                "name": "focusRow"
            },
            {
                "set": "0",
                "text": "The last selected column.",
                "type": "int",
                "class": "listCOMP",
                "name": "radioCol"
            },
            {
                "set": "0",
                "text": "The last selected row.",
                "type": "int",
                "class": "listCOMP",
                "name": "radioRow"
            },
            {
                "set": "0",
                "text": "The last column rolled over.",
                "type": "int",
                "class": "listCOMP",
                "name": "rolloverCol"
            },
            {
                "set": "0",
                "text": "The last row rolled over.",
                "type": "int",
                "class": "listCOMP",
                "name": "rolloverRow"
            },
            {
                "set": "0",
                "text": "The currently selected column.",
                "type": "int",
                "class": "listCOMP",
                "name": "selectCol"
            },
            {
                "set": "0",
                "text": "The currently selected row.",
                "type": "int",
                "class": "listCOMP",
                "name": "selectRow"
            },
            {
                "set": "1",
                "text": "Get or set the border color for the separate selection, expressed as a 4-tuple, representing its red, green, blue and alpha value.",
                "type": "tuple(r, g, b, a)",
                "class": "listCOMP",
                "name": "selectionBorderColor"
            },
            {
                "set": "1",
                "text": "Get or set the background color for the separate selection, expressed as a 4-tuple, representing its red, green, blue and alpha value.",
                "type": "tuple(r, g, b, a)",
                "class": "listCOMP",
                "name": "selectionColor"
            },
            {
                "set": "1",
                "text": "Get or set the row and column coordinates for separate selection formatting, expressed as a list of 4-tuples, each representing startrow, startcol, endrow, endcol.",
                "type": "[(startrow, startcol, endrow, endcol), (startrow, startcol, endrow, endcol), ..]",
                "class": "listCOMP",
                "name": "selections"
            },
            {
                "set": "0",
                "text": "The currently dragged row.",
                "type": "int",
                "class": "listCOMP",
                "name": "dragRow"
            },
            {
                "set": "0",
                "text": "The currently dragged column.",
                "type": "int",
                "class": "listCOMP",
                "name": "dragCol"
            }
        ],
        "methods": [
            {
                "text": "Scroll List component to the row and column specified.\n*row, col - The row and column to scroll to.",
                "returns": "None",
                "name": "scroll",
                "call": "scroll(row, col)",
                "class": "listCOMP"
            },
            {
                "text": "Selects and sets the keyboard focus in a cell of the table if the cell is a field.\n*row, col -  The row and column of the cell to set the keyboard focus.\n*selectAll - (Keyword, Optional) If True, then all text will be selected.",
                "returns": "None",
                "name": "setKeyboardFocus",
                "call": "setKeyboardFocus(row, col, selectAll=False)",
                "class": "listCOMP"
            },
            {
                "text": "Reset the list by running its initialize callbacks.",
                "returns": "None",
                "name": "reset",
                "call": "reset()",
                "class": "listCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "PanelCOMP",
            "COMP"
        ]
    },
    "lodSOP": {
        "label": "lodSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "logicCHOP": {
        "label": "logicCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "lookupCHOP": {
        "label": "lookupCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "lookupTOP": {
        "label": "lookupTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "lsystemSOP": {
        "label": "lsystemSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "ltcinCHOP": {
        "label": "ltcinCHOP",
        "members": [
            {
                "set": "0",
                "text": "Get a Timecode object for the timecode data representation of the LTC In CHOP. See [[Timecode Class]].",
                "type": "tdu.Timecode",
                "class": "ltcinCHOP",
                "name": "timecode"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "ltcoutCHOP": {
        "label": "ltcoutCHOP",
        "members": [
            {
                "set": "0",
                "text": "Get a Timecode object for the timecode data representation of the LTC Out CHOP. See [[Timecode Class]].",
                "type": "tdu.Timecode",
                "class": "ltcoutCHOP",
                "name": "timecode"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "lumablurTOP": {
        "label": "lumablurTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "lumalevelTOP": {
        "label": "lumalevelTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "magnetSOP": {
        "label": "magnetSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "MAT": {
        "label": "MAT",
        "members": [
            {
                "class": "MAT",
                "name": "isMAT",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a Material."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP"
        ],
        "summary": "A [[MAT]] describes a reference to a MAT operator."
    },
    "materialSOP": {
        "label": "materialSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "mathCHOP": {
        "label": "mathCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "mathCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "mathCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "mathTOP": {
        "label": "mathTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "Matrix": {
        "label": "Matrix",
        "members": [
            {
                "class": "Matrix",
                "name": "vals",
                "type": "float",
                "set": "1",
                "text": "Get or set the set of Matrix values."
            },
            {
                "class": "Matrix",
                "name": "rows",
                "type": "list of lists",
                "set": "0",
                "text": "The list of Matrix rows, each a list of values."
            },
            {
                "class": "Matrix",
                "name": "cols",
                "type": "list of lists",
                "set": "0",
                "text": "The list of Matrix columns, each a list of values."
            }
        ],
        "methods": [
            {
                "class": "Matrix",
                "name": "transpose",
                "call": "transpose()",
                "returns": "None",
                "text": "Transpose the values in the matrix.\n<syntaxhighlight lang=python>\nm.transpose() # m now contains the transpose of the matrix\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "getTranspose",
                "call": "getTranspose()",
                "returns": "None",
                "text": "Returns the transpose of the matrix, leaving the matrix itself unchanged.\n<syntaxhighlight lang=python>\nm2 = m.getTranspose()\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "invert",
                "call": "invert()",
                "returns": "None",
                "text": "Inverts the values in the matrix.\n<syntaxhighlight lang=python>\nm.invert() # m now contains the inverse of the matrix\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "getInverse",
                "call": "getInverse()",
                "returns": "tdu.Matrix",
                "text": "Returns the inverse of the matrix, leaving the matrix itself unchanged.\n<syntaxhighlight lang=python>\nm2 = m.getInverse()\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "determinant",
                "call": "determinant()",
                "returns": "float",
                "text": "Returns the determinant of the matrix.\n<syntaxhighlight lang=python>\nl = m.determinant()\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "mapUnitSquareToQuad",
                "call": "mapUnitSquareToQuad(blX, blY, brX, brY, tlX, tlY, trX, trY)",
                "returns": "None",
                "text": "Set the matrix to be a projection matrix that maps coordinates from to a unit square (0,0) -> (1,1) space to a space defined by an arbitrary quadrilateral (blX, blY) -> (trX, trY). The 4 corners of the quadrilateral are given ('bl' means bottom left, 'tr' means top right etc.)."
            },
            {
                "class": "Matrix",
                "name": "mapQuadToUnitSquare",
                "call": "mapQuadToUnitSquare(blX, blY, brX, brY, tlX, tlY, trX, trY)",
                "returns": "None",
                "text": "Is the inverse of mapUnitSquareToQuad(). Mapping coordinates in an arbitrary quadrilateral into a space defined by the unit square."
            },
            {
                "class": "Matrix",
                "name": "fillTable",
                "call": "fillTable(tableDAT)",
                "returns": "None",
                "text": "Fill in the contents of a table from the matrix which the method is called upon.\n*tableDAT - The table to be filled."
            },
            {
                "class": "Matrix",
                "name": "numpyArray",
                "call": "numpyArray()",
                "returns": "numpy.array",
                "text": "Returns this matrix as a 4x4 NumPy array."
            },
            {
                "class": "Matrix",
                "name": "identity",
                "call": "identity()",
                "returns": "None",
                "text": "Replaces the values in the matrix with the [http://en.wikipedia.org/wiki/Identity_matrix identity matrix].\n<syntaxhighlight lang=python>\nm.identity() # now contains the identity matrix\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "copy",
                "call": "copy()",
                "returns": "tdu.Matrix",
                "text": "Returns a new matrix that is a copy of the matrix.\n<syntaxhighlight lang=python>\nnewM = m.copy() # newM will have the same values as m, m is unchanged\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "translate",
                "call": "translate(tx, ty, tz, fromRight=False)",
                "returns": "None",
                "text": "Multiplies the current matrix by a new translation matrix created from tx, ty and tz. The translation is applied from the left of the matrix by default. That is to say, if T is the new translation matrix, and M is the current matrix, then the result of this operation is M = T * M.\n*tx, ty, tz - The translation value in each axis.\n*fromRight - (Keyword, Optional) If True, the translation matrix will be multiplied from the right instead of the left.\n<syntaxhighlight lang=python>\nm = tdu.Matrix()\nm.translate(5, 0, 10)\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "rotate",
                "call": "rotate(rx, ry, rz, fromRight=False, pivot=None)",
                "returns": "None",
                "text": "Multiplies the current matrix by 3 rotation matrices, first a rotation around the X axis by rx degrees, followed by a rotation around the Y axis by ry degrees, followed by the same for rz. The rotation values are in degrees. The rotation is applied from the left of the matrix by default. So if M is the current matrix, then the result of this operation is M = RZ * RY * RX * M.\n*rx, ry, rz - The rotation value around each X, Y and Z axis. The value is in degrees. The rotation is applied in XYZ order.\n*fromRight - (Keyword, Optional) If True, the rotation matrix will be multiplied from the right instead of the left. In this case the operation is M = M * RZ * RY * RX.\n*pivot - (Keyword, Optional) If given, the rotation will be applied around the given pivot. The pivot should be a Vector, Position or a list with 3 entries.\n<syntaxhighlight lang=python>\nm = tdu.Matrix()\nm.rotate(45, 0, 0)\n\nm = tdu.Matrix()\nm.rotate(0, 0, 90, pivot=[0, 5, 0])\n\nm = tdu.Matrix()\np = tdu.Position(0, 5, 0)\nm.rotate(0, 90, 0, pivot=p)\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "rotateOnAxis",
                "call": "rotateOnAxis(rotationAxis, angle, fromRight=False, pivot=None)",
                "returns": "None",
                "text": "Multiplies the current matrix by a new rotation matrix created by rotation angle degrees around the axis specified by rotationAxis. The angle is in degrees. The rotation is applied from the left of the matrix by default. That is to say, if R is the new rotation matrix specified by rotationAxis and angle, and M is the current matrix, then the result of this operation is M = R * M.\n*rotationAxis - A axis to rotate around. This should be a Vector or a list with 3 entries. It does not need to be normalized.\n*angle - The amount to rotate around the axis, specified in degrees.\n*fromRight - (Keyword, Optional) If True, the rotation matrix will be multiplied from the right instead of the left.\n*pivot - (Keyword, Optional) If given, the rotation will be applied around the given pivot. The pivot should be a Vector, Position or a list with 3 entries."
            },
            {
                "class": "Matrix",
                "name": "scale",
                "call": "scale(sx, sy, sz, fromRight=False, pivot=None)",
                "returns": "None",
                "text": "Multiplies the current matrix by a scale matrix created from sx, sy and sz. The scale is applied from the left of the matrix by default. That is to say, if S is the new scale matrix, and M is the current matrix, then the result of this operation is M = S * M.\n*sx, sy, sz - The scale value along each X, Y and Z axis.\n*fromRight - (Keyword, Optional) If True, the scale matrix will be multiplied from the right instead of the left.\n*pivot - (Keyword, Optional) If given, the scale will be applied around the given pivot. The pivot should be a Vector, Position or a list with 3 entries.\n<syntaxhighlight lang=python>\nm = tdu.Matrix()\nm.scale(2, 1, 1)\n\nm = tdu.Matrix()\nm.scale(2, 1, 2, pivot=[0, 5, 0])\n\nm = tdu.Matrix()\np = tdu.Position(0, 5, 0)\nm.scale(1, 2, 1, pivot=p)\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "lookat",
                "call": "lookat(eyePos, target, up)",
                "returns": "None",
                "text": "Multiplies the current matrix by a lookat matrix created using the given values to the matrix. The lookat matrix is applied from the left of the matrix by default. That is to say, if L is the new lookat matrix, and M is the current matrix, then the result of this operation is M = L * M. The values for to parameters can be given as anything that can be treated as a list of 3 values. E.g a tdu.Vector, tdu.Position or simply a list of size 3.\n*eyePos - The position in space of the eye/camera.\n*target - The position in space that should be looked at, from the eyePos.\n*up - The Up vector. Ensure the up vector isn't pointing in the same direction as the lookat direction.\n<syntaxhighlight lang=python>\nm = tdu.Matrix()\neyeP = tdu.Position(0, 0, -5)\ntarget = tdu.Position(0, 5, 5)\nup = tdu.Position(0, 1, 0)\nm.lookat(eyeP, target, up)\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "decompose",
                "call": "decompose()",
                "returns": "Tuple(Tuple, Tuple, Tuple)",
                "text": "Decomposes the matrix into its scale, rotate and translate values. These are the same as the translate, rotate and scale that are in the [[Geometry COMP]] and other Object components. However due to rotations being able to be solved in different ways, it's likely a decomposed transform matrix from a Geometry COMP will not have the same values as its parameter. The resulting transform is the same though. This function returns a tuple of tuples (3 tuples), which are the scale, rotate and translate values respectively.\n<syntaxhighlight lang=python>\ns, r, t = m.decompose()\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "projectionFrustum",
                "call": "projectionFrustum(left, right, bottom, top, near, far)",
                "returns": "None",
                "text": "Replaces the contents of the matrix with a projection matrix using the given frustum extents. The left, right, bottom, top extents are located on the near plane. The depth range generated by this matrix will be [0,1] from near to far, as is required by Vulkan."
            },
            {
                "class": "Matrix",
                "name": "projectionFovX",
                "call": "projectionFovX(fovX, aspectX, aspectY, near, far)",
                "returns": "None",
                "text": "Replaces the contents of the matrix with a projection matrix defined by the FOV(given in degrees), an aspect ratio and near/far planes.  The depth range generated by this matrix will be [0,1] from near to far, as is required by Vulkan.\n*fovX - The horizontal FOV, specified in degrees.\n*aspectX, aspectY - The aspect ration values. These can be something like 16 and 9 for an aspect or the render resolution such as 1920 and 1080. The results will be the same for the same ratio."
            },
            {
                "class": "Matrix",
                "name": "projectionStereo",
                "call": "projectionStereo(ipd, convergeZ, fovX, aspectX, aspectY, near, far, rightEye = false)",
                "returns": "None",
                "text": "Replaces the contents of the matrix with an asymetrical projection matrix suitable for stereo rendering. The left eye's projection matrix is given by default, set rightEye=True to get the right eye's instead. For proper rendering, the cameras will also need to be translated in X by -ipd/2 and +ipd/2 for the left and right eyes respectively.  The depth range generated by this matrix will be [0,1] from near to far, as is required by Vulkan.\n*ipd - Interpupillary distance of the user, generally specified in meters. Typically between 0.05 and 0.08\n*covergeZ - distance in Z from the camera where the stereo convergence should occur, in the same units as ipd.\n*aspectX, aspectY - The aspect ratio values. These can be something like 16 and 9 for an aspect or the render resolution such as 1920 and 1080. The results will be the same for the same ratio.\n*rightEye - (Keyword, Optional) If set to True, the matrix will contain the projection for the right eye, otherwise it will contain the projection for the left eye."
            },
            {
                "class": "Matrix",
                "name": "[]",
                "call": "[row, column]",
                "returns": "float",
                "text": "Gets or sets the specified entry in the matrix.\n<syntaxhighlight lang=python>\ntx = m[0, 3]\nm[0, 3] = tx + 5\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "*",
                "call": "Matrix * Matrix",
                "returns": "tdu.Matrix",
                "text": "Performs a matrix multiplication returns the results in a new matrix.\n<syntaxhighlight lang=python>\nnewM = m1 * m2\n</syntaxhighlight>"
            },
            {
                "class": "Matrix",
                "name": "-",
                "call": "Matrix - Matrix",
                "returns": "tdu.Matrix",
                "text": "Subtracts the matrices, component-by-component, and returns the results in a new matrix."
            },
            {
                "class": "Matrix",
                "name": "+",
                "call": "Matrix + Matrix",
                "returns": "tdu.Matrix",
                "text": "Adds the matrices, component-by-component, and returns the results in a new matrix"
            },
            {
                "class": "tdu.Matrix",
                "name": "*v",
                "call": "tdu.Matrix * tdu.Vector",
                "returns": "tdu.Vector",
                "text": "Multiplies the vector by the matrix and returns the a new vector as the result. Since a Vector is direction only and has no notion of a position, the translate part of the matrix does not get applied to the vector.\n<syntaxhighlight lang=python>\nnewV = M * v\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Matrix",
                "name": "*p",
                "call": "tdu.Matrix * tdu.Position",
                "returns": "tdu.Position",
                "text": "Multiplies the position by the matrix and returns the a new position as the result. If the matrix was not an transformation matrix, such as a projection matrix instead, the perspective divide by W will automatically be applied to X, Y and Z.\n<syntaxhighlight lang=python>\nnewP = M * p\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The matrix class holds a single 4x4 matrix for use in transformations. The matrix's data layout is in [http://en.wikipedia.org/wiki/Column-major_order#Column-major_order column-major format], which is to say that the matrix is multiplied from the left of [[Vector Class|vectors]] and [[Position Class|positions]]. The translation values are stored in the last column of the matrix.\nA matrix is created with this line, and will always be initialized to the identity matrix.\n<syntaxhighlight lang=python>\nm = tdu.Matrix()\n</syntaxhighlight>\nYou can also initialize a matrix with an initial set of values. Valid arguments for initialization is another tdu.Matrix, a list of 16 values or 4 lists of 4 values. The entries are specified column-by-column. For example the following lines of code will produce the shown matrix\n<syntaxhighlight lang=python>\nm = tdu.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])\n# or\nm = tdu.Matrix([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16])\n</syntaxhighlight>\n<syntaxhighlight lang=python>\n# matrix values\n1  5  9   13\n2  6  10  14\n3  7  11  15\n4  8  12  16\n</syntaxhighlight>\nYou can also get transformation and projection matrices from [[ObjectCOMP Class|Object COMP]] and [[CameraCOMP Class|Camera COMP]] by using the various methods such as <code>transform(), pretransform(), projection()</code>."
    },
    "matteTOP": {
        "label": "matteTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "mergeCHOP": {
        "label": "mergeCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "mergeDAT": {
        "label": "mergeDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "mergeSOP": {
        "label": "mergeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "Mesh": {
        "label": "Mesh",
        "members": [
            {
                "class": "Mesh",
                "name": "closedU",
                "type": "bool",
                "set": "0",
                "text": "Returns True if the mesh is closed in U, False otherwise."
            },
            {
                "class": "Mesh",
                "name": "closedV",
                "type": "bool",
                "set": "0",
                "text": "Returns True if the mesh is closed in V, False otherwise."
            },
            {
                "class": "Mesh",
                "name": "numRows",
                "type": "int",
                "set": "0",
                "text": "Number of rows in the mesh."
            },
            {
                "class": "Mesh",
                "name": "numCols",
                "type": "int",
                "set": "0",
                "text": "Number of columns in the mesh."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "Prim"
        ],
        "summary": "A Mesh describes an instance of a single [[Mesh|geometry mesh]].  It is an instance of a [[Prim Class]]."
    },
    "metaballSOP": {
        "label": "metaballSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "midieventDAT": {
        "label": "midieventDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "midiinCHOP": {
        "label": "midiinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "midiinDAT": {
        "label": "midiinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "midiinmapCHOP": {
        "label": "midiinmapCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "midioutCHOP": {
        "label": "midioutCHOP",
        "members": [],
        "methods": [
            {
                "text": "Send a sequence of bytes through this CHOP.\nMessages can any combination of strings, byte arrays, or individual single-byte numeric values.\nTo serialize non-byte values (example floats or integers) there are several python modules to do this, such as pickle or struct.\n<syntaxhighlight lang=python>\nn.send(0xb0,0x2f,0x40) # Control Change : Channel 1, Index 48, Value 64\n</syntaxhighlight>.",
                "returns": "None",
                "name": "send",
                "call": "send(message1, message2...)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Balance event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendBalance(1, 103)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendBalance",
                "call": "sendBalance(channel, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Note On event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*index - The MIDI index/note.  Valid ranges are 0 to 127, or 1 to 128, dependent on the One Based Index parameter.\n*value - (Optional) The MIDI note value.  Valid ranges are determined by the CHOP Note Normalize parameter. Maximum when not specified.\n<syntaxhighlight lang=python>\nn.sendNoteOn(1, 63)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendNoteOn",
                "call": "sendNoteOn(channel, index, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Polyphonic Key Pressure event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*index - The MIDI index/note.  Valid ranges are 0 to 127, or 1 to 128, dependent on the One Based Index parameter.\n*value - The MIDI pressure value.  Valid ranges are determined by the CHOP Note Normalize parameter.\n<syntaxhighlight lang=python>\nn.sendPolyKeyPressure(1, 63, 100)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendPolyKeyPressure",
                "call": "sendPolyKeyPressure(channel, index, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Pitch Bend event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The pitch bend value.  Valid ranges are between 0 and 16384.\n<syntaxhighlight lang=python>\nn.sendPitchBend(1, 5000)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendPitchBend",
                "call": "sendPitchBend(channel, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Effects Depth event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*index - Valid index ranges are 1 to 5.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendEffectsDepth(1,4,61)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendEffectsDepth",
                "call": "sendEffectsDepth(channel, index,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Mono On/Poly Off event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendMonoOn(1,57)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendMonoOn",
                "call": "sendMonoOn(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a volume off event for each channel and note off event for each note.\n<syntaxhighlight lang=python>\nn.panic()\n</syntaxhighlight>",
                "returns": "None",
                "name": "panic",
                "call": "panic()",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Damper Pedal event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendDamperPedal(1,14)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendDamperPedal",
                "call": "sendDamperPedal(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Channel Pressure event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The channel pressure.  Valid ranges are dependent on the Note Normalize parameter.\n<syntaxhighlight lang=python>\nn.sendChannelPressure(1, 10)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendChannelPressure",
                "call": "sendChannelPressure(channel, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Controller event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*index - The MIDI controller index.  Valid ranges are 0 to 127, or 1 to 128, dependent on the One Based Index parameter..\n*value - The MIDI control value.  Valid ranges are determined by the CHOP Controller Normalize and Controller Format parameters.\n<syntaxhighlight lang=python>\nn.sendControl(1, 10, 100)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendControl",
                "call": "sendControl(channel, index, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Data Decrement event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendDataDecrement(1,17)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendDataDecrement",
                "call": "sendDataDecrement(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a All Notes Off event through the CHOP.\n*channel - The MIDI event channel. Valid ranges are 1 to 16.\n*value - The MIDI value. Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendAllNotesOff(1,125)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendAllNotesOff",
                "call": "sendAllNotesOff(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Sound Controller event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*index - Valid index ranges are 1 to 10.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendSoundController(1,5,29)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendSoundController",
                "call": "sendSoundController(channel, index,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Bank Select event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendBankSelect(1, 65)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendBankSelect",
                "call": "sendBankSelect(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Main Volume event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendMainVolume(1, 100)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendMainVolume",
                "call": "sendMainVolume(channel, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Soft Pedal event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendSoftPedal(1,20)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendSoftPedal",
                "call": "sendSoftPedal(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Local Control Controllers event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendLocalControl(1,87)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendLocalControl",
                "call": "sendLocalControl(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Poly On/Mono Off event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendPolyOn(1,16)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendPolyOn",
                "call": "sendPolyOn(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Pan event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendPan(1, 45)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendPan",
                "call": "sendPan(channel, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Reset All Controllers event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendResetAllControllers(1,34)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendResetAllControllers",
                "call": "sendResetAllControllers(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Breath Controller event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendBreathController(1, 12)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendBreathController",
                "call": "sendBreathController(channel, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Portamento Time event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendPortamentoTime(1, 78)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendPortamentoTime",
                "call": "sendPortamentoTime(channel, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Data Increment event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendDataIncrement(1,17)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendDataIncrement",
                "call": "sendDataIncrement(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Foot Controller event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendFootController(1, 12)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendFootController",
                "call": "sendFootController(channel, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Hold2 event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendHold2(1,55)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendHold2",
                "call": "sendHold2(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Sostenuto event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendSostenuto(1,42)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendSostenuto",
                "call": "sendSostenuto(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Omni Off event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendOmniOff(1,91)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendOmniOff",
                "call": "sendOmniOff(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a General Purpose Controller event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*index - Valid index ranges are 1 to 8.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendGeneralPurposeController(1,3,76)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendGeneralPurposeController",
                "call": "sendGeneralPurposeController(channel, index,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Note Off event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*index - The MIDI index/note.  Valid ranges are 0 to 127, or 1 to 128, dependent on the One Based Index parameter.\n*value - (Optional) The MIDI note value.  Valid ranges are determined by the CHOP Note Normalize parameter. Minimum when not specified.\n<syntaxhighlight lang=python>\nn.sendNoteOff(1, 63)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendNoteOff",
                "call": "sendNoteOff(channel, index, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Send a sytem exclusive message through this CHOP. The System Exclusive start and end character are added to the message.\nMessages can any combination of strings, byte arrays, or individual single-byte numeric values.\nTo serialize non-byte values (example floats or integers) there are several python modules to do this, such as pickle or struct.\n<syntaxhighlight lang=python>\nn.sendExclusive(0xb0, 'abc' ,0x40)  # Send a system exclusive message consisting of a start byte, 0xb0, 'a', 'b', 'c' (as ascii), 0x40, and an end byte.\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendExclusive",
                "call": "sendExclusive(message1, message2...)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Portamento event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendPortamento(1,34)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendPortamento",
                "call": "sendPortamento(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Main Volume event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*index - Valid index ranges are 1 to 2.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendEffectControl(1,1,27)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendEffectControl",
                "call": "sendEffectControl(channel, index,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Legato Footswitch event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendLegatoFootswitch(1,07)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendLegatoFootswitch",
                "call": "sendLegatoFootswitch(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Modulation Wheel event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendModulationWheel(1, 65)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendModulationWheel",
                "call": "sendModulationWheel(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Program Change event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI program change.  Valid ranges are dependent on the Controller Normalize parameter.\n<syntaxhighlight lang=python>\nn.sendProgram(1, 10)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendProgram",
                "call": "sendProgram(channel, value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Omni On event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendOmniOn(1,41)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendOmniOn",
                "call": "sendOmniOn(channel,value)",
                "class": "midioutCHOP"
            },
            {
                "text": "Sends a Portamento Control event through the CHOP.\n*channel - The MIDI event channel.  Valid ranges are 1 to 16.\n*value - The MIDI value.  Valid ranges are 0 to 127.\n<syntaxhighlight lang=python>\nn.sendPortamentoControl(1,112)\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendPortamentoControl",
                "call": "sendPortamentoControl(channel,value)",
                "class": "midioutCHOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "mirrorTOP": {
        "label": "mirrorTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "MOD": {
        "label": "MOD",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The MOD class provides access to Module On Demand object, which allows [[DAT|DATs]] to be dynamically imported as modules.  It can be accessed with the mod object, found in the automatically imported [[td Module|td module]].  Alternatively, one can use the regular python statement: import.\nUse of the import statement is limited to modules in the search path, where as the mod format allows complete statements in one line, which is more useful for entering expressions.  Also note that DAT modules cannot be organized into packages as regular file system based python modules can be."
    },
    "modelSOP": {
        "label": "modelSOP",
        "members": [],
        "methods": [
            {
                "class": "modelSOP",
                "name": "appendPoint",
                "call": "appendPoint()",
                "returns": "Point",
                "text": "Append a [[Point Class|point]] to this SOP. The appended point will be returned."
            },
            {
                "class": "modelSOP",
                "name": "appendPoly",
                "call": "appendPoly(numVertices, closed=True, addPoints=True)",
                "returns": "Poly",
                "text": "Append a [[Poly Class|poly]] to this SOP. Returns the appended polygon.\n* numVertices - Specifies the initial number of [[Vertex Class|vertices]].\n* closed - (Keyword, Optional) Specifies whether or not the last [[Vertex Class|vertex]] of the polygon will connect to the first. An open polygon will be drawn as a line.\n* addPoints - (Keyword, Optional) If True, a new [[Point Class|point]] will be attached to each [[Vertex Class|vertex]], otherwise the [[Vertex Class|vertex]] point references will need to be manually set afterwards. Use this option when creating [[Poly Class|polygons]] with shared [[Vertex Class|vertices]]."
            },
            {
                "class": "modelSOP",
                "name": "appendBezier",
                "call": "appendBezier(numVertices, closed=False, order=4, addPoints=True)",
                "returns": "Bezier",
                "text": "Append a [[Bezier Class|Bezier]] to this SOP. Returns the appended Bezier.\n* numVertices - Specifies the initial number of [[Vertex Class|vertices]].  The number of [[Vertex Class|vertices]] '''must''' correspond to the order (degree-1) and closed/open state of the curve.  For closed curves, the number of vertices must be a multiple of the degree.  For open curves, it must be one more than a multiple of the degree. \n<syntaxhighlight lang=python>\nn.appendBezier(6, closed=True) #closed, cubic, 6 vertices, or 2 spans\n</syntaxhighlight>\n<syntaxhighlight lang=python>\nn.appendBezier(7) #open, cubic, 7 vertices, or 2 spans\n</syntaxhighlight>\n* closed - (Keyword, Optional) Specifies whether or not the last [[Vertex Class|vertex]] of the curve will connect to the first. An open Bezier will be drawn as a line.\n* order - (Keyword, Optional) Specifies the degree of the Bezier. By default it creates cubic (order=4) Beziers.\n* addPoints - (Keyword, Optional) If True, a new [[Point Class|point]] will be attached to each [[Vertex Class|vertex]], otherwise the [[Vertex Class|vertex]] point references will need to be manually set afterwards. Use this option when creating Beziers with shared vertices."
            },
            {
                "class": "modelSOP",
                "name": "appendMesh",
                "call": "appendMesh(numRows, numCols, closedU=False, closedV=False, addPoints=True)",
                "returns": "Mesh",
                "text": "Append a [[Mesh Class|mesh]] to this SOP. Returns the appended mesh.\n* numRows, numCols - Specifies the initial number of rows and columns.\n* closedU - (Keyword, Optional) Specifies whether or not the grid is wrapped in the u direction.\n* closedV - (Keyword, Optional) Specifies whether or not the grid is wrapped in the v direction.\n* addPoints - (Keyword, Optional) If True, a new [[Point Class|point]] will be attached to each [[Vertex Class|vertex]], otherwise the [[Vertex Class|vertex]] point references will need to be manually set afterwards. Use this option when creating [[Mesh Class|meshes]] with shared [[Vertex Class|vertices]]."
            },
            {
                "class": "modelSOP",
                "name": "clear",
                "call": "clear()",
                "returns": "None",
                "text": "Remove all geometry."
            },
            {
                "class": "modelSOP",
                "name": "copy",
                "call": "copy(sop)",
                "returns": "None",
                "text": "Copy geometry from the specified [[SOP]] operator.\n* sop - The SOP to copy geometry from. Geometry currently in this SOP will be removed."
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "Monitor": {
        "label": "Monitor",
        "members": [
            {
                "class": "Monitor",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The monitor position in the list."
            },
            {
                "class": "Monitor",
                "name": "isPrimary",
                "type": "bool",
                "set": "0",
                "text": "Returns true, if this monitor is the primary display."
            },
            {
                "class": "Monitor",
                "name": "isAffinity",
                "type": "bool",
                "set": "0",
                "text": "Returns true, if this monitor is connected to the GPU that has been selected for GPU Affinity. Always True if GPU Affinity is not used."
            },
            {
                "class": "Monitor",
                "name": "width",
                "type": "int",
                "set": "0",
                "text": "The width of the monitor area, measured in pixels."
            },
            {
                "class": "Monitor",
                "name": "height",
                "type": "int",
                "set": "0",
                "text": "The height of the monitor area, measured in pixels."
            },
            {
                "class": "Monitor",
                "name": "left",
                "type": "int",
                "set": "0",
                "text": "The position of left edge of the monitor area, measured in pixels."
            },
            {
                "class": "Monitor",
                "name": "right",
                "type": "int",
                "set": "0",
                "text": "The position of right edge of the monitor area, measured in pixels."
            },
            {
                "class": "Monitor",
                "name": "top",
                "type": "int",
                "set": "0",
                "text": "The position of top edge of the monitor area, measured in pixels."
            },
            {
                "class": "Monitor",
                "name": "bottom",
                "type": "int",
                "set": "0",
                "text": "The position of bottom edge of the monitor area, measured in pixels."
            },
            {
                "class": "Monitor",
                "name": "displayName",
                "type": "str",
                "set": "0",
                "text": "The unique display name associated with this monitor."
            },
            {
                "class": "Monitor",
                "name": "description",
                "type": "str",
                "set": "0",
                "text": "A description of the monitor or its display adapter."
            },
            {
                "class": "Monitor",
                "name": "dpiScale",
                "type": "float",
                "set": "0",
                "text": "The DPI Scaling factor the monitor is current set to."
            },
            {
                "class": "Monitor",
                "name": "scaledWidth",
                "type": "int",
                "set": "0",
                "text": "The width of the monitor area, measured in points."
            },
            {
                "class": "Monitor",
                "name": "scaledHeight",
                "type": "int",
                "set": "0",
                "text": "The height of the monitor area, measured in points."
            },
            {
                "class": "Monitor",
                "name": "scaledLeft",
                "type": "int",
                "set": "0",
                "text": "The position of left edge of the monitor area, measured in points."
            },
            {
                "class": "Monitor",
                "name": "scaledRight",
                "type": "int",
                "set": "0",
                "text": "The position of right edge of the monitor area, measured in points."
            },
            {
                "class": "Monitor",
                "name": "scaledTop",
                "type": "int",
                "set": "0",
                "text": "The position of top edge of the monitor area, measured in points."
            },
            {
                "class": "Monitor",
                "name": "scaledBottom",
                "type": "int",
                "set": "0",
                "text": "The position of bottom edge of the monitor area, measured in points."
            },
            {
                "class": "Monitor",
                "name": "serialNumber",
                "type": "str",
                "set": "0",
                "text": "The serial number name associated with this monitor. May be blank."
            },
            {
                "class": "Monitor",
                "name": "refreshRate",
                "type": "float",
                "set": "0",
                "text": "The refresh rate the monitor is currently running at."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The Monitor class describes a single instance of a monitor display. They can be accessed from the [[Monitors Class|monitors]] object."
    },
    "Monitors": {
        "label": "Monitors",
        "members": [
            {
                "class": "Monitors",
                "name": "primary",
                "type": "int",
                "set": "0",
                "text": "The primary [[Monitor Class|monitor]] display."
            },
            {
                "class": "Monitors",
                "name": "width",
                "type": "int",
                "set": "0",
                "text": "The width of the combined monitor area, measured in pixels."
            },
            {
                "class": "Monitors",
                "name": "height",
                "type": "int",
                "set": "0",
                "text": "The height of the combined monitor area, measured in pixels."
            },
            {
                "class": "Monitors",
                "name": "left",
                "type": "int",
                "set": "0",
                "text": "The leftmost edge of the combined monitor area, measured in pixels."
            },
            {
                "class": "Monitors",
                "name": "right",
                "type": "int",
                "set": "0",
                "text": "The rightmost edge of the combined monitor area, measured in pixels."
            },
            {
                "class": "Monitors",
                "name": "top",
                "type": "int",
                "set": "0",
                "text": "The topmost position of the combined monitor area, measured in pixels."
            },
            {
                "class": "Monitors",
                "name": "bottom",
                "type": "int",
                "set": "0",
                "text": "The bottommost position of the combined monitor area, measured in pixels."
            }
        ],
        "methods": [
            {
                "class": "Monitors",
                "name": "locate",
                "call": "locate(x,y)",
                "returns": "td.Monitor",
                "text": "Return the [[Monitor Class|monitor]] at the specified mouse coordinates, or None."
            },
            {
                "class": "Monitors",
                "name": "refresh",
                "call": "refresh()",
                "returns": "None",
                "text": "Causes the application to behave as if a monitor device has changed. [[Monitors DAT]] and other sources will be updated. This is typically done automatically by the operating system, but in special cases can be triggered manually with this method."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Monitors class describes the set of all installed [[Monitor Class|monitor objects]]. It can be accessed with the monitors object, found in the automatically imported [[td Module|td module]].   It operates much like a Python list of monitor objects.\n<syntaxhighlight lang=python>\nprint(len(monitors))\t\t# number of monitors \nprint(monitors[0])\t\t\t# first monitor in the list\nfor m in monitors:\n\tprint(m.description)\t# print all installed monitors' descriptions\n</syntaxhighlight>"
    },
    "monitorsDAT": {
        "label": "monitorsDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "monochromeTOP": {
        "label": "monochromeTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "mouseinCHOP": {
        "label": "mouseinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "mouseoutCHOP": {
        "label": "mouseoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "moviefileinTOP": {
        "label": "moviefileinTOP",
        "members": [
            {
                "set": "0",
                "text": "Height of the movie, in pixels.",
                "type": "int",
                "class": "moviefileinTOP",
                "name": "fileHeight"
            },
            {
                "set": "0",
                "text": "Width of the movie, in pixels.",
                "type": "int",
                "class": "moviefileinTOP",
                "name": "fileWidth"
            },
            {
                "set": "0",
                "text": "True if the movie contains audio.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "hasAudio"
            },
            {
                "set": "0",
                "text": "True if any frames failed to decode, likely due to file corruption. Currently only works on Hap codec files.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "hasDecodeErrors"
            },
            {
                "set": "0",
                "text": "Current movie index.",
                "type": "float",
                "class": "moviefileinTOP",
                "name": "index"
            },
            {
                "set": "0",
                "text": "Current movie index expressed as a fraction of total length.",
                "type": "float",
                "class": "moviefileinTOP",
                "name": "indexFraction"
            },
            {
                "set": "0",
                "text": "True if the movie has pre-read all of its Pre-Read frames and is ready to play. For single images this is true when the image is ready to be shown. When a movie is playing, this member will flip between True and False as its pre-read frames get consumed/refilled. When a movie isn't playing forward, this member can tell you if the movie is in an optimal state to start playing back from its currently selected frame/cued frame.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "isFullyPreRead"
            },
            {
                "set": "0",
                "text": "True if the movie has failed to load.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "isInvalid"
            },
            {
                "set": "0",
                "text": "True if the movie is currently showing its last frame.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "isLastFrame"
            },
            {
                "set": "0",
                "text": "True if the movie has just looped and is showing the first frame after a loop.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "isLoopFrame"
            },
            {
                "set": "0",
                "text": "True if the current displayed de-interlaced frame is the odd field.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "isOddField"
            },
            {
                "set": "0",
                "text": "True if the file has been opened.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "isOpen"
            },
            {
                "set": "0",
                "text": "True when the file is opening.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "isOpening"
            },
            {
                "set": "0",
                "text": "Returns true while the file header is being read.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "isFileOpening",
                "deprecated": "True"
            },
            {
                "set": "0",
                "text": "True when the file is preloading.",
                "type": "bool",
                "class": "moviefileinTOP",
                "name": "isPreloading"
            },
            {
                "set": "0",
                "text": "The index of the if the last frame uploaded to the GPU.",
                "type": "float",
                "class": "moviefileinTOP",
                "name": "lastIndexUploaded"
            },
            {
                "set": "0",
                "text": "Returns the number of key-value pairs in the file's header.",
                "type": "int",
                "class": "moviefileinTOP",
                "name": "numHeaders"
            },
            {
                "set": "0",
                "text": "The number of images in the movie.",
                "type": "float",
                "class": "moviefileinTOP",
                "name": "numImages"
            },
            {
                "set": "0",
                "text": "The number of seconds in the movie.",
                "type": "float",
                "class": "moviefileinTOP",
                "name": "numSeconds"
            },
            {
                "set": "0",
                "text": "The movie sample rate.",
                "type": "float",
                "class": "moviefileinTOP",
                "name": "rate"
            },
            {
                "set": "0",
                "text": "A list of the available channels in the file e.g. R, G, B, A for typical color images.",
                "type": "tuple",
                "class": "moviefileinTOP",
                "name": "sourceChannels"
            },
            {
                "set": "0",
                "text": "The start index of the movie.",
                "type": "float",
                "class": "moviefileinTOP",
                "name": "start"
            },
            {
                "set": "0",
                "text": "The actual current index of the movie, disregarding trimming and other options.",
                "type": "float",
                "class": "moviefileinTOP",
                "name": "trueIndex"
            },
            {
                "set": "0",
                "text": "The actual number of images contained in the movie, not affected by trimming.",
                "type": "float",
                "class": "moviefileinTOP",
                "name": "trueNumImages"
            },
            {
                "set": "0",
                "text": "Get a Timecode object for the timecode data representation of the true current index of the movie. See [[Timecode Class]].",
                "type": "tdu.Timecode",
                "class": "moviefileinTOP",
                "name": "timecode"
            }
        ],
        "methods": [
            {
                "text": "Returns the value of the header with the given key. This method will return a blank string if the header is not found.\n*key - The name of the header to search for.",
                "returns": "string",
                "name": "findHeader",
                "call": "findHeader(key)",
                "class": "moviefileinTOP"
            },
            {
                "text": "Returns a tuple with the key and value of the header at the given index. This method will throw an error if the index is not valid. The numHeaders member can be used to get the number of valid headers in the file.\n*index - The index of the header to search for starting with 0.",
                "returns": "tuple",
                "name": "getHeader",
                "call": "getHeader(index)",
                "class": "moviefileinTOP"
            },
            {
                "text": "Unloads the movie and frees its memory usage. The movie will open again next time it cooks, so make sure nothing is still using it to keep it closed.\n*cacheMemory - (Keyword, Optional) If you are preloading into a Movie File In TOP that already has video, and the video format/resolution is the same, you can use the cacheMemory option to first unload the original movie and cache its memory, avoiding a reallocation when the preload() occurs. If True the memory (textures, upload buffers) of the movie will be cached for use by another movie later on. Useful if you are opening/closing many movies with the same codec and resolution.",
                "returns": "None",
                "name": "unload",
                "call": "unload(cacheMemory=False)",
                "class": "moviefileinTOP"
            },
            {
                "text": "Preloads the movie by opening it and pre-reading the first frames. Use the isFullyPreRead member to see if it's ready to play. This is done in a way to minimize impact on the existing playback of the application. If movies are being loaded on startup it's better to just call cook() on the Movie File In TOP instead of preload() since cook() will be more thorough.\n*index - (Optional) If specified the movie will be opened at the specified frame index. If not, then the movie will be opened at the index specified by its parameters.",
                "returns": "None",
                "name": "preload",
                "call": "preload(index)",
                "class": "moviefileinTOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "moviefileoutTOP": {
        "label": "moviefileoutTOP",
        "members": [
            {
                "set": "0",
                "text": "The number of files that have been written. This can be used to create an incrementing file name.",
                "type": "",
                "class": "moviefileoutTOP",
                "name": "writeCount"
            },
            {
                "set": "0",
                "text": "The current index of the last written image on disk.",
                "type": "",
                "class": "moviefileoutTOP",
                "name": "curSeqIndex"
            },
            {
                "class": "moviefileoutTOP",
                "name": "fileSuffix",
                "type": "str",
                "set": "0",
                "text": "Returns the generated file suffix. It will be generated based on the values of the parameters Unique Suffix and N, plus the file extension. It will take one of two forms: <code>''N''.''ext''</code> or <code>''N''.''i''.''ext''</code> where <code>''N''</code> is the suffix index (uniquely generated if Unique Suffix is enabled), <code>''i''</code> is the image sequence index (used only for the image sequence type), and <code>''ext''</code> is the image/movie extension."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "mqttclientDAT": {
        "label": "mqttclientDAT",
        "members": [
            {
                "set": "0",
                "text": "Return True if connected to a broker, and False if not.",
                "type": "bool",
                "class": "mqttclientDAT",
                "name": "isConnected"
            }
        ],
        "methods": [
            {
                "text": "Publish content to a specific topic.\n*topic - The topic to publish to.\n*payload - The actual message to send.\n*qos - (Keyword, Optional) The quality of service level to use.\n*retain - (Keyword, Optional) If set to True, the message will be set as the \"last known good\"retained message for the topic.\n<syntaxhighlight lang=python>\nn.publish('temperature', b'23')\n</syntaxhighlight>",
                "returns": "None",
                "name": "publish",
                "call": "publish(topic, payload, qos=0, retain=False)",
                "class": "mqttclientDAT"
            },
            {
                "text": "Subscribe to a specific topic from the broker.\n*topic - The topic to subscribe to. Multiple topics can be subscribed to at once by providing a list.\n*qos - (Keyword, Optional) Quality of Service for delivery: At most once (0), At least once (1) or Exactly once (2).\n<syntaxhighlight lang=python>\nn.subscribe('weather')\n</syntaxhighlight>",
                "returns": "None",
                "name": "subscribe",
                "call": "subscribe(topic, qos=0)",
                "class": "mqttclientDAT"
            },
            {
                "text": "Unsubscribe from a previously subscribed topic.\n*topic - The topic to unsubscribe from.  Multiple topics can be unsubscribed from at once by providing a list.\n<syntaxhighlight lang=python>\nn.unsubscribe('weather')\n</syntaxhighlight>",
                "returns": "None",
                "name": "unsubscribe",
                "call": "unsubscribe(topic)",
                "class": "mqttclientDAT"
            }
        ],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "multiplyTOP": {
        "label": "multiplyTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "multitouchinDAT": {
        "label": "multitouchinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "natnetinCHOP": {
        "label": "natnetinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "ndiinTOP": {
        "label": "ndiinTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "ndioutTOP": {
        "label": "ndioutTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "NetworkEditor": {
        "label": "NetworkEditor",
        "members": [
            {
                "class": "NetworkEditor",
                "name": "showBackdropCHOPs",
                "type": "bool",
                "set": "1",
                "text": "Enable or disable [[CHOP]] viewers as backdrops."
            },
            {
                "class": "NetworkEditor",
                "name": "showBackdropGeometry",
                "type": "bool",
                "set": "1",
                "text": "Enable or disable [[SOP]] and [[Geometry Object|Geometry object]] viewers as backdrops."
            },
            {
                "class": "NetworkEditor",
                "name": "showBackdropTOPs",
                "type": "bool",
                "set": "1",
                "text": "Enable or disable [[TOP]] viewers as backdrops."
            },
            {
                "class": "NetworkEditor",
                "name": "showColorPalette",
                "type": "bool",
                "set": "1",
                "text": "Enable or disable display of the operator color palette selector."
            },
            {
                "class": "NetworkEditor",
                "name": "showDataLinks",
                "type": "bool",
                "set": "1",
                "text": "Enable or disable disable of operator data links."
            },
            {
                "class": "NetworkEditor",
                "name": "showList",
                "type": "bool",
                "set": "1",
                "text": "Control display of operators as a list, or connected nodes."
            },
            {
                "class": "NetworkEditor",
                "name": "showNetworkOverview",
                "type": "bool",
                "set": "1",
                "text": "Enable or disable display of the network overview."
            },
            {
                "class": "NetworkEditor",
                "name": "showParameters",
                "type": "bool",
                "set": "1",
                "text": "Enable or disable display of the currently selected operator parameters."
            },
            {
                "class": "NetworkEditor",
                "name": "straightLinks",
                "type": "bool",
                "set": "1",
                "text": "Control display of operator links as straight or curved."
            },
            {
                "class": "NetworkEditor",
                "name": "x",
                "type": "float",
                "set": "1",
                "text": "Get or set the x coordinate of the network editor area,  where 1 unit = 1 pixel when zoom = 1."
            },
            {
                "class": "NetworkEditor",
                "name": "y",
                "type": "float",
                "set": "1",
                "text": "Get or set the y coordinate of the network editor area, where 1 unit = 1 pixel when zoom = 1."
            },
            {
                "class": "NetworkEditor",
                "name": "zoom",
                "type": "float",
                "set": "1",
                "text": "Get or set the zoom factor of the network editor area, where a zoom factor of 1 draws each node at its unscaled resolution."
            }
        ],
        "methods": [
            {
                "class": "NetworkEditor",
                "name": "fitWidth",
                "call": "fitWidth(width)",
                "returns": "None",
                "text": "Fit the network area to specified width, specified in node units.  This affects the zoom factor.\n*width - The width to fit to."
            },
            {
                "class": "NetworkEditor",
                "name": "fitHeight",
                "call": "fitHeight(height)",
                "returns": "None",
                "text": "Fit the network area to specified height, specified in node units. This affects the zoom factor.\n*height - The height to fit to."
            },
            {
                "class": "NetworkEditor",
                "name": "home",
                "call": "home(zoom=True, op=None)",
                "returns": "None",
                "text": "Home all operators in the network.\n*zoom - (Keyword, Optional) When true, the view will be scaled accordingly, otherwise the nodes will only be re-centered.\n*op - (Keyword, Optional) If an operator is specified, the network will be homed around its location.\n<syntaxhighlight lang=python>\np = ui.panes['pane1']\nn = op('/project1')\np.home(op=n)\np = ui.panes[2]\np.home(zoom=True)\n</syntaxhighlight>"
            },
            {
                "class": "NetworkEditor",
                "name": "homeSelected",
                "call": "homeSelected(zoom=True)",
                "returns": "None",
                "text": "Home all selected operators in the network.\n*zoom - (Keyword, Optional) When true, the view will be scaled accordingly, otherwise the nodes will only be re-centered."
            },
            {
                "class": "NetworkEditor",
                "name": "placeOPs",
                "call": "placeOPs(listOfOPs, inputIndex=None, outputIndex=None, delOP=None, undoName='Operators')",
                "returns": "None",
                "text": "Use the mouse to place the specified operators in the pane.\n*listOfOps - The list of operators to be placed.\n*inputIndex - If specified, which input index to connect to.\n*outputIndex - If specified, which output index to connect to.\n*delOP - If specified, deletes that operator immediately after placing the listOfOPs.\n*undoName - Describes the [[Undo]] operation."
            }
        ],
        "subclasses": {},
        "inherits": [
            "Pane"
        ],
        "summary": "The NetworkEditor class describes an instance of a [[Network Editor]]. They are subclasses of the [[Pane Class]], which can be accessed from the [[UI Class|ui]] object."
    },
    "noiseCHOP": {
        "label": "noiseCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "noiseCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "noiseCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "noiseSOP": {
        "label": "noiseSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "noiseTOP": {
        "label": "noiseTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "normalmapTOP": {
        "label": "normalmapTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "nullCHOP": {
        "label": "nullCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "nullCOMP": {
        "label": "nullCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "nullDAT": {
        "label": "nullDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "nullMAT": {
        "label": "nullMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "nullSOP": {
        "label": "nullSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "nullTOP": {
        "label": "nullTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "objectCHOP": {
        "label": "objectCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "ObjectCOMP": {
        "label": "ObjectCOMP",
        "members": [
            {
                "class": "ObjectCOMP",
                "name": "localTransform",
                "type": "tdu.Matrix",
                "set": "0",
                "text": "The current local transform of the Object. This is the combination of both the parameters from the Xform and Pre-Xform page, without taking into account any parent or constraint transforms. See also [[Matrix Class]], [[Position Class]] and [[Vector Class]]."
            },
            {
                "class": "ObjectCOMP",
                "name": "worldTransform",
                "type": "tdu.Matrix",
                "set": "0",
                "text": "The current world transform of the Object."
            }
        ],
        "methods": [
            {
                "class": "ObjectCOMP",
                "name": "transform",
                "call": "transform()",
                "returns": "tdu.Matrix",
                "text": "Gets the current transform of the Object as defined by the Translate, Rotate, Scale and Pivot parameters on the Xform page."
            },
            {
                "class": "ObjectCOMP",
                "name": "setTransform",
                "call": "setTransform(matrix)",
                "returns": "None",
                "text": "Sets the Translate, Rotate, Scale and Pivot parameters on the Xform page from the given [[Matrix Class|matrix]].\n*matrix - A matrix of values."
            },
            {
                "class": "ObjectCOMP",
                "name": "preTransform",
                "call": "preTransform()",
                "returns": "tdu.Matrix",
                "text": "Gets the current transform of the Object as defined by the Translate, Rotate, Scale and Pivot parameters on the Pre-Xform page."
            },
            {
                "class": "ObjectCOMP",
                "name": "setPreTransform",
                "call": "setPreTransform(matrix)",
                "returns": "None",
                "text": "Sets the Translate, Rotate, Scale and Pivot parameters on the Pre-Xform page from the given [[Matrix Class|matrix]].\n*matrix - A matrix of values."
            },
            {
                "class": "ObjectCOMP",
                "name": "relativeTransform",
                "call": "relativeTransform(target)",
                "returns": "tdu.Matrix",
                "text": "Returns a matrix that is the transform from the called object to the target object. This is, if you transform the called objects current transformation by the returned matrix, it will now be positioned at the target objects positions.\n*target - The target [[ObjectCOMP Class|ObjectCOMP]]. See also [[Matrix Class]], [[Position Class]] and [[Vector Class]]."
            },
            {
                "class": "ObjectCOMP",
                "name": "importABC",
                "call": "importABC(filepath, lights=True, cameras=True, mergeGeometry=True, gpuDeform=True, rate=None, textureFolder=None, geometryFolder=None, animationFolder=None)",
                "returns": "None",
                "text": "Load ABC files from the given file path.\n*filepath - The path and filename of the ABC file to import.\n*lights - (Keyword, Optional) If True, lights will be imported.\n*cameras - (Keyword, Optional) If True, cameras will be imported.\n*mergeGeometry - (Keyword, Optional) If True, geometry will be merged when it is static, and will share materials with other geometry. Less SOPs results in faster rendering, so merge geometry whenever possible.\n*gpuDeform - (Keyword, Optional) If True, geometry will be deformed with MATs using the gpu. If False, geometry will be deformed with SOPs using the CPU.\n*rate - (Keyword, Optional) If specified, animation channels will sampled at this rate.\n*textureFolder - (Keyword, Optional) Texture files (.jpeg, .tiff etc.) will be created in this folder. If the texture files aren't embeded in the .fbx file, you should place the textures in this folder.\n*geometryFolder - (Keyword, Optional) Geometry (.tog) files will be created in this folder. If this option is missing, geometry won't be imported.\n*animationFolder - (Keyword, Optional) Animation (.bchan) files will be created in this folder. If this option is missing, animation won't be imported."
            },
            {
                "class": "ObjectCOMP",
                "name": "importFBX",
                "call": "importFBX(filepath, lights=True, cameras=True, mergeGeometry=True, gpuDeform=True, rate=None, textureFolder=None, geometryFolder=None, animationFolder=None)",
                "returns": "None",
                "text": "Load FBX files from the given file path.\n*filepath - The path and filename of the FBX file to import.\n*lights - (Keyword, Optional) If True, lights will be imported.\n*cameras - (Keyword, Optional) If True, cameras will be imported.\n*mergeGeometry - (Keyword, Optional) If True, geometry will be merged when it is static, and will share materials with other geometry. Less SOPs results in faster rendering, so merge geometry whenever possible.\n*gpuDeform - (Keyword, Optional) If True, geometry will be deformed with MATs using the gpu. If False, geometry will be deformed with SOPs using the CPU.\n*rate - (Keyword, Optional) If specified, animation channels will sampled at this rate.\n*textureFolder - (Keyword, Optional) Texture files (.jpeg, .tiff etc.) will be created in this folder. If the texture files aren't embeded in the .fbx file, you should place the textures in this folder.\n*geometryFolder - (Keyword, Optional) Geometry (.tog) files will be created in this folder. If this option is missing, geometry won't be imported.\n*animationFolder - (Keyword, Optional) Animation (.bchan) files will be created in this folder. If this option is missing, animation won't be imported."
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "COMP"
        ],
        "summary": "This class inherits from the COMP class.\nIt is the parent class of these subclasses."
    },
    "objectmergeSOP": {
        "label": "objectmergeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "oculusaudioCHOP": {
        "label": "oculusaudioCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "oculusriftCHOP": {
        "label": "oculusriftCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "oculusriftTOP": {
        "label": "oculusriftTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "OP": {
        "label": "OP",
        "members": [
            {
                "class": "OP",
                "name": "valid",
                "type": "bool",
                "set": "0",
                "text": "True if the referenced operator currently exists, False if it has been deleted."
            },
            {
                "class": "OP",
                "name": "id",
                "type": "int",
                "set": "0",
                "text": "Unique id for the operator. This id can also be passed to the op() and ops() methods. Id's are not consistent when a file is re-opened, and will change if the OP is copied/pasted, changes OP types, deleted/undone. The id will not change if the OP is renamed though. Its data type is integer."
            },
            {
                "class": "OP",
                "name": "name",
                "type": "str",
                "set": "1",
                "text": "Get or set the operator name."
            },
            {
                "class": "OP",
                "name": "path",
                "type": "str",
                "set": "0",
                "text": "Full path to the operator."
            },
            {
                "class": "OP",
                "name": "digits",
                "type": "int",
                "set": "0",
                "text": "Returns the numeric value of the last consecutive group of digits in the name, or None if not found. The digits can be in the middle of the name if there are none at the end of the name."
            },
            {
                "class": "OP",
                "name": "base",
                "type": "str",
                "set": "0",
                "text": "Returns the beginning portion of the name occurring before any digits."
            },
            {
                "class": "OP",
                "name": "passive",
                "type": "bool",
                "set": "0",
                "text": "If true, operator will not cook before its access methods are called.  To use a passive version of an operator n, use passive(n)."
            },
            {
                "class": "OP",
                "name": "curPar",
                "type": "td.Par",
                "set": "0",
                "text": "The parameter currently being evaluated. Can be used in a parameter expression to reference itself."
            },
            {
                "class": "OP",
                "name": "time",
                "type": "OP",
                "set": "0",
                "text": "[[timeCOMP Class|Time Component]] that defines the operator's time reference."
            },
            {
                "class": "OP",
                "name": "ext",
                "type": "class",
                "set": "0",
                "text": "The object to search for parent [[Extensions|extensions]].\n<syntaxhighlight lang=\"python\">\nme.ext.MyClass\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "mod",
                "type": "mod",
                "set": "0",
                "text": "Get a [[MOD Class|module on demand]] object that searches for DAT modules relative to this operator."
            },
            {
                "class": "OP",
                "name": "pages",
                "type": "list",
                "set": "0",
                "text": "A list of all built-in pages."
            },
            {
                "class": "OP",
                "name": "parGroup",
                "type": "tuple",
                "set": "0",
                "text": "An intermediate [[ParGroupCollection Class|parameter collection]] object, from which a specific [[ParGroup Class|parameter group]] can be found.\n<syntaxhighlight lang=\"python\">\nn.parGroup.t\n# or\nn.parGroup['t']\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "par",
                "type": "td.Par",
                "set": "0",
                "text": "An intermediate [[ParCollection Class|parameter collection]] object, from which a specific [[Par Class|parameter]] can be found.\n<syntaxhighlight lang=\"python\">\nn.par.tx\n# or\nn.par['tx']\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "builtinPars",
                "type": "list or par",
                "set": "0",
                "text": "A list of all [[Par Class|built-in parameters]]."
            },
            {
                "class": "OP",
                "name": "customParGroups",
                "type": "list of parGroups",
                "set": "0",
                "text": "A list of all [[ParGroup Class|ParGroups]], where a ParGroup is a set of parameters all drawn on the same line of a dialog, sharing the same label."
            },
            {
                "class": "OP",
                "name": "customPars",
                "type": "list of par",
                "set": "0",
                "text": "A list of all [[Par Class|custom parameters]]."
            },
            {
                "class": "OP",
                "name": "customPages",
                "type": "list",
                "set": "0",
                "text": "A list of all [[Page Class|custom pages]]."
            },
            {
                "class": "OP",
                "name": "customTuplets",
                "deprecated": "True",
                "type": "list",
                "set": "0",
                "text": "A list of all parameter tuplets, where a tuplet is a set of parameters all drawn on the same line of a dialog, sharing the same label."
            },
            {
                "class": "OP",
                "name": "replicator",
                "type": "OP or None",
                "set": "0",
                "text": "The [[replicatorCOMP Class|replicatorCOMP]] that created this operator, if any."
            },
            {
                "class": "OP",
                "name": "storage",
                "type": "dict",
                "set": "0",
                "text": "[[Storage]] is dictionary associated with this operator. Values stored in this dictionary are persistent, and saved with the operator. The dictionary attribute is read only, but not its contents. Its contents may be manipulated directly with methods such as OP.fetch() or OP.store() described below, or examined with an [[Examine DAT]]."
            },
            {
                "class": "OP",
                "name": "tags",
                "type": "list",
                "set": "1",
                "text": "Get or set a set of user defined strings. [[Tag|Tags]] can be searched using OP.findChildren() and the [[OP Find DAT]].\nThe set is a regular python set, and can be accessed accordingly:\n<syntaxhighlight lang=\"python\">\nn.tags = ['effect', 'image filter']\nn.tags.add('darken')\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "children",
                "type": "list",
                "set": "0",
                "text": "A list of [[OP Class|operators]] contained within this operator. Only [[COMP Class|component]] operators have children, otherwise an empty list is returned."
            },
            {
                "class": "OP",
                "name": "numChildren",
                "type": "int",
                "set": "0",
                "text": "Returns the number of children contained within the operator. Only [[COMP Class|component]] operators have children."
            },
            {
                "class": "OP",
                "name": "numChildrenRecursive",
                "type": "int",
                "set": "0",
                "text": "Returns the number of operators contained recursively within this operator. Only [[COMP Class|component]] operators have children."
            },
            {
                "class": "OP",
                "name": "op",
                "type": "OP or None",
                "set": "0",
                "text": "The operator finder object, for accessing operators through paths or shortcuts. '''Note:''' a version of this method that searches relative to '/' is also in the global [[td Module|td module]].\n\n<code>'''op(pattern1, pattern2..., includeUtility=False)'''</code> &rarr; <code class=\"return\">[[OP Class|OP]] or None</code>\n<blockquote>\nReturns the first OP whose path matches the given pattern, relative to the inside of this operator. Will return None if nothing is found. Multiple patterns may be specified which are all added to the search. Numeric OP ids may also be used.\n* <code>pattern</code> - Can be string following the [[Pattern Matching]] rules, specifying which OP to return, or an integer, which must be an OP Id. Multiple patterns can be given, the first matching OP will be returned.\n* <code>includeUtility</code> '''(Optional)''' - if True, allow [[Network_Utilities:_Comments,_Network_Boxes,_Annotates|Utility nodes]] to be returned. If False, Utility operators will be ignored.\n\n<syntaxhighlight lang=\"python\">\nb = op('project1')\nb = op('foot*', 'hand*') #comma separated\nb = op('foot* hand*')  #space separated\nb = op(154)\n</syntaxhighlight>\n</blockquote>\n<code>'''op.shortcut'''</code> &rarr; <code>OP</code>\n<blockquote>\n:An operator specified with by a [[Global OP Shortcut]]. If no operator exists an exception is raised. These shortcuts are global, and must be unique. That is, cutting and pasting an operator with a Global OP Shortcut specified will lead to a name conflict. One shortcut must be renamed in that case. Furthermore, only components can be given Global OP Shortcuts.\n:*<code>shortcut</code> - Corresponds to the Global OP Shortcut parameter specified in the target operator.\n<syntaxhighlight lang=\"python\">\nb = op.Videoplayer \n</syntaxhighlight>\nTo list all Global OP Shortcuts:\n<syntaxhighlight lang=\"python\">\nfor x in op:\n\tprint(x)\n</syntaxhighlight>\n</blockquote>"
            },
            {
                "class": "OP",
                "name": "parent",
                "type": "OP",
                "set": "0",
                "text": "The [[Parent Shortcut|Parent Shortcut]] object, for accessing parent components through indices or shortcuts.\n'''Note:''' ''a version of this method that searches relative to the current operator is also in the global [[td Module|td module]].''\n\n<code class=\"python\">parent(n)</code> &rarr; <code class=\"return\">OP or None</code>\n<blockquote>\nThe nth parent of this operator. If n not specified, returns the parent. If n = 2, returns the parent of the parent, etc. If no parent exists at that level, None is returned.\n*n - (Optional) n is the number of levels up to climb. When n = 1 it will return the operator's parent.\n<syntaxhighlight lang=\"python\">\np = parent(2) #grandfather\n</syntaxhighlight>\n</blockquote>\n<code class=\"python\">parent.shortcut</code> &rarr; <code class=\"return\">OP</code>\n<blockquote>\nA parent component specified with a shortcut. If no parent exists an exception is raised.\n*shortcut - Corresponds to the [[Parent Shortcut]] parameter specified in the target parent.\n<syntaxhighlight lang=\"python\">\nn = parent.Videoplayer\n</syntaxhighlight>\nSee also Parent Shortcut for more examples.</blockquote>"
            },
            {
                "class": "OP",
                "name": "iop",
                "type": "OP",
                "set": "0",
                "text": "The Internal Operator Shortcut object, for accessing internal shortcuts. See also [[Internal Operators]].\n\n'''Note:''' a version of this method that searches relative to the current operator is also in the global [[td Module]]."
            },
            {
                "class": "OP",
                "name": "ipar",
                "type": "OP",
                "set": "0",
                "text": "The Internal Operator Parameter Shortcut object, for accessing internal shortcuts.  See also [[Internal Parameters]].\n    \n'''Note:''' a version of this method that searches relative to the current operator is also in the global [[td Module]]."
            },
            {
                "class": "OP",
                "name": "currentPage",
                "type": "[[Page Class|Page]]",
                "set": "1",
                "text": "Get or set the currently displayed parameter page. It can be set by setting it to another page or a string label.\n<syntaxhighlight lang=\"python\">n.currentPage = 'Common'</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "activeViewer",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Viewer Active Flag]]."
            },
            {
                "class": "OP",
                "name": "allowCooking",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Cooking Flag]]. Only COMPs can disable this flag."
            },
            {
                "class": "OP",
                "name": "bypass",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Bypass Flag]]."
            },
            {
                "class": "OP",
                "name": "cloneImmune",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Immune Flag|Clone Immune Flag]]."
            },
            {
                "class": "OP",
                "name": "current",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Current Flag]]."
            },
            {
                "class": "OP",
                "name": "display",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Display Flag]]."
            },
            {
                "class": "OP",
                "name": "expose",
                "type": "bool",
                "set": "1",
                "text": "Get or set the [[Expose Flag]] which hides a node from view in a network."
            },
            {
                "class": "OP",
                "name": "lock",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Lock Flag]]."
            },
            {
                "class": "OP",
                "name": "selected",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Selected Flag]]. This controls if the node is part of the network selection. (yellow box around it)."
            },
            {
                "class": "OP",
                "name": "python",
                "type": "bool",
                "set": "1",
                "text": "Get or set parameter expression language as python."
            },
            {
                "class": "OP",
                "name": "render",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Render Flag]]."
            },
            {
                "class": "OP",
                "name": "showCustomOnly",
                "type": "bool",
                "set": "1",
                "text": "Get or set the Show Custom Only Flag which controls whether or not non custom parameters are display in[[Parameter Dialog | parameter dialogs]]."
            },
            {
                "class": "OP",
                "name": "showDocked",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Docking|Show Docked Flag]]. This controls whether this node is visible or hidden when it is docked to another node."
            },
            {
                "class": "OP",
                "name": "viewer",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Viewer Flag]]."
            },
            {
                "class": "OP",
                "name": "color",
                "type": "tuple(r, g, b)",
                "set": "1",
                "text": "Get or set color value, expressed as a 3-tuple, representing its red, green, blue values. To convert between color spaces, use the built in colorsys module."
            },
            {
                "class": "OP",
                "name": "comment",
                "type": "str",
                "set": "1",
                "text": "Get or set comment string."
            },
            {
                "class": "OP",
                "name": "nodeHeight",
                "type": "int",
                "set": "1",
                "text": "Get or set node height, expressed in [[NetworkEditor Class|network editor]] units."
            },
            {
                "class": "OP",
                "name": "nodeWidth",
                "type": "int",
                "set": "1",
                "text": "Get or set node width, expressed in [[NetworkEditor Class|network editor]] units."
            },
            {
                "class": "OP",
                "name": "nodeX",
                "type": "int",
                "set": "1",
                "text": "Get or set node X value, expressed in [[NetworkEditor Class|network editor]] units, measured from its left edge."
            },
            {
                "class": "OP",
                "name": "nodeY",
                "type": "int",
                "set": "1",
                "text": "Get or set node Y value, expressed in [[NetworkEditor Class|network editor]] units, measured from its bottom edge."
            },
            {
                "class": "OP",
                "name": "nodeCenterX",
                "type": "int",
                "set": "1",
                "text": "Get or set node X value, expressed in [[NetworkEditor Class|network editor]] units, measured from its center."
            },
            {
                "class": "OP",
                "name": "nodeCenterY",
                "type": "int",
                "set": "1",
                "text": "Get or set node Y value, expressed in [[NetworkEditor Class|network editor]] units, measured from its center."
            },
            {
                "class": "OP",
                "name": "dock",
                "type": "OP",
                "set": "1",
                "text": "Get or set the [[OP Class|operator]] this operator is docked to.  To clear docking, set this member to None."
            },
            {
                "class": "OP",
                "name": "docked",
                "type": "list",
                "set": "0",
                "text": "The (possibly empty) list of [[OP Class|operators]] docked to this node."
            },
            {
                "class": "OP",
                "name": "inputs",
                "type": "list",
                "set": "0",
                "text": "List of input [[OP Class|operators]] (via left side connectors) to this operator. To get the number of inputs, use len(OP.inputs)."
            },
            {
                "class": "OP",
                "name": "outputs",
                "type": "list",
                "set": "0",
                "text": "List of output [[OP Class|operators]] (via right side connectors) from this operator."
            },
            {
                "class": "OP",
                "name": "inputConnectors",
                "type": "list",
                "set": "0",
                "text": "List of input [[Connector Class|connectors]] (on the left side) associated with this operator."
            },
            {
                "class": "OP",
                "name": "outputConnectors",
                "type": "list",
                "set": "0",
                "text": "List of output [[Connector Class|connectors]] (on the right side) associated with this operator."
            },
            {
                "class": "OP",
                "name": "cookFrame",
                "type": "float",
                "set": "0",
                "text": "Last frame at which this operator cooked."
            },
            {
                "class": "OP",
                "name": "cookTime",
                "type": "float",
                "set": "0",
                "text": "'''Deprecated''' Duration of the last measured cook (in milliseconds)."
            },
            {
                "class": "OP",
                "name": "cpuCookTime",
                "type": "float",
                "set": "0",
                "text": "Duration of the last measured cook in CPU time (in milliseconds)."
            },
            {
                "class": "OP",
                "name": "cookAbsFrame",
                "type": "float",
                "set": "0",
                "text": "Last absolute frame at which this operator cooked."
            },
            {
                "class": "OP",
                "name": "cookStartTime",
                "type": "float",
                "set": "0",
                "text": "Last offset from frame start at which this operator cook began, expressed in milliseconds."
            },
            {
                "class": "OP",
                "name": "cookEndTime",
                "type": "float",
                "set": "0",
                "text": "Last offset from frame start at which this operator cook ended, expressed in milliseconds.  Other operators may have cooked between the start and end time.  See the cookTime member for this operator's specific cook duration."
            },
            {
                "class": "OP",
                "name": "cookedThisFrame",
                "type": "bool",
                "set": "0",
                "text": "True when this operator has cooked this frame."
            },
            {
                "class": "OP",
                "name": "cookedPreviousFrame",
                "type": "bool",
                "set": "0",
                "text": "True when this operator has cooked the previous frame."
            },
            {
                "class": "OP",
                "name": "childrenCookTime",
                "type": "float",
                "set": "0",
                "text": "'''Deprecated''' The total accumulated cook time of all children of this operator during the last frame. Zero if the operator is not a [[COMP Class|COMP]] and/or has no children."
            },
            {
                "class": "OP",
                "name": "childrenCPUCookTime",
                "type": "float",
                "set": "0",
                "text": "The total accumulated cook time of all children of this operator during the last frame. Zero if the operator is not a [[COMP Class|COMP]] and/or has no children."
            },
            {
                "class": "OP",
                "name": "childrenCookAbsFrame",
                "type": "float",
                "set": "0",
                "text": "'''Deprecated''' The absolute frame on which childrenCookTime is based."
            },
            {
                "class": "OP",
                "name": "childrenCPUCookAbsFrame",
                "type": "float",
                "set": "0",
                "text": "The absolute frame on which childrenCPUCookTime is based."
            },
            {
                "class": "OP",
                "name": "gpuCookTime",
                "type": "float",
                "set": "0",
                "text": "Duration of GPU operations during the last measured cook (in milliseconds)."
            },
            {
                "class": "OP",
                "name": "childrenGPUCookTime",
                "type": "float",
                "set": "0",
                "text": "The total accumulated GPU cook time of all children of this operator during the last frame. Zero if the operator is not a COMP and/or has no children."
            },
            {
                "class": "OP",
                "name": "childrenGPUCookAbsFrame",
                "type": "float",
                "set": "0",
                "text": "The absolute frame on which childrenGPUCookTime is based."
            },
            {
                "class": "OP",
                "name": "totalCooks",
                "type": "int",
                "set": "0",
                "text": "Number of times the operator has cooked."
            },
            {
                "class": "OP",
                "name": "cpuMemory",
                "type": "int",
                "set": "0",
                "text": "The approximate amount of CPU memory this Operator is using, in bytes."
            },
            {
                "class": "OP",
                "name": "gpuMemory",
                "type": "int",
                "set": "0",
                "text": "The amount of GPU memory this OP is using, in bytes."
            },
            {
                "class": "OP",
                "name": "type",
                "type": "str",
                "set": "0",
                "text": "Operator type as a string. Example: 'oscin'."
            },
            {
                "class": "OP",
                "name": "subType",
                "type": "str",
                "set": "0",
                "text": "Operator subtype. Currently only implemented for [[Component|components]]. May be one of: 'panel', 'object', or empty string in the case of base components."
            },
            {
                "class": "OP",
                "name": "OPType",
                "type": "str",
                "set": "0",
                "text": "Python operator class type, as a string. Example: 'oscinCHOP'. Can be used with COMP.create() method."
            },
            {
                "class": "OP",
                "name": "label",
                "type": "str",
                "set": "0",
                "text": "Operator type label. Example: 'OSC In'."
            },
            {
                "class": "OP",
                "name": "icon",
                "type": "str",
                "set": "0",
                "text": "Get the letters used to create the operator's icon."
            },
            {
                "class": "OP",
                "name": "family",
                "type": "str",
                "set": "0",
                "text": "Operator family. Example: CHOP. Use the global dictionary families for a list of each operator type."
            },
            {
                "class": "OP",
                "name": "isFilter",
                "type": "bool",
                "set": "0",
                "text": "True if operator is a filter, false if it is a generator."
            },
            {
                "class": "OP",
                "name": "minInputs",
                "type": "int",
                "set": "0",
                "text": "Minimum number of inputs to the operator."
            },
            {
                "class": "OP",
                "name": "maxInputs",
                "type": "int",
                "set": "0",
                "text": "Maximum number of inputs to the operator."
            },
            {
                "class": "OP",
                "name": "isMultiInputs",
                "type": "bool",
                "set": "0",
                "text": "True if inputs are ordered, false otherwise. Operators with an arbitrary number of inputs have unordered inputs, example [[Merge CHOP]]."
            },
            {
                "class": "OP",
                "name": "visibleLevel",
                "type": "int",
                "set": "0",
                "text": "Visibility level of the operator. For example, expert operators have visibility level 1, regular operators have visibility level 0."
            },
            {
                "class": "OP",
                "name": "isBase",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a Base (miscellaneous) [[Component|component]]."
            },
            {
                "class": "OP",
                "name": "isCHOP",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a [[CHOP]]."
            },
            {
                "class": "OP",
                "name": "isCOMP",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a [[Component|component]]."
            },
            {
                "class": "OP",
                "name": "isDAT",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a [[DAT]]."
            },
            {
                "class": "OP",
                "name": "isMAT",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a [[MAT|Material]]."
            },
            {
                "class": "OP",
                "name": "isObject",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is an [[object]]."
            },
            {
                "class": "OP",
                "name": "isPanel",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a [[Panel]]."
            },
            {
                "class": "OP",
                "name": "isSOP",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a [[SOP]]."
            },
            {
                "class": "OP",
                "name": "isTOP",
                "type": "bool",
                "set": "0",
                "text": "True if the operators is a [[TOP]]."
            },
            {
                "class": "OP",
                "name": "licenseType",
                "type": "str",
                "set": "0",
                "text": "Type of [[License Class|License]] required for the operator."
            }
        ],
        "methods": [
            {
                "class": "OP",
                "name": "pars",
                "call": "pars(pattern)",
                "returns": "list",
                "text": "Returns a (possibly empty) list of [[Par Class|parameter objects]] that match the pattern.\n*pattern - Is a string following the [[Pattern Matching]] rules, specifying which parameters to return.\n<syntaxhighlight lang=\"python\">\nnewlist = op('geo1').pars('t?', 'r?', 's?') #translate/rotate/scale parameters\n</syntaxhighlight>Note: If searching for a single parameter given a name, it's much more efficient to use the subscript operator. For example:<syntaxhighlight lang=\"python\">name = 'MyName1'\nop('geo1').par[name]</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "cook",
                "call": "cook(force=False, recurse=False, includeUtility=False)",
                "returns": "None",
                "text": "Cook the contents of the operator if required.\n*force - (Keyword, Optional) If True, the operator will always cook, even if it wouldn't under normal circumstances.\n*recurse - (Keyword, Optional) If True, all children and sub-children of the operator will be cooked.\n*includeUtility - (Keyword, Optional) If specified, controls whether or not utility components (eg Comments) are included in the results."
            },
            {
                "class": "OP",
                "name": "copyParameters",
                "call": "copyParameters(OP, custom=True, builtin=True)",
                "returns": "None",
                "text": "Copy all of the parameters from the specified [[OP Class|operator]].  Both operators should be the same type.\n*OP - The operator to copy.\n*custom - (Keyword, Optional) When True, custom parameters will be copied. \n*builtin - (Keyword, Optional) When True, built in parameters will be copied.\n<syntaxhighlight lang=\"python\">\nop('geo1').copyParameters( op('geo2') )\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "changeType",
                "call": "changeType(OPtype)",
                "returns": "OP",
                "text": "Change referenced operator to a new operator type.  After this call, this OP object should no longer be referenced.  Instead use the returned OP object.\n*OPtype - The python class name of the operator type you want to change this operator to. This is not a string, but instead is a class defined in the global [[td Module|td module]].\n<syntaxhighlight lang=\"python\">\nn = op('wave1').changeType(nullCHOP) #changes 'wave1' into a Null CHOP\nn = op('text1').changeType(tcpipDAT) #changes 'text1' operator into a TCPIP DAT\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "dependenciesTo",
                "call": "dependenciesTo(OP)",
                "returns": "list",
                "text": "Returns a (possibly empty) list of operator dependency paths between this operator and the specified operator. Multiple paths may be found."
            },
            {
                "class": "OP",
                "name": "evalExpression",
                "call": "evalExpression(str)",
                "returns": "value",
                "text": "Evaluate the expression from the context of this OP.  Can be used to evaluate arbitrary snippets of code from arbitrary locations. \n*str - The expression to evaluate.\n<syntaxhighlight lang=\"python\">\nop('wave1').evalExpression('me.digits')  #returns 1\n</syntaxhighlight>\nIf the expression already resides in a parameter, use that parameters [[Par Class|evalExpression()]] method instead."
            },
            {
                "class": "OP",
                "name": "destroy",
                "call": "destroy()",
                "returns": "None",
                "text": "Destroy the operator referenced by this OP. An exception will be raised if the OP's operator has already been destroyed."
            },
            {
                "class": "OP",
                "name": "var",
                "call": "var(name, search=True)",
                "returns": "str",
                "text": "Evaluate a[[Variables | variable]]. This will return the empty string, if not found. Most information obtained from variables (except for Root and Component variables) are accessible through other means in Python, usually in the global [[td Module|td module]].\n*name - The variable name to search for.\n*search - (Keyword, Optional) If set to True (which is default) the operator hierarchy is searched until a variable matching that name is found.  If false, the search is constrained to the operator."
            },
            {
                "class": "OP",
                "name": "openMenu",
                "call": "openMenu(x=None, y=None)",
                "returns": "None",
                "text": "Open a node menu for the operator at x, y.  Opens at mouse if x & y are not specified.\n*x - (Keyword, Optional) The X coordinate of the menu, measured in screen pixels.\n*y - (Keyword, Optional) The Y coordinate of the menu, measured in screen pixels."
            },
            {
                "class": "OP",
                "name": "relativePath",
                "call": "relativePath(OP)",
                "returns": "str",
                "text": "Returns the relative path from this operator to the OP that is passed as the argument.   See OP.shortcutPath for a version using expressions."
            },
            {
                "class": "OP",
                "name": "setInputs",
                "call": "setInputs(listOfOPs)",
                "returns": "None",
                "text": "Set all the operator inputs to the specified list.\n* listOfOPs - A list containing one or more OPs. Entries in the list can be None to disconnect specific inputs.  An empty list disconnects all inputs."
            },
            {
                "class": "OP",
                "name": "shortcutPath",
                "call": "shortcutPath(OP, toParName=None)",
                "returns": "str",
                "text": "Returns an expression from this operator to the OP that is passed as the argument. See OP.relativePath for a version using relative path constants.\n* toParName - (Keyword, Optional) Return an expression to this parameter instead of its operator."
            },
            {
                "class": "OP",
                "name": "ops",
                "call": "ops(pattern1, pattern2.., includeUtility=False)",
                "returns": "list of OPs",
                "text": "Returns a (possibly empty) list of OPs that match the patterns, relative to the inside of this OP.\nMultiple patterns may be provided. Numeric OP ids may also be used.\n*pattern - Can be string following the [[Pattern Matching]] rules, specifying which OPs to return, or an integer, which must be an OP Id. Multiple patterns can be given and all matched OPs will be returned.\n*includeUtility - (Keyword, Optional) If specified, controls whether or not utility components (eg Comments) are included in the results.\n'''Note:''' a version of this method that searches relative to '/' is also in the global [[td Module|td module]].\n<syntaxhighlight lang=\"python\">\nnewlist = n.ops('arm*', 'leg*', 'leg5/foot*')\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "addScriptError",
                "call": "addScriptError(msg)",
                "returns": "None",
                "text": "Adds a script error to a node.\n*msg - The error to add."
            },
            {
                "class": "OP",
                "name": "addError",
                "call": "addError(msg)",
                "returns": "None",
                "text": "Adds an error to an operator.  Only valid if added while the operator is cooking. (Example Script SOP, CHOP, DAT).\n*msg - The error to add."
            },
            {
                "class": "OP",
                "name": "addWarning",
                "call": "addWarning(msg)",
                "returns": "None",
                "text": "Adds a warning to an operator.  Only valid if added while the operator is cooking. (Example Script SOP, CHOP, DAT).\n*msg - The error to add."
            },
            {
                "class": "OP",
                "name": "errors",
                "call": "errors(recurse=False)",
                "returns": "str",
                "text": "Get error messages associated with this OP.\n*recurse - Get errors in any children or subchildren as well."
            },
            {
                "class": "OP",
                "name": "warnings",
                "call": "warnings(recurse=False)",
                "returns": "str",
                "text": "Get warning messages associated with this OP.\n*recurse - Get warnings in any children or subchildren as well."
            },
            {
                "class": "OP",
                "name": "scriptErrors",
                "call": "scriptErrors(recurse=False)",
                "returns": "str",
                "text": "Get script error messages associated with this OP.\n*recurse - Get errors in any children or subchildren as well."
            },
            {
                "class": "OP",
                "name": "clearScriptErrors",
                "call": "clearScriptErrors(recurse=False, error='*')",
                "returns": "None",
                "text": "Clear any errors generated during script execution.  These may be generated during execution of DATs, Script Nodes, Replicator COMP callbacks, etc.\n*recurse - Clear script errors in any children or subchildren as well.\n*error - Pattern to match when clearing errors\n<syntaxhighlight lang=\"python\">\nop('/project1').clearScriptErrors(recurse=True)\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "childrenCPUMemory",
                "call": "childrenCPUMemory()",
                "returns": "int",
                "text": "Returns the total CPU memory usage for all the children from this COMP."
            },
            {
                "class": "OP",
                "name": "childrenGPUMemory",
                "call": "childrenGPUMemory()",
                "returns": "int",
                "text": "Returns the total GPU memory usage for all the children from this COMP."
            },
            {
                "class": "OP",
                "name": "resetNodeSize",
                "call": "resetNodeSize()",
                "returns": "None",
                "text": "Reset the node tile size to its default width and height."
            },
            {
                "class": "OP",
                "name": "closeViewer",
                "call": "closeViewer(topMost=False)",
                "returns": "None",
                "text": "Close the floating content viewers of the OP.\n*topMost - (Keyword, Optional) If True, any viewer window containing any parent of this OP is closed instead.\n<syntaxhighlight lang=\"python\">\nop('wave1').closeViewer()\nop('wave1').closeViewer(topMost=True) # any viewer that contains 'wave1' will be closed.\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "openViewer",
                "call": "openViewer(unique=False, borders=True)",
                "returns": "None",
                "text": "Open a floating content viewer for the OP.\n*unique - (Keyword, Optional) If False, any existing viewer for this OP will be re-used and popped to the foreground. If unique is True, a new window is created each time instead.\n*borders - (Keyword, Optional) If true, the floating window containing the viewer will have borders.\n<syntaxhighlight lang=\"python\">\nop('geo1').openViewer(unique=True, borders=False) # opens a new borderless viewer window for 'geo1'\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "resetViewer",
                "call": "resetViewer(recurse=False)",
                "returns": "None",
                "text": "Reset the OP content viewer to default view settings.\n*recurse - (Keyword, Optional) If True, this is done for all children and sub-children as well.\n<syntaxhighlight lang=\"python\">\nop('/').resetViewer(recurse=True) # reset the viewer for all operators in the entire file.\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "openParameters",
                "call": "openParameters()",
                "returns": "None",
                "text": "Open a floating dialog containing the operator parameters."
            },
            {
                "class": "OP",
                "name": "fetch",
                "call": "fetch(key, default, search=True, storeDefault=False)",
                "returns": "value",
                "text": "Return an object from the OP storage dictionary.  If the item is not found, and a default it supplied, it will be returned instead.\n*key - The name of the entry to retrieve.\n*default - (Optional) If provided and no item is found then the passed value/object is returned instead.\n*storeDefault - (Keyword, Optional) If True, and the key is not found, the default is stored as well.\n*search - (Keyword, Optional) If True, the parent of each OP is searched recursively until a match is found\n<syntaxhighlight lang=\"python\">\nv = n.fetch('sales5', 0.0)\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "fetchOwner",
                "call": "fetchOwner(key)",
                "returns": "OP",
                "text": "Return the operator which contains the stored key, or None if not found.\n*key - The key to the stored entry you are looking for.\n<syntaxhighlight lang=\"python\">\nwho = n.fetchOwner('sales5') #find the OP that has a storage entry called 'sales5'\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "store",
                "call": "store(key, value)",
                "returns": "value",
                "text": "Add the key/value pair to the OP's storage dictionary, or replace it if it already exists.  If this value is not intended to be saved and loaded in the toe file, it can be be given an alternate value for saving and loading, by using the method storeStartupValue described below.\n*key - A string name for the storage entry. Use this name to retrieve the value using fetch().\n*value - The value/object to store.\n<syntaxhighlight lang=\"python\">\nn.store('sales5', 34.5) # stores a floating point value 34.5.\nn.store('moviebank', op('/project1/movies')) # stores an OP for easy access later on.\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "unstore",
                "call": "unstore(keys1, keys2..)",
                "returns": "None",
                "text": "For key, remove it from the OP's storage dictionary. Pattern Matching is supported as well.\n*keys - The name or pattern defining which key/value pairs to remove from the storage dictionary.\n<syntaxhighlight lang=\"python\">\nn.unstore('sales*') # removes all entries from this OPs storage that start with 'sales'\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "storeStartupValue",
                "call": "storeStartupValue(key, value)",
                "returns": "None",
                "text": "Add the key/value pair to the OP's storage startup dictionary.  The storage element will take on this value when the file starts up.\n*key - A string name for the storage startup entry.\n*value - The startup value/object to store.\n<syntaxhighlight lang=\"python\">\nn.storeStartupValue('sales5', 1) # 'sales5' will have a value of 1 when the file starts up.\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "unstoreStartupValue",
                "call": "unstoreStartupValue(keys1, keys2..)",
                "returns": "None",
                "text": "For key, remove it from the OP's storage startup dictionary. Pattern Matching is supported as well.  This does not affect the stored value, just its startup value.\n*keys - The name or pattern defining which key/value pairs to remove from the storage startup dictionary.\n<syntaxhighlight lang=\"python\">\nn.unstoreStartupValue('sales*') # removes all entries from this OPs storage startup that start with 'sales'\n</syntaxhighlight>"
            },
            {
                "class": "OP",
                "name": "__getstate__",
                "call": "__getstate__()",
                "returns": "dict",
                "text": "Returns a dictionary with persistent data about the object suitable for pickling and deep copies."
            },
            {
                "class": "OP",
                "name": "__setstate__",
                "call": "__setstate__()",
                "returns": "dict",
                "text": "Reads the dictionary to update persistent details about the object, suitable for unpickling and deep copies."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The OP class defines a reference to a single [[Operator|operator]]."
    },
    "opencolorioTOP": {
        "label": "opencolorioTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "openvrCHOP": {
        "label": "openvrCHOP",
        "members": [],
        "methods": [
            {
                "text": "Triggers a haptic/vibration pulse on the given controller/analog index for the specified number of milliseconds.\n*controllerIndex - 0 based controller index. Same order as the controllers are listed in the OpenVR CHOP.\n*analogIndex - index of the analog button/pad. Currently only 0 is supported on Vive hardware.\n*durationMilliSeconds - The length of the feedback in milliseconds. Anything equal to or above 4ms does not seem to work with current hardware.",
                "returns": "None",
                "name": "triggerHapticPulse",
                "call": "triggerHapticPulse(controllerIndex, analogIndex, durationMilliseconds)",
                "class": "openvrCHOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "openvrSOP": {
        "label": "openvrSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "openvrTOP": {
        "label": "openvrTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "opexecuteDAT": {
        "label": "opexecuteDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "opfindDAT": {
        "label": "opfindDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "Options": {
        "label": "Options",
        "members": [],
        "methods": [
            {
                "class": "Options",
                "name": "resetToDefaults",
                "call": "resetToDefaults()",
                "returns": "None",
                "text": "Reset all options to their default values."
            },
            {
                "class": "Options",
                "name": "len",
                "call": "len(Options)",
                "returns": "int",
                "text": "Returns the total number of options.\n<syntaxhighlight lang=python>\na = len(ui.options)\n</syntaxhighlight>"
            },
            {
                "class": "Options",
                "name": "[]",
                "call": "[<option name>]",
                "returns": "value",
                "text": "Get or set specific option given an option name key.\n<syntaxhighlight lang=python>\nv = ui.options['DAT.width']\nui.options['DAT.width'] = 50\n</syntaxhighlight>"
            },
            {
                "class": "Options",
                "name": "iterator",
                "call": "Iterator",
                "returns": "str",
                "text": "Iterate over each option name.\n<syntaxhighlight lang=python>\nfor n in ui.options:\n\tprint(n) # print the name of all options\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Options class describes the set of configurable UI options.  It can be accessed with the ui.options object."
    },
    "opviewerCOMP": {
        "label": "opviewerCOMP",
        "members": [],
        "methods": [
            {
                "class": "opviewerCOMP",
                "name": "isViewable",
                "call": "isViewable(path)",
                "returns": "bool",
                "text": "Returns true if this operator can view the specified operator without recursion issues.\"\n*path - Path to the specfied operator. An operator can be supplied as well."
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "PanelCOMP",
            "COMP"
        ]
    },
    "opviewerTOP": {
        "label": "opviewerTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "oscinCHOP": {
        "label": "oscinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "oscinDAT": {
        "label": "oscinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "oscoutCHOP": {
        "label": "oscoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "oscoutDAT": {
        "label": "oscoutDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "outCHOP": {
        "label": "outCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "outDAT": {
        "label": "outDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "outMAT": {
        "label": "outMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "outsideTOP": {
        "label": "outsideTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "outSOP": {
        "label": "outSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "outTOP": {
        "label": "outTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "overrideCHOP": {
        "label": "overrideCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "overTOP": {
        "label": "overTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "packTOP": {
        "label": "packTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "Page": {
        "label": "Page",
        "members": [
            {
                "class": "Page",
                "name": "name",
                "type": "bool",
                "set": "1",
                "text": "Get or set the name of the page."
            },
            {
                "class": "Page",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Page",
                "deprecated": "False",
                "name": "parGroups",
                "type": "list",
                "set": "0",
                "text": "A list of [[ParGroup Class|parameter groups]] on this page. A ParGroup is the set of parameters on one line."
            },
            {
                "class": "Page",
                "deprecated": "True",
                "name": "parTuplets",
                "type": "list",
                "set": "0",
                "text": "The list of [[Par Class|parameter]] tuplets on this page. A [[tuplet]] is the set of parameters on one line."
            },
            {
                "class": "Page",
                "name": "pars",
                "type": "list",
                "set": "0",
                "text": "The list of [[Par Class|parameters]] on this page."
            },
            {
                "class": "Page",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The numeric index of this page."
            },
            {
                "class": "Page",
                "name": "isCustom",
                "type": "bool",
                "set": "0",
                "text": "Boolean for whether this page is custom or not."
            }
        ],
        "methods": [
            {
                "class": "Page",
                "name": "appendOP",
                "call": "appendOP(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a node reference type [[Par Class|parameter]]. This parameter will accept references to any operator.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendCOMP",
                "call": "appendCOMP(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a COMP node reference type [[Par Class|parameter]]. This parameter will only accept references to COMPs, and will refuse operators of other families.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendOBJ",
                "call": "appendOBJ(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "deprecated": "True",
                "text": "Create a 3D Object COMP node reference type [[Par Class|parameter]]. This parameter will only accept references to 3D Object COMPs, and will refuse operators of other families.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendObject",
                "call": "appendObject(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a 3D Object COMP node reference type [[Par Class|parameter]]. This parameter will only accept references to 3D Object COMPs, and will refuse operators of other families.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendPanelCOMP",
                "call": "appendPanelCOMP(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a Panel COMP node reference type [[Par Class|parameter]]. This parameter will only accept references to Panel COMPs, and will refuse operators of other families.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendTOP",
                "call": "appendTOP(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a TOP node reference type [[Par Class|parameter]]. This parameter will only accept references to TOPs, and will refuse operators of other families.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendCHOP",
                "call": "appendCHOP(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a CHOP node reference type [[Par Class|parameter]]. This parameter will only accept references to CHOPs, and will refuse operators of other families.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendSOP",
                "call": "appendSOP(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a SOP node reference type [[Par Class|parameter]]. This parameter will only accept references to SOPs, and will refuse operators of other families.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendMAT",
                "call": "appendMAT(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a MAT node reference type [[Par Class|parameter]]. This parameter will only accept references to MATs, and will refuse operators of other families.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendDAT",
                "call": "appendDAT(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a DAT node reference type [[Par Class|parameter]]. This parameter will only accept references to DATs, and will refuse operators of other families.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendInt",
                "call": "appendInt(name, label=None, size=1, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a integer type [[Par Class|parameter]]. Returns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*size - (Keyword, Optional) Set the number of values associated with the parameter. When greater than 1, the parameter will be shown as multiple float fields without a slider and multiple parameters will be created with the index of the parameter appended to the parameter name, starting at 1.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendFloat",
                "call": "appendFloat(name, label=None, size=1, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a float type [[Par Class|parameter]]. Returns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*size - (Keyword, Optional) Set the number of values associated with the parameter. When greater than 1, the parameter will be shown as multiple float fields without a slider and multiple parameters will be created with the index of the parameter appended to the parameter name, starting at 1.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendXY",
                "call": "appendXY(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a XY position type [[Par Class|parameter]]. Similar to creating a float parameter with size=2, but with more appropriate default naming.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendXYZ",
                "call": "appendXYZ(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a XYZ position type [[Par Class|parameter]]. Similar to creating a float parameter with size=3, but with more appropriate default naming.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendXYZW",
                "call": "appendXYZW(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a XYZW position type [[Par Class|parameter]]. Similar to creating a float parameter with size=4, but with more appropriate default naming.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendWH",
                "call": "appendWH(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a WH size type [[Par Class|parameter]]. Similar to creating a float parameter with size=2, but with more appropriate default naming.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendUV",
                "call": "appendUV(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a UV 2D texture type [[Par Class|parameter]]. Similar to creating a float parameter with size=2, but with more appropriate default naming.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendUVW",
                "call": "appendUVW(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a UVW 3D texture type [[Par Class|parameter]]. Similar to creating a float parameter with size=3, but with more appropriate default naming.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendRGB",
                "call": "appendRGB(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a RGB color type [[Par Class|parameter]]. Similar to creating a float parameter with size=3, but with more appropriate default naming.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendRGBA",
                "call": "appendRGBA(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a RGBA color type [[Par Class|parameter]]. Similar to creating a float parameter with size=4, but with more appropriate default naming.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendStr",
                "call": "appendStr(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a string type [[Par Class|parameter]]. Returns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendStrMenu",
                "call": "appendStrMenu(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a menu type [[Par Class|parameter]]. Returns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendMenu",
                "call": "appendMenu(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a menu type [[Par Class|parameter]]. Returns the created [[ParGroup Class|parameter group]] object.\nTo set the actual menu entries, use the [[Par Class|Par]] members: .menuNames and .menuLabels.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendFile",
                "call": "appendFile(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a file reference type [[Par Class|parameter]]. Has built-in functionality to open a new file picker window.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendFolder",
                "call": "appendFolder(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a folder reference type [[Par Class|parameter]]. Has built-in functionality to open a new folder picker window.\nReturns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendPulse",
                "call": "appendPulse(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a pulse button type [[Par Class|parameter]]. Returns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendMomentary",
                "call": "appendMomentary(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a momentary button type [[Par Class|parameter]]. Returns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendToggle",
                "call": "appendToggle(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a toggle button type [[Par Class|parameter]]. Returns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendPython",
                "call": "appendPython(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a python expression [[Par Class|parameter]]. Returns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendPar",
                "call": "appendPar(name, par=None, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Create a parameter with attributes copied from an existing parameter. Returns the created [[ParGroup Class|parameter group]] object.\n*name - The name of the parameter. Built-in names can be used as they will be automatically adjusted to match proper custom name casing (begin with uppercase letter followed by lowercase letters and numbers only).\n*par - (Keyword, Optional) The parameter to copy attributes from. If none specified, a default parameter created.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "appendHeader",
                "call": "appendHeader(name, label=None, order=None, replace=True)",
                "returns": "ParGroup",
                "text": "Returns the created [[ParGroup Class|parameter group]] object. Only the value will be shown, not its label.\n*name - The name of the parameter.\n*label - (Keyword, Optional) The displayed label of the parameter, default will use the name argument.\n*order - (Keyword, Optional) Specify the display order of the parameter, default is highest.\n*replace - (Keyword, Optional) By default, replaces parameter with fresh attributes. If False, it errors if the parameter already exists."
            },
            {
                "class": "Page",
                "name": "destroy",
                "call": "destroy()",
                "returns": "None",
                "text": "Destroy the page this object refers to, and all its parameters."
            },
            {
                "class": "Page",
                "name": "sort",
                "call": "sort(pargoup1, pargroup2, pargroup3..)",
                "returns": "None",
                "text": "Reorder custom parameter groups or parameters in specified order.\n<syntaxhighlight lang=\"python\">\nn = op('base1')\npage = n.appendCustomPage('Custom1')\npage.sort('Speed','Color','Value')\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Page Class describes the list of custom [[Par Class|parameters]] contained on a page. Pages are created on components via the COMP Class. See also the guide [[Custom Parameters]].\n\nMethods that create parameters return a list of [[Par Class|parameters]] that were created.\n\nTo view individual attributes of each parameter such as default, min, max, etc, see the [[Par Class]] documentation.\n\nPages can be accessed like a Python list of parameters:\n<syntaxhighlight lang=python>\npage = op('button1').pages[0]\t# get the page object\nprint(len(page))\t\t\t\t# number of parameters on the page \ndebug(page[0])\t\t\t\t\t# first parameter on the page\nfor p in pages:\n\tdebug(m.description)\t\t# print all the parameters on the page\n</syntaxhighlight>"
    },
    "Pane": {
        "label": "Pane",
        "members": [
            {
                "class": "Pane",
                "name": "owner",
                "type": "COMP",
                "set": "1",
                "text": "Get or set the [[COMP Class|component]] this pane points to."
            },
            {
                "class": "Pane",
                "name": "id",
                "type": "int",
                "set": "0",
                "text": "A unique numeric identifier."
            },
            {
                "class": "Pane",
                "name": "link",
                "type": "int",
                "set": "1",
                "text": "Get or set the numeric link index."
            },
            {
                "class": "Pane",
                "name": "enable",
                "type": "bool",
                "set": "1",
                "text": "Get or set mouse and keyboard interactivity on the pane."
            },
            {
                "class": "Pane",
                "name": "maximize",
                "type": "bool",
                "set": "1",
                "text": "Enable or disable the pane maximize state."
            },
            {
                "class": "Pane",
                "name": "name",
                "type": "str",
                "set": "1",
                "text": "Get or set the pane name."
            },
            {
                "class": "Pane",
                "name": "ratio",
                "type": "float",
                "set": "1",
                "text": "Get or set the split proportion of the pane, if the pane was previously split."
            },
            {
                "class": "Pane",
                "name": "bottomLeft",
                "type": "tuple(x,y,u,v)",
                "set": "0",
                "text": "The coordinates of the bottom left corner, expressed in both pixels and uv offsets, in a named tuple."
            },
            {
                "class": "Pane",
                "name": "topRight",
                "type": "tuple(x,y,u,v)",
                "set": "0",
                "text": "The coordinates of the top right corner, expressed in both pixels and uv offsets, in a named tuple."
            },
            {
                "class": "Pane",
                "name": "type",
                "type": "PaneType",
                "set": "0",
                "text": "The enumerated type of the pane. Example: NetworkEditor.\nThe enumeration is called PaneType and consists of:\n*PaneType.NETWORKEDITOR\n*PaneType.PANEL\n*PaneType.GEOMETRYVIEWER\n*PaneType.TOPVIEWER\n*PaneType.CHOPVIEWER\n*PaneType.ANIMATIONEDITOR\n*PaneType.PARAMETERS\n*PaneType.TEXTPORT"
            }
        ],
        "methods": [
            {
                "class": "Pane",
                "name": "changeType",
                "call": "changeType(paneType)",
                "returns": "td.Pane",
                "text": "Change the pane to the specified type.  Will return a new Pane object that represents the Pane. After being called, the current Pane instance will no longer be valid.\n*paneType - The type of pane to change this pane to.\n<syntaxhighlight lang=python>\np = ui.panes[0]\np = p.changeType(PaneType.TOPVIEWER)  # note: must re-assign p to new object.\n</syntaxhighlight>"
            },
            {
                "class": "Pane",
                "name": "close",
                "call": "close()",
                "returns": "None",
                "text": "Close the pane."
            },
            {
                "class": "Pane",
                "name": "floatingCopy",
                "call": "floatingCopy()",
                "returns": "td.Pane",
                "text": "Return a floating copy of the pane."
            },
            {
                "class": "Pane",
                "name": "splitBottom",
                "call": "splitBottom()",
                "returns": "td.Pane",
                "text": "Split the bottom portion of the pane into a new pane."
            },
            {
                "class": "Pane",
                "name": "splitLeft",
                "call": "splitLeft()",
                "returns": "td.Pane",
                "text": "Split the left portion of the pane into a new pane."
            },
            {
                "class": "Pane",
                "name": "splitRight",
                "call": "splitRight()",
                "returns": "td.Pane",
                "text": "Split the right portion of the pane into a new pane."
            },
            {
                "class": "Pane",
                "name": "splitTop",
                "call": "splitTop()",
                "returns": "td.Pane",
                "text": "Split the top portion of the pane into a new pane."
            },
            {
                "class": "Pane",
                "name": "tearAway",
                "call": "tearAway()",
                "returns": "bool",
                "text": "Detach the pane into a floating window. Returns True if successful."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Pane class describes an instance of a [[Pane|pane]] interface.  It can be accessed through the [[Panes Class|ui.panes]] object. It is the parent class of the [[NetworkEditor Class]]."
    },
    "Panel": {
        "label": "Panel",
        "members": [
            {
                "class": "Panel",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs.\n\nIn addition to the above, this object contains a member for each panel value in the component.\n<syntaxhighlight lang=python>\na = op('button1').panel.u\n</syntaxhighlight>"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The Panel class manages Panel Components, and is used to access the state of a panel via its [[PanelValue Class|Panel Value Class]].\n\nFor a list of available panel values, see: [[Panel Value]]."
    },
    "panelCHOP": {
        "label": "panelCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "PanelCOMP": {
        "label": "PanelCOMP",
        "members": [
            {
                "class": "PanelCOMP",
                "name": "panel",
                "type": "td.Panel",
                "set": "0",
                "text": "The [[Panel Class|Panel]] from which [[Panel Value|Panel Values]] and the [[PanelValue Class]] may be accessed. (The second form is usually sufficient.)\n<syntaxhighlight lang=python>\nv = op('button1').panel.u.val\nv = op('button1').panel.u\n</syntaxhighlight>"
            },
            {
                "class": "PanelCOMP",
                "name": "panelRoot",
                "type": "OP",
                "set": "0",
                "text": "The panelCOMP at the top of the panel hierarchy."
            },
            {
                "class": "PanelCOMP",
                "name": "panelChildren",
                "type": "list",
                "set": "0",
                "text": "The children panelCOMPs of this operator."
            },
            {
                "class": "PanelCOMP",
                "name": "x",
                "type": "int",
                "set": "0",
                "text": "The panel's x coordinate, as measured in pixels."
            },
            {
                "class": "PanelCOMP",
                "name": "y",
                "type": "int",
                "set": "0",
                "text": "The panel's y coordinate, as measured in pixels."
            },
            {
                "class": "PanelCOMP",
                "name": "width",
                "type": "int",
                "set": "0",
                "text": "The panel's width, as measured in pixels."
            },
            {
                "class": "PanelCOMP",
                "name": "height",
                "type": "int",
                "set": "0",
                "text": "The panel's height, as measured in pixels."
            },
            {
                "class": "PanelCOMP",
                "name": "marginX",
                "type": "int",
                "set": "0",
                "text": "The panel's x coordinate adjusted by margins as measured in pixels."
            },
            {
                "class": "PanelCOMP",
                "name": "marginY",
                "type": "int",
                "set": "0",
                "text": "The panel's y coordinate adjusted by margins, as measured in pixels."
            },
            {
                "class": "PanelCOMP",
                "name": "marginWidth",
                "type": "int",
                "set": "0",
                "text": "The panel's width adjusted by margins, as measured in pixels."
            },
            {
                "class": "PanelCOMP",
                "name": "marginHeight",
                "type": "int",
                "set": "0",
                "text": "The panel's height adjusted by margins, as measured in pixels."
            }
        ],
        "methods": [
            {
                "class": "PanelCOMP",
                "name": "panelParent",
                "call": "panelParent(n)",
                "returns": "OP or None",
                "text": "The nth panel parent of this operator.  If n not specified, returns the panel parent. If n = 2, returns the parent of the parent, etc. If no panel parent exists at that level, None is returned.  A panel parent is the panel wired to the input of this operator, or if that does not exist, the panel containing this operator.\n*n - (Optional) n is the number of levels up to climb. When n = 1 it will return the operator's panel parent.\n<syntaxhighlight lang=python>\np = me.panelParent(2) #grandfather\n</syntaxhighlight>"
            },
            {
                "class": "PanelCOMP",
                "name": "interactMouse",
                "call": "interactMouse(u, v, leftClick=0, middleClick=0, rightClick=0, left=False, middle=False, right=False, wheel=0, pixels=False, Screen=False, quiet=True)",
                "returns": "PanelCOMP",
                "text": "Simulates virtual mouse clicks, rollovers, moves and drags on a panel. It will also update the panel values: inside, insideu, insidev, state, u and v, in panels all the way up to the parent panel. The first (primary) mouse down/touch on a panel takes precedence over subsequent mouse downs and touches, and overrides any hovers. The primary state on a panel is global as each panel can only have one interaction updating its state.\n*u - The first coordinate for the click to occur at.\n*v - The second coordinate for the click to occur at.\n*leftClick, middleClick, rightClick -  (Keyword, Optional) Use to specify the number of times a button is clicked on\n*left, middle, right -  (Keyword, Optional) Use to specify if the button is being pressed.  When set to False it simulates a mouse move with the button up.  The first time the button is set to True will initiate a virtual mouse down on the child panel at the coordinates u,v.  Subsequent True states will simulate a drag (mouse button down and moving).  Simulate a mouse-up by calling the button set to False, e.g. left=False.\n*wheel -  (Keyword, Optional) Roll the mouse wheel\n*pixels - (Keyword, Optional) When True, the coordinates are treated as pixel offsets.  When False, they are treated as normalized values.\n*screen - (Keyword, Optional) When True, the coordinates are relative to the screen. When False, they are relative to the calling container.\n*quiet - (Keyword, Optional) When False, print warning messages, such as starting a mouse-down-move on a panel that is already being moved (dragged).\n*aux - (Keyword, Optional) Auxiliary data.\n<syntaxhighlight lang=python>\nop('container1').interactMouse(0.5, 0.5) # roll over the middle of container1\nop('container1').interactMouse(0.5, 0.5, leftClick=2) # double click the middle of container1\nop('container1').interactMouse(0.5, 0.5, left=True) # left mouse down on the middle of container1\nop('container1').interactMouse(0.6, 0.6, left=True) # move with left mouse down in container1\nop('container1').interactMouse(0.6, 0.6) # mouse up\nop('container1').interactMouse(0.5, 0.5, wheel=0.3) # roll the mouse wheel in the middle of container1\nop('container1').interactMouse(10, 20, pixels=True) # send a mouse event 10 pixels to the right, and 20 pixels above the lower left corner of container1\n</syntaxhighlight>"
            },
            {
                "class": "PanelCOMP",
                "name": "interactTouch",
                "call": "interactTouch(u, v, hover='id', start='id', move='id', end='id', pixels=False, screen=False, quiet=True, aux='data')",
                "returns": "PanelCOMP",
                "text": "Simulates virtual multiple touches and hovers on a panel via user assigned id. It will also update the panel values: inside, insideu, insidev, state, u and v, in panels all the way up to the parent panel. The first (primary) mouse down/touch on a panel takes precedence over subsequent mouse downs and touches, and overrides any hovers. The primary state on a panel is global.\n*u - The first coordinate for the click to occur at.\n*v - The second coordinate for the click to occur at.\n*hover - (Keyword, Optional) Indicates a hover performed by the touch identifiable by 'id'.  If 'id' is used by a touch, the touch is ended.  If the <u,v> is out of bounds, the hover will end.\n*start - (Keyword, Optional) Start a touch identifiable by 'id'.  If 'id' is already touching or hovering, the action is ended and a new touch is started.\n*move - (Keyword, Optional) Move a touch identifiable by 'id'.  Nothing happens if 'id' is not found.\n*end - (Keyword, Optional) End a touch identifiable by 'id'.  Nothing happens if 'id' is not found.\n*pixels - (Keyword, Optional) When True, the coordinates are treated as pixel offsets.  When False, they are treated as normalized values.\n*screen - (Keyword, Optional) When True, the coordinates are relative to the screen. When False, they are relative to the calling container.\n*quiet - (Keyword, Optional) Print warning messages, such as starting a touch down on a panel that already has a touch.\n<syntaxhighlight lang=python>\nop('container1').interactTouch(0.5, 0.5, hover='finger') # roll over the middle of container1\nop('container1').interactTouch(0.5, 0.5, start='finger') # ends the hover and start a touch\nop('container1').interactTouch(0.7, 0.5, move='finger') # move the touch\nop('container1').interactTouch(0.3, 0.4, start='finger') # ends the previous touch and start a new touch\nop('container1').interactTouch(-1, -1, hover='finger') # ends the previous touch, and end any rollover state\n</syntaxhighlight>"
            },
            {
                "class": "PanelCOMP",
                "name": "interactClear",
                "call": "interactClear()",
                "returns": "None",
                "text": "Terminates any existing interactions. Touch or mouse interactions will end. Panels that are hovered over will end their rollover state."
            },
            {
                "class": "PanelCOMP",
                "name": "interactStatus",
                "call": "interactStatus()",
                "returns": "list",
                "text": "Returns a list of panel interactions.  Each interaction is encapsulated in a list as follows: [id, panel, state, primary].\n*id - The unique string identifying the interaction.  '__MOUSE__' is used if the interaction was established via interactMouse.\n*panel - The child panel being interacted with .\n*state - Interaction types 'hover' or 'touch'.\n*primary - True if the interaction is the first to act on the panel.\n<syntaxhighlight lang=python>\nop('container1').interactStatus  # list the current hover over a slider and 2 touches over a button in container1\n[['touch1', type:sliderCOMP path:/project1/container1/slider1, 'hover', False],\n['__MOUSE__', type:buttonCOMP path:/project1/container1/button1, 'touch', True],\n['touch2', type:buttonCOMP path:/project1/container1/button1, 'touch', False]]\n</syntaxhighlight>"
            },
            {
                "class": "PanelCOMP",
                "name": "locateMouse",
                "call": "locateMouse()",
                "returns": "tuplet(x,y)",
                "text": "Returns a tuplet containing the mouse coordinates relative to the [[Panel Component]]. If the mouse is not over a window containing the panel, None is returned instead."
            },
            {
                "class": "PanelCOMP",
                "name": "locateMouseUV",
                "call": "locateMouseUV()",
                "returns": "tuplet(u,v)",
                "text": "Returns a tuplet containing the normalized mouse coordinates relative to the [[Panel Component]]. If the mouse is not over a window containing the panel, None is returned instead."
            },
            {
                "class": "PanelCOMP",
                "name": "setFocus",
                "call": "setFocus(moveMouse=False)",
                "returns": "None",
                "text": "Set the hierarchical focus to this component, which sets the Panel value focusselect to 1. Focus will only be set successfully if the panel is open.\n*moveMouse - (Keyword, Optional) If set to True, the mouse will be moved to the component as well."
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "COMP"
        ],
        "summary": "The PanelCOMP describes an instance of a [[Panel Component]]. The state is represented by [[Panel Value|Panel Values]].\nThis class inherits from the COMP Class."
    },
    "panelexecuteDAT": {
        "label": "panelexecuteDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "PanelValue": {
        "label": "PanelValue",
        "members": [
            {
                "class": "PanelValue",
                "name": "name",
                "type": "str",
                "set": "0",
                "text": "The name of the panel value. See [[Panel Value]] for the list of possible names. name is a string."
            },
            {
                "class": "PanelValue",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "PanelValue",
                "name": "val",
                "type": "value",
                "set": "1",
                "text": "Get or set the panel value."
            },
            {
                "class": "PanelValue",
                "name": "valid",
                "type": "bool",
                "set": "0",
                "text": "True if the referenced panel value currently exists, False if it has been deleted."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "A PanelValue describes an instance to a [[Panel Value]].  They can be accessed through a component's [[Panel|panel]] member, and are used in the [[Panel Execute DAT]].\n\nFor a list of available panel values, see: [[Panel Value]]."
    },
    "Panes": {
        "label": "Panes",
        "members": [
            {
                "class": "Panes",
                "name": "current",
                "type": "td.Pane",
                "set": "0",
                "text": "The currently selected [[Pane Class|pane]]."
            }
        ],
        "methods": [
            {
                "class": "Panes",
                "name": "createFloating",
                "call": "createFloating(type=PaneType.NETWORKEDITOR, name=None, maxWidth=1920, maxHeight=1080, monitorSpanWidth=0.9, monitorSpanHeight=0.9)",
                "returns": "td.Pane",
                "text": "Return a floating pane.\n*type - (Keyword, Optional) Type of pane created. See [[Pane Class|Pane]] for examples.\n*name - (Keyword, Optional) Name of the pane.  This value can be used to find the pane in ui.panes.\n*maxWidth - (Keyword, Optional) Upper limit on the width of the created window. Specified in pixels.\n*maxHeight - (Keyword, Optional) Upper limit on the height of the created window. Specified in pixels.\n*monitorSpanWidth - (Keyword, Optional) Specifies window width as a portion of the monitor width.\n*monitorSpanHeight - (Keyword, Optional) Specifies window height as a portion of the monitor height.\nExample\n<syntaxhighlight lang=python>\n    p = ui.panes.createFloating(type=PaneType.NETWORKEDITOR, name=\"Output\")\n    p.owner = op('/project1/base1')\n</syntaxhighlight>"
            },
            {
                "class": "Panes",
                "name": "len",
                "call": "len(Panes)",
                "returns": "int",
                "text": "Returns the total number of panes.\n<syntaxhighlight lang=python>\na = len(ui.panes)\n</syntaxhighlight>"
            },
            {
                "class": "Panes",
                "name": "[]",
                "call": "[index]",
                "returns": "td.Pane",
                "text": "Get specific pane, referenced by string or index.\n<syntaxhighlight lang=python>\np = ui.panes[0]\np = ui.panes['pane1']\n</syntaxhighlight>"
            },
            {
                "class": "Panes",
                "name": "iterator",
                "call": "Iterator",
                "returns": "td.Pane",
                "text": "Iterate over each pane.\n<syntaxhighlight lang=python>\nfor n in ui.panes:\n\t# do something with n\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Panes class describes the list of all [[Pane Class|pane objects]].  It can be accessed from [[UI Class|ui.panes]]."
    },
    "Par": {
        "label": "Par",
        "members": [
            {
                "class": "Par",
                "name": "valid",
                "type": "bool",
                "set": "0",
                "text": "True if the referenced parameter currently exists, False if it has been deleted."
            },
            {
                "class": "Par",
                "name": "val",
                "type": "value",
                "set": "1",
                "text": "Get or set the constant value of the parameter only. To get the parameter's current value, regardless of the [[Parameter Mode]] (constant, expression, export or bound), use the <syntaxhighlight lang=python inline>eval()</syntaxhighlight> method described below.\n<syntaxhighlight lang=python>\nop('geo1').par.tx.val   # the constant value \nop('geo1').par.tx.eval()   # the evaluated parameter\nop('geo1').par.tx.val = 5\nop('geo1').par.tx = 5  # equivalent to above, more concise form\nop('parexec1').par.op = [parent(), parent(2)] # you can assign a list of ops to a parameter that allows multiple operators\n</syntaxhighlight>\nWhen setting this member, the parameter will also be placed in constant mode.  See mode member below.\nTo set a menu value by its index, use the <code>menuIndex</code> member as described below."
            },
            {
                "class": "Par",
                "name": "expr",
                "type": "str",
                "set": "1",
                "text": "Get or set the non-evaluated expression only. To get the parameter's current value, regardless of the [[Parameter Mode]] (constant, expression, export or bound), use the <syntaxhighlight lang=python inline>eval()</syntaxhighlight> method described below.\n<syntaxhighlight lang=python>\nop('geo1').par.tx.expr = 'absTime.frame'  #set to match current frame\n</syntaxhighlight>\nWhen setting this member, the parameter will also be placed in expression mode. See mode member below.\n'''NOTE:''' For convenience, the expression is placed in double-quotes so you can safely put in expressions containing single quotes. 'a' and \"a\" have the same effect of enclosing strings in python."
            },
            {
                "class": "Par",
                "name": "enableExpr",
                "type": "str",
                "set": "1",
                "text": "Get or set an expression that controls the enable state for this parameter.\n<syntaxhighlight lang=python>\np.enableExpr = \"me.par.X.menuIndex == 5\"\n# Note the outside quotes, as this is an expression, not an object.\n</syntaxhighlight>"
            },
            {
                "class": "Par",
                "name": "exportOP",
                "type": "OP or None",
                "set": "0",
                "text": "The [[OP Class|operator]] exporting to this parameter."
            },
            {
                "class": "Par",
                "name": "exportSource",
                "type": "Cell Channel or None",
                "set": "0",
                "text": "The object exporting to this parameter. Examples: [[Cell Class|Cell]], [[Channel Class|Channel]] or None."
            },
            {
                "class": "Par",
                "name": "bindExpr",
                "type": "expression",
                "set": "1",
                "text": "Get or set an expression that returns a Parameter object. This can be used to bind this parameter's constant value to the referenced parameter.\n<syntaxhighlight lang=python>p.bindExpr = \"op('geo1').par.tx\"</syntaxhighlight>  \nNote the outside quotes, as bindExpr is an expression, not an object."
            },
            {
                "class": "Par",
                "name": "bindMaster",
                "type": "OP or None",
                "set": "0",
                "text": "The object to which this parameter is bound to, possibly None."
            },
            {
                "class": "Par",
                "name": "bindReferences",
                "type": "list",
                "set": "0",
                "text": "The (possibly empty) list of objects which bind to this parameter."
            },
            {
                "class": "Par",
                "name": "bindRange",
                "type": "bool",
                "set": "1",
                "text": "Get or set parameter's range binding state. If True, min, max, clampMin, clampMax, normMin, normMax, normVal values will be based on master bind parameter. Can only be set on Custom Parameters."
            },
            {
                "class": "Par",
                "name": "hidden",
                "type": "bool",
                "set": "0",
                "text": "Get the parameter's hidden status. When True the parameter is considered obsolete or irrelevant and should not be modified. They are not shown in the dialog but only maintained for backward compatibility."
            },
            {
                "class": "Par",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "A unique identifier for the parameter.  May change in the case of custom parameters."
            },
            {
                "class": "Par",
                "name": "vecIndex",
                "type": "int",
                "set": "0",
                "text": "The parameter's vector index. For example, <syntaxhighlight lang=python inline>op('geo1').par.tz</syntaxhighlight> would have a value of 2."
            },
            {
                "class": "Par",
                "name": "name",
                "type": "str",
                "set": "1",
                "text": "Get or set the parameter's unique name.\n<syntaxhighlight lang=python>\nop('myOperator').par.Custompar.name = 'Translate' \n</syntaxhighlight>\nCan only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "label",
                "type": "str",
                "set": "1",
                "text": "Get or set the parameter's label.\n<syntaxhighlight lang=python>\nop('myOperator').par.Custompar.label = 'Translate' \n</syntaxhighlight>\nCan only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "subLabel",
                "type": "str",
                "set": "0",
                "text": "Returns the name of the sub-label."
            },
            {
                "class": "Par",
                "name": "startSection",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's separator status. When <code>True</code> a visible separator is drawn between this parameter and the ones preceding it. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "displayOnly",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's displayOnly state. Can only be set on Custom Parameters."
            },
            {
                "class": "Par",
                "name": "readOnly",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's read only status. When <code>True</code> the parameter cannot be modified through the UI, only scripting."
            },
            {
                "class": "Par",
                "name": "help",
                "type": "str",
                "set": "1",
                "text": "Get or set a custom parameter's help text. To see any parameter's help, rollover the parameter while holding the Alt key. For built-in parameters this can be used to get the parameter's help text."
            },
            {
                "class": "Par",
                "name": "tuplet",
                "type": "tuplet",
                "deprecated ": "True",
                "set": "0",
                "text": "The tuplet of parameters this parameter belongs to. A tuplet is typically a set of parameters sharing one line on a parameter dialog, example: Translate (x, y, z)."
            },
            {
                "class": "Par",
                "name": "tupletName",
                "deprecated ": "True",
                "type": "str",
                "set": "1",
                "text": "The tuplet name of a parameter.  Example: The tuplet name of a (tx,ty,tz) translate parameter is t."
            },
            {
                "class": "Par",
                "name": "parGroup",
                "type": "tuplet",
                "deprecated ": "False",
                "set": "0",
                "text": "The [[ParGroup]] of parameters this parameter belongs to. A ParGroup is a set of parameters sharing one line on a parameter dialog with a common label, example: Translate (x, y, z).."
            },
            {
                "class": "Par",
                "name": "min",
                "type": "value",
                "set": "1",
                "text": "Get or set the parameter's numerical minimum value. The parameter's value will be clamped at that minimum if clampMin = True. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "max",
                "type": "value",
                "set": "1",
                "text": "Get or set the parameter's numerical maximum value. The parameter's value will be clamped at that maximum if clampMax = True. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "clampMin",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's numerical clamping behavior. If set to clampMin = True, the parameter will clamp on the lower end at the value specified in min Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "clampMax",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's numerical clamping behavior. If set to clampMax = True, the parameter will clamp on the upper end at the value specified in max Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "default",
                "type": "value",
                "set": "1",
                "text": "Get or set the parameter's default value. Can only be set on [[Custom Parameters]].  Only one of default, defaultExpr can be set."
            },
            {
                "class": "Par",
                "name": "defaultExpr",
                "type": "str",
                "set": "1",
                "text": "Get or set the parameter's default expression. Can only be set on [[Custom Parameters]].  Only one of default, defaultExpr can be set.\n<syntaxhighlight lang=python>\n# value defaults to this expression.\nop('base1').par.Size.defaultExpr = 'me.time.frame'\n</syntaxhighlight>"
            },
            {
                "class": "Par",
                "name": "normMin",
                "type": "float",
                "set": "1",
                "text": "Get or set the parameter's minimum slider value if the parameter is a numerical slider. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "normMax",
                "type": "float",
                "set": "1",
                "text": "Get or set the parameter's maximum slider value if the parameter is a numerical slider. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "normVal",
                "type": "float",
                "set": "1",
                "text": "Get or set the parameter's value as a normalized slider position. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "enable",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's enable state. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "order",
                "type": "int",
                "set": "1",
                "text": "Get or set the parameter's position on the parameter page.  Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "page",
                "type": "td.Page",
                "set": "1",
                "text": "Get or set the parameter page the custom parameter is part of. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "password",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's password mode. When True all text is rendered as asterisks. Can only be set on Custom string, int or float parameters. [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "mode",
                "type": "ParMode",
                "set": "1",
                "text": "Get or set the parameter's evaluation mode.\n<syntaxhighlight lang=python>\nop('geo1').par.tx.mode = ParMode.EXPRESSION\n</syntaxhighlight>\nThe mode is one of:  <code>ParMode.CONSTANT</code>, <code>ParMode.EXPRESSION</code>, or <code>ParMode.EXPORT</code>, or <code>ParMode.BIND</code>.\nSee [[Parameter_Dialog#Working_with_Parameter_Modes]] for more information."
            },
            {
                "class": "Par",
                "name": "prevMode",
                "type": "ParMode",
                "set": "0",
                "text": "The parameter's previous evaluation mode."
            },
            {
                "class": "Par",
                "name": "menuNames",
                "type": "list",
                "set": "1",
                "text": "Get or set a list of all possible menu choice names. In the case of non menu parameters, None is returned. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "menuLabels",
                "type": "list",
                "set": "1",
                "text": "Get or set a list of all possible menu choice labels. In the case of non menu parameters, None is returned. Can only be set on [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "menuIndex",
                "type": "int",
                "set": "1",
                "text": "Get or set a menu constant value by its index."
            },
            {
                "class": "Par",
                "name": "menuSource",
                "type": "str",
                "set": "1",
                "text": "Get or set an expression that returns an object with .menuItems .menuNames members.  This can be used to create a custom menu whose entries dynamically follow that of another menu for example. Simple menu sources include another parameter with a menu c, an object created by [[Tdu Module|tdu.TableMenu]], or an object created by [[TDFunctions|TDFunctions.parMenu]].\n<syntaxhighlight lang=python>\np.menuSource = \"op('audiodevin1').par.device\"\n</syntaxhighlight>\nNote the outside quotes, as menuSource is an expression, not an object."
            },
            {
                "class": "Par",
                "name": "collapser",
                "type": "bool",
                "set": "0",
                "text": "Returns True if the parameter is a parent of collapsable parameters (ie. a collapser)."
            },
            {
                "class": "Par",
                "name": "collapsable",
                "type": "bool",
                "set": "0",
                "text": "Returns True if the parameter is collapsable."
            },
            {
                "class": "Par",
                "name": "sequence",
                "type": "set",
                "set": "0",
                "text": "The set of [[Sequence Class|sequential]] parameter blocks this parameter belongs to, or None."
            },
            {
                "class": "Par",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Par",
                "name": "styleCloneImmune",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's style clone immunity. When <code>False</code>, the parameter definition is matched to any matching master parameter its operator is cloned to. When <code>True</code>, it is left unchanged."
            },
            {
                "class": "Par",
                "name": "lastScriptChange",
                "type": "tuple",
                "set": "0",
                "text": "Return information about when this parameter was last modified by a script. Cleared when the parameter is updated via the UI.\n<syntaxhighlight lang=python>\npython >>> op('/level1').par.invert.lastScriptChange\nSetInfo(dat=type:textDAT path:/text1, function='<module>', line=1, frame=300061, timeStamp=1613150878)\n</syntaxhighlight>"
            },
            {
                "class": "Par",
                "name": "isDefault",
                "type": "bool",
                "set": "0",
                "text": "True when the parameter value, expression and mode are in their default settings."
            },
            {
                "class": "Par",
                "name": "isCustom",
                "type": "bool",
                "set": "0",
                "text": "True for [[Custom Parameters]]."
            },
            {
                "class": "Par",
                "name": "isPulse",
                "type": "bool",
                "set": "0",
                "text": "True for pulse parameters."
            },
            {
                "class": "Par",
                "name": "isMomentary",
                "type": "bool",
                "set": "0",
                "text": "True for momentary parameters."
            },
            {
                "class": "Par",
                "name": "isMenu",
                "type": "bool",
                "set": "0",
                "text": "True for menu parameters."
            },
            {
                "class": "Par",
                "name": "isNumber",
                "type": "bool",
                "set": "0",
                "text": "True for numeric parameters."
            },
            {
                "class": "Par",
                "name": "isFloat",
                "type": "bool",
                "set": "0",
                "text": "True for floating point numeric parameters."
            },
            {
                "class": "Par",
                "name": "isInt",
                "type": "bool",
                "set": "0",
                "text": "True for integer numeric parameters."
            },
            {
                "class": "Par",
                "name": "isOP",
                "type": "bool",
                "set": "0",
                "text": "True for OP parameters."
            },
            {
                "class": "Par",
                "name": "isPython",
                "type": "bool",
                "set": "0",
                "text": "True for python parameters."
            },
            {
                "class": "Par",
                "name": "isString",
                "type": "bool",
                "set": "0",
                "text": "True for string parameters."
            },
            {
                "class": "Par",
                "name": "isToggle",
                "type": "bool",
                "set": "0",
                "text": "True for toggle parameters."
            },
            {
                "class": "Par",
                "name": "style",
                "type": "str",
                "set": "0",
                "text": "Describes the behavior and contents of the custom parameter. Example <code>'Float'</code>, <code>'Int'</code>, <code>'Pulse'</code>, <code>'XYZ'</code>, etc."
            }
        ],
        "methods": [
            {
                "class": "Par",
                "name": "copy",
                "call": "copy(Par)",
                "returns": "None",
                "text": "Copy the specified [[Par Class|parameter]].\n*Par - The parameter to copy.\n<syntaxhighlight lang=python>\nop('geo1').par.tx.copy( op('geo2').par.tx )\n</syntaxhighlight>"
            },
            {
                "class": "Par",
                "name": "eval",
                "call": "eval()",
                "returns": "value",
                "text": "Evaluate a parameter. This value may be derived by the parameter's constant value, expression, or export, dependent on its mode.\n<syntaxhighlight lang=python>\na = op('geo1').par.tx.eval()\n</syntaxhighlight>\n\nCalling <code>eval</code> on an OP parameter that can hold multiple OPs will return a single OP if there is only 1 result, a list of OPs if there are more than 1, and None if there are no results."
            },
            {
                "class": "Par",
                "name": "evalNorm",
                "call": "evalNorm()",
                "returns": "value",
                "text": "Similar to eval() but the returns the normalized slider value."
            },
            {
                "class": "Par",
                "name": "evalExpression",
                "call": "evalExpression()",
                "returns": "value",
                "text": "Evaluate the expression portion of a parameter, if it contains one. This will ignore any exports, etc.\n<syntaxhighlight lang=python>\na = op('geo1').par.tx.evalExpression()\n</syntaxhighlight>\n'''Note''': the results of evalExpression is always the expression's Python return value, which can be slightly different than <code>Par.eval()</code>. For example, in parameters that hold an operator, <code>.eval()</code> will always return an operator if it exists, even if the expression actually returns a string path. The evalExpression function would return the string path.\n\nTo evaluate an arbitrary expression string, that is not inside a parameter, see [[OP Class|OP]].evalExpression."
            },
            {
                "class": "Par",
                "name": "evalExport",
                "call": "evalExport()",
                "returns": "value",
                "text": "Evaluate the export portion of a parameter, if it contains one. This will ignore any expressions, etc.\n<syntaxhighlight lang=python>\na = op('geo1').par.tx.evalExport()\n</syntaxhighlight>"
            },
            {
                "class": "Par",
                "name": "evalOPs",
                "call": "evalOPs()",
                "returns": "list",
                "text": "Evaluate the parameter as series of operators. This is useful for a custom  parameter that specifies a list of operator paths for example.\n<syntaxhighlight lang=python>\na = op('base1').par.Paths.evalOPs()\n</syntaxhighlight>"
            },
            {
                "class": "Par",
                "name": "pulse",
                "call": "pulse(value, frames=nframes, seconds=nseconds)",
                "returns": "None",
                "text": "Pulsing sets a parameter to the specific value, cooks the operator, then restores the parameter to its previous value.\nFor pulse type parameters no value is specified or used.\n*value - (Optional) The value to pulse this parameter with, default is 1.\n*frames - (Optional) Number of frames before restoring the parameter to its original value.\n*seconds - (Optional) Number of seconds before restoring the parameter to its original value.\n<syntaxhighlight lang=python>\nop('moviein1').par.reload.pulse(1) #set the reload toggle, then cook\nop('glsl1').par.loadvariablenames.pulse() #activate the pulse parameter\nop('geo1').par.ty.pulse(2, frames=120) #pulse geometry ty for 120 frames\nop('text1').par.text.pulse('GO!', seconds=3) #pulse text TOP string field, for 3 seconds\nop('noise').par.type.pulse('random', seconds=0.5) #pulse noise meny type for half a second\n</syntaxhighlight>"
            },
            {
                "class": "Par",
                "name": "destroy",
                "call": "destroy()",
                "returns": "None",
                "text": "Destroy the parameter referenced by this Par. An exception will be raised if the parameter has already been destroyed. Only custom and sequential parameters can be destroyed.  Destroying a sequential parameter will destroy its entire block. Note: When any parameter is destroyed, any existing parameter objects will be invalid and should be re-fetched."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Par class describes an instance of a single [[Parameter]]. See also [[Custom Parameters]]."
    },
    "parameterCHOP": {
        "label": "parameterCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "parameterCOMP": {
        "label": "parameterCOMP",
        "members": [
            {
                "class": "parameterCOMP",
                "name": "minWidth",
                "type": "int",
                "set": "0",
                "text": "The minimum width the parameter dialog can be drawn at before scaling is required."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "PanelCOMP",
            "COMP"
        ]
    },
    "parameterexecuteDAT": {
        "label": "parameterexecuteDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "ParCollection": {
        "label": "ParCollection",
        "members": [
            {
                "class": "ParCollection",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            }
        ],
        "methods": [
            {
                "class": "ParCollection",
                "name": "[]",
                "call": "[name]",
                "returns": "Par",
                "text": "[[Par Class|Parameters]] may be easily accessed using the [] subscript and assignment operators.\n*name - Must be an exact string name. Wildcards are not supported. If not found None is returned.\n<syntaxhighlight lang=python>\np = op('base1').par['Myfloat5']\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The ParCollection class can be used to access [[Par Class|Parameters]]. To access a parameter you need to use its internal name, which you can obtain by hovering your mouse over the parameter name, and looking at the popup that will come up. See also [[Par Class]]. An operator's instance of this can be found in <code>OP.par</code>."
    },
    "ParGroup": {
        "label": "ParGroup",
        "members": [
            {
                "class": "ParGroup",
                "name": "bindExpr",
                "type": "tuple",
                "set": "1",
                "text": "Get or set expressions that return a Parameter object. This can be used to bind this parameter's constant values to the referenced parameters.\n\nExample:\n<syntaxhighlight lang=python>p.bindExpr = (\"op('geo1').par.tx\", \"op('geo1').par.ty\", \"op('geo1').par.tz\")</syntaxhighlight>  \n        Note the outside quotes, as bindExpr is an expression, not an object."
            },
            {
                "class": "ParGroup",
                "name": "bindMaster",
                "type": "tuple",
                "set": "0",
                "text": "The objects to which this parameter is bound to, possibly None."
            },
            {
                "class": "ParGroup",
                "name": "bindRange",
                "type": "bool",
                "set": "1",
                "text": "Get or set parameter's range binding state. If True, min, max, clampMin, clampMax, normMin, normMax, normVal values will be based on master bind parameter. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "bindReferences",
                "type": "tuple",
                "set": "0",
                "text": "The (possibly empty) lists of objects which bind to this parameter."
            },
            {
                "class": "ParGroup",
                "name": "clampMax",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's numerical clamping behaviors. If set to <syntaxhighlight lang=python inline=true>clampMax = True</syntaxhighlight>, the parameter will clamp on the upper end at the value specified in max Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "clampMin",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's numerical clamping behaviors. If set to <syntaxhighlight lang=python inline=true>clampMin = True</syntaxhighlight>, the parameter will clamp on the lower end at the value specified in min Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "collapsable",
                "type": "bool",
                "set": "0",
                "text": "Returns True if the parameter is collapsable."
            },
            {
                "class": "ParGroup",
                "name": "collapser",
                "type": "bool",
                "set": "0",
                "text": "Returns True if the parameter is a parent of collapsable parameters (ie. a collapser)."
            },
            {
                "class": "ParGroup",
                "name": "default",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's default values. Can only be set on Custom Parameters. Only one of default, defaultExpr can be set."
            },
            {
                "class": "ParGroup",
                "name": "defaultExpr",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's default expressions. Can only be set on Custom Parameters. Only one of default, defaultExpr can be set.\n<syntaxhighlight lang=python>\n# value defaults to this expression.\nop('base1').parGroup.Size.defaultExpr = ('me.time.frame', 'me.time.frame', 'me.time.frame')\n</syntaxhighlight>"
            },
            {
                "class": "ParGroup",
                "name": "enable",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's enable state. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "enableExpr",
                "type": "string",
                "set": "1",
                "text": "Get or set an expression that controls the enable state for this parameter group.\n<syntaxhighlight lang=python>\np.enableExpr = \"me.par.X.menuIndex == 5\"\n</syntaxhighlight>\nNote the outside quotes, as this is an expression, not an object."
            },
            {
                "class": "ParGroup",
                "name": "exportOP",
                "type": "tuple",
                "set": "0",
                "text": "The operators exporting to this parameter."
            },
            {
                "class": "ParGroup",
                "name": "exportSource",
                "type": "tuple of cell, channel or None",
                "set": "0",
                "text": "The objects exporting to this parameter. Examples: Cell, Channel or None."
            },
            {
                "class": "ParGroup",
                "name": "expr",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the non-evaluated expressions only. To get the parameter's current values, regardless of the Parameter Mode (constant, expression, export or bound), use the eval() method described below.\n<syntaxhighlight lang=python>\nop('geo1').parGroup.t.expr = ('absTime.frame', 'absTime.frame', 'absTime.frame')  \n# set to match current frame\n</syntaxhighlight>\nWhen setting this member, the parameter will also be placed in expression mode. See mode member below.\n'''NOTE:''' For convenience, the expression is placed in double-quotes so you can safely put in expressions containing single quotes. 'a' and \"a\" have the same effect of enclosing strings in python."
            },
            {
                "class": "ParGroup",
                "name": "help",
                "type": "string",
                "set": "1",
                "text": "Get or set a custom parameter's help text. To see any parameter's help, rollover the parameter while holding the Alt key."
            },
            {
                "class": "ParGroup",
                "name": "isDefault",
                "type": "bool",
                "set": "0",
                "text": "True when the parameter value, expression and mode are in their default settings."
            },
            {
                "class": "ParGroup",
                "name": "isCustom",
                "type": "bool",
                "set": "0",
                "text": "True for Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "isFloat",
                "type": "bool",
                "set": "0",
                "text": "True for floating point numeric parameters."
            },
            {
                "class": "ParGroup",
                "name": "isInt",
                "type": "bool",
                "set": "0",
                "text": "True for integer numeric parameters."
            },
            {
                "class": "ParGroup",
                "name": "isMenu",
                "type": "bool",
                "set": "0",
                "text": "True for menu parameters."
            },
            {
                "class": "ParGroup",
                "name": "isMomentary",
                "type": "bool",
                "set": "0",
                "text": "True for momentary parameters."
            },
            {
                "class": "ParGroup",
                "name": "isNumber",
                "type": "bool",
                "set": "0",
                "text": "True for numeric parameters."
            },
            {
                "class": "ParGroup",
                "name": "isOP",
                "type": "bool",
                "set": "0",
                "text": "True for OP parameters."
            },
            {
                "class": "ParGroup",
                "name": "isPulse",
                "type": "bool",
                "set": "0",
                "text": "True for pulse parameters."
            },
            {
                "class": "ParGroup",
                "name": "isPython",
                "type": "bool",
                "set": "0",
                "text": "True for python parameters."
            },
            {
                "class": "ParGroup",
                "name": "isString",
                "type": "bool",
                "set": "0",
                "text": "True for string parameters."
            },
            {
                "class": "ParGroup",
                "name": "isToggle",
                "type": "bool",
                "set": "0",
                "text": "True for toggle parameters."
            },
            {
                "class": "ParGroup",
                "name": "label",
                "type": "string",
                "set": "1",
                "text": "Get or set the parameter's label.\n<syntaxhighlight lang=python>\nop('myOperator').parGroup.Custompar.label = 'Translate'\n</syntaxhighlight> \nCan only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "max",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's numerical maximum values. The parameter's values will be clamped at that maximum if <syntaxhighlight lang=python inline=true>clampMax = True</syntaxhighlight>. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "menuIndex",
                "type": "tuple",
                "set": "1",
                "text": "Get or set a tuple of menu constant values by their indices."
            },
            {
                "class": "ParGroup",
                "name": "menuLabels",
                "type": "tuple",
                "set": "1",
                "text": "Get or set a tuple of lists of all possible menu choice labels. In the case of non menu parameters, None(s) are returned. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "menuNames",
                "type": "tuple",
                "set": "1",
                "text": "Get or set a tuple of lists of all possible menu choice names. In the case of non menu parameters, None(s) are returned. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "menuSource",
                "type": "tuple",
                "set": "1",
                "text": "Get or set a tuple of expressions that returns objects with <code>.menuItems</code> <code>.menuNames</code> members.  This can be used to create a custom menu whose entries dynamically follow that of another menu for example."
            },
            {
                "class": "ParGroup",
                "name": "min",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's numerical minimum values. The parameter's values will be clamped at that minimum if <syntaxhighlight lang=python inline=true>clampMin = True</syntaxhighlight> for the particular Par. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "mode",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's evaluation modes.\n<syntaxhighlight lang=python>\nop('geo1').parGroup.t.mode = (ParMode.EXPRESSION, ParMode.EXPRESSION, ParMode.EXPRESSION)\n</syntaxhighlight>\nThe modes are one of:  <code>ParMode.CONSTANT</code>, <code>ParMode.EXPRESSION</code>, or <code>ParMode.EXPORT</code>, or <code>ParMode.BIND</code>.\nSee [[Parameter_Dialog#Working_with_Parameter_Modes]] for more information."
            },
            {
                "class": "ParGroup",
                "name": "name",
                "type": "string",
                "set": "1",
                "text": "Get or set the parameter's unique name.\n<syntaxhighlight lang=python\n>op('myOperator').parGroup.Custompar.name = 'Translate'\n</syntaxhighlight> \nCan only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "normMax",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's maximum slider values if the parameter is a numerical slider. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "normMin",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's minimum slider values if the parameter is a numerical slider. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "normVal",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the parameter's values as a normalized slider position. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "order",
                "type": "int",
                "set": "1",
                "text": "Get or set the parameter's position on the parameter page.  Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The OP to which this object belongs."
            },
            {
                "class": "ParGroup",
                "name": "page",
                "type": "Page",
                "set": "1",
                "text": "Get or set the parameter page the custom parameter is part of. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "password",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's password mode. When True all text is rendered as asterisks. Can only be set on Custom string, int or float parameters. Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "prevMode",
                "type": "tuple",
                "set": "0",
                "text": "The parameter's previous evaluation modes."
            },
            {
                "class": "ParGroup",
                "name": "readOnly",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's read only status. When True the parameter cannot be modified through the UI, only scripting."
            },
            {
                "class": "ParGroup",
                "name": "displayOnly",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's displayOnly state. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "sequence",
                "type": "",
                "set": "0",
                "text": "The set of sequential parameter blocks this parameter belongs to, or None."
            },
            {
                "class": "ParGroup",
                "name": "startSection",
                "type": "bool",
                "set": "1",
                "text": "Get or set the parameter's separator status. When True a visible separator is drawn between this parameter and the ones preceding it. Can only be set on Custom Parameters."
            },
            {
                "class": "ParGroup",
                "name": "style",
                "type": "string",
                "set": "0",
                "text": "Describes the behavior and contents of the custom parameter. Example 'Float', 'Int', 'Pulse', 'XYZ', etc."
            },
            {
                "class": "ParGroup",
                "name": "subLabel",
                "type": "tuple",
                "set": "0",
                "text": "Returns the names of the sub-label."
            },
            {
                "class": "ParGroup",
                "name": "val",
                "type": "tuple",
                "set": "1",
                "text": "Get or set the constant values of the parameter only. To get the parameter's current values, regardless of the Parameter Modes (<code>constant</code>, <code>expression</code>, <code>export</code> or <code>bound</code>), use the eval() method described below.\n<syntaxhighlight lang=python>\nop('geo1').parGroup.t.val   # the constant values \nop('geo1').parGroup.t.eval()   # the evaluated parameter\nop('geo1').parGroup.t.val = (1,2,3)\nop('geo1').parGroup.t = (1,2,3)  #equivalent to above, more concise form\n</syntaxhighlight>\nWhen setting this member, the parameter will also be placed in constant mode.  See mode member below.\nTo set a menu value by its index, use the menuIndex member as described below."
            },
            {
                "class": "ParGroup",
                "name": "valid",
                "type": "bool",
                "set": "0",
                "text": "True if the referenced parameter currently exists, False if it has been deleted."
            },
            {
                "class": "ParGroup",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The parameter's order in the list."
            }
        ],
        "methods": [
            {
                "class": "ParGroup",
                "name": "copy",
                "call": "copy(ParGroup)",
                "returns": "None",
                "text": "Copy the specified parameter.\n* ParGroup - The parameter to copy.\n<syntaxhighlight lang=python>op('geo1').parGroup.t.copy( op('geo2').parGroup.t )</syntaxhighlight>"
            },
            {
                "class": "ParGroup",
                "name": "destroy",
                "call": "destroy()",
                "returns": "None",
                "text": "Destroy the parameter referenced by this ParGroup. An exception will be raised if the parameter has already been destroyed. Only custom and sequential parameters can be destroyed.  Destroying a sequential parameter will destroy its entire block. Note: When any parameter is destroyed, any existing parameter objects will be invalid and should be re-fetched."
            },
            {
                "class": "ParGroup",
                "name": "eval",
                "call": "eval()",
                "returns": "tuple",
                "text": "Evaluate a parameter group. This value may be derived by the parameter group's constant value, expression, or export, dependent on its mode.\n<syntaxhighlight lang=python>a = op('geo1').parGroup.t.eval()</syntaxhighlight>"
            },
            {
                "class": "ParGroup",
                "name": "evalExport",
                "call": "evalExport()",
                "returns": "tuple",
                "text": "Evaluate the export portions of a parameter, if it contains any. This will ignore any expressions, etc.\n<syntaxhighlight lang=python>a = op('geo1').parGroup.t.evalExport()</syntaxhighlight>"
            },
            {
                "class": "ParGroup",
                "name": "evalExpression",
                "call": "evalExpression()",
                "returns": "tuple",
                "text": "Evaluate the expression portions of a parameter, if it contains any. This will ignore any exports, etc.\n<syntaxhighlight lang=python>a = op('geo1').parGroup.t.evalExpression()</syntaxhighlight>\nTo evaluate an arbitrary expression string, that is not inside a parameter, see [[OP Class#evalExpression|OP.evalExpression]]."
            },
            {
                "class": "ParGroup",
                "name": "evalNorm",
                "call": "evalNorm()",
                "returns": "tuple",
                "text": "Similar to eval() but the returns the normalized slider values."
            },
            {
                "class": "ParGroup",
                "name": "evalOPs",
                "call": "evalOPs()",
                "returns": "tuple of lists",
                "text": "Evaluate the parameter as series of operators. This is useful for a custom  parameter that specifies a list of operator paths for example.\n<syntaxhighlight lang=python>a = op('base1').parGroup.Paths.evalOPs()</syntaxhighlight>"
            },
            {
                "class": "ParGroup",
                "name": "pars",
                "call": "pars(pattern)",
                "returns": "list",
                "text": "Returns a (possibly empty) list of parameter objects that match the pattern.\n* pattern - Is a string following the Pattern Matching rules, specifying which parameters to return.\n<syntaxhighlight lang=python>\n# translate parameters\nnewlist = op('geo1').parGroup.t.pars('t?')\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The ParGroup class describes an instance of a single Parameter.\n\nSee also [[Custom Parameters]].",
        "inherit": "",
        "parent": ""
    },
    "ParGroupCollection": {
        "label": "ParGroupCollection",
        "members": [
            {
                "class": "ParGroupCollection",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The OP to which this object belongs."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The ParGroupCollection class can be used to access parameter tuples. To access a parameter you need to use its internal name. See also [[Par Class]].",
        "inherit": "",
        "parent": ""
    },
    "ParGroupPulse": {
        "label": "ParGroupPulse",
        "members": [],
        "methods": [
            {
                "class": "ParGroupPulse",
                "name": "pulse",
                "call": "pulse(value, frames=nframes, seconds=nseconds)",
                "returns": "None",
                "text": "Pulsing sets a parameter to the specific value, cooks the operator, then restores the parameter to its previous value.\nFor pulse type parameters no value is specified or used.\n* value - (Optional) The tuple to pulse this parGroup with, default is <syntaxhighlight lang=python inline=true>[1]</syntaxhighlight>.\n* frames - (Optional) Number of frames before restoring the parameter to its original value.\n* seconds - (Optional) Number of seconds before restoring the parameter to its original value.\n<syntaxhighlight lang=python>\nop('moviein1').parGroup.reload.pulse([1]) # set the reload toggle, then cook\nop('glsl1').parGroup.loadvariablenames.pulse() # activate the pulse parameter\nop('geo1').parGroup.t.pulse([0,2,0], frames=120) # pulse geometry transform for 120 frames\nop('text1').parGroup.text.pulse(['GO!'], seconds=3) # pulse text TOP string field, for 3 seconds\nop('noise').parGroup.type.pulse(['random'], seconds=0.5) # pulse noise menu type for half a second\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The ParGroupPulse class describes a subclass of a ParGroup ending with a pulse parameter. See also Custom ParGroup.",
        "inherit": "",
        "parent": ""
    },
    "ParGroupUnit": {
        "label": "ParGroupUnit",
        "members": [
            {
                "class": "ParGroupUnit",
                "name": "unit",
                "type": "par",
                "set": "0",
                "text": "The unit parameter in this ParGroupUnit object."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The ParGroupUnit class describes a subclass of a [[ParGroup Class|ParGroup]] ending with a unit parameter. See also Custom ParGroup.",
        "inherit": "",
        "parent": ""
    },
    "particleSOP": {
        "label": "particleSOP",
        "members": [],
        "methods": [
            {
                "class": "particleSOP",
                "name": "createParticles",
                "call": "createParticles(num)",
                "returns": "[points]",
                "text": "Creates a number of particles without advancing the particle simulation. Returns a list of points, where each point describes a particle. Point attributes (v, life, N, etc.) can be used to modify these or any existing particles.\n* num - The number of particles to create.\"",
                "deprecated": ""
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "patternCHOP": {
        "label": "patternCHOP",
        "members": [
            {
                "set": "0",
                "text": "The index of the current [[Channel Class|channel]] being evaluated. For example, if Pattern generates three channels you can put <code>[1, 3, 7][me.chanIndex]</code> in the Amplitude parameter to customize the amplitude for each channel.",
                "type": "int",
                "class": "patternCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "patternCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "pbrMAT": {
        "label": "pbrMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "Peer": {
        "label": "Peer",
        "members": [
            {
                "class": "Peer",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Peer",
                "name": "port",
                "type": "int",
                "set": "0",
                "text": "The network port associated with the peer."
            },
            {
                "class": "Peer",
                "name": "address",
                "type": "str",
                "set": "0",
                "text": "The network address associated with the peer."
            },
            {
                "class": "Peer",
                "name": "hostname",
                "type": "str",
                "set": "0",
                "text": "The network hostname associated with the peer."
            }
        ],
        "methods": [
            {
                "class": "Peer",
                "name": "close",
                "call": "close()",
                "returns": "bool",
                "text": "Close the peer connection. Returns True if successful. Closing a peer can be useful when implementing HTML server protocols for example."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "A Peer describes the network connection originating a message in the callback functions found in [[oscinDAT Class|oscinDAT]], [[tcpipDAT Class|tcpipDAT]], [[udpinDAT Class|udpinDAT]], [[udtinDAT Class|udtinDAT]]."
    },
    "performCHOP": {
        "label": "performCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "performDAT": {
        "label": "performDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "phongMAT": {
        "label": "phongMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "photoshopinTOP": {
        "label": "photoshopinTOP",
        "members": [
            {
                "set": "0",
                "text": "Is true if the operator is connected to a running instance of Photoshop.",
                "type": "bool",
                "class": "photoshopinTOP",
                "name": "isConnected"
            },
            {
                "set": "0",
                "text": "Is true if the operator is receiving image update. It will get updates when it's not locked to a particular document, or if it is locked and the document is opened in that Photoshop instance.",
                "type": "bool",
                "class": "photoshopinTOP",
                "name": "isReceivingUpdates"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "pipeinCHOP": {
        "label": "pipeinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "pipeoutCHOP": {
        "label": "pipeoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "Point": {
        "label": "Point",
        "members": [
            {
                "class": "Point",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The point index in the list."
            },
            {
                "class": "Point",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Point",
                "name": "P",
                "type": "td.AttributeData",
                "set": "1",
                "text": "The coordinates as [[AttributeData Class|AttributeData]]. Individual components can be read or written with the [] operator.\n<syntaxhighlight lang=python>\npoint.P[0] = 5\npoint.P = (1,0,1)\n</syntaxhighlight>"
            },
            {
                "class": "Point",
                "name": "x",
                "type": "float",
                "set": "1",
                "text": "Get or set x coordinate value. This is the same as P[0]."
            },
            {
                "class": "Point",
                "name": "y",
                "type": "float",
                "set": "1",
                "text": "Get or set y coordinate value. This is the same as P[1]."
            },
            {
                "class": "Point",
                "name": "z",
                "type": "float",
                "set": "1",
                "text": "Get or set z coordinate value. This is the same as P[2]."
            },
            {
                "class": "Point",
                "name": "normP",
                "type": "tdu.Position",
                "set": "0",
                "text": "The normalized position of this point within the bounding box of the SOP. Will always be in the range [0,1]. Expressed as tdu.Position object."
            }
        ],
        "methods": [
            {
                "class": "Point",
                "name": "destroy",
                "call": "destroy()",
                "returns": "None",
                "text": "Destroy and remove the actual point this object refers to. This operation is only valid when the primitive belongs to a [[scriptSOP Class|scriptSOP]]. Note: after this call, other existing Point objects in this SOP may no longer be valid."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "A Point describes an instance to a single [[Point|geometry point]].  They are accessible through the [[SOP Class|SOP.points]] member."
    },
    "Points": {
        "label": "Points",
        "members": [
            {
                "class": "Points",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            }
        ],
        "methods": [
            {
                "class": "Points",
                "name": "len",
                "call": "len(Points)",
                "returns": "int",
                "text": "Returns the total number of points.\n<syntaxhighlight lang=python>\na = len(op('box1').points)\n</syntaxhighlight>"
            },
            {
                "class": "Points",
                "name": "[]",
                "call": "[index]",
                "returns": "td.Point",
                "text": "Get a specific point given an integer index.\n<syntaxhighlight lang=python>\nn = op('box1').points[0]\n</syntaxhighlight>"
            },
            {
                "class": "Points",
                "name": "Iterator",
                "call": "Iterator",
                "returns": "td.Point",
                "text": "Iterate over each point.\n<syntaxhighlight lang=python>\nfor m in op('box1').points:\n\t# do something with m, which is a Point\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Points class describes the set of [[Point Class|point objects]] owned by one [[SOP Class|SOP]]."
    },
    "pointSOP": {
        "label": "pointSOP",
        "members": [
            {
                "set": "0",
                "text": "The current point color being evaluated, from the first input, or a default if not present, expressed as a 4-tuple.",
                "type": "tuple(r, g, b, a)",
                "class": "pointSOP",
                "name": "inputColor"
            },
            {
                "set": "0",
                "text": "The current point color being evaluated, from the second input, or a default if not present, expressed as a 4-tuple.",
                "type": "tuple(r, g, b, a)",
                "class": "pointSOP",
                "name": "inputColor2"
            },
            {
                "set": "0",
                "text": "The current point normal being evaluated, from the first input, or a default if not present, expressed as a 3-tuple.",
                "type": "tuple(n1, n2, n3)",
                "class": "pointSOP",
                "name": "inputNormal"
            },
            {
                "set": "0",
                "text": "The current point normal being evaluated, from the second input, or a default if not present, expressed as a 3-tuple.",
                "type": "tuple(n1, n2, n3)",
                "class": "pointSOP",
                "name": "inputNormal2"
            },
            {
                "set": "0",
                "text": "The current [[Point Class|point]] being evaluated, from the first input.",
                "type": "Point",
                "class": "pointSOP",
                "name": "inputPoint"
            },
            {
                "set": "0",
                "text": "The current [[Point Class|point]] being evaluated, from the second input.",
                "type": "Point",
                "class": "pointSOP",
                "name": "inputPoint2"
            },
            {
                "set": "0",
                "text": "The current point texture being evaluated, from the first input, or a default if not present, expressed as a 3-tuple.",
                "type": "tuple(u, v, w)",
                "class": "pointSOP",
                "name": "inputTexture"
            },
            {
                "set": "0",
                "text": "The current point texture being evaluated, from the second input, or a default if not present, expressed as a 3-tuple.",
                "type": "tuple(u, v, w)",
                "class": "pointSOP",
                "name": "inputTexture2"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "pointspriteMAT": {
        "label": "pointspriteMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "Poly": {
        "label": "Poly",
        "members": [
            {
                "class": "Poly",
                "name": "closed",
                "type": "bool",
                "set": "0",
                "text": "Returns True if the poly is closed, False otherwise."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "Prim"
        ],
        "summary": "A Poly describes an instance of a single [[Polygon|geometry polygon]]. It is an instance of a [[Prim Class]]."
    },
    "polyloftSOP": {
        "label": "polyloftSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "polypatchSOP": {
        "label": "polypatchSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "polyreduceSOP": {
        "label": "polyreduceSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "polysplineSOP": {
        "label": "polysplineSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "polystitchSOP": {
        "label": "polystitchSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "posistagenetCHOP": {
        "label": "posistagenetCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "Position": {
        "label": "Position",
        "members": [
            {
                "class": "tdu.Position",
                "name": "x",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the X component of the position."
            },
            {
                "class": "tdu.Position",
                "name": "y",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the Y component of the position."
            },
            {
                "class": "tdu.Position",
                "name": "z",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the Z component of the position."
            }
        ],
        "methods": [
            {
                "class": "tdu.Position",
                "name": "translate",
                "call": "translate(x, y, z)",
                "returns": "None",
                "text": "Translates the position by the specified values.\n*x, y, z - The values to translate by.\n<syntaxhighlight lang=python>\np.translate(5, 2, 0)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Position",
                "name": "scale",
                "call": "scale(x, y, z)",
                "returns": "None",
                "text": "Scales each component of the position by the specified values.\n*x, y, z - The values to scale each component of the position by.\n<syntaxhighlight lang=python>\np.scale(1, 2, 1)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Position",
                "name": "copy",
                "call": "copy()",
                "returns": "tdu.Position",
                "text": "Returns a new position that is a copy of the position.\n<syntaxhighlight lang=python>\nnewV = v.copy()\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The position class holds a single 3 component position. A position is a single point in space, and it's important to use a position or [[Vector Class|vector]] as appropriate for the data that is being calculated, since matrix operations on them will end in different results. When being multiplied by a [[Matrix Class|Matrix]], this class will implicitly have a 4th component (W component) of 1. If the Matrix is a projection matrix that will cause the W component to become something other than 1, all 4 components will be divided by W to make the position homogeneous again. A new position can be created without any arguments, with 3 arguments for the x,y,z values, or with a single argument which is a variable that has 3 entries such as a list of length 3, or another position or vector.\n\n\nExamples of creating a position:\n<syntaxhighlight lang=python>\np = tdu.Position() # starts as (0, 0, 0)\np2 = tdu.Position(1, 5, 0)\nvalues = [0, 1, 0]\np3 = tdu.Position(values)\n</syntaxhighlight>"
    },
    "Preferences": {
        "label": "Preferences",
        "members": [
            {
                "class": "Preferences",
                "name": "defaults",
                "type": "dict",
                "set": "0",
                "text": "A dictionary of preferences with their default values."
            }
        ],
        "methods": [
            {
                "class": "Preferences",
                "name": "save",
                "call": "save()",
                "returns": "None",
                "text": "Save preference values to disk.  Unless saved, changes to preferences will be lost, next time application is started."
            },
            {
                "class": "Preferences",
                "name": "resetToDefaults",
                "call": "resetToDefaults()",
                "returns": "None",
                "text": "Reset all preferences to their default values."
            },
            {
                "class": "Preferences",
                "name": "load",
                "call": "load()",
                "returns": "None",
                "text": "Restore preference values from disk."
            },
            {
                "class": "Preferences",
                "name": "len",
                "call": "len(Preferences)",
                "returns": "int",
                "text": "Returns the total number of preferences.\n<syntaxhighlight lang=python>\na = len(ui.preferences)\n</syntaxhighlight>"
            },
            {
                "class": "Preferences",
                "name": "[]",
                "call": "[<preference name>]",
                "returns": "value",
                "text": "Get or set specific preference given a preference name key.\n<syntaxhighlight lang=python>\nv = ui.preferences['dats.autoindent']\nui.preferences['dats.autoindent'] = 0\n</syntaxhighlight>"
            },
            {
                "class": "Preferences",
                "name": "iterator",
                "call": "Iterator",
                "returns": "str",
                "text": "Iterate over each preference name.\n<syntaxhighlight lang=python>\nfor p in ui.preferences:\n\tprint(p) # print the name of all preferences\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Preferences class describes the set of configurable preferences that are retained between sessions. It can be accessed with the ui.preferences object or through the [[Dialogs:Preferences_Dialog|Preferences Dialog]]."
    },
    "prefiltermapTOP": {
        "label": "prefiltermapTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "Prim": {
        "label": "Prim",
        "members": [
            {
                "class": "Prim",
                "name": "center",
                "type": "tdu.Position",
                "set": "1",
                "text": "Get or set the barycentric coordinate of this primitive. It is expressed as a tdu.Position object."
            },
            {
                "class": "Prim",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The primitive index in the list."
            },
            {
                "class": "Prim",
                "name": "normal",
                "type": "tdu.Vector",
                "set": "0",
                "text": "The calculated normal vector of this primitive, expressed as a tdu.Vector object."
            },
            {
                "class": "Prim",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Prim",
                "name": "weight",
                "type": "float",
                "set": "0",
                "text": "The associated weight of the primitive. Only certain primitives, such as those created by the [[Metaball SOP]] can modify this value from its default of 2.0."
            },
            {
                "class": "Prim",
                "name": "direction",
                "type": "tdu.Vector",
                "set": "0",
                "text": "A normalized vector pointing from the centroid of the SOP to the centroid of this primitive."
            },
            {
                "class": "Prim",
                "name": "min",
                "type": "tdu.Position",
                "set": "0",
                "text": "The minimum coordinates of this primitive along each dimension, expressed as a tdu.Position object."
            },
            {
                "class": "Prim",
                "name": "max",
                "type": "tdu.Position",
                "set": "0",
                "text": "The maximum coordinates of this primitive along each dimension, expressed as a tdu.Position object."
            },
            {
                "class": "Prim",
                "name": "size",
                "type": "tdu.Position",
                "set": "0",
                "text": "The size of this primitive along each dimension, expressed as a tdu.Position object."
            }
        ],
        "methods": [
            {
                "class": "Prim",
                "name": "destroy",
                "call": "destroy(destroyPoints=True)",
                "returns": "None",
                "text": "Destroy and remove the actual primitive this object refers to. This operation is only valid when the primitive belongs to a [[scriptSOP Class|scriptSOP]]. Note: after this call, other existing Prim objects in this SOP may no longer be valid.\n*destroyPoints - (Keyword, Optional) If True, its [[Point Class|points]] are destroyed as well, if false, they are simply detached. The argument is True by default."
            },
            {
                "class": "Prim",
                "name": "eval",
                "call": "eval(u, v)",
                "returns": "td.Position",
                "text": "Evaluate the [[Position Class|position]] on the primitive given the u,v coordinates. u,v should be in the range [0,1]. '''Note:''' Polygons and curves ignore the v parameter.\n<syntaxhighlight lang=python>\ncenter = op('box1').prim[0].eval(0.5, 0.5)\n</syntaxhighlight>"
            },
            {
                "class": "Prim",
                "name": "len",
                "call": "len(Prim)",
                "returns": "int",
                "text": "Returns the total number of vertices.\n<syntaxhighlight lang=python>\na = len(op('box1').prim[0])\n</syntaxhighlight>"
            },
            {
                "class": "Prim",
                "name": "[]",
                "call": "[index]",
                "returns": "td.Vertex",
                "text": "Get specific vertex given an integer index\n<syntaxhighlight lang=python>\nn = op('box1').prims[5][0]\n</syntaxhighlight>"
            },
            {
                "class": "Prim",
                "name": "[]",
                "call": "[row, col]",
                "returns": "td.Vertex",
                "text": "Get specific vertex from a Mesh given integer row and column values.\n<syntaxhighlight lang=python>\nv = op('grid1').prims[2,3]\n</syntaxhighlight>"
            },
            {
                "class": "Prim",
                "name": "Iterator",
                "call": "Iterator",
                "returns": "td.Vertex",
                "text": "Iterate over each vertex.\n<syntaxhighlight lang=python>\nfor m in op('box1').prims[5]:\n\t# do something with m, which is a Vertex\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "A Prim describes an instance to a single [[Primitive|geometry primitive]].  They are accessible through the [[SOP Class|SOP.prims]] member."
    },
    "primitiveSOP": {
        "label": "primitiveSOP",
        "members": [
            {
                "set": "0",
                "text": "The current primitive color being evaluated or a default if not present, expressed as a 4-tuple.",
                "type": "tuple(r, g, b, a)",
                "class": "primitiveSOP",
                "name": "inputColor"
            },
            {
                "set": "0",
                "text": "The current [[Prim Class|primitive]] being evaluated.",
                "type": "Prim",
                "class": "primitiveSOP",
                "name": "inputPrim"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "Prims": {
        "label": "Prims",
        "members": [
            {
                "class": "Prims",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            }
        ],
        "methods": [
            {
                "class": "Prims",
                "name": "len",
                "call": "len(Prims)",
                "returns": "int",
                "text": "Returns the total number of prims.\n<syntaxhighlight lang=python>\na = len(op('box1').prims)\n</syntaxhighlight>"
            },
            {
                "class": "Prims",
                "name": "[]",
                "call": "[index]",
                "returns": "td.Prim",
                "text": "Get a specific prim given an integer index.\n<syntaxhighlight lang=python>\nn = op('box1').prims[0]\n</syntaxhighlight>"
            },
            {
                "class": "Prims",
                "name": "Iterator",
                "call": "Iterator",
                "returns": "td.Prim",
                "text": "Iterate over each prim.\n<syntaxhighlight lang=python>\nfor m in op('box1').prims:\n\t# do something with m, which is a Prim\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Prims class describes the set of [[Prim Class|prim objects]] (primitives) owned by one [[SOP Class|SOP]]."
    },
    "ProductEntry": {
        "label": "ProductEntry",
        "members": [
            {
                "class": "ProductEntry",
                "name": "licenseType",
                "type": "int",
                "set": "0",
                "text": "Returns the license type for this product entry on the dongle."
            },
            {
                "class": "ProductEntry",
                "name": "updateDate",
                "type": "tuple(YYYY, MM, DD)",
                "set": "0",
                "text": "The date the product entry is valid until. Returns a tuple in the form (YYYY, MM, DD)."
            },
            {
                "class": "ProductEntry",
                "name": "version",
                "type": "str",
                "set": "0",
                "text": "The version of TouchDesigner this dongle product entry is valid for."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "A class to interact with a dongle entry for a single dongle connected to the system."
    },
    "profileSOP": {
        "label": "profileSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "Project": {
        "label": "Project",
        "members": [
            {
                "class": "Project",
                "name": "folder",
                "type": "str",
                "set": "0",
                "text": "The folder at which the project resides."
            },
            {
                "class": "Project",
                "name": "name",
                "type": "str",
                "set": "0",
                "text": "The filename under which the project is saved."
            },
            {
                "class": "Project",
                "name": "saveVersion",
                "type": "str",
                "set": "0",
                "text": "The [[App Class|App]] version number when the project was last saved."
            },
            {
                "class": "Project",
                "name": "saveBuild",
                "type": "str",
                "set": "0",
                "text": "The [[App Class|App]] build number when the project was last saved."
            },
            {
                "class": "Project",
                "name": "saveTime",
                "type": "str",
                "set": "0",
                "text": "The time and date the project was last saved."
            },
            {
                "class": "Project",
                "name": "saveOsName",
                "type": "str",
                "deprecated": "True",
                "set": "0",
                "text": "The [[App Class|App]] operating system name when the project was last saved."
            },
            {
                "class": "Project",
                "name": "saveOsVersion",
                "type": "str",
                "deprecated": "True",
                "set": "0",
                "text": "The [[App Class|App]] operating system version when the project was last saved."
            },
            {
                "class": "Project",
                "name": "saveOSName",
                "type": "str",
                "set": "0",
                "text": "The [[App Class|App]] operating system name when the project was last saved."
            },
            {
                "class": "Project",
                "name": "saveOSVersion",
                "type": "str",
                "set": "0",
                "text": "The [[App Class|App]] operating system version when the project was last saved."
            },
            {
                "class": "Project",
                "name": "paths",
                "type": "dict",
                "set": "0",
                "text": "A dictionary which can be used to define URL-syntax path prefixes, enabling you to move your media to different locations easily. This dictionary is saved and loaded in the <code>.toe</code> file.  Example: Run <code>project.paths['movies'] = 'C:/MyMovies'</code>, and reference it with a parameter expression: <code>movies://butterfly.jpg</code>. To manually convert between expanded and collapsed paths, use <code>tdu.collapsePath()</code> and <code>tdu.expandPath</code> from the [[Tdu Module]], for example <code>tdu.expandPath('movies://butterfly.jpg')</code> expands to <code>C:/MyMovies/butterfly.jpg</code>. If you already have your paths setup, choosing files from file browsers in OPs will create paths using these shortcuts rather than full paths. Additionally, to enable you to have different media locations on different machines, you can put a JSON file in the same folder as your <code>.toe</code> that gets read on startup. This will override any existing locations saved in projects.paths to the new machine specific file paths specified in the .json. Only existing entries in <code>project.paths</code> will be used. If the .json contains path names not specified in <code>project.paths</code>, those will be ignored. It would contain something like <code>{ \"project.paths\": { \"movies\": \"M:/MyMovies\" } }</code>. If your <code>.toe</code> file is called <code>MyProject.10.toe</code>, the JSON file must be called <code>MyProject.Settings.json</code>. The idea is that this .json would be unique to machines, and not commited to version control or shared between machines."
            },
            {
                "class": "Project",
                "name": "cookRate",
                "type": "float",
                "set": "1",
                "text": "Get or set the maximum number of frames processed each second. In general you should not need to use this. It is preferred to look at the FPS of the root component to know the cooking rate. Individual [[COMP Class|components]] may have their own rates, specified by rate.\n<syntaxhighlight lang=python>\na = project.cookRate # get the current cook rate \nproject.cookRate = 30 # set the cook rate to 30 FPS\n</syntaxhighlight>\nNote: This is displayed and set in the user interface at the bottom-left: the \"FPS\" field."
            },
            {
                "class": "Project",
                "name": "realTime",
                "type": "bool",
                "set": "1",
                "text": "Get or set the real time cooking state. When True, frames may be skipped in order to maintain the cookRate. When False, all frames are processed sequentially regardless of duration. This is useful to render movies out using the Movie File Out TOP without dropping any frames for example.\n<syntaxhighlight lang=python>\na = project.realTime\nproject.realTime = False # turn off real time playback.\n</syntaxhighlight>"
            },
            {
                "class": "Project",
                "name": "isPrivate",
                "type": "bool",
                "set": "0",
                "text": "True when the project networks cannot be directly viewed."
            },
            {
                "class": "Project",
                "name": "isPrivateKey",
                "type": "bool",
                "set": "0",
                "text": "True when the private networks are accessible by a pass phrase."
            },
            {
                "class": "Project",
                "name": "cacheParameters",
                "type": "bool",
                "set": "1",
                "text": "Cache parameter values instead of always evaluating."
            },
            {
                "class": "Project",
                "name": "externalToxModifiedInProject",
                "type": "bool",
                "set": "0",
                "text": "Callback for when an external tox has been modified in the current project and there are other instances of the same tox loaded elsewhere in the project."
            },
            {
                "class": "Project",
                "name": "externalToxModifiedOnDisk",
                "type": "bool",
                "set": "0",
                "text": "Callback for when an external tox file has been modified on disk."
            },
            {
                "class": "Project",
                "name": "windowOnTop",
                "type": "bool",
                "set": "1",
                "text": "Get or set the window on top state."
            },
            {
                "class": "Project",
                "name": "windowStartMode",
                "type": "WindowStartMode",
                "set": "1",
                "text": "Get or set the window start mode.\nThe mode is one of: <code>WindowStartMode.AUTO</code>, <code>WindowStartMode.FULL</code>, <code>WindowStartMode.LEFT</code>, <code>WindowStartMode.RIGHT</code> or <code>WindowStartMode.CUSTOM</code>."
            },
            {
                "class": "Project",
                "name": "windowDraw",
                "type": "bool",
                "set": "1",
                "text": "Get or set the window drawing state."
            },
            {
                "class": "Project",
                "name": "windowStartCustomWidth",
                "type": "int",
                "set": "1",
                "text": "Get or set the window start width. Only used when windowStartMode is <code>WindowStartMode.CUSTOM</code>."
            },
            {
                "class": "Project",
                "name": "windowStartCustomHeight",
                "type": "int",
                "set": "1",
                "text": "Get or set the window start height. Only used when windowStartMode is <code>WindowStartMode.CUSTOM</code>."
            },
            {
                "class": "Project",
                "name": "windowStartCustomX",
                "type": "int",
                "set": "1",
                "text": "Get or set the window start X position. Only used when windowStartMode is <code>WindowStartMode.CUSTOM</code>."
            },
            {
                "class": "Project",
                "name": "windowStartCustomY",
                "type": "int",
                "set": "1",
                "text": "Get or set the window start Y position. Only used when windowStartMode is <code>WindowStartMode.CUSTOM</code>."
            },
            {
                "class": "Project",
                "name": "performOnStart",
                "type": "bool",
                "set": "1",
                "text": "Get or set the perform on start state."
            },
            {
                "class": "Project",
                "name": "performWindowPath",
                "type": "OP",
                "set": "1",
                "text": "Get or set the perform window path."
            },
            {
                "class": "Project",
                "name": "resetAudioOnDeviceChange",
                "type": "bool",
                "set": "1",
                "text": "Get or set whether audio devices momentarily reset when devices are added or removed to the system."
            }
        ],
        "methods": [
            {
                "class": "Project",
                "name": "load",
                "call": "load(path)",
                "returns": "None",
                "text": "Load a specific .toe file from disk.\n*path - (Optional) The path of the file to load.  If not specified, loads the default[[.toe file]], as specified in preferences.\n<syntaxhighlight lang=python>\nproject.load('test_demo.toe')\n</syntaxhighlight>"
            },
            {
                "class": "Project",
                "name": "save",
                "call": "save(path, saveExternalToxs=False)",
                "returns": "bool",
                "text": "Save the current session to disk.  Returns True if a file was saved, False otherwise (eg, if the file exists, and when prompted, the user selects to not overwrite).\n*path - (Optional) If not provided the default/current filename is incremented and used. The current file is project.name under folder project.folder.\n*saveExternalToxs - (Keyword, Optional) If set to True, will save out the contents of any COMP that references an external .tox into the referenced .tox file.\n<syntaxhighlight lang=python>\nproject.save('test_demo.toe')\nproject.save()\n</syntaxhighlight>"
            },
            {
                "class": "Project",
                "name": "quit",
                "call": "quit(force=False, crash=False)",
                "returns": "None",
                "text": "Quit the project.\n*force - (Keyword, Optional) If set to True, unsaved changes will be discarded without prompting.\n*crash - (Keyword, Optional) If set to True, the application will terminate unexpectedly. This is used for system testing.\n<syntaxhighlight lang=python>\nproject.quit()  #quit project, possibly prompting for unsaved changes if 'Prompt to Save on Exit' in Preferences dialog is enabled.\nproject.quit(force=True)  #quit project immediately.\n</syntaxhighlight>"
            },
            {
                "class": "Project",
                "name": "addPrivacy",
                "call": "addPrivacy(key)",
                "returns": "bool",
                "text": "Add privacy to a toe file with the given key.\nPrivacy can only be added to toes that currently have no privacy, and are using a Pro license.\n*key - The key phrase. This should resolve to a non-blank string.\n<syntaxhighlight lang=python>\nproject.addPrivacy('secret')\n</syntaxhighlight>"
            },
            {
                "class": "Project",
                "name": "removePrivacy",
                "call": "removePrivacy(key)",
                "returns": "bool",
                "text": "Completely remove privacy from a toe file.\n*key - The current privacy key phrase.\n<syntaxhighlight lang=python>\nproject.removePrivacy('secret')\n</syntaxhighlight>"
            },
            {
                "class": "Project",
                "name": "accessPrivateContents",
                "call": "accessPrivateContents(key)",
                "returns": "bool",
                "text": "Gain access to a private file. The file will still be private the next time it is saved or re-opened.\n*key - The current privacy key phrase.\n<syntaxhighlight lang=python>\nproject.accessPrivateContents('secret')\n</syntaxhighlight>"
            },
            {
                "class": "Project",
                "name": "applyWindowSettings",
                "call": "applyWindowSettings()",
                "returns": "None",
                "text": "Applies the project's window start settings to the current TouchDesigner window."
            },
            {
                "class": "Project",
                "name": "stack",
                "call": "stack()",
                "returns": "str",
                "text": "Formatted contents of current cook and parameter evaluation stack.\n<syntaxhighlight lang=python>\nprint(project.stack())\n</syntaxhighlight>"
            },
            {
                "class": "Project",
                "name": "pythonStack",
                "call": "pythonStack()",
                "returns": "str",
                "text": "Formatted contents of current python stack.\n<syntaxhighlight lang=python>\nprint(project.pythonStack())\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Project class describes the current session.  It can be accessed with the project object, found in the automatically imported [[td Module|td module]]. Members changed in this such as the 'paths' member will be written to disk when the project is saved."
    },
    "projectionTOP": {
        "label": "projectionTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "projectSOP": {
        "label": "projectSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "pulseCHOP": {
        "label": "pulseCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "pulseCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "Quaternion": {
        "label": "Quaternion",
        "members": [
            {
                "class": "tdu.Quaternion",
                "name": "x",
                "type": "float",
                "set": "1",
                "text": "Get or set the x component of the quaternion."
            },
            {
                "class": "tdu.Quaternion",
                "name": "y",
                "type": "float",
                "set": "1",
                "text": "Get or set the y component of the quaternion."
            },
            {
                "class": "tdu.Quaternion",
                "name": "z",
                "type": "float",
                "set": "1",
                "text": "Get or set the z component of the quaternion."
            },
            {
                "class": "tdu.Quaternion",
                "name": "w",
                "type": "float",
                "set": "1",
                "text": "Get or set the w component of the quaternion."
            }
        ],
        "methods": [
            {
                "class": "tdu.Quaternion",
                "name": "lerp",
                "call": "lerp(q2, factor)",
                "returns": "quaternion",
                "text": "Returns the linear interpolation of the quaternion with another quaternion and an interpolation factor. \nThe quaternion argument can be anything from which a quaternion can be derived ie. (x,y,z,w), Matrix, etc.\nThe interpolation factor must be between 0 and 1.\n<syntaxhighlight lang=python>\nq3 = q.lerp(q2, factor)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "length",
                "call": "length()",
                "returns": "float",
                "text": "Returns the length of the quaternion.\n<syntaxhighlight lang=python>\nl = q.length()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "cross",
                "call": "cross(q2)",
                "returns": "vector",
                "text": "Returns the cross product of the quaternion and argument.\nThe quaternion argument can be anything from which a quaternion can be derived ie. (x,y,z,w), Matrix, etc.\n<syntaxhighlight lang=python>\nl = q.cross(q2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "rotate",
                "call": "rotate(vec)",
                "returns": "vector",
                "text": "Rotates a vector using the current quaternion. Returns a new vector.\n<syntaxhighlight lang=python>\nv2 = q.rotate(v1)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "slerp",
                "call": "slerp(q2, factor)",
                "returns": "quaternion",
                "text": "Returns the spherical interpolation of the quaternion with another quaternion and an interpolation factor.\nThe quaternion argument can be anything from which a quaternion can be derived ie. (x,y,z,w), Matrix, etc.\n<syntaxhighlight lang=python>\nq3 = q.slerp(q2, factor)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "eulerAngles",
                "call": "eulerAngles(order='xyz')",
                "returns": "tuple",
                "text": "Returns euler angles in degrees as a tuple (i.e. pitch as x, yaw as y, roll as z) from current quaternion and a rotation order. The 'order' argument can be set to any valid rotation order which by default is set to 'xyz'. \n<syntaxhighlight lang=python>\nr = q.eulerAngles(order='xyz')\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "fromEuler",
                "call": "fromEuler(order='xyz')",
                "returns": "tuple",
                "text": "Returns and set the current quaternion from euler angles in degrees as a 3 inputs argument (i.e. pitch as x, yaw as y, roll as z). The 'order' argument can be set to any valid rotation order which by default is set to 'xyz'.\n<syntaxhighlight lang=python>r = q.fromEuler(order='xyz')</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "axis",
                "call": "axis()",
                "returns": "vector",
                "text": "Returns the rotation axis vector of the quaternion.\n<syntaxhighlight lang=python>\nv = q.axis()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "dot",
                "call": "dot(q2)",
                "returns": "float",
                "text": "Returns the dot product of the quaternion and the argument.\nThe quaternion argument can be anything from which a quaternion can be derived ie. (x,y,z,w), Matrix, etc.\n<syntaxhighlight lang=python>\nl = q.dot(q2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "exp",
                "call": "exp()",
                "returns": "quaternion",
                "text": "Returns the exponential of the quaternion as a new quaternion.\n<syntaxhighlight lang=python>\nq2 = q.exp()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "copy",
                "call": "copy()",
                "returns": "quaternion",
                "text": "Creates a copy of the quaternion with separate values."
            },
            {
                "class": "tdu.Quaternion",
                "name": "log",
                "call": "log()",
                "returns": "quaternion",
                "text": "Returns the natural logarithm of the current quaternion as a new quaternion.\n<syntaxhighlight lang=python>\nl = q.log()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "inverse",
                "call": "inverse()",
                "returns": "None",
                "text": "Invert the quaternion in place.\n<syntaxhighlight lang=python>\nq.inverse()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "angle",
                "call": "angle()",
                "returns": "float",
                "text": "Returns the rotation angle (in degrees) of the quaternion.\n<syntaxhighlight lang=python>\na = q.angle()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Quaternion",
                "name": "*=",
                "call": "Quaternion *= Quaternion",
                "returns": "Quaternion",
                "text": "Applies the rotation of one quaternion to another quaternion.\n<syntaxhighlight lang=python>\n# apply rotation of q2 to q1\nq1 *= q2\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "Holds a Quaternion object which can be used to manipulate rotations in various ways. Quaternions can be constructed using a few different ways to describe the initial rotation:\n\n<syntaxhighlight lang=python>\n# From Euler Angles\nq = tdu.Quaternion(tdu.Vector(30, 5, -5))\n# From an angle and a rotation axis\nq = tdu.Quaternion(30, tdu.Vector(0, 1, 0))\n# From two vectors, rotate from the first vector to the second vector\nq = tdu.Quaternion(tdu.Vector(1, 0, 0), tdu.Vector(0, 1, 0))\n# From a set of 4 quaternion values\nq = tdu.Quaternion(x, y, z, w)\n\n</syntaxhighlight>\n\nQuaternions can be used like simple Python lists:\n<syntaxhighlight lang=python>\nprint(q[1])\t\t# same as q.y\nq[2] = 0\t\t# same as q.z\n</syntaxhighlight>\n\nSee also [[Transform CHOP]] which accepts, manipulates and outputs quaternions as sets of CHOP channels."
    },
    "railsSOP": {
        "label": "railsSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "rampTOP": {
        "label": "rampTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "raySOP": {
        "label": "raySOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "realsenseCHOP": {
        "label": "realsenseCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "realsenseTOP": {
        "label": "realsenseTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "recordCHOP": {
        "label": "recordCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "rectangleSOP": {
        "label": "rectangleSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "rectangleTOP": {
        "label": "rectangleTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "refineSOP": {
        "label": "refineSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "remapTOP": {
        "label": "remapTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "renameCHOP": {
        "label": "renameCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "renderpassTOP": {
        "label": "renderpassTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "renderpickCHOP": {
        "label": "renderpickCHOP",
        "members": [
            {
                "set": "0",
                "text": "The [[SOP Class|SOP]] that was last picked.",
                "type": "OP",
                "class": "renderpickCHOP",
                "name": "pickedSOP"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "renderselectTOP": {
        "label": "renderselectTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "renderTOP": {
        "label": "renderTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "reorderCHOP": {
        "label": "reorderCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "reorderDAT": {
        "label": "reorderDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "reorderTOP": {
        "label": "reorderTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "replaceCHOP": {
        "label": "replaceCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "replicatorCOMP": {
        "label": "replicatorCOMP",
        "members": [
            {
                "set": "0",
                "text": "Reference to the current [[operator]] replicant.",
                "type": "OP",
                "class": "ReplicatorCOMP",
                "name": "curItem"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "COMP"
        ]
    },
    "resampleCHOP": {
        "label": "resampleCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "resampleSOP": {
        "label": "resampleSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "resolutionTOP": {
        "label": "resolutionTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "revolveSOP": {
        "label": "revolveSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "rgbkeyTOP": {
        "label": "rgbkeyTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "rgbtohsvTOP": {
        "label": "rgbtohsvTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "Run": {
        "label": "Run",
        "members": [
            {
                "class": "Run",
                "name": "active",
                "type": "bool",
                "set": "1",
                "text": "Get or set whether or not this script will execute once its target frame is reached."
            },
            {
                "class": "Run",
                "name": "group",
                "type": "string",
                "set": "1",
                "text": "Get or set the group label associated with this script."
            },
            {
                "class": "Run",
                "name": "isCell",
                "type": "bool",
                "set": "0",
                "text": "Returns true when the source is a [[Cell Class|cell]], from a Cell.run() call."
            },
            {
                "class": "Run",
                "name": "isDAT",
                "type": "bool",
                "set": "0",
                "text": "Returns true when the source is a [[DAT Class|DAT]], from a DAT.run() call."
            },
            {
                "class": "Run",
                "name": "isString",
                "type": "bool",
                "set": "0",
                "text": "Returns true when the source is a string, from a td module run() call"
            },
            {
                "class": "Run",
                "name": "path",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|operator]] location from which this script will execute."
            },
            {
                "class": "Run",
                "name": "remainingFrames",
                "type": "int",
                "set": "1",
                "text": "Get or set the remaining number of frames before the execution will occur."
            },
            {
                "class": "Run",
                "name": "remainingMilliseconds",
                "type": "int",
                "set": "1",
                "text": "Get or set the remaining number of milliseconds before the execution will occur."
            },
            {
                "class": "Run",
                "name": "source",
                "type": "[DAT, cell, string]",
                "set": "0",
                "text": "The source of the run. It will be either a [[DAT Class|DAT]], [[Cell Class|cell]], or string."
            }
        ],
        "methods": [
            {
                "class": "Run",
                "name": "kill",
                "call": "kill()",
                "returns": "None",
                "text": "Kill this run before it executes, and remove it from the global runs list, located in the [[td Module]]."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The Run class describes a single instance of a delayed script execution. See [[Run Command Examples]] for more info.\nThey can be accessed from the [[Runs Class|runs]] object. Scripts can be executed with delays with the following methods:\n<syntaxhighlight lang=python>\nDAT.run()\nCell.run()\ntd.run()\n</syntaxhighlight>"
    },
    "Runs": {
        "label": "Runs",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The Runs class describes the set of all delayed [[Run Class|run objects]]. It can be accessed with the runs object, found in the automatically imported [[td Module|td module]]. See [[Run Command Examples]] for more info.\n<syntaxhighlight lang=python>\nprint(len(runs))\t# number of active run objects \nprint(runs[0])\t\t# first run object\nfor r in runs:\n\tr.kill()\t\t# kill all run objects\n</syntaxhighlight>"
    },
    "scalabledisplayTOP": {
        "label": "scalabledisplayTOP",
        "members": [
            {
                "set": "0",
                "text": "Gets the loaded camera transform [[Matrix Class|matrix]] for the configuration. This should be referenced in the 'Xform Matrix/CHOP/DAT' parameter of the [[Camera COMP]].",
                "type": "tdu.Matrix",
                "class": "scalabledisplayTOP",
                "name": "cameraTransform"
            },
            {
                "set": "0",
                "text": "Gets the loaded projection [[Matrix Class|matrix]] for the configuration. This should be referenced in the 'Proj Matrix/CHOP/DAT' parameter of the [[Camera COMP]], with the 'Projection' set to 'Custom Projection Matrix'.",
                "type": "tdu.Matrix",
                "class": "scalabledisplayTOP",
                "name": "projection"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "scanCHOP": {
        "label": "scanCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "screengrabTOP": {
        "label": "screengrabTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "screenTOP": {
        "label": "screenTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "scriptCHOP": {
        "label": "scriptCHOP",
        "members": [
            {
                "class": "scriptCHOP",
                "name": "timeSliceDefault",
                "type": "bool",
                "set": "0",
                "text": "Get the default [[Time Slice]] for the [[Script CHOP]]. Equal to the first input's <code>isTimeSlice</code>."
            }
        ],
        "methods": [
            {
                "class": "scriptCHOP",
                "name": "copyNumpyArray",
                "call": "copyNumpyArray(numpyArray, baseName='chan')",
                "returns": "None",
                "text": "Copies the contents of the numpyArray into the CHOP.\n*numpyArray - The NumPy Array to copy. Must be <syntaxhighlight lang=python, inline=true>shape(numChannels, numSamples)</syntaxhighlight>. The data type must be float32.\n* baseName - (Keyword, Optional) The base of all created channel names beginning with a suffix of 1. Example 'chan' creates 'chan1', 'chan2', etc."
            },
            {
                "text": "Remove all custom parameters from COMP.",
                "returns": "total",
                "name": "destroyCustomPars",
                "call": "destroyCustomPars()",
                "class": "scriptCHOP"
            },
            {
                "text": "Reorder custom parameter pages.\n\nscriptOp.sortPages('Definition','Controls')",
                "returns": "None",
                "name": "sortCustomPages",
                "call": "sortCustomPages(page1, page2, page3..)",
                "class": "scriptCHOP"
            },
            {
                "text": "Remove all channels from the CHOP. The channel length, sample rate etc. remain unchanged.",
                "returns": "None",
                "name": "clear",
                "call": "clear()",
                "class": "scriptCHOP"
            },
            {
                "text": "Add a new [[Page Class|page]] of custom parameters. See [[Page Class]] for more details.\n<syntaxhighlight lang=python>\npage = scriptOp.appendCustomPage('Custom1')\npage.appendFloat('X1')\n</syntaxhighlight>",
                "returns": "Page",
                "name": "appendCustomPage",
                "call": "appendCustomPage(name)",
                "class": "scriptCHOP"
            },
            {
                "text": "Match all of this CHOPs channel data to the given [[CHOP]]. This includes sample rate, length, channel names and channel data.\n*chop - The CHOP to copy. This should be a [[CHOP Class]] instance, not a path to the CHOP.",
                "returns": "None",
                "name": "copy",
                "call": "copy(chop)",
                "class": "scriptCHOP"
            },
            {
                "text": "Append a new channel to the CHOP. If no name is given the channel will be given a default but unique name.\n*name - (Optional) The name to give the channel.\n<syntaxhighlight lang=python>\nc = n.appendChan()\nc = n.appendChan('velocity')\n</syntaxhighlight>",
                "returns": "Channel",
                "name": "appendChan",
                "call": "appendChan(name)",
                "class": "scriptCHOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "scriptDAT": {
        "label": "scriptDAT",
        "members": [],
        "methods": [
            {
                "text": "Add a new [[Page Class|page]] of custom parameters. See [[Page Class]] for more details.\n<syntaxhighlight lang=python>\npage = scriptOp.appendCustomPage('Custom1')\npage.appendFloat('X1')\n</syntaxhighlight>",
                "returns": "Page",
                "name": "appendCustomPage",
                "call": "appendCustomPage(name)",
                "class": "scriptDAT"
            },
            {
                "text": "Remove all custom parameters from COMP.",
                "returns": "total",
                "name": "destroyCustomPars",
                "call": "destroyCustomPars()",
                "class": "scriptDAT"
            },
            {
                "text": "Reorder custom parameter pages.\n<syntaxhighlight lang=python>\nscriptOp.sortCustomPages('Definition','Controls')\n</syntaxhighlight>",
                "returns": "None",
                "name": "sortCustomPages",
                "call": "sortCustomPages(page1, page2, page3..)",
                "class": "scriptDAT"
            }
        ],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "scriptSOP": {
        "label": "scriptSOP",
        "members": [],
        "methods": [
            {
                "text": "Remove all geometry.",
                "returns": "None",
                "name": "clear",
                "call": "clear()",
                "class": "scriptSOP"
            },
            {
                "text": "Copy geometry from the specified [[SOP]] operator.\n*sop - The SOP to copy geometry from. Geometry currently in this SOP will be removed.",
                "returns": "None",
                "name": "copy",
                "call": "copy(sop)",
                "class": "scriptSOP"
            },
            {
                "text": "Append a [[Point Class|point]] to this SOP. The appended point will be returned.",
                "returns": "Point",
                "name": "appendPoint",
                "call": "appendPoint()",
                "class": "scriptSOP"
            },
            {
                "text": "Append a [[Poly Class|poly]] to this SOP. Returns the appended polygon. The returned polygon, is a list of vertices, and if <code>addPoints=True</code>, then <code>polygon[0].point.x</code> can be set to the x value of the first point of the polygon, for example.\n*numVertices - Specifies the initial number of [[Vertex Class|vertices]].\n*closed - (Keyword, Optional) Specifies whether or not the last [[Vertex Class|vertex]] of the polygon will connect to the first. An open polygon will be drawn as a line.\n*addPoints - (Keyword, Optional) If True, a new [[Point Class|point]] will be attached to each [[Vertex Class|vertex]], otherwise the [[Vertex Class|vertex]] point references will need to be manually set afterwards. Manually add them when creating [[Poly Class|polygons]] with shared [[Vertex Class|vertices]].",
                "returns": "Poly",
                "name": "appendPoly",
                "call": "appendPoly(numVertices, closed=True, addPoints=True)",
                "class": "scriptSOP"
            },
            {
                "text": "Append a [[Bezier Class|Bezier]] to this SOP. Returns the appended Bezier.\n* numVertices - Specifies the initial number of [[Vertex Class|vertices]].  The number of [[Vertex Class|vertices]] '''must''' correspond to the order (degree-1) and closed/open state of the curve.  For closed curves, the number of vertices must be a multiple of the degree.  For open curves, it must be one more than a multiple of the degree.\n<syntaxhighlight lang=python>\nscriptOp.appendBezier(6, closed=True) #closed, cubic, 6 vertices, or 2 spans\n</syntaxhighlight>\n<syntaxhighlight lang=python>\nscriptOp.appendBezier(7) #open, cubic, 7 vertices, or 2 spans\n</syntaxhighlight>\n* closed - (Keyword, Optional) Specifies whether or not the last [[Vertex Class|vertex]] of the curve will connect to the first. An open Bezier will be drawn as a line.\n* order - (Keyword, Optional) Specifies the degree of the Bezier. By default it creates cubic (order=4) Beziers.\n* addPoints - (Keyword, Optional) If True, a new [[Point Class|point]] will be attached to each [[Vertex Class|vertex]], otherwise the [[Vertex Class|vertex]] point references will need to be manually set afterwards. Use this option when creating Beziers with shared vertices.",
                "returns": "Bezier",
                "name": "appendBezier",
                "call": "appendBezier(numVertices, closed=False, order=4, addPoints=True)",
                "class": "scriptSOP"
            },
            {
                "text": "Append a [[Mesh Class|mesh]] to this SOP. Returns the appended mesh.\n*numRows, numCols - Specifies the initial number of rows and columns.\n*closedU - (Keyword, Optional) Specifies whether or not the grid is wrapped in the u direction.\n*closedV - (Keyword, Optional) Specifies whether or not the grid is wrapped in the v direction.\n*addPoints - (Keyword, Optional) If True, a new [[Point Class|point]] will be attached to each [[Vertex Class|vertex]], otherwise the [[Vertex Class|vertex]] point references will need to be manually set afterwards. Use this option when creating [[Mesh Class|meshes]] with shared [[Vertex Class|vertices]].",
                "returns": "Mesh",
                "name": "appendMesh",
                "call": "appendMesh(numRows, numCols, closedU=False, closedV=False, addPoints=True)",
                "class": "scriptSOP"
            },
            {
                "text": "Creates a point [[Group Class|group]] with input string name. Returns an error if the group already exists.",
                "returns": "None or Error",
                "name": "createPointGroup",
                "call": "createPointGroup(str)",
                "class": "scriptSOP"
            },
            {
                "text": "Creates a primitive [[Group Class|group]] with input string name. Returns an error if the group already exists.",
                "returns": "None or Error",
                "name": "createPrimGroup",
                "call": "createPrimGroup(str)",
                "class": "scriptSOP"
            },
            {
                "text": "Add a new [[Page Class|page]] of custom parameters. See [[Page Class]] for more details.\n<syntaxhighlight lang=python>\npage = scriptOp.appendCustomPage('Custom1')\npage.appendFloat('X1')\n</syntaxhighlight>",
                "returns": "Page",
                "name": "appendCustomPage",
                "call": "appendCustomPage(name)",
                "class": "scriptSOP"
            },
            {
                "text": "Remove all custom parameters from COMP.",
                "returns": "Total",
                "name": "destroyCustomPars",
                "call": "destroyCustomPars()",
                "class": "scriptSOP"
            },
            {
                "text": "Reorder custom parameter pages.\n<syntaxhighlight lang=python>\nscriptOp.sortCustomPages('Definition','Controls')\n</syntaxhighlight>",
                "returns": "None",
                "name": "sortCustomPages",
                "call": "sortCustomPages(page1, page2, page3..)",
                "class": "scriptSOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "scurveCHOP": {
        "label": "scurveCHOP",
        "members": [
            {
                "class": "scurveCHOP",
                "name": "chanIndex",
                "type": "",
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "Segment": {
        "label": "Segment",
        "members": [
            {
                "class": "Segment",
                "name": "beginFrames",
                "type": "int",
                "set": "0",
                "text": "The beginning point of the segment expressed in frames."
            },
            {
                "class": "Segment",
                "name": "beginSamples",
                "type": "int",
                "set": "0",
                "text": "The beginning point of the segment expressed in samples."
            },
            {
                "class": "Segment",
                "name": "beginSeconds",
                "type": "float",
                "set": "0",
                "text": "The beginning point of the segment expressed in seconds."
            },
            {
                "class": "Segment",
                "name": "custom",
                "type": "oDict",
                "set": "0",
                "text": "Ordered dictionary of all the extra column values associated with the segment."
            },
            {
                "class": "Segment",
                "name": "cycle",
                "type": "bool",
                "set": "0",
                "text": "Whether or not the segment will repeat itself."
            },
            {
                "class": "Segment",
                "name": "cycleEndAlertFrames",
                "type": "int",
                "set": "0",
                "text": "The amount of time before cycling the callback will be executed, expressed in frames."
            },
            {
                "class": "Segment",
                "name": "cycleEndAlertSamples",
                "type": "int",
                "set": "0",
                "text": "The amount of time before cycling the callback will be executed, expressed in samples."
            },
            {
                "class": "Segment",
                "name": "cycleEndAlertSeconds",
                "type": "float",
                "set": "0",
                "text": "The amount of time before cycling the callback will be executed, expressed in seconds."
            },
            {
                "class": "Segment",
                "name": "cycleLimit",
                "type": "bool",
                "set": "0",
                "text": "Whether or not the segment will repeat itself indefinitely."
            },
            {
                "class": "Segment",
                "name": "delayFrames",
                "type": "int",
                "set": "0",
                "text": "The delay portion of the segment expressed in frames."
            },
            {
                "class": "Segment",
                "name": "delaySamples",
                "type": "int",
                "set": "0",
                "text": "The delay portion of the segment expressed in samples."
            },
            {
                "class": "Segment",
                "name": "delaySeconds",
                "type": "float",
                "set": "0",
                "text": "The delay portion of the segment expressed in seconds."
            },
            {
                "class": "Segment",
                "name": "lengthFrames",
                "type": "int",
                "set": "0",
                "text": "The length portion of the segment expressed in frames."
            },
            {
                "class": "Segment",
                "name": "lengthSamples",
                "type": "int",
                "set": "0",
                "text": "The length portion of the segment expressed in samples."
            },
            {
                "class": "Segment",
                "name": "lengthSeconds",
                "type": "float",
                "set": "0",
                "text": "The length portion of the segment expressed in seconds."
            },
            {
                "class": "Segment",
                "name": "maxCycles",
                "type": "int",
                "set": "0",
                "text": "The maximum number of repetitions."
            },
            {
                "class": "Segment",
                "name": "owner",
                "type": "op",
                "set": "0",
                "text": "The OP to which this object belongs."
            },
            {
                "class": "Segment",
                "name": "row",
                "type": "int",
                "set": "0",
                "text": "Named tuple of all the parameter or column values describing the segment."
            },
            {
                "class": "Segment",
                "name": "speed",
                "type": "float",
                "set": "0",
                "text": "The speed multiplier of the segment."
            },
            {
                "class": "Segment",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The numeric index of this segment."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "A Segment object describes a single segment from a Timer CHOP.",
        "inherit": "",
        "parent": ""
    },
    "selectCHOP": {
        "label": "selectCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "selectCOMP": {
        "label": "selectCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "PanelCOMP",
            "COMP"
        ]
    },
    "selectDAT": {
        "label": "selectDAT",
        "members": [
            {
                "set": "0",
                "text": "The current input [[Cell Class|cell]] being evaluated. From the [[Cell Class|cell]] you can get its row, column and value. e.g. me.inputCell.val or use the specific members listed below.",
                "type": "Cell",
                "class": "selectDAT",
                "name": "inputCell"
            },
            {
                "set": "0",
                "text": "The current input column being evaluated.",
                "type": "Col",
                "class": "selectDAT",
                "name": "inputCol"
            },
            {
                "set": "0",
                "text": "The current input row being evaluated.",
                "type": "Row",
                "class": "selectDAT",
                "name": "inputRow"
            },
            {
                "set": "0",
                "text": "The current input [[DAT Class|DAT]] being evaluated.\n<syntaxhighlight lang=python>\nme.inputCell.val #value in cell\nme.inputTable[2,3].val #cell row 2, column 3\nme.inputTable[me.inputRow, me.inputCol-1].val #cell in previous column\nme.inputCell.offset(0, -1) #alternative syntax for previous column\n</syntaxhighlight>",
                "type": "OP",
                "class": "selectDAT",
                "name": "inputTable"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "selectMAT": {
        "label": "selectMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "selectSOP": {
        "label": "selectSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "selectTOP": {
        "label": "selectTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "Sequence": {
        "label": "Sequence",
        "members": [
            {
                "class": "Sequence",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The OP to which this object belongs."
            },
            {
                "class": "Sequence",
                "name": "numBlocks",
                "type": "int",
                "set": "1",
                "text": "Get or set the total number of parameter blocks in this sequence."
            },
            {
                "class": "Sequence",
                "name": "maxBlocks",
                "type": "int",
                "set": "0",
                "text": "The maximum number of blocks allowed in the sequence, or None if limitless."
            },
            {
                "class": "Sequence",
                "name": "blocks",
                "type": "set",
                "set": "0",
                "text": "The set of all blocks in this sequence. A block is a set of parameters which can be repeated in an operator."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "An object describing a set of sequential parameter blocks. Accessed via the <code>sequence</code> member of [[Par Class|parameters]]. You can use any parameter inside the sequence to retreive it's <code>sequence</code> object.\n<syntaxhighlight lang=python>\nseq = op('/base1').par.iopshortcut1.sequence\t# get the sequence object\nprint(len(seq))\t\t\t\t\t\t\t\t\t# number of par blocks in the sequence\nprint(seq[0])\t\t\t\t\t\t\t\t\t# first par block in the sequence\nfor parBlock in seq:\n\tprint(parBlock)\t\t\t\t\t\t\t\t# print all par blocks\n\nseq.numBlocks += 1\t\t\t\t\t\t\t    # add a new block of parameters (same as pressing + in the UI)\n\n\n# A parameter block is a tuple of parameters that make up one block in a set of sequential parameters.\n</syntaxhighlight>"
    },
    "sequenceblendSOP": {
        "label": "sequenceblendSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "sequencerCHOP": {
        "label": "sequencerCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "serialCHOP": {
        "label": "serialCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "serialDAT": {
        "label": "serialDAT",
        "members": [],
        "methods": [
            {
                "text": "Send one or more sequence of bytes. No terminators are appended.\n*message - Messages can any combination of strings, byte arrays, or individual single-byte numeric values. To serialize non-byte values (example floats or integers) there are several python modules such as pickle or struct.\n<syntaxhighlight lang=python>\nn.sendBytes( 'TYPE', 23, 255, 12, 0x34, b'\\x01\\x00\\x02\\x00\\x03\\x00\\x00\\x00' )\n</syntaxhighlight>",
                "returns": "int",
                "name": "sendBytes",
                "call": "sendBytes(message1, message2...)",
                "class": "serialDAT"
            },
            {
                "call": "send(message1, message2... , terminator=' ')",
                "returns": "int",
                "text": "Send a sequence of strings through this connection.\n*message - One or more strings to write into the file.\n*terminator - (Keyword, Optional) Specifies how the message is to be terminated. If no append terminator is specified, a null character will automatically be appended to the message. To send no terminator, use terminator=''.\nThe number of bytes sent is returned.\n<syntaxhighlight lang=python>\nn.send('Hello', 'World',  terminator='\\r\\n') #send two strings with windows style newline termination.\n</syntaxhighlight>",
                "name": "send",
                "class": "serialDAT"
            }
        ],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "sharedmeminCHOP": {
        "label": "sharedmeminCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "sharedmeminCOMP": {
        "label": "sharedmeminCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "sharedmeminTOP": {
        "label": "sharedmeminTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "sharedmemoutCHOP": {
        "label": "sharedmemoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "sharedmemoutCOMP": {
        "label": "sharedmemoutCOMP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "ObjectCOMP",
            "COMP"
        ]
    },
    "sharedmemoutTOP": {
        "label": "sharedmemoutTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "shiftCHOP": {
        "label": "shiftCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "shiftCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "shuffleCHOP": {
        "label": "shuffleCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "skinSOP": {
        "label": "skinSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "sliderCOMP": {
        "label": "sliderCOMP",
        "members": [],
        "methods": [
            {
                "text": "Simulate a mouse click of the slider.\nIf only 1 value is given, it specifies the primary coordinate of the slider. (Either U or V, depending on its type). uOrV and v should be given in normalized coordinates. If two values are given, they specifies both the U and V coordinates.\n*uOrV - The first coordinate for the click to occur at. For V slider, this value will be treated as the V coordinate, and nothing needs to be passed into the v argument.\n*v - (Optional) The V coordinate to click at. This only needs to be passed if U is being specified in the first argument.\n*clickCount - (Keyword, Optional) Sets the number of clicks, for double clicking etc.\n*force - (Keyword, Optional) Forces the click to occur, even if the slider is disabled.\n*left,middle,right - (Keyword, Optional) Override the default mouse button used.  When none are set, the left mouse button is pressed, and the other buttons released.\n*vOnly - (Keyword, Optional) If True and only one coordinate is given on a UV slider, then update the V coordinate only.\n<syntaxhighlight lang=python>\nop('slider1').click(0.2) #Update U or V on a 1D slider.\nop('slider2').click(0.4, 0.5) #Update both U and V on a 2D slider.\nop('slider3').click(0.4, vOnly=True) #Update just V on a 2D slider.\n</syntaxhighlight>",
                "returns": "None",
                "name": "click",
                "call": "click(uOrV, v, clickCount=1, force=False, left=False, middle=False, right=False, vOnly=False)",
                "class": "sliderCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "PanelCOMP",
            "COMP"
        ]
    },
    "slopeCHOP": {
        "label": "slopeCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "slopeTOP": {
        "label": "slopeTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "SOP": {
        "label": "SOP",
        "members": [
            {
                "class": "SOP",
                "name": "compare",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Compare Flag]]."
            },
            {
                "class": "SOP",
                "name": "template",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Template Flag]]."
            },
            {
                "class": "SOP",
                "name": "points",
                "type": "td.Points",
                "set": "0",
                "text": "The set of [[Points Class|points]] contained in this SOP."
            },
            {
                "class": "SOP",
                "name": "prims",
                "type": "td.Prims",
                "set": "0",
                "text": "The set of [[Prims Class|primitives]] contained in this SOP."
            },
            {
                "class": "SOP",
                "name": "numPoints",
                "type": "int",
                "set": "0",
                "text": "The number of [[Points Class|points]] contained in this SOP."
            },
            {
                "class": "SOP",
                "name": "numVertices",
                "type": "int",
                "set": "0",
                "text": "The number of [[Vertex Class|vertices]] contained in all primitives within this SOP."
            },
            {
                "class": "SOP",
                "name": "numPrims",
                "type": "int",
                "set": "0",
                "text": "The number of [[Prims Class|primitivies]] contained in this SOP."
            },
            {
                "class": "SOP",
                "name": "pointAttribs",
                "type": "td.Attributes",
                "set": "0",
                "text": "The set of point [[Attributes Class|attributes]] defined in this SOP."
            },
            {
                "class": "SOP",
                "name": "primAttribs",
                "type": "td.Attributes",
                "set": "0",
                "text": "The set of primitive [[Attributes Class|attributes]] defined in this SOP."
            },
            {
                "class": "SOP",
                "name": "vertexAttribs",
                "type": "td.Attributes",
                "set": "0",
                "text": "The set of vertex [[Attributes Class|attributes]] defined in this SOP."
            },
            {
                "class": "SOP",
                "name": "pointGroups",
                "type": "dict",
                "set": "0",
                "text": "Returns a dictionary of point [[Group Class|groups]] defined for this SOP."
            },
            {
                "class": "SOP",
                "name": "primGroups",
                "type": "dict",
                "set": "0",
                "text": "Returns a dictionary of primitive [[Group Class|groups]] defined for this SOP."
            },
            {
                "class": "SOP",
                "name": "center",
                "type": "tdu.Position",
                "set": "1",
                "text": "Get or set the barycentric coordinate of this operator's geometry. It is expressed as a [[Position Class|Position]]."
            },
            {
                "class": "SOP",
                "name": "min",
                "type": "tdu.Position",
                "set": "0",
                "text": "The minimum coordinates of this operator's geometry along each dimension, expressed as a [[Position Class|Position]]."
            },
            {
                "class": "SOP",
                "name": "max",
                "type": "tdu.Position",
                "set": "0",
                "text": "The maximum coordinates of this operator's geometry along each dimension, expressed as [[Position Class|Position]]."
            },
            {
                "class": "SOP",
                "name": "size",
                "type": "tdu.Position",
                "set": "0",
                "text": "The size of this operator's geometry along each dimension, expressed as a [[Position Class|Position]]."
            },
            {
                "class": "SOP",
                "name": "isSOP",
                "type": "bool",
                "set": "0",
                "text": "True if the operator is a SOP."
            }
        ],
        "methods": [
            {
                "class": "SOP",
                "name": "computeBounds",
                "call": "computeBounds()",
                "returns": "Bounds",
                "text": "Returns an object with the bounds, center and size of the SOP's geometry. Keywords can be used to check if the correct render or display flags are set.",
                "deprecated": ""
            },
            {
                "class": "SOP",
                "name": "save",
                "call": "save(filepath, createFolders=False)",
                "returns": "filepath",
                "text": "Saves the geometry to the file system. Multiple file types are supported. Returns the filename and path saved.\n*filepath - (Optional) The path and filename to save to. If not given then a default filename will be used, and the file will be saved in the project.folder folder.\n*createFolders - (Keyword, Optional) If True, it creates the not existent directories provided by the filepath.\n<syntaxhighlight lang=python>\nname = n.save()   #save in native format with default name.\nn.save('output.bgeo')  #alternate format compatible with some other modelling packages.\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP"
        ],
        "summary": "A [[SOP]] describes a reference to a SOP operator, containing [[Points Class|points]] and [[Prims Class|primitives]]."
    },
    "soptoCHOP": {
        "label": "soptoCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "soptoDAT": {
        "label": "soptoDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "sortCHOP": {
        "label": "sortCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "sortDAT": {
        "label": "sortDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "sortSOP": {
        "label": "sortSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "speedCHOP": {
        "label": "speedCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "speedCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "sphereSOP": {
        "label": "sphereSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "spliceCHOP": {
        "label": "spliceCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "springCHOP": {
        "label": "springCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "springCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "springSOP": {
        "label": "springSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "spriteSOP": {
        "label": "spriteSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "ssaoTOP": {
        "label": "ssaoTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "stitchSOP": {
        "label": "stitchSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "stretchCHOP": {
        "label": "stretchCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "stretchCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "subdivideSOP": {
        "label": "subdivideSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "substanceselectTOP": {
        "label": "substanceselectTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "substanceTOP": {
        "label": "substanceTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "substituteDAT": {
        "label": "substituteDAT",
        "members": [
            {
                "set": "0",
                "text": "The current input [[Cell Class|cell]] being evaluated. From the [[Cell Class|cell]] you can get its row, column and value. e.g. me.inputCell.val or use the specific members listed below.",
                "type": "Cell",
                "class": "substituteDAT",
                "name": "inputCell"
            },
            {
                "set": "0",
                "text": "The current input colunn being evaluated.",
                "type": "Col",
                "class": "substituteDAT",
                "name": "inputCol"
            },
            {
                "set": "0",
                "text": "The current input row being evaluated.",
                "type": "Row",
                "class": "substituteDAT",
                "name": "inputRow"
            },
            {
                "set": "0",
                "text": "The current input [[DAT Class|DAT]] being evaluated.\n<syntaxhighlight lang=python>\nme.inputCell.val # value in cell\nme.inputTable[2,3].val # cell row 2, column 3\nme.inputTable[me.inputRow, me.inputCol-1].val # cell in previous column\nme.inputCell.offset(0, -1) # alternative syntax for previous column\n</syntaxhighlight>",
                "type": "OP",
                "class": "substituteDAT",
                "name": "inputTable"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "subtractTOP": {
        "label": "subtractTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "superquadSOP": {
        "label": "superquadSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "surfsectSOP": {
        "label": "surfsectSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "svgTOP": {
        "label": "svgTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "sweepSOP": {
        "label": "sweepSOP",
        "members": [
            {
                "set": "0",
                "text": "The current [[Vertex Class|vertex]] being evaluated, along the backbone input.",
                "type": "Vertex",
                "class": "sweepSOP",
                "name": "inputVertex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "switchCHOP": {
        "label": "switchCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "switchDAT": {
        "label": "switchDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "switchMAT": {
        "label": "switchMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "switchSOP": {
        "label": "switchSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "switchTOP": {
        "label": "switchTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "syncinCHOP": {
        "label": "syncinCHOP",
        "members": [
            {
                "set": "0",
                "text": "Get a Timecode object for the timecode data representation of the last received index. See [[Timecode Class]].",
                "type": "tdu.Timecode",
                "class": "syncinCHOP",
                "name": "timecode"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "syncoutCHOP": {
        "label": "syncoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "syphonspoutinTOP": {
        "label": "syphonspoutinTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "syphonspoutoutTOP": {
        "label": "syphonspoutoutTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "SysInfo": {
        "label": "SysInfo",
        "members": [
            {
                "class": "SysInfo",
                "name": "numCPUs",
                "type": "int",
                "set": "0",
                "text": "The number of CPUs/cores on the system."
            },
            {
                "class": "SysInfo",
                "name": "ram",
                "type": "float",
                "set": "0",
                "text": "Amount of available RAM memory."
            },
            {
                "class": "SysInfo",
                "name": "numMonitors",
                "type": "int",
                "set": "0",
                "text": "The number of monitors."
            },
            {
                "class": "SysInfo",
                "name": "xres",
                "type": "int",
                "set": "0",
                "text": "The system's current monitor resolution width."
            },
            {
                "class": "SysInfo",
                "name": "yres",
                "type": "int",
                "set": "0",
                "text": "The system's current monitor resolution height."
            },
            {
                "class": "SysInfo",
                "name": "tfs",
                "type": "str",
                "set": "0",
                "text": "The path to the TFS directory."
            },
            {
                "class": "SysInfo",
                "name": "MIDIInputs",
                "type": "list of str",
                "set": "0",
                "text": "A list of all MIDI Input device names."
            },
            {
                "class": "SysInfo",
                "name": "MIDIOutputs",
                "type": "list of str",
                "set": "0",
                "text": "A list of all MIDI Output device names."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "The SysInfo class describes current system information. '''Note:''' It can be accessed with the <syntaxhighlight lang=python inline=true>sysinfo</syntaxhighlight> object, found in the automatically imported [[td Module|td module]].\n<syntaxhighlight lang=python>\n# return the amount of available ram\nsysinfo.ram\n</syntaxhighlight>"
    },
    "tableCOMP": {
        "label": "tableCOMP",
        "members": [],
        "methods": [
            {
                "text": "Return the table row value, given a cell ID.\n*id - The cell id.  Usually taken from [[PanelValue Class|panel values]]: celloverid, cellfocusid, etc.",
                "returns": "int",
                "name": "getRowFromID",
                "call": "getRowFromID(id)",
                "class": "tableCOMP"
            },
            {
                "text": "Simulate a mouse click on a cell of the table. (0,0) is the top-left cell.\n*row, col - The row and column of the cell to click.\n*clickCount - (Keyword, Optional), Sets the number of clicks, for double clicking etc.\n*force - (Keyword, Optional) Forces the panel click, even if it's disabled.\n*left,middle,right - (Keyword, Optional) Override the default mouse button used.  When none are set to true, the left mouse button is pressed, and the other buttons released.\n<syntaxhighlight lang=python>\nop('table1').click(2,3) #row 2, column 3\n</syntaxhighlight>",
                "returns": "None",
                "name": "click",
                "call": "click(row, col, clickCount=1, force=False, left=False, middle=False, right=False)",
                "class": "tableCOMP"
            },
            {
                "text": "Return the table column value, given a cell ID.\n*id - The cell id.  Usually taken from [[PanelValue Class|panel values]]: celloverid, cellfocusid, etc.",
                "returns": "int",
                "name": "getColFromID",
                "call": "getColFromID(id)",
                "class": "tableCOMP"
            },
            {
                "text": "The same as the click method, except it uses a cell ID instead of the row/col to specify the cell to click.\n<syntaxhighlight lang=python>\nop('table1').clickID(5) # cell id 5\n</syntaxhighlight>",
                "returns": "None",
                "name": "clickID",
                "call": "clickID(id, clickCount=1, force=False, left=False, middle=False, right=False)",
                "class": "tableCOMP"
            },
            {
                "text": "Return the cell ID value, given a row and column.\n*row, col - The table component row and column of interest.",
                "returns": "int",
                "name": "getCellID",
                "call": "getCellID(row, col)",
                "class": "tableCOMP"
            },
            {
                "text": "Selects and sets the keyboard focus in a cell of the table if the cell is a field.\n*row, col -  The row and column of the cell to set the keyboard focus.\n*selectAll - (Keyword, Optional) If True, then all text will be selected.\n<syntaxhighlight lang=python>\nop('table1').select(0, 5) # row 0, column 5, do not select all text\n</syntaxhighlight>",
                "returns": "None",
                "name": "setKeyboardFocus",
                "call": "setKeyboardFocus(row, col, selectAll=False)",
                "class": "tableCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "PanelCOMP",
            "COMP"
        ]
    },
    "tableDAT": {
        "label": "tableDAT",
        "members": [
            {
                "class": "tableDAT",
                "name": "subRow",
                "type": "int",
                "set": "0",
                "text": "Current row index for Table expressions.",
                "deprecated": ""
            },
            {
                "class": "tableDAT",
                "name": "subCol",
                "type": "int",
                "set": "0",
                "text": "Current col index for Table expressions.",
                "deprecated": ""
            },
            {
                "class": "tableDAT",
                "name": "fillName",
                "type": "string",
                "set": "0",
                "text": "Current header name for Table expressions.",
                "deprecated": ""
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "tabletCHOP": {
        "label": "tabletCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "tcpipDAT": {
        "label": "tcpipDAT",
        "members": [],
        "methods": [
            {
                "class": "tcpipDAT",
                "name": "sendBytes",
                "call": "sendBytes(message1, message2...)",
                "returns": "int",
                "text": "Send one or more sequence of bytes. No terminators are appended.\n*message - Messages can any combination of strings, byte arrays, or individual single-byte numeric values. To serialize non-byte values (example floats or integers) there are several python modules such as pickle or struct.\n<syntaxhighlight lang=python>\nn.sendBytes( 'TYPE', 23, 255, 12, 0x34, b'\\x01\\x00\\x02\\x00\\x03\\x00\\x00\\x00' )\n</syntaxhighlight>"
            },
            {
                "class": "tcpipDAT",
                "name": "send",
                "call": "send(message1, message2... , terminator=' ')",
                "returns": "int",
                "text": "Send a sequence of strings through this connection.\n*message - One or more strings to send.\n*terminator - (Keyword, Optional) Specifies how the message is to be terminated. IIf no append terminator is specified, a null character will automatically be appended to the message. To send no terminator, use terminator=''.\nThe number of bytes sent is returned.\n<syntaxhighlight lang=python>\nn.send('Hello', 'World',  terminator='\\r\\n') # send two strings with windows style newline termination.\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "td": {
        "label": "td",
        "members": [
            {
                "class": "td",
                "name": "me",
                "type": "OP",
                "set": "0",
                "text": "Reference to the current [[OP Class|operator]] that is being executed or evaluated. This can be used in parameter expressions, or DAT scripts."
            },
            {
                "class": "td",
                "name": "absTime",
                "type": "absTime",
                "set": "0",
                "text": "Reference to the [[AbsTime Class|AbsTime]] object."
            },
            {
                "class": "td",
                "name": "app",
                "type": "app",
                "set": "0",
                "text": "Reference to the [[App Class|application]] installation."
            },
            {
                "class": "td",
                "name": "ext",
                "type": "ext",
                "set": "0",
                "text": "Reference to the extension searching object. See [[extensions]] for more information."
            },
            {
                "class": "td",
                "name": "families",
                "type": "dict",
                "set": "0",
                "text": "A dictionary containing a list of [[OP Class|operator]] types for each operator family. \n<syntaxhighlight lang=python>\nfor a in families['SOP']:\n\t# do something with a\n</syntaxhighlight>"
            },
            {
                "class": "td",
                "name": "licenses",
                "type": "licenses",
                "set": "0",
                "text": "Reference to the currently installed [[Licenses Class|licences]]."
            },
            {
                "class": "td",
                "name": "mod",
                "type": "mod",
                "set": "0",
                "text": "Reference to the [[MOD Class|Module On Demand]] object."
            },
            {
                "class": "td",
                "name": "monitors",
                "type": "monitors",
                "set": "0",
                "text": "Reference to the group of available [[Monitors Class|monitors]]."
            },
            {
                "class": "td",
                "name": "op",
                "type": "OP",
                "set": "0",
                "text": "The operator finder object, for accessing operators through paths or shortcuts. '''Note:''' a version of this method that searches relative to a specific operator is also in [[OP Class]].\n\n<code>op(pattern1, pattern2..., includeUtility=False) &rarr; [[OP Class|OP]] or None</code>\n<blockquote>\nReturns the first OP whose path matches the given pattern, relative to <code>root</code>. Will return None if nothing is found. Multiple patterns may be specified which are all added to the search. Numeric OP ids may also be used.\n* <code>pattern</code> - Can be string following the [[Pattern Matching]] rules, specifying which OP to return, or an integer, which must be an OP Id. Multiple patterns can be given, the first matching OP will be returned.\n* <code>includeUtility</code> '''(Optional)''' - if True, allow [[Network_Utilities:_Comments,_Network_Boxes,_Annotates|Utility nodes]] to be returned. If False, Utility operators will be ignored.\n\n<syntaxhighlight lang=python>\nb = op('project1')\nb = op('foot*', 'hand*')\nb = op(154)\n</syntaxhighlight>\n</blockquote>\n<code>op.shortcut &rarr; OP</code>\n<blockquote>\n:An operator specified with by a [[Global OP Shortcut]]. If no operator exists an exception is raised. These shortcuts are global, and must be unique. That is, cutting and pasting an operator with a Global OP Shortcut specified will lead to a name conflict. One shortcut must be renamed in that case. Furthermore, only components can be given Global OP Shortcuts.\n:*<code>shortcut</code> - Corresponds to the Global OP Shortcut parameter specified in the target operator.\n<syntaxhighlight lang=python>\nb = op.Videoplayer \n</syntaxhighlight>\nTo list all Global OP Shortcuts:\n<syntaxhighlight lang=python>\nfor x in op:\n\tprint(x)\n</syntaxhighlight>\n</blockquote>"
            },
            {
                "class": "td",
                "name": "parent",
                "type": "OP",
                "set": "0",
                "text": "The [[Parent Shortcut|Parent Shortcut]] object, for accessing parent components through indices or shortcuts.\n    \n'''Note:''' a version of this method that searches from a specific operator is also in [[OP Class]].\n\n<code>parent(n)  OP or None</code>\n\nThe nth parent of the current operator. If n not specified, returns the parent. If n = 2, returns the parent of the parent, etc. If no parent exists at that level, None is returned.\n*n - (Optional) n is the number of levels up to climb. When n = 1 it will return the operator's parent.\n<syntaxhighlight lang=python>\np = parent(2) #grandfather\n</syntaxhighlight>\n<code>parent.shortcut  OP</code>\n\nA parent component specified with a shortcut. If no parent exists an exception is raised.\n*shortcut - Corresponds to the [[Parent Shortcut]] parameter specified in the target parent.\n<syntaxhighlight lang=python>\n   n = parent.Videoplayer\n</syntaxhighlight>\nSee also Parent Shortcut for more examples."
            },
            {
                "class": "td",
                "name": "iop",
                "type": "OP",
                "set": "0",
                "text": "The Internal Operator Shortcut object, for accessing internal shortcuts.\n    \n'''Note:''' a version of this method that searches from a specific operator is also in [[OP Class]]."
            },
            {
                "class": "td",
                "name": "ipar",
                "type": "OP",
                "set": "0",
                "text": "The Internal Operator Parameter Shortcut object, for accessing internal shortcuts.\n    \n'''Note:''' a version of this method that searches from a specific operator is also in [[OP Class]]."
            },
            {
                "class": "td",
                "name": "project",
                "type": "project",
                "set": "0",
                "text": "Reference to the [[Project Class|project session]]."
            },
            {
                "class": "td",
                "name": "root",
                "type": "OP",
                "set": "0",
                "text": "Reference to the topmost root [[OP Class|operator]]."
            },
            {
                "class": "td",
                "name": "runs",
                "type": "runs",
                "set": "0",
                "text": "Reference to the [[Runs Class|runs]] object, which contains delayed executions."
            },
            {
                "class": "td",
                "name": "sysinfo",
                "type": "sysinfo",
                "set": "0",
                "text": "Reference to the [[SysInfo Class|system information]]."
            },
            {
                "class": "td",
                "name": "ui",
                "type": "ui",
                "set": "0",
                "text": "Reference to the [[UI Class|ui options]]."
            }
        ],
        "methods": [
            {
                "class": "td",
                "name": "ops",
                "call": "ops(pattern1, pattern2.., includeUtility=False)",
                "returns": "list",
                "text": "Returns a (possibly empty) list of OPs that match the patterns, relative to this OP.\nMultiple patterns may be provided. Numeric OP ids may also be used.\n*pattern - Can be string following the [[Pattern Matching]] rules, specifying which OPs to return, or an integer, which must be an OP Id. Multiple patterns can be given and all matched OPs will be returned.\nNote a version of this method that searches relative to an operator is also in the [[OP Class]].\n<syntaxhighlight lang=python>\nnewlist = n.ops('arm*', 'leg*', 'leg5/foot*')\n</syntaxhighlight>"
            },
            {
                "class": "td",
                "name": "passive",
                "call": "passive(OP)",
                "returns": "OP",
                "text": "Returns a passive version of the [[OP Class|operator]]. Passive OPs do not cook before their members are accessed."
            },
            {
                "class": "td",
                "name": "run",
                "call": "run(script, arg1, arg2..., endFrame=False, fromOP=None, asParameter=False, group=None, delayFrames=0, delayMilliSeconds=0, delayRef=me)",
                "returns": "Run",
                "text": "[[Run Class|Run]] the script, returning a [[Run Class|Run]] object which can be used to optionally modify its execution. This is most often used to run a script with a delay, as specified in the delayFrames or delayMilliSeconds arguments. See [[Run Command Examples]] for more info.\n*script - A string that is the script code to execute.\n*arg - (Optional) One or more arguments to be passed into the script when it executes. They are accessible in the script using a tuple named args.\n*endFrame - (Keyword, Optional) If True, the execution will be delayed until the end of the current frame.\n*fromOP - (Keyword, Optional) Specifies an optional [[OP Class|operator]] from which the execution will be run relative to.\n*asParameter - (Keyword, Optional) When fromOP used, run relative to a parameter of fromOP.\n*group - (Keyword, Optional) Can be used to specify a string label for the group of Run objects this belongs to. This label can then be used with the [[Runs Class|td.runs]] object to modify its execution.\n*delayFrames - (Keyword, Optional) The number of frames to wait before executing the script.\n*delayMilliSeconds - (Keyword, Optional) The number of milliseconds to wait before executing the script. This value is rounded to the nearest frame.\n*delayRef - (Keyword, Optional) Specifies an optional [[OP Class|operator]] from which the delay time is derived. You can use your own [[Time COMP|independent time component]] or <code>op.TDResources</code>, a built-in independent time component."
            },
            {
                "class": "td",
                "name": "fetchStamp",
                "call": "fetchStamp(key, default)",
                "returns": "value",
                "text": "Return an object from the global stamped parameters. If the item is not found, the default is returned instead. Parameters can be stamped with the [[Copy SOP]].\n*key - The name of the entry to retrieve.\n*default - If no item is found then the passed value is returned instead.\n<syntaxhighlight lang=python>\nv = fetchStamp('sides', 3)\n</syntaxhighlight>"
            },
            {
                "class": "td",
                "name": "var",
                "call": "var(varName)",
                "returns": "str",
                "text": "Find the value for the given [[Variables|variable]]."
            },
            {
                "class": "td",
                "name": "varExists",
                "call": "varExists(varName)",
                "returns": "bool",
                "text": "Returns true if the [[Variables|variable]] is defined."
            },
            {
                "class": "td",
                "name": "varOwner",
                "call": "varOwner(varName)",
                "returns": "OP or None",
                "text": "Returns the [[OP Class|operator]] that defines the [[Variables|variable]], or None if it's not defined."
            },
            {
                "class": "td",
                "name": "isMainThread",
                "call": "isMainThread()",
                "returns": "bool",
                "text": "Is True when called from the main application editing thread. Any calls that access operators, etc., must be called from the main thread."
            },
            {
                "class": "td",
                "name": "clear",
                "call": "clear()",
                "returns": "None",
                "text": "Clear the textport of all text."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The td module contains all TouchDesigner related Python classes and utilities. All td module members and methods are imported when the application launches and are automatically available in scripts, expressions, and the textport.<br><br>For additional helpful Python classes and utilities not directly related to TouchDesigner, see the [[Tdu Module]]"
    },
    "tdu": {
        "label": "tdu",
        "members": [
            {
                "class": "tdu",
                "name": "fileTypes",
                "type": "dict",
                "set": "0",
                "text": "A dictionary of all supported file types, organized by category.\n<syntaxhighlight lang=python>\n# example of various file types accepted by Movie File In TOP\ntdu.fileTypes['movie']\ntdu.fileTypes['image']\n</syntaxhighlight>\n<syntaxhighlight lang=python>\n# other file types\ntdu.fileTypes['audio']\n</syntaxhighlight>\nNote: Acceptable file types can be both uppercase and lowercase, so if <code>suffix</code> is a suffix string, you need to force it to lowercase by using <code>suffix.lower()</code>:\n<syntaxhighlight lang=python>\nfor suffix.lower() in tdu.fileTypes['movie']:\n\tprint(suffix)\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "Matrix",
                "type": "tdu.Matrix",
                "set": "0",
                "text": "The [[Matrix Class|Matrix]] definition class."
            },
            {
                "class": "tdu",
                "name": "Position",
                "type": "tdu.Position",
                "set": "0",
                "text": "The [[Position Class|Position]] definition class."
            },
            {
                "class": "tdu",
                "name": "Vector",
                "type": "tdu.Vector",
                "set": "0",
                "text": "The [[Vector Class|Vector]] definition class."
            },
            {
                "class": "tdu",
                "name": "Quaternion",
                "type": "tdu.Quaternion",
                "set": "0",
                "text": "The [[Quaternion Class|Quaternion]] definition class."
            },
            {
                "class": "tdu",
                "name": "Color",
                "type": "tdu.Color",
                "set": "0",
                "text": "The [[Color Class|Color]] definition class."
            },
            {
                "class": "tdu",
                "name": "Dependency",
                "type": "tdu.Dependency",
                "set": "0",
                "text": "The [[Dependency Class|Dependency]] definition class."
            },
            {
                "class": "tdu",
                "name": "FileInfo",
                "type": "tdu.FileInfo",
                "set": "0",
                "text": "The FileInfo object takes a file path and has a few utility properties to provide additional information. It is derived from str, so will work as a Python string, but can be differentiated from a regular string by using <code>isinstance(tdu.FileInfo)</code>.\nUtility properties include:\n*path: filepath string\n*ext: string after and including \".\"\n*fileType: the TD filetype (from tdu.fileTypes)\n*absPath: the absolute path to filepath\n*dir: the containing directory of filepath\n*exists: exists in file-system\n*isDir: is a directory in the file-system\n*isFile: is a file in the file-system\n*baseName: the name of the final element in the path"
            },
            {
                "class": "tdu",
                "name": "ArcBall",
                "type": "tdu.ArcBall",
                "set": "0",
                "text": "The [[ArcBall Class|ArcBall]] definition class."
            },
            {
                "class": "tdu",
                "name": "Camera",
                "type": "tdu.Camera",
                "set": "0",
                "text": "The [[Camera Class|Camera]] definition class.",
                "deprecated": ""
            },
            {
                "class": "tdu",
                "name": "debug",
                "type": "module",
                "set": "0",
                "text": "Helper module for the builtin debug statement. [[Debug_module|Documentation.]]"
            }
        ],
        "methods": [
            {
                "class": "tdu",
                "name": "rand",
                "call": "rand(seed)",
                "returns": "float",
                "text": "Return a random value in the range [0.0, 1.0) given the input seed value. That is, it will never return 1.0, but it may return 0.0. For a given seed, it will always return the same random number. The seed does not need to be a number. If the seed is not numeric, it resolves it to its string representation to produce a unique value. In the case of OPs for example, its string representation is a constant path. Thus one can produce a unique random value for each OP which remains the same for that OP each time you reload TouchDesigner.\n<syntaxhighlight lang=python>\ntdu.rand(me) # return a specific random number based on path\ntdu.rand(5) # return a specific random number\ntdu.rand(absTime.frame) # return a different number every frame\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "clamp",
                "call": "clamp(inputVal, min, max)",
                "returns": "val",
                "text": "Returns the input value clamped between min and max values. Arguments can be any type that can be compared (float, int, str, etc)."
            },
            {
                "class": "tdu",
                "name": "remap",
                "call": "remap(inputVal, fromMin, fromMax, toMin, toMax)",
                "returns": "float",
                "text": "Returns the input value remapped from the first range to the second.\n<syntaxhighlight lang=python>\ntdu.remap(0.5, 0, 1,  -180, 180)  #remap slider value to angle range\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "base",
                "call": "base(str)",
                "returns": "str",
                "text": "Returns the beginning portion of the string occurring before any digits. The search begins after the last slash if any are present.\n*str - The string to extract the base name from.\n<syntaxhighlight lang=python>\ntdu.base('arm123') # returns 'arm'\ntdu.base('arm123/leg456') # returns 'leg'\n</syntaxhighlight>\nNote this method will work on any string, but when given a specific operator, its more efficient to use its local base member:\n<syntaxhighlight lang=python>\nn = op('arm123/leg456')\nb = n.base #returns 'leg'\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "digits",
                "call": "digits(str)",
                "returns": "int or None",
                "text": "Returns the numeric value of the last consecutive group of digits in the string, or None if not found. The search begins after the last slash if any are present. The digits do not nessearily need to be at the end of the string.\n<syntaxhighlight lang=python>\ntdu.digits('arm123') # returns 123\ntdu.digits('arm123/leg456') # returns 456\ntdu.digits('arm123/leg') # returns None, searching is only done after the last /\ntdu.digits('arm123/456leg') # returns 456\n</syntaxhighlight>\nNote this method will work on any string, but when given a specific operator, its more efficient to use its local digits member:\n<syntaxhighlight lang=python>\nn = op('arm123/leg456')\nd = n.digits # returns 456\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "validName",
                "call": "validName(str)",
                "returns": "str",
                "text": "Returns a version of the string suitable for an operator name. Converts illegal characters to underscores.\n    Slashes are converted to underscores. To preserve forward slashes, use validPath() instead.\n<syntaxhighlight lang=python>\ntdu.validName('a#bc def') # returns 'a_bc_def'\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "validPath",
                "call": "validPath(str)",
                "returns": "str",
                "text": "Returns a version of the string suitable for an operator path, including slashes. Converts illegal characters to underscores.\n<syntaxhighlight lang=python>\ntdu.validPath('/a#bc d/ef') # returns '/a_bc_d/ef'\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "expand",
                "call": "expand(pattern)",
                "returns": "list",
                "text": "Return a list of the expanded items, following the rules of [[Pattern Expansion]].\n<syntaxhighlight lang=python>\ntdu.expand('A[1-3] B[xyz]') # return ['A1', 'A2', 'A3', 'Bx', 'By', 'Bz']\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "expandPath",
                "call": "expandPath(path)",
                "returns": "str",
                "text": "Expand the file path, using project.paths, the current folder, and any other relevant information.\n<syntaxhighlight lang=python>\ntdu.expandPath('movies:/test.bmp') # looks at project.paths for 'movies' entry.\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "collapsePath",
                "call": "collapsePath(path, asExpression=False)",
                "returns": "str",
                "text": "Collapse the file path, using project.paths, the current folder, and any other relevant information.\n<syntaxhighlight lang=python>\ntdu.collapsePath('C:/downloads/test.bmp') # looks at project.paths for any entries matching the path, and removes current folder from prefix.\n</syntaxhighlight>\n*path - The path to be shortened.\n*asExpression  - (Keyword, Optional) If True, result can be used as an expression, including [[App Class]] members and quoted strings."
            },
            {
                "class": "tdu",
                "name": "split",
                "call": "split(string, eval=False)",
                "returns": "list",
                "text": "Return a list from a space separated string, allowing quote delimiters.\n*string - Any Python object, as it will be evaluated as str(string). Parameters will work.\n*eval - (Keyword, Optional) If True convert any valid Python literal structures: strings, numbers, tuples, lists, dicts, booleans, and None.\n<syntaxhighlight lang=python>\nsplit('1 2.3 None fred \"one \\'2\\'\" \"[1,2]\"') #yields ['1', '2.3', 'None', 'fred', \"one '2'\", '[1, 2]']\nsplit('1 2.3 None fred \"one \\'2\\'\" \"[1,2]\"', True) #yields [1, 2.3, None, 'fred', \"one '2'\", [1, 2]]\n</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "match",
                "call": "match(pattern, inputList, caseSensitive=True)",
                "returns": "list",
                "text": "Return a subset of inputList, in which each element matches the pattern. Wildcards are supported.\n<syntaxhighlight lang=python>tdu.match('foo*', ['foo', 'bar']) # return ['foo']\ntdu.match('ba?', ['foo', 'bar']) # return ['bar']</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "calibrateCamera",
                "call": "calibrateCamera()",
                "returns": "None",
                "text": "Returns a set of values based on the input calibration data. This Method is not necessary anymore due to the inclusion of [[openCV]] in TouchDesigner. Refer to [http://docs.opencv.org/3.1.0/d4/d94/tutorial_camera_calibration.html OpenCV Documentation]"
            },
            {
                "class": "tdu",
                "name": "forceCrash",
                "call": "forceCrash()",
                "returns": "None",
                "text": "forces a crash for debugging and crash recovery purposes"
            },
            {
                "class": "tdu",
                "name": "tryExcept",
                "call": "tryExcept(func1, func2 or val)",
                "returns": "result",
                "text": "Evaluate the first function (func1). If an exception is raised, return second argument instead. Second argument can be either a function that is a called, or a final result. '''Note:''' If the second argument is a function, it is only called if the first function fails.\n    \nThis is a one-liner try/except function for use in parameter expressions to handle simple errors. '''Tip:''' always be careful when hiding errors with try/except, because it can make real problems in your code/network invisible.\n<syntaxhighlight lang=python>\n    tdu.tryExcept(lambda: 1/me.par.w, 0.0) # second argument is simply 0.0\n    tdu.tryExcept(lambda: 1/me.par.w, me.GetDefaultValue)   # Good:  me.GetDefaultValue not called until needed.\n    tdu.tryExcept(lambda: 1/me.par.w, me.GetDefaultValue()) # >> INCORRECT <<.  Always calls second function even if not needed.</syntaxhighlight>"
            },
            {
                "class": "tdu",
                "name": "ParMenu",
                "call": "ParMenu(menuNames, menuLabels=None)",
                "returns": "menuSource object",
                "text": "This method uses a list of strings to create an object meant to be used as a [[Par Class|parameter]] menu source. \n*menuNames - A list of strings for menu values.\n*menuLabels - (Optional) A list of strings for menu labels. Defaults to menuNames."
            },
            {
                "class": "tdu",
                "name": "TableMenu",
                "call": "TableMenu(table, nameCol=0, labelCol=None, includeFirstRow=False)",
                "returns": "object suitable for menuSource property of parameters",
                "text": "Create a parameter menu source object based on a DAT table.\n    \nThis method uses a table to create an object meant to be used as a [[Par Class|parameter]] menu source. \n*table - a DAT table to get the menu information from\n*nameCol - (Keyword, Optional) Column name or number for menuNames. Defaults to 0.\n*labelCol - (Keyword, Optional) Column name or number for menuLabels. Defaults to None, which means to use names as labels.\n*includeFirstRow - (Keyword, Optional) if True, include first row of table in menu entries. Defaults to False.\n\nGenerally you will use this in the menuSource field in the Component Editor as follows\n<syntaxhighlight lang=python>\n    tdu.TableMenu(op('table1')) # use the first column of table1 as a list of menu names and labels \n    tdu.TableMenu(op('table2'), nameCol='names', labelCol='labels') # from table2, use the column labeled 'names' as menu names, and the column labeled 'labels' as menu names\n    tdu.TableMenu(op('table3'), labelCol=1, includeFirstRow=True) # from table3, use the first column as menu names and the second column as menu labels. Include the first row of the table in those lists\n</syntaxhighlight>"
            }
        ],
        "subclasses": {
            "Timecode": {
                "label": "Timecode",
                "members": [
                    {
                        "class": "tdu.Timecode",
                        "name": "countdown",
                        "type": "tdu.Timecode",
                        "set": "0",
                        "text": "Return a Timecode Object of the difference between the length and the current time. If a custom length is not specified then it will use a default: 23:59:59:ff for SMPTE and 99:59:59:ff."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "dropFrame",
                        "type": "bool",
                        "set": "0",
                        "text": "True if the Timecode is drop-frame, False otherwise."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "fps",
                        "type": "float",
                        "set": "0",
                        "text": "Get or set the framerate (in frames per second) of the Timecode."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "frame",
                        "type": "int",
                        "set": "0",
                        "text": "The Timecode frame: 0 to fps-1"
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "hour",
                        "type": "int",
                        "set": "0",
                        "text": "The Timecode hour: 0 to 99 if non-SMPTE, 0 to 23 otherwise."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "minute",
                        "type": "int",
                        "set": "0",
                        "text": "The Timecode minute: 0 to 59."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "second",
                        "type": "int",
                        "set": "0",
                        "text": "The Timecode second: 0 to 59."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "negative",
                        "type": "bool",
                        "set": "0",
                        "text": "True if the Timecode is negative, and False otherwise. Always False if the Timecode is following SMPTE standard."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "smpte",
                        "type": "bool",
                        "set": "0",
                        "text": "True if the Timecode is SMPTE standard, and False otherwise. SMPTE Timecodes cannot be negative and cannot exceed 24 hours."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "text",
                        "type": "string",
                        "set": "0",
                        "text": "Get the text format of the Timecode."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "totalFrames",
                        "type": "int",
                        "set": "0",
                        "text": "The total number of Timecode frames, which is calculated from the hour, minute, second, frame values. Whether or not the Timecode is drop frame will also affect the value."
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "totalSeconds",
                        "type": "float",
                        "set": "0",
                        "text": "The total number of Timecode seconds, which is calculated from the hour, minute, second, frame values. Whether or not the Timecode is drop frame will also affect the value."
                    }
                ],
                "methods": [
                    {
                        "class": "tdu.Timecode",
                        "name": "setComponents",
                        "call": "setComponents(hour, minute, second, frame, negative=False, fps=None)",
                        "returns": "None",
                        "text": "Set the Timecode from individual time components.\n* hour - The new hour value.\n* minute - The new minute value.\n* second - The new second value.\n* frame - The new frame value.\n* negative (Keyword, Optional) - Whether the new Timecode is negative, False by default.\n* fps (Keyword, Optional) - The Timecode's FPS. If not specified then the FPS will not change.\n<syntaxhighlight lang=python>\nn.setComponents(12, 22, 33, 45, negative=True, fps=60) -> new Timecode will be -12:22:33:45.\n</syntaxhighlight>"
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "setString",
                        "call": "setString(timecodeStr, fps=None)",
                        "returns": "None",
                        "text": "Set the Timecode from a string formated as [-]hh:mm:ss:ff.\n* timecodeStr - The string in the format: [-]hh:mm:ss:ff.\n* fps (Keyword, Optional) - The Timecode's FPS. If not specified then the FPS will not change.\n<syntaxhighlight lang=python>\nn.setString('01:01:00:00', fps=60)\n</syntaxhighlight>"
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "setTotalFrames",
                        "call": "setTotalFrames(totalFrames, fps=None)",
                        "returns": "None",
                        "text": "Set the Timecode to a single integer value representing the new total frames.\n* totalFrames - The new total frame value.\n* fps (Keyword, Optional) - The Timecode's FPS. If not specified then the FPS will not change.\n<syntaxhighlight lang=python>\nn.setTotalFrames(120, fps=60) # new Timecode will be 00:00:02:00\n</syntaxhighlight>"
                    },
                    {
                        "class": "tdu.Timecode",
                        "name": "setLength",
                        "call": "setLength(length)",
                        "returns": "None",
                        "text": "Set Timecode to a custom length. Useful in conjunction with countdown.\n* length - The new length, either a total frame value or a Timecode Object. Must be above 0.\n<syntaxhighlight lang=python>\nn.setLength(600) # sets the length to 10 seconds for a Timecode with 60 FPS.\n</syntaxhighlight>"
                    }
                ],
                "subclasses": {},
                "inherits": [],
                "summary": "The Timecode class holds a timecode value.\n* str (Optional) - Initializes the Timecode object from a Timecode formatted String: ie. hh:mm:ss:ff or hh:mm:ss.ff\t\n* fps - (Keyword, Optional) Initialize the Timecode object with the specified fps. If not specified it will be initialized with the rate of the local time.\n* hour - (Keyword, Optional) Specify the hour. Should be left blank if a String arg is provided. 0 by default.\n* minute - (Keyword, Optional) Specify the minute. Should be left blank if a String arg is provided. 0 by default.\n* second - (Keyword, Optional) Specify the second. Should be left blank if a String arg is provided. 0 by default.\n* frame - (Keyword, Optional) Specify the frame. Should be left blank if a String arg is provided. 0 by default.\n* negative - (Keyword, Optional) Specify whether the Timecode is negative. Should be left blank if a String arg is provided. False by default.\n* smpte - (Keyword, Optional) Specify whether the Timecode is SMPTE standard. True by default.\n<syntaxhighlight lang=python>\nt = tdu.Timecode() # 00:00:00:00 with fps=me.time.rate\t\nt2 = tdu.Timecode('01:11:11:15', fps=30) # 01:11:11:15 with fps=30\nt3 = tdu.Timecode(frame=185, fps=30) # 00:00:06:05 with fps=30\nt4 = tdu.Timecode(hour=1, minute=2, second=3, frame=4, negative=True, fps=30) # -01:02:03:04 with fps=30\n</syntaxhighlight>",
                "inherit": "",
                "parent": ""
            }
        },
        "inherits": [],
        "summary": "The <code>tdu</code> module is a generic utility module containing all miscellaneous functions that don't refer specifically to TouchDesigner data structures.  <code>tdu</code> is imported by default when the application launches."
    },
    "textDAT": {
        "label": "textDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "TextLine": {
        "label": "TextLine",
        "members": [
            {
                "class": "TextLine",
                "name": "glyph",
                "type": "int",
                "set": "0",
                "text": "The index of the glyph that represents this text line."
            },
            {
                "class": "TextLine",
                "name": "fontIndex",
                "type": "int",
                "set": "0",
                "text": "The index of the font that the glyph belongs to. Glyphs are not interchangable between fonts."
            },
            {
                "class": "TextLine",
                "name": "text",
                "type": "str",
                "set": "0",
                "text": "The text for this line."
            },
            {
                "class": "TextLine",
                "name": "origin",
                "type": "tdu.Position",
                "set": "0",
                "text": "A tdu.Position object that gives the baseline origin of the line of text."
            },
            {
                "class": "TextLine",
                "name": "lineWidth",
                "type": "float",
                "set": "0",
                "text": "The width of the format box of this line of text."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "A line of text in the [[Text TOP]] or [[Text SOP]], after it has been formatted. Contains various members about the line such as it's text, position etc.\""
    },
    "Textport": {
        "label": "Textport",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "This class defines the interface to a texport interface..",
        "inherit": "",
        "parent": ""
    },
    "textSOP": {
        "label": "textSOP",
        "members": [
            {
                "set": "0",
                "text": "Get the number of lines of the outputted text, after operations such as word-wrap have been applied.",
                "type": "int",
                "class": "textSOP",
                "name": "numLines"
            },
            {
                "set": "0",
                "text": "The ascender of the font, as described by the font's metrics.",
                "type": "float",
                "class": "textSOP",
                "name": "ascender"
            },
            {
                "set": "0",
                "text": "The descender of the font, as described by the font's metrics.",
                "type": "float",
                "class": "textSOP",
                "name": "descender"
            },
            {
                "set": "0",
                "text": "The cap height of the font, as described by the font's metrics. This is usually the height of a capital H.",
                "type": "float",
                "class": "textSOP",
                "name": "capHeight"
            },
            {
                "set": "0",
                "text": "The x height of the font, as described by the font's metrics. This is usually the height of a lower case x.",
                "type": "float",
                "class": "textSOP",
                "name": "xHeight"
            },
            {
                "set": "0",
                "text": "The suggested gap between lines, as described by the font's metrics.",
                "type": "float",
                "class": "textSOP",
                "name": "lineGap"
            },
            {
                "set": "0",
                "text": "The number of glyphs that were generated. Note that this isn't nessesarily the number of characters (code points) in the original string.",
                "type": "int",
                "class": "textSOP",
                "name": "numGlyphs"
            }
        ],
        "methods": [
            {
                "text": "Returns True if every character maps to a glyph. This doesn't mean the font supports the language in all cases. Glyphs that come from ligatures etc. may still be missing from the font.\n*str - The string to be analyzed.",
                "returns": "bool",
                "name": "fontSupportsChars",
                "call": "fontSupportsChars(str)",
                "class": "textSOP"
            },
            {
                "text": "Get the number of lines of the outputted text, after operations such as word-wrap have been applied.",
                "returns": "list TextLine",
                "name": "lines",
                "call": "lines()",
                "class": "textSOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "textTOP": {
        "label": "textTOP",
        "members": [
            {
                "set": "0",
                "text": "Current text contents, when used with a [[Field COMP]].",
                "type": "str",
                "class": "textTOP",
                "name": "curText"
            },
            {
                "set": "1",
                "text": "Get or set cursor end position, when used with a [[Field COMP]].",
                "type": "int",
                "class": "textTOP",
                "name": "cursorEnd"
            },
            {
                "set": "1",
                "text": "Get or set cursor start position, when used with a [[Field COMP]].",
                "type": "int",
                "class": "textTOP",
                "name": "cursorStart"
            },
            {
                "set": "0",
                "text": "The descender of the current font, in pixels. This is the distance from the baseline to the bottom of lowest hanging character in the font. This value does not change based on the currently displayed text.",
                "type": "int",
                "class": "textTOP",
                "name": "fontDescender",
                "deprecated": "True"
            },
            {
                "set": "0",
                "text": "Selected contents, when used with a [[Field COMP]].",
                "type": "str",
                "class": "textTOP",
                "name": "selectedText"
            },
            {
                "set": "0",
                "text": "Calculated height of text, in pixels. This value does '''not''' changes based on the particular of characters in the string. It only depends on the number of lines, line spacing, positioning and font metrics of the font.",
                "type": "int",
                "class": "textTOP",
                "name": "textHeight"
            },
            {
                "set": "0",
                "text": "Calculated width of text, in pixels. This value '''does''' change depending on the particular characters in the string. Different characters have difference advance widths, and this value is the sum of all the advance widths of the characters.",
                "type": "int",
                "class": "textTOP",
                "name": "textWidth"
            },
            {
                "set": "0",
                "text": "Get the number of lines of the outputted text, after operations such as word-wrap have been applied.",
                "type": "int",
                "class": "textTOP",
                "name": "numLines"
            },
            {
                "set": "0",
                "text": "The ascender of the font, as described by the font's metrics.",
                "type": "float",
                "class": "textTOP",
                "name": "ascender"
            },
            {
                "set": "0",
                "text": "The descender of the font, as described by the font's metrics.",
                "type": "float",
                "class": "textTOP",
                "name": "descender"
            },
            {
                "set": "0",
                "text": "The cap height of the font, as described by the font's metrics. This is usually the height of a capital H.",
                "type": "float",
                "class": "textTOP",
                "name": "capHeight"
            },
            {
                "set": "0",
                "text": "The x height of the font, as described by the font's metrics. This is usually the height of a lower case x.",
                "type": "float",
                "class": "textTOP",
                "name": "xHeight"
            },
            {
                "set": "0",
                "text": "The suggested gap between lines, as described by the font's metrics.",
                "type": "float",
                "class": "textTOP",
                "name": "lineGap"
            }
        ],
        "methods": [
            {
                "text": "Returns True if every character maps to a glyph. This doesn't mean the font supports the language in all cases. Glyphs that come from ligatures etc. may still be missing from the font.\n*str - The string to be analyzed.",
                "returns": "bool",
                "name": "fontSupportsChars",
                "call": "fontSupportsChars(str)",
                "class": "textTOP"
            },
            {
                "text": "Evaluates the width and height of the given string using the operators settings.  Does not include the word wrap and auto size font options.\n*str - The string to be measured.",
                "returns": "tuple(width, height)",
                "name": "evalTextSize",
                "call": "evalTextSize(str)",
                "class": "textTOP"
            },
            {
                "text": "Returns a list of [[TextLine Class]] objects. This list of lines is formed after operations such as word-wrap have been applied.",
                "returns": "list TextLine",
                "name": "lines",
                "call": "lines()",
                "class": "textTOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "texture3dTOP": {
        "label": "texture3dTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "textureSOP": {
        "label": "textureSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "thresholdTOP": {
        "label": "thresholdTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "tileTOP": {
        "label": "tileTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "timeCOMP": {
        "label": "timeCOMP",
        "members": [
            {
                "set": "1",
                "text": "Get or set the current frame output by this component.",
                "type": "float",
                "class": "timeCOMP",
                "name": "frame"
            },
            {
                "set": "1",
                "text": "Get or set the current time output by this component (expressed in seconds).",
                "type": "float",
                "class": "timeCOMP",
                "name": "seconds"
            },
            {
                "set": "1",
                "text": "Get or set the frames per second, (or rate).",
                "type": "float",
                "class": "timeCOMP",
                "name": "rate"
            },
            {
                "set": "1",
                "text": "Get or set whether the component is playing.",
                "type": "bool",
                "class": "timeCOMP",
                "name": "play"
            },
            {
                "set": "1",
                "text": "Get or set the current timecode generated by this component.",
                "type": "str",
                "class": "timeCOMP",
                "name": "timecode"
            },
            {
                "set": "1",
                "text": "Get or set start of main frame range.",
                "type": "float",
                "class": "timeCOMP",
                "name": "start"
            },
            {
                "set": "1",
                "text": "Get or set end of main frame range.",
                "type": "float",
                "class": "timeCOMP",
                "name": "end"
            },
            {
                "set": "1",
                "text": "Get or set start of sub frame range. Must be within main start, end range",
                "type": "float",
                "class": "timeCOMP",
                "name": "rangeStart"
            },
            {
                "set": "1",
                "text": "Get or set end of sub frame range. Must be within main start, end range.",
                "type": "float",
                "class": "timeCOMP",
                "name": "rangeEnd"
            },
            {
                "set": "1",
                "text": "Get or set whether the timeline loops.",
                "type": "bool",
                "class": "timeCOMP",
                "name": "loop"
            },
            {
                "set": "1",
                "text": "Get or set whether the timeline runs independently of other timelines.",
                "type": "float",
                "class": "timeCOMP",
                "name": "independent"
            },
            {
                "set": "1",
                "text": "Get or set beats per minute.",
                "type": "float",
                "class": "timeCOMP",
                "name": "tempo"
            },
            {
                "set": "1",
                "text": "Get or set time signature, first value.",
                "type": "int",
                "class": "timeCOMP",
                "name": "signature1"
            },
            {
                "set": "1",
                "text": "Get or set time signature, second value.",
                "type": "int",
                "class": "timeCOMP",
                "name": "signature2"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "COMP"
        ]
    },
    "timelineCHOP": {
        "label": "timelineCHOP",
        "members": [
            {
                "set": "0",
                "text": "Get a Timecode object for the timecode data representation of the current timeline frame. See [[Timecode Class]].",
                "type": "tdu.Timecode",
                "class": "timelineCHOP",
                "name": "timecode"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "timemachineTOP": {
        "label": "timemachineTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "timerCHOP": {
        "label": "timerCHOP",
        "members": [
            {
                "set": "0",
                "text": "Get a list of begin values in frames. 0-based.",
                "type": "list",
                "class": "timerCHOP",
                "name": "beginFrame"
            },
            {
                "set": "0",
                "text": "Get a list of begin values in samples. 0-based.",
                "type": "list",
                "class": "timerCHOP",
                "name": "beginSample"
            },
            {
                "set": "0",
                "text": "Get a list of begin values in seconds.",
                "type": "list",
                "class": "timerCHOP",
                "name": "beginSeconds"
            },
            {
                "set": "0",
                "text": "Get the cumulative time expressed in frames. See <code>.cumulativeSeconds</code>.",
                "type": "int",
                "class": "timerCHOP",
                "name": "cumulativeFrames"
            },
            {
                "set": "0",
                "text": "Get the cumulative time expressed in samples. See <code>.cumulativeSeconds</code>.",
                "type": "int",
                "class": "timerCHOP",
                "name": "cumulativeSample",
                "deprecated": "True"
            },
            {
                "set": "0",
                "text": "Get the cumulative time expressed in samples. See <code>.cumulativeSeconds</code>.",
                "type": "int",
                "class": "timerCHOP",
                "name": "cumulativeSamples"
            },
            {
                "set": "0",
                "text": "Get the cumulative time expressed in seconds. It counts from 0 when you Start. Unlike <code>.runningSeconds</code>, it is slowed/sped by the Speed parameter, and paused by the Play parameter. It continues to increase if there is any looping, jumping or scrubbing around.",
                "type": "float",
                "class": "timerCHOP",
                "name": "cumulativeSeconds"
            },
            {
                "set": "0",
                "text": "Get the cumulative time as a Timecode Object. See [[Timecode Class]]. See <code>.cumulativeSeconds</code>.",
                "type": "tdu.Timecode",
                "class": "timerCHOP",
                "name": "cumulativeTimecode"
            },
            {
                "set": "1",
                "text": "Get or set the master time expressed in frames. 0-based. See <code>.masterSeconds</code>.",
                "type": "int",
                "class": "timerCHOP",
                "name": "masterFrames"
            },
            {
                "set": "1",
                "text": "Get or set the master time expressed in frames. 0-based. See <code>.masterSeconds</code>.",
                "type": "int",
                "deprecated": "True",
                "class": "timerCHOP",
                "name": "masterFrame"
            },
            {
                "set": "1",
                "text": "Get or set the master time expressed in samples. See <code>.masterSeconds</code>.",
                "type": "int",
                "class": "timerCHOP",
                "name": "masterSamples"
            },
            {
                "set": "1",
                "text": "Get or set the master time expressed in samples. See <code>.masterSeconds</code>.",
                "type": "int",
                "deprecated": "True",
                "class": "timerCHOP",
                "name": "masterSample"
            },
            {
                "set": "1",
                "text": "Get or set the master time expressed in seconds. It counts from 0 when you Start, <code>.masterSeconds</code> is slowed/sped by the Speed parameter, and paused by the Play parameter. It jumps to the appropriate time when you scrub. This is the main clock in the Timer CHOP and can be set directly using python (<code>OP.masterSeconds = ''val''</code>), or use the <code>.goTo()</code> function which has more options. When multi-segments are specified to the Timer CHOP, it reflects the time as if you ran through the segments without interrupting it. If in any segment Cycle is on and Cycle Limit is off, it calculates as if the cycle runs only once.",
                "type": "float",
                "class": "timerCHOP",
                "name": "masterSeconds"
            },
            {
                "set": "1",
                "text": "Get or set the master time expressed in fractional form. See <code>.masterSeconds</code>.",
                "type": "float",
                "class": "timerCHOP",
                "name": "masterFraction"
            },
            {
                "set": "1",
                "text": "Get or set the master time expressed as a Timecode Object. See [[Timecode Class]]. See <code>.masterSeconds</code>.",
                "type": "tdu.Timecode",
                "class": "timerCHOP",
                "name": "masterTimecode"
            },
            {
                "set": "1",
                "text": "Get or set the cycle index of the current segment.",
                "type": "float",
                "class": "timerCHOP",
                "name": "cycle"
            },
            {
                "set": "0",
                "text": "Get the time index in fractional form, same as the <code>timer_fraction</code> channel. Used in the callbacks, it's more up-to-date to the current frame. (When using segments, it's the first segment).",
                "type": "float",
                "class": "timerCHOP",
                "name": "fraction"
            },
            {
                "set": "0",
                "text": "Get the playing time expressed in frames. 0-based. See <code>.playingSeconds</code>.",
                "type": "int",
                "class": "timerCHOP",
                "name": "playingFrames"
            },
            {
                "set": "0",
                "text": "Get the playing time expressed in samples. See <code>.playingSeconds</code>.",
                "type": "int",
                "class": "timerCHOP",
                "name": "playingSample",
                "deprecated": "True"
            },
            {
                "set": "0",
                "text": "Get the playing time expressed in samples. See <code>.playingSeconds</code>.",
                "type": "int",
                "class": "timerCHOP",
                "name": "playingSamples"
            },
            {
                "set": "0",
                "text": "Get the playing time expressed in seconds. It counts from 0 when you Start. it is unaffected by the Speed parameter, but unlike <code>.runningSeconds</code>, it is paused by the Play parameter. It continues to increase if there is any looping, jumping or scrubbing around.",
                "type": "float",
                "class": "timerCHOP",
                "name": "playingSeconds"
            },
            {
                "set": "0",
                "text": "Get the playing time as a Timecode Object. See [[Timecode Class]]. See <code>.playingSeconds</code>.",
                "type": "tdu.Timecode",
                "class": "timerCHOP",
                "name": "playingTimecode"
            },
            {
                "set": "1",
                "text": "Get the running time index expressed in fractional form. See <code>.runningSeconds</code>. This will be an estimate as the actual length is approximated on start.",
                "type": "float",
                "class": "timerCHOP",
                "name": "runningFraction"
            },
            {
                "set": "1",
                "text": "Get the running time expressed in frames. 0-based. See <code>.runningSeconds</code>.",
                "type": "float",
                "class": "timerCHOP",
                "name": "runningFrames"
            },
            {
                "set": "1",
                "text": "Get the running time expressed in frames. 0-based. See <code>.runningSeconds</code>.",
                "type": "float",
                "class": "timerCHOP",
                "deprecated": "True",
                "name": "runningFrame"
            },
            {
                "set": "1",
                "text": "Get the running time index expressed in samples. See <code>.runningSeconds</code>.",
                "type": "float",
                "class": "timerCHOP",
                "name": "runningSamples"
            },
            {
                "set": "1",
                "text": "Get the running time index expressed in samples. See <code>.runningSeconds</code>.",
                "type": "float",
                "class": "timerCHOP",
                "deprecated": "True",
                "name": "runningSample"
            },
            {
                "set": "1",
                "text": "Get the running time expressed in seconds. It keeps counting up after Start and is not affected by changing the Speed or pausing Play or scrubbing. It is basically the \"wall clock\" after pressing Start. (You normally don't set the value, use <code>.masterSeconds</code>.)  It doesn't reset to 0 until you Initialize or Start again.",
                "type": "float",
                "class": "timerCHOP",
                "name": "runningSeconds"
            },
            {
                "set": "1",
                "text": "Get the running time index as a Timecode Object. See [[Timecode Class]]. See <code>.runningSeconds</code>.",
                "type": "tdu.Timecode",
                "class": "timerCHOP",
                "name": "runningTimecode"
            },
            {
                "set": "0",
                "text": "Get the running length expressed in frames.",
                "type": "float",
                "class": "timerCHOP",
                "name": "runningLengthFrames"
            },
            {
                "set": "0",
                "text": "Get the running length expressed in samples.",
                "type": "float",
                "class": "timerCHOP",
                "name": "runningLengthSamples"
            },
            {
                "set": "0",
                "text": "Get the running length expressed in seconds.",
                "type": "float",
                "class": "timerCHOP",
                "name": "runningLengthSeconds"
            },
            {
                "set": "0",
                "text": "Get the running length as a Timecode Object. See [[Timecode Class]].",
                "type": "tdu.Timecode",
                "class": "timerCHOP",
                "name": "runningLengthTimecode"
            },
            {
                "set": "1",
                "text": "Get or set the segment index.",
                "type": "float",
                "class": "timerCHOP",
                "name": "segment"
            },
            {
                "set": "0",
                "text": "Get the list of segments.",
                "type": "list",
                "class": "timerCHOP",
                "name": "segments"
            },
            {
                "set": "0",
                "text": "Get the master timecode. See [[Timecode Class]].",
                "type": "tdu.Timecode",
                "class": "timerCHOP",
                "name": "timecode"
            }
        ],
        "methods": [
            {
                "text": "Jump to the next segment. Equivalent to pulsing the Go to Next Segment parameter on the Segments Page.",
                "returns": "None",
                "name": "goToNextSegment",
                "call": "goToNextSegment()",
                "class": "timerCHOP"
            },
            {
                "text": "Jump to the end of the current cycle. Equivalent to pulsing the Go to End of Cycle parameter on the Timer Page.",
                "returns": "None",
                "name": "goToCycleEnd",
                "call": "goToCycleEnd()",
                "class": "timerCHOP"
            },
            {
                "text": "Allows the user to jump to a different time index based on the arguments passed in. Only one unit of time (seconds, frame, sample, fraction) can be specified when calling this method. For example, including both seconds and frame will yield an error. If there are multiple segments, and only a unit of time is specified, the method will jump to the corresponding running time index. If either a segment index or a cycle index or both are specified along with a unit of time, the method will jump to the corresponding local time index. There are fifteen different combinations of arguments that the user can pass in. An example of how this method can be called is: timerop.goTo(segment=1, cycle=2, seconds=5, endOfCycle=True).\n*segment - (Keyword, Optional) If specified, will jump to the indicated segment number (0 is first).\n*cycle - (Keyword, Optional) If specified, will jump to the indicated cycle number (0 is first).\n*endOfCycle - (Keyword, Optional) False by default. If specified as True, the goTo() function with the specified arguments will be called again at the end of the cycle, causing a jump only at that time to the specified location.\n*seconds - (Keyword, Optional) If specified, will jump to the indicated time index. Cannot also specify frame, sample, or fraction.\n*frame - (Keyword, Optional) If specified, will jump to the indicated time index. Cannot also specify seconds, sample, or fraction.\n*sample - (Keyword, Optional) If specified, will jump to the indicated time index. Cannot also specify seconds, frame, or fraction.\n*fraction - (Keyword, Optional) If specified, will jump to the indicated time index. Cannot also specify seconds, frame, or sample.",
                "returns": "None",
                "name": "goTo",
                "call": "goTo(segment=num, cycle=num, endOfCycle=True, seconds=num, frame=num, sample=num,  fraction=num)",
                "class": "timerCHOP"
            },
            {
                "text": "Jump to the previous segment. Equivalent to pulsing the Go to Previous Segment parameter on the Segments Page.",
                "returns": "None",
                "name": "goToPrevSegment",
                "call": "goToPrevSegment()",
                "class": "timerCHOP"
            },
            {
                "text": "Sets the current cycle to be the last cycle of the current segment. Equivalent to pulsing the Exit at End of Cycle parameter on the Timer Page.",
                "returns": "None",
                "name": "lastCycle",
                "call": "lastCycle()",
                "class": "timerCHOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "timesliceCHOP": {
        "label": "timesliceCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "TOP": {
        "label": "TOP",
        "members": [
            {
                "class": "TOP",
                "name": "width",
                "type": "int",
                "set": "0",
                "text": "Texture width, measured in pixels."
            },
            {
                "class": "TOP",
                "name": "height",
                "type": "int",
                "set": "0",
                "text": "Texture height, measured in pixels."
            },
            {
                "class": "TOP",
                "name": "aspect",
                "type": "float",
                "set": "0",
                "text": "Texture aspect ratio, width divided by height."
            },
            {
                "class": "TOP",
                "name": "aspectWidth",
                "type": "float",
                "set": "0",
                "text": "Texture aspect ratio, width."
            },
            {
                "class": "TOP",
                "name": "aspectHeight",
                "type": "float",
                "set": "0",
                "text": "Texture aspect ratio, height."
            },
            {
                "class": "TOP",
                "name": "depth",
                "type": "int",
                "set": "0",
                "text": "Texture depth, when using a 3 dimensional texture."
            },
            {
                "class": "TOP",
                "name": "gpuMemory",
                "type": "int",
                "set": "0",
                "text": "The amount of GPU memory this TOP is using, in bytes."
            },
            {
                "class": "TOP",
                "name": "curPass",
                "type": "int",
                "set": "0",
                "text": "The current cooking pass iteration, beginning at 0. The total can be set with the 'Passes' parameter on the operator's common page."
            },
            {
                "class": "TOP",
                "name": "isTOP",
                "type": "bool",
                "set": "0",
                "text": "True if the operators is a TOP."
            }
        ],
        "methods": [
            {
                "class": "TOP",
                "name": "sample",
                "call": "sample(x=None,y=None,z=None,u=None,v=None,w=None)",
                "returns": "tuple(r,g,b,a)",
                "text": "Returns a 4-tuple representing the color value at the specified texture location. One horizontal and one vertical component must be specified. Note that this is a very expensive operation currently. It will always stall the graphics pipeline if the TOP is currently queued to get updated, and then downloads the entire texture (not just the requested pixel). Use this for debugging and non-realtime workflows only.\n*x - (Keyword, Optional) The horizontal pixel coordinate to be sampled.\n*y - (Keyword, Optional) The vertical pixel coordinate to be sampled.\n*z - (Keyword, Optional) The depth pixel coordinate to be sampled. Available in builds 2022.23800 and later.\n*u - (Keyword, Optional) The normalized horizontal coordinate to be sampled.\n*v - (Keyword, Optional) The normalized vertical coordinate to be sampled.\n*w - (Keyword, Optional) The normalized depth pixel coordinate to be sampled. Available in builds 2022.23800 and later.\n<syntaxhighlight lang=python>\nr = n.sample(x=25,y=100)[0]   #The red component at pixel 25,100.\ng = n.sample(u=0.5,v=0.5)[1]  #The green component at the central location.\nb = n.sample(x=25,v=0.5)[2]  #The blue 25 pixels across, and half way down.\n</syntaxhighlight>"
            },
            {
                "class": "TOP",
                "name": "numpyArray",
                "call": "numpyArray(delayed=False, writable=False)",
                "returns": "numpy.array",
                "text": "Returns the TOP image as a Python NumPy array. Note that since NumPy arrays are referenced by line first, pixels are addressed as [h, w]. Currently data will always be in floating point, regardless of what the texture data format is on the GPU.\n*delayed - (Keyword, Optional) If set to True, the download results will be delayed until the next call to numpyArray(), avoiding stalling the GPU waiting for the result immediately. This is useful to avoid long stalls that occur if immediately asking for the result. Each call with return the image that was 'current' on the previous call to numpyArray(). None will be returned if there isn't a result available. You should always check the return value against None to make sure you have a result. Call numpyArray() again, ideally on the next frame or later, to get the result. If you always need a result, you can call numpyArray() a second time in the event None is returned on the first call.\n*writable - (Keyword, Optional) If set to True, the memory in the numpy array will be allocated in such a way that writes to it arn't slow. By default the memory the numpy array holds can be allocated in such a way that is very slow to write to. Note that in either case, writing to the numpy array will *not* change the data in the TOP."
            },
            {
                "class": "TOP",
                "name": "save",
                "call": "save(filepath, asynchronous=False, createFolders=False, quality=1.0, metadata=[])",
                "returns": "filepath",
                "text": "Saves the image to the file system. Support file formats are: <code>.tif</code>, <code>.tiff</code>, <code>.jpg</code>, <code>.jpeg</code>, <code>.bmp</code>, <code>.png</code>, <code>.exr</code> and <code>.dds</code>. Returns the filename and path used.\n*filepath - (Optional) The path and filename to save to. If not given then a default filename will be used, and the file will be saved in the <code>project.folder</code> folder.\n*aysnchronous - (Keyword, Optional) If True, the save will occur in another thread. The file may not be done writing at the time this function returns.\n*createFolders - (Keyword, Optional) If True, folders listed in the path that don't exist will be created.\n*quality - (Keyword, Optional) Specify the compression quality used. Values range from 0 (lowest quality, small size) to 1 (best quality, largest size).\n*metadata - (Keyword, Optional) A list of string pairs that will be inserted into the file's metadata section. Any type of list structure is supported (dictionary, tuple, etc) as long as each metadata item has two entries (key & value). '''Note:''' Only supported on EXR files.\n<syntaxhighlight lang=python>\nname = n.save()   #save in default format with default name.\nn.save('picture.jpg')\nn.save('image.exr', metadata=[ (\"my_key\", \"my_value\"), (\"author_name\", \"derivative\") ] ); # save as .exr with custom metadata\n</syntaxhighlight>"
            },
            {
                "class": "TOP",
                "name": "saveByteArray",
                "call": "saveByteArray(filetype, quality=1.0, metadata=[])",
                "returns": "bytearray",
                "text": "Saves the image to a bytearray object in the requested file format. Support file formats are: .tif, .tiff, .jpg, .jpeg, .bmp, .png, .exr and .dds. Returns the bytearray object. To get the raw image data use <code>numpyArray()</code> or <code>cudaArray()</code> instead.\n*filetype - (Optional) A string specifying the file type to save as. If not given the default file type '.tiff' will be used. Just the suffix of the string is used to determine the file type. E.g '.tiff', 'file.tiff', 'C:/Files/file.tiff' will all work. '''Suffix must include the period'''.\n*quality - (Keyword, Optional) Specify the compression quality used. Values range from 0 (lowest quality, small size) to 1 (best quality, largest size).\n*metadata - (Keyword, Optional) A list of string pairs that will be inserted into the file's metadata section. Any type of list structure is supported (dictionary, tuple, etc) as long as each metadata item has two entries (key & value). '''Note:''' Only supported on EXR files.\n<syntaxhighlight lang=python>\narr = n.saveByteArray() # save in default format.\narr = n.saveByteArray('.jpg') # save as .jpg\narr = n.saveByteArray('.exr', metadata=[ (\"my_key\", \"my_value\"), (\"author_name\", \"derivative\") ] ); # save as .exr with custom metadata\n</syntaxhighlight>"
            },
            {
                "class": "TOP",
                "name": "cudaMemory",
                "call": "cudaMemory()",
                "returns": "CUDAMemory",
                "text": "Copies the contents of the TOP to a newly allocated block of raw CUDA memory. The CUDA memory will be deallocated when the returned [[CUDAMemory_Class|CUDAMemory]] object is deallocated. Ensure you keep a reference to the returned object around as long as you are using it."
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP"
        ],
        "summary": "A [[TOP]] describes a reference to a TOP operator."
    },
    "toptoCHOP": {
        "label": "toptoCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "torusSOP": {
        "label": "torusSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "touchinCHOP": {
        "label": "touchinCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "touchinDAT": {
        "label": "touchinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "touchinTOP": {
        "label": "touchinTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "touchoutCHOP": {
        "label": "touchoutCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "touchoutDAT": {
        "label": "touchoutDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "touchoutTOP": {
        "label": "touchoutTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "traceSOP": {
        "label": "traceSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "trailCHOP": {
        "label": "trailCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "trailSOP": {
        "label": "trailSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "transformCHOP": {
        "label": "transformCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "transformSOP": {
        "label": "transformSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "transformTOP": {
        "label": "transformTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "transposeDAT": {
        "label": "transposeDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "triggerCHOP": {
        "label": "triggerCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "triggerCHOP",
                "name": "chanIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "trimCHOP": {
        "label": "trimCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "trimSOP": {
        "label": "trimSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "tristripSOP": {
        "label": "tristripSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "tubeSOP": {
        "label": "tubeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "tuioinDAT": {
        "label": "tuioinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "twistSOP": {
        "label": "twistSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "udpinDAT": {
        "label": "udpinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "udpoutDAT": {
        "label": "udpoutDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "udtinDAT": {
        "label": "udtinDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "udtoutDAT": {
        "label": "udtoutDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "UI": {
        "label": "UI",
        "members": [
            {
                "class": "UI",
                "name": "clipboard",
                "type": "str",
                "set": "1",
                "text": "Get or set the operating system clipboard text contents."
            },
            {
                "class": "UI",
                "name": "colors",
                "type": "td.Colors",
                "set": "0",
                "text": "Access to the application [[Colors Class|colors]]."
            },
            {
                "class": "UI",
                "name": "dpiBiCubicFilter",
                "type": "bool",
                "set": "1",
                "text": "Get or set the global DPI scale filtering mode of TouchDesigner windows. True means bi-cubic, False means linear."
            },
            {
                "class": "UI",
                "name": "masterVolume",
                "type": "float",
                "set": "1",
                "text": "Get or set the master audio output volume. A value of 0 is no output, while a value of 1 is full output."
            },
            {
                "class": "UI",
                "name": "options",
                "type": "td.Options",
                "set": "0",
                "text": "Access to the application [[Options Class|options]]."
            },
            {
                "class": "UI",
                "name": "panes",
                "type": "td.Panes",
                "set": "0",
                "text": "Access to the set of all [[Panes Class|panes]]."
            },
            {
                "class": "UI",
                "name": "performMode",
                "type": "bool",
                "set": "1",
                "text": "Get or set [[Perform Mode]].  Set to True to go into Perform Mode, False to go into [[Designer Mode]]."
            },
            {
                "class": "UI",
                "name": "preferences",
                "type": "td.Preferences",
                "set": "0",
                "text": "Access to the application [[Preferences Class|preferences]], which can also be access through the [[Preferences Dialog]]."
            },
            {
                "class": "UI",
                "name": "redrawMainWindow",
                "type": "bool",
                "set": "1",
                "text": "Get or set whether the main window should redraw. The main window is either the main network editor, or the perform window."
            },
            {
                "class": "UI",
                "name": "rolloverOp",
                "type": "OP",
                "set": "0",
                "text": "Operator currently under the mouse in a network editor."
            },
            {
                "class": "UI",
                "name": "rolloverPar",
                "type": "td.Par",
                "set": "0",
                "text": "Parameter currently under the mouse in a parameter dialog."
            },
            {
                "class": "UI",
                "name": "rolloverPanel",
                "type": "panelCOMP",
                "set": "0",
                "text": "returns the latest panel to get a rollover event. Takes into account click through, depth order, and other panel settings."
            },
            {
                "class": "UI",
                "name": "lastChopChannelSelected",
                "type": "td.Par",
                "set": "0",
                "text": "Last [[Channel|CHOP channel]] selected via mouse."
            },
            {
                "class": "UI",
                "name": "showPaletteBrowser",
                "type": "bool",
                "set": "1",
                "text": "Get or set display of the palette browser."
            },
            {
                "class": "UI",
                "name": "status",
                "type": "str",
                "set": "1",
                "text": "Get or set the status message.\n<syntaxhighlight lang=python>\nui.status = 'Operation Complete'\n</syntaxhighlight>"
            },
            {
                "class": "UI",
                "name": "undo",
                "type": "td.Undo",
                "set": "0",
                "text": "Acess to application undo functions."
            },
            {
                "class": "UI",
                "name": "windowWidth",
                "type": "int",
                "set": "0",
                "text": "Get the app window width."
            },
            {
                "class": "UI",
                "name": "windowHeight",
                "type": "int",
                "set": "0",
                "text": "Get the app window height."
            },
            {
                "class": "UI",
                "name": "windowX",
                "type": "int",
                "set": "0",
                "text": "Get the app window X position."
            },
            {
                "class": "UI",
                "name": "windowY",
                "type": "int",
                "set": "0",
                "text": "Get the app window Y position."
            }
        ],
        "methods": [
            {
                "class": "UI",
                "name": "copyOPs",
                "call": "copyOPs(listOfOPs)",
                "returns": "None",
                "text": "Copy a list of operators to the operator clipboard. All operators must be children of the same component.\n*listOfOPs - A list containing one or more OPs to be copied.\n<syntaxhighlight lang=python>ui.copyOPs( op('geo1').selected )</syntaxhighlight>"
            },
            {
                "class": "UI",
                "name": "pasteOPs",
                "call": "pasteOPs(COMP, x=None, y=None)",
                "returns": "None",
                "text": "Copy the contents of the operator clipboard into the specified component.\n*COMP - The destination to receive the operators.\n*x - Optional network coordinates at which to paste the operators.\n*y - see x\n<syntaxhighlight lang=python>l = ui.pasteOPs( op('geo2') )</syntaxhighlight>"
            },
            {
                "class": "UI",
                "name": "messageBox",
                "call": "messageBox(title, message, buttons=['Ok'])",
                "returns": "int",
                "text": "This method will open a message dialog box with the specified message.  Returns the index of the button clicked.\n*title - Specifies the window title.\n*message - Specifies the content of the dialog.\n*buttons - (Keyword, Optional) Specifies a list button labels to show in the dialog.\n<syntaxhighlight lang=python>\n# basic usage\nui.messageBox('Warning', 'Have a nice day.')\n# specify options and report result\na = ui.messageBox('Please select:', 'Buttons:', buttons=['a', 'b', 'c'])\nui.messageBox('Results', 'You selected item: ' + str(a))\n# pick a node from their paths\nui.messageBox('Please select:', 'Nodes:', buttons=parent().children)\n# pick a node from their first names (list comprehension)\nui.messageBox('Please select:', 'Nodes:', buttons=[x.name for x in parent().children])\n# pick a cell\nui.messageBox('Please select:', 'Cells:', buttons=op('table1').cells('*','*'))\n</syntaxhighlight>"
            },
            {
                "class": "UI",
                "name": "refresh",
                "call": "refresh()",
                "returns": "None",
                "text": "Update and redraw all viewports, nodes, UI elements etc immediately. This update is otherwise done once per frame at the end of all script executions. For example, if the current frame is manually changed during a script, a call to refresh will cause all dependent data to update immediately.\n<syntaxhighlight lang=python>\nfor i in range(100):\n\tui.status = str(i)\n\tui.refresh()\n</syntaxhighlight>"
            },
            {
                "class": "UI",
                "name": "chooseFile",
                "call": "chooseFile(load=True, start=None, fileTypes=None, title=None, asExpression=False)",
                "returns": "str or None",
                "text": "Open a dialog box for loading or saving a file.  Returns the filename selected or None if the dialog is cancelled.\n*load - (Keyword, Optional) If set to True, the dialog will be a Load dialog, otherwise it's a Save dialog.\n*start - (Keyword, Optional) If provided, specifies an initial folder location and/or filename selection.\n*fileTypes - (Keyword, Optional) If provided, specifies a list of file extensions that can be used as filters. Otherwise '*.*' is the only filter.\n*asExpression - (Keyword, Optional) If set to true, the results are provided as an expression, suitable for a [[Par Class|Parameter]] expression or as input to an eval() call.  [[App Class]] member constants such as samplesFolder may be included in the result.\n*title (Keyword, Optional) If provided, will override the default window title.\n<syntaxhighlight lang=python>\na = ui.chooseFile(start='python_examples.toe', fileTypes=['toe'], title='Select a toe') # specify extension\na = ui.chooseFile(fileTypes=tdu.fileTypes['image'], title='Select an image') # any support image extension\npath = ui.chooseFile(load=False,fileTypes=['txt'],title='Save table as:')\nif (path):\n\top('table1').save(path)\n</syntaxhighlight>"
            },
            {
                "class": "UI",
                "name": "chooseFolder",
                "call": "chooseFolder(title=<nowiki>'Select Folder'</nowiki>, start=None, asExpression=False)",
                "returns": "str or None",
                "text": "Open a dialog box for selecting a folder.  Returns the folder selected or None if the dialog is cancelled.\n*title - (Keyword, Optional) If provided, specifies the window title.\n*start - (Keyword, Optional) If provided, specifies an initial folder location and/or filename selection.\n*asExpression - (Keyword, Optional) If set to true, the results are provided as an expression, suitable for a [[Par Class|Parameter]] expression or as input to an eval() call.  [[App Class]] member constants such as samplesFolder may be included in the result.\n<syntaxhighlight lang=python>\na = ui.chooseFolder()\na = ui.chooseFolder(title='Select a folder location.')\n</syntaxhighlight>"
            },
            {
                "class": "UI",
                "name": "viewFile",
                "call": "viewFile(URL_or_path, showInFolder=False)",
                "returns": "None",
                "text": "View a URL or file in the default external application. You can use <code>ui.viewFile()</code> to open a folder/directory in Windows Explorer or macOS Finder.\n*URL_or_path - URL or path to launch.\n<syntaxhighlight lang=python>\na = ui.viewFile('output.txt')\n</syntaxhighlight>\n*showInFolder - Show file as selected in Explorer or macOS Finder instead of launching an external application.\n<syntaxhighlight lang=python>\na = ui.viewFile('output.txt', showInFolder=True)\n</syntaxhighlight>"
            },
            {
                "class": "UI",
                "name": "openAbletonControl",
                "call": "openAbletonControl()",
                "returns": "None",
                "text": "Deprecated. Use [[TDAbleton]] instead."
            },
            {
                "class": "UI",
                "name": "openBeat",
                "call": "openBeat()",
                "returns": "None",
                "text": "Open the [[Beat Dialog]]."
            },
            {
                "class": "UI",
                "name": "openBookmarks",
                "call": "openBookmarks()",
                "returns": "None",
                "text": "Open the [[Bookmarks Dialog]]."
            },
            {
                "class": "UI",
                "name": "openCOMPEditor",
                "call": "openCOMPEditor(path)",
                "returns": "None",
                "text": "Open component editor for the specific operator.\n*path - Specifies the path to the operator.  An OP can be passed in as well."
            },
            {
                "class": "UI",
                "name": "openConsole",
                "call": "openConsole()",
                "returns": "None",
                "text": "Open the [[Console Window]]."
            },
            {
                "class": "UI",
                "name": "openDialogHelp",
                "call": "openDialogHelp(title)",
                "returns": "None",
                "text": "Open help page for the specific dialog.\n*title - Specifies the help page to open.\n<syntaxhighlight lang=python>\nui.openDialogHelp('Window Placement Dialog')\n</syntaxhighlight>"
            },
            {
                "class": "UI",
                "name": "openErrors",
                "call": "openErrors()",
                "returns": "None",
                "text": "Open the [[Errors Dialog]]."
            },
            {
                "class": "UI",
                "name": "openExplorer",
                "call": "openExplorer()",
                "returns": "None",
                "text": "Open an Explorer window."
            },
            {
                "class": "UI",
                "name": "openExportMovie",
                "call": "openExportMovie(path=\"\")",
                "returns": "None",
                "text": "Open the [[Export Movie Dialog]].\n*path - Specifies the operator content to export."
            },
            {
                "class": "UI",
                "name": "openHelp",
                "call": "openHelp()",
                "returns": "None",
                "text": "Open the [[Commands_and_Expressions|Help Dialog]]."
            },
            {
                "class": "UI",
                "name": "openImportFile",
                "call": "openImportFile()",
                "returns": "None",
                "text": "Open the [[Import File Dialog]]."
            },
            {
                "class": "UI",
                "name": "openKeyManager",
                "call": "openKeyManager()",
                "returns": "None",
                "text": "Open the [[Key Manager Dialog]]."
            },
            {
                "class": "UI",
                "name": "openMIDIDeviceMapper",
                "call": "openMIDIDeviceMapper()",
                "returns": "None",
                "text": "Open the [[MIDI Device Mapper Dialog]]."
            },
            {
                "class": "UI",
                "name": "openNewProject",
                "call": "openNewProject()",
                "returns": "None",
                "text": "Open the [[New Project Dialog]]."
            },
            {
                "class": "UI",
                "name": "openOperatorSnippets",
                "call": "openOperatorSnippets(family=None, type=None, example=None)",
                "returns": "None",
                "text": "Open the Operator Snippets window."
            },
            {
                "class": "UI",
                "name": "openPaletteBrowser",
                "call": "openPaletteBrowser()",
                "returns": "None",
                "text": "Open the [[Palette]]."
            },
            {
                "class": "UI",
                "name": "openPerformanceMonitor",
                "call": "openPerformanceMonitor()",
                "returns": "None",
                "text": "Open the [[Performance Monitor Dialog]]."
            },
            {
                "class": "UI",
                "name": "openPreferences",
                "call": "openPreferences()",
                "returns": "None",
                "text": "Open the [[Preferences Dialog]]."
            },
            {
                "class": "UI",
                "name": "openSearch",
                "call": "openSearch()",
                "returns": "None",
                "text": "Open the [[Search Replace Dialog]]."
            },
            {
                "class": "UI",
                "name": "openTextport",
                "call": "openTextport()",
                "returns": "None",
                "text": "Open the [[Textport]]."
            },
            {
                "class": "UI",
                "name": "openVersion",
                "call": "openVersion()",
                "returns": "None",
                "text": "Open a dialog displaying current version information.\nSee also: [[App Class|App.version]]"
            },
            {
                "class": "UI",
                "name": "openWindowPlacement",
                "call": "openWindowPlacement()",
                "returns": "None",
                "text": "Open the [[Window Placement Dialog]]."
            },
            {
                "class": "UI",
                "name": "findEditDAT",
                "call": "findEditDAT(filename)",
                "returns": "DAT or None",
                "text": "Given an external filename, finds the corresponding DAT thats update from this filename if any.."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The UI class describes access to the UI elements of the application, found in the automatically imported [[td Module|td module]].\n\nTo access members and methods of this class use the default instance <code>ui</code>.\n\nFor Example:\n<syntaxhighlight lang=python>\n# open the Midi Device Mapper Dialog\nui.openMIDIDeviceMapper()\n</syntaxhighlight>"
    },
    "underTOP": {
        "label": "underTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "Undo": {
        "label": "Undo",
        "members": [
            {
                "class": "Undo",
                "name": "globalState",
                "type": "bool",
                "set": "1",
                "text": "Is global undo enabled or not."
            },
            {
                "class": "Undo",
                "name": "redoStack",
                "type": "list",
                "set": "0",
                "text": "A list of names for redo operations available."
            },
            {
                "class": "Undo",
                "name": "state",
                "type": "bool",
                "set": "0",
                "text": "Is undo enabled or not."
            },
            {
                "class": "Undo",
                "name": "undoStack",
                "type": "list",
                "set": "0",
                "text": "A list of names for undo operations available."
            }
        ],
        "methods": [
            {
                "class": "Undo",
                "name": "startBlock",
                "call": "startBlock(name, enable=True)",
                "returns": "None",
                "text": "Start a named undo block."
            },
            {
                "class": "Undo",
                "name": "clear",
                "call": "clear()",
                "returns": "None",
                "text": "Clear undo and redo stack. This will terminate any current undo blocks."
            },
            {
                "class": "Undo",
                "name": "addCallback",
                "call": "addCallback(callback, info=None)",
                "returns": "None",
                "text": "Add a Python callback into the undo block\n* callback - user defined callback in the form of <syntaxhighlight lang=python inline>callback(isUndo, info)</syntaxhighlight>\n* info - this argument will be passed back to user in the callback"
            },
            {
                "class": "Undo",
                "name": "redo",
                "call": "redo()",
                "returns": "None",
                "text": "Redo the next operation. This will terminate any current undo blocks."
            },
            {
                "class": "Undo",
                "name": "undo",
                "call": "undo()",
                "returns": "None",
                "text": "Undo the last operation. This will terminate any current undo blocks."
            },
            {
                "class": "Undo",
                "name": "endBlock",
                "call": "endBlock()",
                "returns": "None",
                "text": "Terminate an undo block."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "A class to enable and disable undo functionality. Undo blocks can be created during python callbacks. At the end of callbacks, any dangling undo blocks will be terminated."
    },
    "Vector": {
        "label": "Vector",
        "members": [
            {
                "class": "tdu.Vector",
                "name": "x",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the X component of the vector."
            },
            {
                "class": "tdu.Vector",
                "name": "y",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the Y component of the vector."
            },
            {
                "class": "tdu.Vector",
                "name": "z",
                "type": "float",
                "set": "1",
                "text": "Gets or sets the Z component of the vector."
            }
        ],
        "methods": [
            {
                "class": "tdu.Vector",
                "name": "angle",
                "call": "angle(vec)",
                "returns": "float",
                "text": "Returns the angel (in degrees) between the current vector and specified vector (vec).\n<syntaxhighlight lang=python>\nd = v.angle(v2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "scale",
                "call": "scale(x, y, z)",
                "returns": "None",
                "text": "Scales each component of the vector by the specified values.\n*x, y, z - The values to scale each component of the vector by.\n<syntaxhighlight lang=python>\nv.scale(1, 2, 1)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "normalize",
                "call": "normalize()",
                "returns": "None",
                "text": "Makes the length of this vector 1.\n<syntaxhighlight lang=python>\nm.normalize()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "length",
                "call": "length()",
                "returns": "float",
                "text": "Returns the length of this vector.\n<syntaxhighlight lang=python>\nl = m.length()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "lengthSquared",
                "call": "lengthSquared()",
                "returns": "float",
                "text": "Returns the squared length of this vector.\n<syntaxhighlight lang=python>\nl = v.lengthSquared()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "copy",
                "call": "copy()",
                "returns": "tdu.Vector",
                "text": "Returns a new vector that is a copy of the vector.\n<syntaxhighlight lang=python>\nnewV = v.copy()\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "distance",
                "call": "distance(vec)",
                "returns": "float",
                "text": "Returns the distance of the current vector to specified vector (vec).\n<syntaxhighlight lang=python>\nl = v.distance(v2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "lerp",
                "call": "lerp(vec2, t)",
                "returns": "tdu.Vector",
                "text": "Returns the linear interpolation of this vector and vec2. That is vec1 * (1.0 - t) + vec2 * t, where vec1 is the current vector.  The value for t is not restricted to the range [0, 1].\n<syntaxhighlight lang=python>\nl = v.lerp(v2, t)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "slerp",
                "call": "slerp(vec2, t)",
                "returns": "tdu.Vector",
                "text": "Returns the spherical interpolation of this vector and vec2. The value for t is not restricted to the range [0, 1].\n<syntaxhighlight lang=python>\nl = v.slerp(v2, t)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "dot",
                "call": "dot(vec)",
                "returns": "float",
                "text": "Returns the dot product of this vector and the passed vector.\n*vec - The other vector to use to calculate the dot product\n<syntaxhighlight lang=python>\nd = v.dot(otherV)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "cross",
                "call": "cross(vec)",
                "returns": "tdu.Vector",
                "text": "Returns the cross product of this vector and the passed vector. The operation is self cross vec.\n*vec - The other vector to use to calculate the cross product.\n<syntaxhighlight lang=python>\nc = v.cross(otherV)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "project",
                "call": "project(vec, vec)",
                "returns": "None",
                "text": "Projects this vector onto the plan defined by vec1 and vec2. Both vec1 and vec2 must be normalized. The result may not be normalized.\n*vec1, vec2 - The  vectors that specify the plane to project onto. Must be normalized.\n<syntaxhighlight lang=python>\nv.project(v1, v2)\n</syntaxhighlight>"
            },
            {
                "class": "tdu.Vector",
                "name": "reflect",
                "call": "reflect(vec)",
                "returns": "None",
                "text": "Reflects the current vector about the specified vector (vec).\n<syntaxhighlight lang=python>\nv.reflect(v2)\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The vector class holds a single 3 component vector. A vector describes a direction in space, and it's important to use a vector or [[Position Class|Position]] as appropriate for the data that is being calculated. When being multiplied by a [[Matrix Class|Matrix]], this class will implicitly have a 4th component (W component) of 0. A new vector can be created without any arguments, with 3 arguments for the x,y,z values, or with a single argument which is a variable that has 3 entries such as a list of length 3, or a position or vector.\nExamples of creating a vector:\n<syntaxhighlight lang=python>\nv = tdu.Vector() # starts as (0, 0, 0)\nv2 = tdu.Vector(0, 0, -1)\nvalues = [0, 1, 0]\nv3 = tdu.Vector(values)\n\n# vectors can be accessed like Python lists\nprint(v3[1])\t# same as v3.y\nv3[2] = 1\t\t# same as v3.z\n</syntaxhighlight>"
    },
    "Vertex": {
        "label": "Vertex",
        "members": [
            {
                "class": "Vertex",
                "name": "index",
                "type": "int",
                "set": "0",
                "text": "The vertex position in its [[Prim Class|primitive]]."
            },
            {
                "class": "Vertex",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "The [[OP Class|OP]] to which this object belongs."
            },
            {
                "class": "Vertex",
                "name": "point",
                "type": "td.Point",
                "set": "1",
                "text": "Get or set the [[Point Class|point]] to which the vertex refers."
            },
            {
                "class": "Vertex",
                "name": "prim",
                "type": "td.Prim",
                "set": "0",
                "text": "The [[Prim Class|prim]] to which the vertex belongs."
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [],
        "summary": "A Vertex describes an instance to a single geometry vertex, contained within a [[Prim Class|Prim]] object."
    },
    "vertexSOP": {
        "label": "vertexSOP",
        "members": [
            {
                "set": "0",
                "text": "The current point or vertex color being evaluated, from the first input, or a default if not present, expressed as a 4-tuple.",
                "type": "tuple(r, g, b, a)",
                "class": "vertexSOP",
                "name": "inputColor"
            },
            {
                "set": "0",
                "text": "The current point or vertex color being evaluated, from the second input, or a default if not present, expressed as a 4-tuple.",
                "type": "tuple(r, g, b, a)",
                "class": "vertexSOP",
                "name": "inputColor2"
            },
            {
                "set": "0",
                "text": "The current point or vertex normal being evaluated, from the first input, or a default if not present, expressed as a 3-tuple.",
                "type": "tuple(n1, n2, n3)",
                "class": "vertexSOP",
                "name": "inputNormal"
            },
            {
                "set": "0",
                "text": "The current point or vertex normal being evaluated, from the second input, or a default if not present, expressed as a 3-tuple.",
                "type": "tuple(n1, n2, n3)",
                "class": "vertexSOP",
                "name": "inputNormal2"
            },
            {
                "set": "0",
                "text": "The current point or vertex texture being evaluated, from the first input, or a default if not present, expressed as a 3-tuple.",
                "type": "tuple(u, v, w)",
                "class": "vertexSOP",
                "name": "inputTexture"
            },
            {
                "set": "0",
                "text": "The current point or vertex texture being evaluated, from the second input, or a default if not present, expressed as a 3-tuple.",
                "type": "tuple(u, v, w)",
                "class": "vertexSOP",
                "name": "inputTexture2"
            },
            {
                "set": "0",
                "text": "The current [[Vertex Class|vertex]] being evaluated, from the first input.",
                "type": "Vertex",
                "class": "vertexSOP",
                "name": "inputVertex"
            },
            {
                "set": "0",
                "text": "The current [[Vertex Class|vertex]] being evaluated, from the second input.",
                "type": "Vertex",
                "class": "vertexSOP",
                "name": "inputVertex2"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "VFS": {
        "label": "VFS",
        "members": [
            {
                "class": "VFS",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "Get the OP owner."
            }
        ],
        "methods": [
            {
                "class": "VFS",
                "name": "[]",
                "call": "[name]",
                "returns": "VFSFile",
                "text": "[[VFSFile Class|VFS Files]] may be easily accessed using the [] syntax.\n*name - Must be an exact VFS file name. Wildcards are not supported. If not found, an error will be raised.\n<syntaxhighlight lang=python>\np = op('base1').vfs['Banana.tif']\n</syntaxhighlight>"
            },
            {
                "class": "VFS",
                "name": "addByteArray",
                "call": "addByteArray(byteArray, name)",
                "returns": "VFSFile",
                "text": "Add an embedded file from a bytearray to the component. Returns a VFSFile instance of the added file.  To delete the file, see <code>destroy()</code> on [[VFSFile Class]].\n* byteArray - A bytearray or bytes object representing the contents of the file.\n* name - The name of the file on VFS."
            },
            {
                "class": "VFS",
                "name": "addFile",
                "call": "addFile(filePath, overrideName=None)",
                "returns": "VFSFile",
                "text": "Add an embedded file from disk to the component with an option to override the name. Returns a VFSFile instance of the added file. To delete the file, see <code>destroy()</code> on [[VFSFile Class]].\n*filePath - The path of the file on disk to add.\n*overrideName (Keyword, Optional) - When specified, will override the name of the file in VFS."
            },
            {
                "class": "VFS",
                "name": "export",
                "call": "export(folder, pattern='*', overwrite=False)",
                "returns": "list",
                "text": "Exports any matching files to the folder on disk. If overwrite is True then any existing files on disks with the same name will be overwritten. Returns a list of paths on disk to the exported files.\n*folder - The folder on disk to export the files to.\n*pattern (Keyword, Optional) - The pattern to match names by.\n*overwrite (Keyword, Optional) - When True, will overwrite any files that share the same name.\n<syntaxhighlight lang=python>\n# VFS contains one file with name 'A/B.tif'\nCOMP.vfs.export('C:/tmp') # returns ['C:/tmp/A/B.tif']\n</syntaxhighlight>"
            },
            {
                "class": "VFS",
                "name": "find",
                "call": "find(pattern='*')",
                "returns": "list",
                "text": "Finds all files in VFS with names matching the pattern. Returns a list of VFSFile objects.\n*pattern (Keyword, Optional) - The pattern to match names by."
            },
            {
                "class": "VFS",
                "name": "len",
                "call": "len(VFS)",
                "returns": "int",
                "text": "Returns the total number of virtual files.\n<syntaxhighlight lang=python>\na = len(op('base1').vfs)\n</syntaxhighlight>"
            },
            {
                "class": "VFS",
                "name": "iterator",
                "call": "Iterator",
                "returns": "str",
                "text": "Iterate over each virtual file name.\n<syntaxhighlight lang=python>\nfor f in op('base1').vfs:\n\tdebug(f) # print info of all virtual files on base1\n</syntaxhighlight>"
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The VFS Class describes a COMP's [[Virtual File System|Virtual File System]]. <br>To access a virtual file in any operator's file parameter, use the virtual path format: <code>vfs:<path to comp>:<filename></code>. <br>[[VFSFile_Class]] does the file operators.",
        "inherit": "",
        "parent": ""
    },
    "VFSFile": {
        "label": "VFSFile",
        "members": [
            {
                "class": "VFSFile",
                "name": "name",
                "type": "str",
                "set": "1",
                "text": "Get or set the name of the file. This name can include slashes but should not include leading slashes."
            },
            {
                "class": "VFSFile",
                "name": "size",
                "type": "int",
                "set": "0",
                "text": "Get the size of the file data."
            },
            {
                "class": "VFSFile",
                "name": "date",
                "type": "datetime",
                "set": "0",
                "text": "Get the modified date of the file in the form of a datetime Python object."
            },
            {
                "class": "VFSFile",
                "name": "virtualPath",
                "type": "str",
                "set": "0",
                "text": "Get the virtual path of the file. Returns a String formatted for fetching the file data from VFS in operators such as the Movie File In TOP. Format is <code>vfs:<path to owner>:<filename></code>."
            },
            {
                "class": "VFSFile",
                "name": "originalFilePath",
                "type": "str",
                "set": "0",
                "text": "Get the original file path on disk. If the VFSFile was created from a bytearray and not a file on disk then this will be empty."
            },
            {
                "class": "VFSFile",
                "name": "owner",
                "type": "OP",
                "set": "0",
                "text": "Get the OP owner."
            },
            {
                "class": "VFSFile",
                "name": "byteArray",
                "type": "bytearray",
                "set": "1",
                "text": "Get or set the file data as a bytearray."
            }
        ],
        "methods": [
            {
                "class": "VFSFile",
                "name": "destroy",
                "call": "destroy()",
                "returns": "None",
                "text": "Destroys the file in VFS referenced by this object."
            },
            {
                "class": "VFSFile",
                "name": "export",
                "call": "export(folder)",
                "returns": "str",
                "text": "Exports the file to the specified folder on disk and returns the location.\n*folder - The folder on disk to export the file to."
            }
        ],
        "subclasses": {},
        "inherits": [],
        "summary": "The VFSFile Class describes a virtual file contained within a [[Virtual File System]].<br>To access a virtual file in any operator's file parameter, use the virtual path as described below in the <code>virtualPath</code> member.",
        "inherit": "",
        "parent": ""
    },
    "videodeviceinTOP": {
        "label": "videodeviceinTOP",
        "members": [
            {
                "set": "0",
                "text": "True if any device is currently streaming to this operator..",
                "type": "bool",
                "class": "videodeviceinTOP",
                "name": "isConnected"
            },
            {
                "set": "0",
                "text": "If available for the current Library, returns a string for the input signal format. This string can be used to set the 'Signal Format' menu on the Video Device Out TOP.",
                "type": "string",
                "class": "videodeviceinTOP",
                "name": "inputSignalFormat"
            },
            {
                "set": "0",
                "text": "If the device supports timecode, then returns a Timecode object for the latest received frame. see [[Timecode Class]].",
                "type": "tdu.Timecode",
                "class": "videodeviceinTOP",
                "name": "timecode"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "videodeviceoutTOP": {
        "label": "videodeviceoutTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "videostreaminTOP": {
        "label": "videostreaminTOP",
        "members": [
            {
                "set": "0",
                "text": "The number of times this operator has failed to make a connection to any URL.",
                "type": "int",
                "class": "videostreaminTOP",
                "name": "connectionsFailed"
            },
            {
                "set": "0",
                "text": "The number of times this operator has lost a connection it has previous successfully established.",
                "type": "int",
                "class": "videostreaminTOP",
                "name": "connectionsLost"
            },
            {
                "set": "0",
                "text": "The timestamp of the currently shown frame, in seconds.",
                "type": "float",
                "class": "videostreaminTOP",
                "name": "frameTime"
            },
            {
                "set": "0",
                "text": "True if connected to target URL.",
                "type": "bool",
                "class": "videostreaminTOP",
                "name": "isConnected"
            },
            {
                "set": "0",
                "text": "True if attempting to connect to target URL.",
                "type": "bool",
                "class": "videostreaminTOP",
                "name": "isConnecting"
            },
            {
                "set": "0",
                "text": "When de-interlacing, this tells if the odd field is currently being shown.",
                "type": "bool",
                "class": "videostreaminTOP",
                "name": "isOddField"
            },
            {
                "set": "0",
                "text": "Height of the movie, in pixels.",
                "type": "int",
                "class": "videostreaminTOP",
                "name": "videoHeight"
            },
            {
                "set": "0",
                "text": "Width of the movie, in pixels.",
                "type": "int",
                "class": "videostreaminTOP",
                "name": "videoWidth"
            }
        ],
        "methods": [
            {
                "text": "Unloads the video stream and frees it's memory usage. The stream will open again next time it cooks, so make sure nothing is still using it to keep it closed.\n*cacheMemory - (Keyword, Optional) If True the memory (textures, upload buffers) of the movie will be cached for use by another movie later on. Useful if you are opening/closing many movies with the same codec and resolution.",
                "returns": "None",
                "name": "unload",
                "call": "unload(cacheMemory=False)",
                "class": "videostreaminTOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "videostreamoutTOP": {
        "label": "videostreamoutTOP",
        "members": [
            {
                "set": "0",
                "text": "The URL to connect to this operator's stream.",
                "type": "str",
                "class": "videostreamoutTOP",
                "name": "streamURL"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "viosoTOP": {
        "label": "viosoTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "warpCHOP": {
        "label": "warpCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "waveCHOP": {
        "label": "waveCHOP",
        "members": [
            {
                "set": "0",
                "text": "<code>me.chanIndex</code> can be used in any parameter to give a different value for each [[Channel Class|channel]] being generated, for example <code>[3, 4, 5][me.chanIndex]</code>.",
                "type": "int",
                "class": "waveCHOP",
                "name": "chanIndex"
            },
            {
                "set": "0",
                "text": "The index of the current sample being evaluated.",
                "type": "int",
                "class": "waveCHOP",
                "name": "sampleIndex"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "webDAT": {
        "label": "webDAT",
        "members": [
            {
                "set": "0",
                "text": "Total bytes downloaded so far.",
                "type": "int",
                "class": "webDAT",
                "name": "downloadCurrent"
            },
            {
                "set": "0",
                "text": "Fraction of downloaded size to total size.",
                "type": "float",
                "class": "webDAT",
                "name": "downloadFraction"
            },
            {
                "set": "0",
                "text": "Total size for download, expressed in bytes.",
                "type": "int",
                "class": "webDAT",
                "name": "downloadTotal"
            },
            {
                "set": "0",
                "text": "Query Content Encoding, as returned from HTML query.",
                "type": "str",
                "class": "webDAT",
                "name": "queryContentEncoding"
            },
            {
                "set": "0",
                "text": "Query Content Length, as returned from HTML query.",
                "type": "int",
                "class": "webDAT",
                "name": "queryContentLength"
            },
            {
                "set": "0",
                "text": "Query Content Type, as returned from HTML query.",
                "type": "str",
                "class": "webDAT",
                "name": "queryContentType"
            },
            {
                "set": "0",
                "text": "Query Content Type character set, as returned from HTML query.",
                "type": "str",
                "class": "webDAT",
                "name": "queryContentTypeCharset"
            }
        ],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "webrenderTOP": {
        "label": "webrenderTOP",
        "members": [
            {
                "set": "0",
                "text": "The loaded state of the current webpage.",
                "type": "bool",
                "class": "webrenderTOP",
                "name": "loaded"
            }
        ],
        "methods": [
            {
                "text": "Send mouse clicks, rollovers, moves and drags to the webpage.\n*u - The first coordinate for the click to occur at.\n*v - The second coordinate for the click to occur at.\n*leftClick, middleClick, rightClick -  (Keyword, Optional) Use to specify the number of times a button is clicked on.\n*left, middle, right -  (Keyword, Optional) Use to specify if the button is being pressed.  When set to False it simulates a mouse move with the button up.  The first time the button is set to True will initiate a virtual mouse down on the web page at the coordinates u,v.  Subsequent True states will simulate a drag (mouse button down and moving).  Simulate a mouse-up by calling the button set to False, e.g. left=False.\n*wheel -  (Keyword, Optional) Roll the mouse wheel\n*pixels - (Keyword, Optional) When True, the coordinates are treated as pixel offsets.  When False, they are treated as normalized values.\n*aux - (Keyword, Optional) Auxiliary data.\n<syntaxhighlight lang=python>\nop('webrender1').interactMouse(0.5, 0.5) # roll over the middle of the webpage\nop('webrender1').interactMouse(0.5, 0.5, leftClick=2) # double click the middle of the webpage\n</syntaxhighlight>",
                "returns": "None",
                "name": "interactMouse",
                "call": "interactMouse(u, v, leftClick=0, middleClick=0, rightClick=0, left=False, middle=False, right=False, wheel=0, pixels=False)",
                "class": "webrenderTOP"
            },
            {
                "text": "Execute a line of javascript on the current webpage.\n*script - The line to be executed.",
                "returns": "None",
                "name": "executeJavaScript",
                "call": "executeJavaScript(script)",
                "class": "webrenderTOP"
            },
            {
                "text": "Send key characters to the webpage.\n*char - ASCII value or name of a character or key.  Key name matches the names from the [[Keyboard In DAT]].\n*shift - (Keyword, Optional) shift key state.\n*alt - (Keyword, Optional) alt key state.\n*ctrl - (Keyword, Optional) ctrl key state.\n*cmd - (Keyword, Optional) cmd key state.\n<syntaxhighlight lang=python>\nop('webrender1').sendKey(65)      # sends the character \"A\"\nop('webrender1').sendKey(\"left\")  # sends the left arrow key\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendKey",
                "call": "sendKey(char, shift=False, alt=False, ctrl=False, cmd=False)",
                "class": "webrenderTOP"
            },
            {
                "text": "Send a string of characters to the webpage.\n<syntaxhighlight lang=python>\nop('webrender1').sendString(\"TouchDesigner\")  # sends the string TouchDesigner\n</syntaxhighlight>",
                "returns": "None",
                "name": "sendString",
                "call": "sendString(char)",
                "class": "webrenderTOP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    },
    "websocketDAT": {
        "label": "websocketDAT",
        "members": [],
        "methods": [
            {
                "text": "Send a text frame over the WebSocket connection.  Returns the number of bytes sent in the message, or a negative value on error.\n*message - String content to send.  Multiple string values can be specified, which are joined without spaces.\n<syntaxhighlight lang=python>\nn = n.sendText('Hello') # send text frame consisting of 'Hello'\n</syntaxhighlight>",
                "returns": "int",
                "name": "sendText",
                "call": "sendText(message)",
                "class": "websocketDAT"
            },
            {
                "text": "Send a pong reply over the WebSocket connection.  Returns the number of bytes sent in the message, or a negative value on error.\n*contents - (Optional) Binary contents of the frame.  This should match the contents of the original ping request frame. This can include any number of strings, byte arrays, or individual single-byte numeric values.  To serialize non-byte values (example floats or integers) there are several python modules to do this, such as pickle or struct.\n<syntaxhighlight lang=python>\nn = n.sendPong( 23, 'TYPE', 255, 12, 0x34, b'\\\\x01\\\\x00\\\\x02\\\\x00\\\\x03\\\\x00\\\\x00\\\\x00') # send pong reply with specific contents.\n</syntaxhighlight>",
                "returns": "int",
                "name": "sendPong",
                "call": "sendPong(contents)",
                "class": "websocketDAT"
            },
            {
                "text": "Send a ping request over the WebSocket connection.  Returns the number of bytes sent in the message, or a negative value on error.\n*contents - (Optional) Binary contents of the frame.  This can include any number of strings, byte arrays, or individual single-byte numeric values.  To serialize non-byte values (example floats or integers) there are several python modules to do this, such as pickle or struct.\n<syntaxhighlight lang=python>\nn = n.sendPing( 23, 'TYPE', 255, 12, 0x34, b'\\\\x01\\\\x00\\\\x02\\\\x00\\\\x03\\\\x00\\\\x00\\\\x00') # send ping request with specific contents.\n</syntaxhighlight>",
                "returns": "int",
                "name": "sendPing",
                "call": "sendPing(contents)",
                "class": "websocketDAT"
            },
            {
                "text": "Send a binary frame over the WebSocket connection.  Returns the number of bytes sent in the message, or a negative value on error.\n*contents - (Optional) Binary contents of the frame.  This can include any number of strings, byte arrays, or individual single-byte numeric values.  To serialize non-byte values (example floats or integers) there are several python modules to do this, such as pickle or struct.\n<syntaxhighlight lang=python>\nn = n.sendBinary( 23, 'TYPE', 255, 12, 0x34, b'\\\\x01\\\\x00\\\\x02\\\\x00\\\\x03\\\\x00\\\\x00\\\\x00') # send binary frame consisting of various byte values.\n</syntaxhighlight>",
                "returns": "int",
                "name": "sendBinary",
                "call": "sendBinary(contents)",
                "class": "websocketDAT"
            }
        ],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "windowCOMP": {
        "label": "windowCOMP",
        "members": [
            {
                "set": "0",
                "text": "The index of the monitor whose DPI scale is being used to for the Window. This is the usually the monitor the window is covering the most.",
                "type": "int",
                "class": "windowCOMP",
                "name": "scalingMonitorIndex"
            },
            {
                "set": "0",
                "text": "True if the window is bordered.",
                "type": "bool",
                "class": "windowCOMP",
                "name": "isBorders"
            },
            {
                "set": "0",
                "text": "True if the window will stretch its contents to fill its specified area.",
                "type": "bool",
                "class": "windowCOMP",
                "name": "isFill"
            },
            {
                "set": "0",
                "text": "True when window is open.",
                "type": "bool",
                "class": "windowCOMP",
                "name": "isOpen"
            },
            {
                "set": "0",
                "text": "Window width. Expressed in points or pixels, depending on the DPI Scaling parameter of the Window COMP.",
                "type": "int",
                "class": "windowCOMP",
                "name": "width"
            },
            {
                "set": "0",
                "text": "Window height. Expressed in points or pixels, depending on the DPI Scaling parameter of the Window COMP.",
                "type": "int",
                "class": "windowCOMP",
                "name": "height"
            },
            {
                "set": "0",
                "text": "Window X coordinate relative to the bottom left of the main monitor. Expressed in points or pixels, depending on the DPI Scaling parameter of the Window COMP.",
                "type": "int",
                "class": "windowCOMP",
                "name": "x"
            },
            {
                "set": "0",
                "text": "Window Y coordinate relative to the bottom left of the main monitor. Expressed in points or pixels, depending on the DPI Scaling parameter of the Window COMP.",
                "type": "int",
                "class": "windowCOMP",
                "name": "y"
            },
            {
                "set": "0",
                "text": "X position of left edge of the windows contents. Ignores borders if they are present. Expressed in points or pixels, depending on the 'DPI Scaling' parameter setting.",
                "type": "int",
                "class": "windowCOMP",
                "name": "contentX"
            },
            {
                "set": "0",
                "text": "Y position of bottom edge of the windows contents. Ignores borders if they are present. Expressed in points or pixels, depending on the 'DPI Scaling' parameter setting.",
                "type": "int",
                "class": "windowCOMP",
                "name": "contentY"
            },
            {
                "set": "0",
                "text": "Width of windows contents. Ignores borders if they are present. Expressed in points or pixels, depending on the 'DPI Scaling' parameter setting.",
                "type": "int",
                "class": "windowCOMP",
                "name": "contentWidth"
            },
            {
                "set": "0",
                "text": "Height of windows contents. Ignores borders if they are present. Expressed in points or pixels, depending on the 'DPI Scaling' parameter setting.",
                "type": "int",
                "class": "windowCOMP",
                "name": "contentHeight"
            }
        ],
        "methods": [
            {
                "text": "Activates the window, sets it to the foregound and other visual cues. Sets focus and increases process priority.\nCan only be called by a foreground process, or a child of a foreground process.\nReturns true if successful.",
                "returns": "bool",
                "name": "setForeground",
                "call": "setForeground()",
                "class": "windowCOMP"
            }
        ],
        "subclasses": {},
        "inherits": [
            "OP",
            "COMP"
        ]
    },
    "wireframeMAT": {
        "label": "wireframeMAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "MAT"
        ]
    },
    "wireframeSOP": {
        "label": "wireframeSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "xmlDAT": {
        "label": "xmlDAT",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "DAT",
            "OP"
        ]
    },
    "zedCHOP": {
        "label": "zedCHOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "CHOP",
            "OP"
        ]
    },
    "zedSOP": {
        "label": "zedSOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "OP",
            "SOP"
        ]
    },
    "zedTOP": {
        "label": "zedTOP",
        "members": [],
        "methods": [],
        "subclasses": {},
        "inherits": [
            "TOP",
            "OP"
        ]
    }
}